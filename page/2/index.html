<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="路要坚持">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="路要坚持">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="路要坚持">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>路要坚持</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">路要坚持</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/11/Java总结（七）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王邸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路要坚持">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/11/Java总结（七）/" itemprop="url">Java总结（七）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-11T23:43:08+08:00">
                2019-08-11
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/08/11/Java总结（七）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/08/11/Java总结（七）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这周学习了JDBC批处理，事务(默认提交)，连接池（DBCP,C3P0,Druid），DButil，单元测试，也学习了前端，但是讲的太水了，不敢苟同。所以自己去整理，但是自己也没有书，只有去MDN去学习，发现讲的很全面，虽然是火狐浏览器为基础的。但是讲的都是很标准的东西。想要通过几天把前端都回顾完是不可能的，还有很多坑在里面。只有一步步来。每天都复习一点。</p>
<h2 id="星期一（8-5）"><a href="#星期一（8-5）" class="headerlink" title="星期一（8.5）"></a>星期一（8.5）</h2><h3 id="JDBC批处理"><a href="#JDBC批处理" class="headerlink" title="JDBC批处理"></a>JDBC批处理</h3><p>就是多次进行处理，没有批处理，我们如何批量新增数据<br>也许应该是这样：使用循环然后statement.executeUpdate()来插入数据；</p>
<pre><code>//批量插入数据 500条
Connection connection = null;
Statement statement = null;
try {
    connection = JdbcUtil.getConnection();
    statement = connection.createStatement();
    for (int i = 0; i &lt; 500; i++) {
        statement.executeUpdate(&quot;insert into user values (null,&apos;&quot; + i + &quot;&apos;,&apos;&quot; + i + &quot;&apos;)&quot;);
    }
} catch (IOException e) {
    e.printStackTrace();
} catch (ClassNotFoundException e) {
    e.printStackTrace();
} catch (SQLException e) {
    e.printStackTrace();
}finally {
    try {
        JdbcUtil.releaseConnection(connection,null,statement);
    } catch (SQLException e) {
        e.printStackTrace();
    }
}
</code></pre><h3 id="使用statement的批处理："><a href="#使用statement的批处理：" class="headerlink" title="使用statement的批处理："></a>使用statement的批处理：</h3><pre><code>statement.addBatch(sql); 相当于将砖放到一个小推车里
statement.executeBatch(); 推着小推车去目的地
statement.clearBatch();  将小推车里面的砖块卸了，再回到目的地

//批量插入数据 500条
Connection connection = null;
Statement statement = null;
try {
    connection = JdbcUtil.getConnection();
    statement = connection.createStatement();
    for (int i = 0; i &lt; 500; i++) {
        statement.addBatch(&quot;insert into user values (null,&apos;&quot; + i + &quot;&apos;,&apos;&quot; + i + &quot;&apos;)&quot;);
        statement.addBatch(&quot;delete from user where id = 1&quot;);
        if(i == 249){
          statement.executeBatch();
          statement.clearBatch();  //第一次搬砖
        }
    }
    statement.executeBatch();      //第二次搬砖
</code></pre><p>特点：<br>较为灵活，可以执行多条不同类型的sql语句。</p>
<h3 id="prepareStatement批处理："><a href="#prepareStatement批处理：" class="headerlink" title="prepareStatement批处理："></a>prepareStatement批处理：</h3><pre><code>Connextion connection = null;
PrepareStatement preparedStatement = null;
try{
  connection = JdbcUtil.getConnection();
  String sql = &quot;insert into user values (&apos;null&apos;,?,?)&quot;;
  preparedStatement = connection.prepareStatement(sql);
  for(int i = 0; i &lt; 500; i++) {
    preparedStatement.setString(1,i+&quot;&quot;);
    preparedStatement.setString(2,i+&quot;&quot;);
    preparedStatement.addBatch();

    if(i = ((500-1)&gt;&gt;1)){ //先把一半的砖都拿走
      preparedStatement.executeBatch();
      prepatedStatement.clearBatch();
    }
  }
  preparedStatement.executeBatch();//办第二次
  preparedStatement.clearBatch();
} catch (IOException e) {
    e.printStackTrace();
} catch (ClassNotFoundException e) {
    e.printStackTrace();
} catch (SQLException e) {
    e.printStackTrace();
}finally {
    try {
        JdbcUtil.releaseConnection(connection,null,preparedStatement);
    } catch (SQLException e) {
        e.printStackTrace();
    }
}
</code></pre><p>仅能执行类型相同而参数不同的sql语句。但是效率很高</p>
<p>采用PreparedStatement.addBatch()实现批处理<br>优点：与数据库通信次数在批量操作时，PreparedStatment的通信次数远少于Statment。<br>缺点：只能应用在SQL语句相同，但参数不同的批处理中。因此此种形式的批处理经常用于在同一个表中批量插入数据，或批量更新表的数据。</p>
<p><strong>注意事项</strong>：<br>1.默认情况下Mysql的批处理仍然是一条一条执行，需要在url后面添加rewriteBatchedStatements=true参数例如：</p>
<pre><code>url=jdbc:mysql://localhost:3306/bank?characterEncoding=utf8&amp;rewriteBatchedStatements=true
</code></pre><p>2.PreparedStatement.addBatch()注意内存溢出问题</p>
<p>为什么addBatch()会内存溢出？</p>
<pre><code>// private byte[][] parameterValues = (byte[][])null;
public synchronized void addBatch() throws SQLException {
  if (this.batchedArgs == null) {
    this.batchedArgs = new ArrayList();
  }
  for(int i = 0; i &lt; this.parameterValues.length; ++i) {
    this.checkAllParametersSet(this.parameterValues[i], this.parameterStreams[i], i);
  }
  this.batchedArgs.add(new PreparedStatement.BatchParams(this.parameterValues, this.parameterStreams, this.isStream, this.streamLengths, this.isNull));
}
</code></pre><p>看到是一个ArrayList存储的不知道哪里可能会出现内存溢出<br>网上搜了一下：数据库存取内存溢出的问题：</p>
<p>1.是ibatis 频繁读取数据库的问题，换成jdbc就好了<br>2.jdbc statement.executeQuery(sql) 造成内存溢出。<br>如果你要读取一个超大的表，使用下面的语句有可能会造成内存溢出：</p>
<pre><code>Statement statement = conn.createStatement(
                    ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
ResultSet rs = statement.executeQuery(sql);
这是因为如果不设置statement的fetchSize的话，mysql驱动默认会将数据全部载入到内存中，所以就会OutOfMemoryError了。
</code></pre><p>解决的方法有两种，在执行statement.executeQuery(sql);添加下面两行中的一行，即可：</p>
<pre><code>statement.setFetchSize(Integer.MIN_VALUE);
 ((com.mysql.jdbc.Statement)stat).enableStreamingResults();
</code></pre><p>3.<a href="https://antival.iteye.com/blog/1340774" target="_blank" rel="external">JDBC批处理内存溢出问题分析</a>关键点：</p>
<pre><code>第五步，分析发现19万分每次5000笔也是38次，38次connnection和PreparedStatement可能有问题。因此修改代码，将链接(connection)和PreparedStatement都提出来，在循环之外。然后每次批量执行完毕都执行清理操作（pstat.clearBatch()）。内存稳定，没有增加，问题解决。
结论：PreparedStatement批量执行方式占用内存有可能非常大（跟批量数据量有关系），如果只是使用close，包括connection的close，并不能及时释放，哪怕是强制gc也不能释放。
解决的方法就是使用统一个PreparedStatement，那么假设它占用50M的空间，循环使用的情况下，只是覆盖没有新new一些地址，可能就是解决问题的思路。
</code></pre><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务指逻辑上的一组操作，组成这组操作的各个单元，要么全部成功，要么全部不成功。</p>
<p>Mysql数据库在默认情况下是自动提交事务的，这点需要与oracle数据库做一个区分。Oracle数据库执行完之后，需要手动执行commit操作。<br>命令行开启事务的方式：</p>
<pre><code>start transaction  开启事务DTL 取消自动提交事务
rollback           回滚到start transaction
commit             提交
</code></pre><h3 id="事务的四个特性-ACID"><a href="#事务的四个特性-ACID" class="headerlink" title="事务的四个特性(ACID)"></a>事务的四个特性(ACID)</h3><p>原子性（Atomicity）</p>
<pre><code>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 
</code></pre><p>一致性（Consistency）</p>
<pre><code>事务必须使数据库从一个一致性状态变换到另外一个一致性状态。
</code></pre><p><strong>隔离性（Isolation）</strong></p>
<pre><code>事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。
</code></pre><p>持久性（Durability）</p>
<pre><code>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障(软件故障)也不应该对其有任何影响。
</code></pre><h3 id="事务的隔离性"><a href="#事务的隔离性" class="headerlink" title="事务的隔离性"></a>事务的隔离性</h3><p>隔离性做的不够好（对应于不同的隔离等级），会有哪些问题产生：</p>
<pre><code>脏读：一个事务读取到了另外一个事务未提交的数据。
不可重复读：一个事务读取到了另外一个事务已经提交的数据。
虚读：一个事务读取到了另外一个事务新增的数据。
</code></pre><p>脏读是最低级的，虚读是最高级的。</p>
<p>下面就来说说这几种隔离性不好的问题的差异，我们还是在命令行操作，首先使用两个命令行窗口，</p>
<pre><code>窗口一，窗口二同时开始事务 输入命令：start transaction
第一个命令行窗口只做操作，
第二个命令行窗口只去数据库读取信息
</code></pre><p>窗口二只读取数据库三次：</p>
<pre><code>1.在窗口一开始操作之前读
2.在窗口一设置数据之后，未提交之前读
3.在窗口一提交之后读数据库
</code></pre><p>我们分别把这三个结果叫 结果1，结果2，结果3<br>当我们设置隔离等级是read uncommitted ，为了能表示出脏读</p>
<pre><code>set global transaction isolation level read uncommitted;
</code></pre><p>我们可以得出 结果1 ！= 结果2时，就发生了脏读:事务二读取到了事务一的未提交的数据</p>
<p>当我们设置隔离等级是read committed ，为了能表示出不可重复读</p>
<pre><code>set global transaction isolation level read committed;
</code></pre><p>得出： 结果1 = 结果2 ！= 结果3 ：一个事务重新读取前面读取过的数据， 发现该数据已经被另一个已提交的事务修改过。<br>表现出不可重复读</p>
<p><strong>注意事项</strong>Mysql是表现不出虚读的，因为Mysql在隔离级别Repeatable read就避免phantom read（虚读）但是在别的数据库里虚读的表现和不可重读读是类似的也是：结果1 = 结果2 ！= 结果3，但是这就表现出的是行数的不同，而不是数据的不同。</p>
<h3 id="数据库提供了四种不同级别的隔离等级："><a href="#数据库提供了四种不同级别的隔离等级：" class="headerlink" title="数据库提供了四种不同级别的隔离等级："></a>数据库提供了四种不同级别的隔离等级：</h3><pre><code>Read uncommitted ：以上三种情况均不能避免
Read committed：可避免脏读的发生
Repeatable read：可避免脏读，不可重复读发生
Serializable：可避免所有问题发生（串行化，一个一个走）
</code></pre><p>查看和设置事务隔离级别命令：在Mysql的命令下：</p>
<pre><code>select @@transaction_isolation;                                 //查看隔离级别
set session/global transaction isolation level read uncommitted //这是隔离级别
</code></pre><h3 id="JDBC启用事务模式"><a href="#JDBC启用事务模式" class="headerlink" title="JDBC启用事务模式"></a>JDBC启用事务模式</h3><p>当Jdbc程序向数据库获得一个Connection对象时，默认情况下这个Connection对象会自动向数据库提交commit在它上面发送的SQL语句。若想关闭这种默认提交方式，让多条SQL在一个事务中执行，可使用下列语句：<br>JDBC控制事务语句|对应的命令行操作<br>-:|:-<br>Connection.setAutoCommit(false)  |  start transaction<br>Connection.rollback();           |  rollback<br>Connection.commit();             |  commit</p>
<h3 id="设置事务回滚点Connection-rollback"><a href="#设置事务回滚点Connection-rollback" class="headerlink" title="设置事务回滚点Connection.rollback()"></a>设置事务回滚点Connection.rollback()</h3><pre><code>Savepoint sp = conn.setSavepoint();
Conn.rollback(sp);
Conn.commit();   //回滚后必须要提交
</code></pre><p>看下面的例子</p>
<p>//jdbc设置事务：老板给员工转账问题<br>设置事务的回滚点：<br>比如公司老板给多名员工同时发工资，发到一半时，出现了问题，这个时候，我们可以回滚到出错的上一个人位置，而不必直接rollback到最开始的时候。<br>1.首先老板选择需要发放工资的员工人员，接下来，他直接操作，最终程序自动完成转账功能。<br>2.每个员工的薪水是不同的，具体的薪水存放在薪水表中。从新水表获取到需要发放工资的员工对应的薪水，<br>3.之后，进入转账环节，转账成功同时要写入相应的转账记录。</p>
<p>需要的表如下：<br>员工表（包含每个员工应该得的工资） 金额表（每个员工自己的资金是多少）  转账记录表记录转账</p>
<p>员工表：</p>
<pre><code>emp   | CREATE TABLE `emp` (
 `id` int(11) NOT NULL AUTO_INCREMENT,
 `name` varchar(30) DEFAULT NULL,
 `salary` double DEFAULT NULL,
 `flag` enum(&apos;成功&apos;,&apos;失败&apos;) DEFAULT &apos;失败&apos;,
 PRIMARY KEY (`id`)
</code></pre><p>金额表：</p>
<pre><code>account | CREATE TABLE `account` (
 `id` int(11) NOT NULL AUTO_INCREMENT,
 `name` varchar(255) DEFAULT NULL,
 `money` double NOT NULL,
 `eid` int(11) NOT NULL,
 PRIMARY KEY (`id`)
</code></pre><p>转账记录表：</p>
<pre><code>`id` int(11) NOT NULL AUTO_INCREMENT,
  `getId` int(11) DEFAULT NULL,
  `getName` varchar(30) DEFAULT NULL,
  `supplyId` int(11) DEFAULT NULL,
  `supplyName` varchar(30) DEFAULT NULL,
  `money` double DEFAULT NULL,
  `time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
</code></pre><p>这个表使用一个字段来标记是否转账成功，以避免事务中途被强制结束，有一些转账成功，一些转账失败，导致重复转账的情况，下面上代码，这里注意，还是用了之前的jdbcUtil的方法来获取连接和释放资源；<br>首先先需要一个bean(pojo)来保存数据库取出的数据</p>
<pre><code>package practise.pojo;
//java bean设计的一些注意事项
//字段属性设置private，然后提供get和set方法
//提供无参构造函数，如果写了有参，则要把无参另外写出来
public class Emp {
    private int id;
    private String name;
    private double salary;
    private String flag;
    public Emp() {}
    public Emp(int id, String name, double salary) {
        this.id = id;
        this.name = name;
        this.salary = salary;
    }
    public int getId() {return id;}
    public void setId(int id) {this.id = id;}
    public String getName() {return name;}
    public void setName(String name) {this.name = name;}
    public double getSalary() {return salary;}
    public void setSalary(double salary) {this.salary = salary;}
    public String getFlag() {return flag;}
    public void setFlag(String flag) {this.flag = flag;}
}
</code></pre><p>2.编写一个重数据库取出数据的类LoadSalary</p>
<pre><code>public class LoadSalar{
    public static void main(String[] args) {
        Connection connection = null;
        PreparedStatement preparedstatement = null;
        ResultSet resultSet = null;
        List&lt;Emp&gt; list = new ArrayList&lt;&gt;();
        try{
            connection = jdbcUtil.getConnection();
            String s1 = &quot;select * from emp&quot;;
            preparedStatement = connection.prepareStatement(s1);
            resultSet = preparedStatement.executeQuery();
            while(result.next){
                Emp employee = new Emp();
                int id = resultSet.getInt(&quot;id&quot;);
                String name = resultSet.getString(&quot;name&quot;);
                double salary = resultSet.getDouble(&quot;salary&quot;);
                String flag = resultSet.getString(&quot;flag&quot;);
                employee.setId(id);
                employee.setName(name);
                employee.setSalary(salary);
                employee.setFlag(flag);
                list.add(employee);
            }
            TransSalary.transfer(list);// 进行转账操作
        } catch(Exception e) {
            e.printStackTrace();
        } finally {
            try{
                JdbcUtil.releaseConnection(connection,resultSet,preparedStatement);
            } catch(SQLException e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre><p>3.编写转账的JDBC</p>
<pre><code>public class TransSalary{
    public static void transfer(List&lt;Emp&gt; list) {
        //先把boss从list里面拿出来
        Emp boss = new Emp();
        for(Emp emp1 : list) {
            if(&quot;佟掌柜&quot;.equals(emp1.getName)) {
                boss = emp1;
                break;
            }
        }
        Connection connection = null;
        //需要两个prepareStatement来操作两个数据库
        PrepareStatement preparedStatement1 = null;
        PrepareStatement preparedStatement2 = null;
        Savepoint savepoint = nulll; //设置回滚点

        ResultSet resultSet = null;
        try{

            connection = JdbcUtil.getConnection();
            //手动开启事务
            connection.setAutoCommit(false);
            //转账sql
            String sql = &quot;update account set money = money - ? where eid = ?&quot;;
            //修改emp标记sql
            String sql2 = &quot;update emp set flag = &apos;成功&apos; where id = ?&quot;;

            preparement1 = connection.prepareStatement(sql);
            preparement2 = connection.prepareStatement(sql2);

            //转账开始
            for(Emp emp : list) {

                //给钱
                preparement1.setDouble(1,-list.getSalary());
                preparement1.setInt(2,emp.getId());
                preparement1.executeUpdate();  //返回影响的行数

                //老板扣钱
                preparement1.setDouble(1,list.getSalary());
                preparement1.setInt(2,boss.getId());
                preparement1.executeUpdate();

                //设置emp的标签为成功
                preparement2.setInt(1,emp.getId());
                prepatement2.executeUpdate();

                //到这里说明成功，成功就写记录到数据库
                //被转账的人信息  转账人的信息 转账金额 日期
                RecordSalary.record(emp.getId(), emp.getName(), boss.getId(), boss.getName(), emp.getSalary());

                //转账成功记录保存点
                savepoint = connection.setSavepoint();
            }
        connection.commit();//提交事务
        } catch (Exception e) {
            //发生异常需要回滚
            e.printStackTrace();

            //判断一下回滚点是否是null
            if(savepoint == null) {
                connection.rollback();//就停止了
            } else {
                connection.rollback(savepoint);
                //记得提交事务
                connection.commit();
            }

            connection.rollback(savepoint);
        } finnaly{
            try{
                JdbcUtil.releaseConnection(connection,null,preparedStatement);
                preparement2.close();
            } catch(SQLExeception e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre><p>4.向record写入记录</p>
<pre><code>public class RecordSalary {
    public static void record(int getId,String getName, int supplyId, String supplyName, double salary ) {
        Connection connection  = null;
        PreparedStatement preparedStatement = null;
        //id getid getName supplyId supplyName,salary,dateTime
        String sql = &quot;Insert into record values(null,?,?,?,?,?,now())&quot;;
        try {
            connection = JdbcUtil.getConnection();
            preparedStatement = connection.prepareStatement(sql);
            preparedStatement.setInt(1,getId);
            preparedStatement.setString(2,getName);
            preparedStatement.setInt(3,supplyId);
            preparedStatement.setString(4,supplyName);
            preparedStatement.setDouble(5,salary);
            preparedStatement.executeUpdate();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (SQLException e) {
            e.printStackTrace();
        } finally{
            try {
                JdbcUtil.releaseConnection(connection,null,preparedStatement);
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre><p><strong>注意事项</strong><br>1.这里注意rollback方法，回到的是savepoint的地方，这个savepoint是由connection给的，一开始默认值是null,我看了rollback方法两个是分开的方法，所以savepoint一定要先判断是否为null再决定是rollback(savepoint)还是rollback()直接回到一开始；</p>
<p>2.对rollback函数的构想，能否单独抽离出rollback函数，这样自己设置保存点。就能自己写一个callback的方法，能回到自己想回到的地方，但是这个怎么执行之类，还需要对这个函数更加了解才行</p>
<h2 id="星期二（8-6）"><a href="#星期二（8-6）" class="headerlink" title="星期二（8.6）"></a>星期二（8.6）</h2><h3 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h3><p>什么是数据库连接池，为什么需要？<br>在之前的JDBC操作中，每次都需要手动去创建一个连接，并且在使用完成之后，关闭该连接。但是在真实的生产环境中，连接的创建是非常消耗性能的，花费时间较久，在多用户并发访问的时候，极容易出现数据库内存溢出，系统宕机。<br>解决方案，就是新建一个数据库连接池，预先在连接池里面存放一些数据库连接，当用户访问的时候，直接去连接池中去拿一个连接，而不是新创建一个。同时使用完之后，也不是直接关闭销毁，而是放回连接池。</p>
<p>数据库连接池和我们之前学的JDBC的操作流程有没有互相违背的地方？？？<br>JDBC中一致强调要及释放资源，关闭connection对象。连接池又说要用一个池子来保存连接，避免新建一个连接。</p>
<h3 id="初识连接池"><a href="#初识连接池" class="headerlink" title="初识连接池"></a>初识连接池</h3><p>自己手写一个连接池，然后只重写了close方法，close并不是关闭连接，只是把连接丢会连接池</p>
<pre><code>public class MyConnectionPool {
  //要从头删除，所以使用LinkedList
  private static List&lt;Connection&gt; pool = new LinkedList&lt;&gt;();
  //初始化连接池
  static {
    resize(10); //就构建一个长度10的连接池
  }
  private static void resize(int number){
    for (int i = 0; i &lt; number; i++) {
      try {
        //真正类型是JDBC4Connection
        Connection connection = JdbcUtil.getConnection();
        pool.add(connection);
      } catch (IOException e) {
        e.printStackTrace();
      } catch (ClassNotFoundException e) {
        e.printStackTrace();
      } catch (SQLException e) {
        e.printStackTrace();
      }
    }
  }
  public static Connection getConnection(){
    if(pool.size() &lt; 4) {
      resize(6);
    }
    return pool.remove(0);
  }
  //回收Connection
  public static void returnConnection(Connection connection){
    pool.add(connection);
  }
}
</code></pre><p><strong>出现的问题</strong><br>第一个数据库连接池存在的问题：没有符合规范。每家的数据库连接池可能API名称都不同，同时也许有的可以直接通过静态方法调用，有的不能够直接调用，这个时候还是需要去查阅相应的开发文档，使用起来不是很方便，如果有一个规范来约束每个API名称应该是什么，这个时候，在使用各个开源数据库连接池产品时，可以直接调用接口的方法即可。<br>Sun公司定义了一个<strong>DataSource</strong>接口，用以规范数据库连接池相关的API。<br>解决办法就是实现DataSource接口，实现规范！！！让大家用同一种规范来重写方法</p>
<h2 id="重写连接池"><a href="#重写连接池" class="headerlink" title="重写连接池"></a>重写连接池</h2><pre><code>//MyDataSource
public class MyDataSource implements DataScoure {
  private static List&lt;Connection&gt; pool = new LinkedList&lt;&gt;();
  static {
      resize(10);
  }
  private static void resize(int number){
    for (int i = 0; i &lt; number; i++) {
      try {
        //真正类型是JDBC4Connection
        Connection connection = JdbcUtil.getConnection();

        //接下来将JDBC4Connection对象作为参数传入到connectionWrapper中
        ConnectionWrapper connectionWrapper = new ConnectionWrapper(connection,pool);

        //pool.add(connection);
        pool.add(connectionWrapper);
      } catch (IOException e) {
        e.printStackTrace();
      } catch (ClassNotFoundException e) {
        e.printStackTrace();
      } catch (SQLException e) {
        e.printStackTrace();
      }
    }
  }
  @Override 重写方法
  public Connection getConnection() throws SQLException {
      if(pool.size() &lt; 4){
          resize(6);
      }
      return pool.remove(0);
  }

  //这个方法并没有被重写
  //public  void returnConnection(Connection connection){
    public void close(Connection connection) {
      pool.add(connection);
    }
  }
}
</code></pre><p>实现了DataSource接口之后，发现接口中没有定义returnConnection的API，同时还有一点，我们自己实现的DataSoure肯定希望别人能够使用，作为一个第三方jar包。无法阻止其他人主动去调用connection.close方法。再次放入连接池，该连接池就没有任何意义了。我们应该想一个办法重写close()方法：<br><strong>当调用connection.close方法时，不是关闭连接，而是将连接返回到连接池中。</strong><br>所以，这里我们发现resize方法有一些不同，add的是一个ConnectionWrapper，而不是第一次写的Connection。给Connection了一个包装类，这样就能阻止用户直接调用Connection自身的close()方法结束链接，而是调用我们包装类的close()。把数据连接放回到连接池。连接池里面放的就是我们的包装类，而不是Connection的本身实现的子类JDBC4Connection;</p>
<pre><code>public class ConnectionWrapper implements Connection {
  private Connection connectin;
  private List&lt;Connection&gt; pool;

  //通过构造函数传进来一个会写这些方法的connection过来，然后完成这些方法

  public ConnectionWrapper(Connection connection, List&lt;Connection&gt; pool) {
      this.connection = connection;
      this.pool = pool;
  }
  ...
  ...
  ...
  //需要将这个方法重写，不是真正关闭连接，而是返回连接池
  @Override
  public void close() throws SQLException {
      //connection.close();
      pool.add(this);
  }
}
</code></pre><p>虽然我们实现了dataSource接口的规范，但是自己写的工具类还是有一些问题的：</p>
<pre><code>1.很多API没有实现
2.没有扩容机制
3.也没有回收连接机制，存在连接池中也是一种资源浪费
</code></pre><p>更多的还是理解写包装类的作用。就是为了数据连接池能复用连接。</p>
<h3 id="第三方开源的数据库连接池"><a href="#第三方开源的数据库连接池" class="headerlink" title="第三方开源的数据库连接池"></a>第三方开源的数据库连接池</h3><p><strong>友情提示：</strong>这三个数据库的连接池还是需要用：<strong>mysql-connection.jar</strong>的并不是说不用了。这里一定要注意</p>
<h3 id="DBCP"><a href="#DBCP" class="headerlink" title="DBCP"></a>DBCP</h3><p>原理就是上面自己写的connectionpool，就是来使用：</p>
<pre><code>首先要加载三个包：
commons-dbcp2-2.5.0.jar
commons-logging-1.2.jar
commons-pool2-2.6.0.jar
</code></pre><p>//test</p>
<pre><code>public class DbcpTest {
  public static void main(String[] args) {
    Connection connection = null;
    PreparedStatement preparedStatement = null;
    ResultSet resultSet = null;
    try {
      connection = DBCPUtils.getConnection();
      preparedStatement = connection.prepareStatement(&quot;select * from account&quot;);
      resultSet = preparedStatement.executeQuery();
      resultSet.next();
      String name = resultSet.getString(&quot;name&quot;);
      System.out.println(name);
    } catch (SQLException e) {
      e.printStackTrace();
    }finally {
      try {
          //就把connction 放回连接池并不是关闭
          connection.close();
          if(preparedStatement != null){
              preparedStatement.close();
          }
          if(resultSet != null){
              resultSet.close();
          }
      }catch (Exception e){
          e.printStackTrace();
      }
    }
  }
}
</code></pre><p>//代替之前的JdbcUtil工具类<br>DBCPUtils.java</p>
<pre><code>public class DBCPUtil {
  private static DataSource dataSource;
  static {
    BasicDataSourceFactory factory = new BasicDataSourceFactory();
    Properties properties = new Properties)();
    try{
      //以前读取配置文件是这样的：
      properties.load(new FileInputStream(&quot;dbcpconfig.properties&quot;));
      //现在可以这样
      InputStream resourceAsStream = DBCPUtil.class.getClassLoader().getResourceAsStream(&quot;dbcpconfig.properties&quot;);
      properties.load(resourceAsStream);
      //创建连接池
      dataSource = factory.createDataSource(properties);
    } catch (IOException e) {
      e.printStackTrace();
    } catch (Exception e) {
      e.printStackTrace();
    }
  }
  public static Connection getConnection() throws SQLException {
      //调用DBCP重写的dataSource子类的getConnection();
      return dataSource.getConnection();
  }
}
</code></pre><p><strong>注意事项：</strong><br>1.两种配置文件写法的不不同点</p>
<pre><code>第一种写法，相对路径默认是相对于整个项目的相对路径，需要自己去配置edit configuration。
第二种写法，相对路径相对于src文件。不需要自己在配置。可以直接读得到。这个文件最终会被IDEA带到out文件夹里面
</code></pre><h3 id="C3P0"><a href="#C3P0" class="headerlink" title="C3P0"></a>C3P0</h3><p>配置文件必须放到src目录下，且配置文件的名称必须为c3p0-config.xml</p>
<p>需要导入包：</p>
<pre><code>c3p0-0.9.1.2.jar
public class C3p0Test {
  public static void main(String[] args) {
    Connection connection = null;
    PreparedStatement preparedStatement = null;
    ResultSet resultSet = null;
    try {
        connection = C3p0Utils.getConnection();
        preparedStatement = connection.prepareStatement(&quot;select * from account&quot;);
        resultSet = preparedStatement.executeQuery();
        resultSet.next();
        String name = resultSet.getString(&quot;name&quot;);
        System.out.println(name);
    } catch (SQLException e) {
        e.printStackTrace();
    }finally {
        try {
            connection.close();
            if(preparedStatement != null){
                preparedStatement.close();
            }
            if(resultSet != null){
                resultSet.close();
            }
        }catch (Exception e){
            e.printStackTrace();
        }
    }
  }
}
</code></pre><p>//C3p0Utils</p>
<pre><code>public class C3p0Utils {
  private static ComboPooledDataSource dataSource;
  static {
    dataSource = new ComboPooledDataSource(&quot;dev&quot;);
  }
  public static Connection getConnection() throws SQLException {
      return dataSource.getConnection();
  }
}
</code></pre><p>//c3p0-config.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;c3p0-config&gt;
  &lt;default-config&gt;
    &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt;
    &lt;property name=&quot;password&quot;&gt;123456&lt;/property&gt;
    &lt;property name=&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt;
    &lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql://localhost:3306/bank?characterEncoding=utf8&lt;/property&gt;
    &lt;property name=&quot;checkoutTimeout&quot;&gt;30000&lt;/property&gt;
    &lt;property name=&quot;idleConnectionTestPeriod&quot;&gt;30&lt;/property&gt;
    &lt;property name=&quot;initialPoolSize&quot;&gt;10&lt;/property&gt;
    &lt;property name=&quot;maxIdleTime&quot;&gt;30&lt;/property&gt;
    &lt;property name=&quot;maxPoolSize&quot;&gt;100&lt;/property&gt;
    &lt;property name=&quot;minPoolSize&quot;&gt;10&lt;/property&gt;
    &lt;property name=&quot;maxStatements&quot;&gt;200&lt;/property&gt;
  &lt;/default-config&gt;

  &lt;named-config name=&quot;dev&quot;&gt;
    &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt;
    &lt;property name=&quot;password&quot;&gt;123456&lt;/property&gt;
    &lt;property name=&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt;
    &lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql://localhost:3306/bank?serverTimezone=GMT&lt;/property&gt;
    &lt;property name=&quot;checkoutTimeout&quot;&gt;30000&lt;/property&gt;
    &lt;property name=&quot;idleConnectionTestPeriod&quot;&gt;30&lt;/property&gt;
    &lt;property name=&quot;initialPoolSize&quot;&gt;10&lt;/property&gt;
    &lt;property name=&quot;maxIdleTime&quot;&gt;30&lt;/property&gt;
    &lt;property name=&quot;maxPoolSize&quot;&gt;100&lt;/property&gt;
    &lt;property name=&quot;minPoolSize&quot;&gt;10&lt;/property&gt;
    &lt;property name=&quot;maxStatements&quot;&gt;200&lt;/property&gt;
  &lt;/named-config&gt;

&lt;/c3p0-config&gt;
</code></pre><p>我们看到C3P0Util里面只有一两句话，这主要是因为他把需要用的参数都抽离出来成配置文件了。只需要时设置一下使用哪个标签</p>
<pre><code>默认是&lt;c3p0-config&gt;
dataSource = new ComboPooledDataSource(); //默认会调用标签：&lt;c3p0-config&gt;里的配置
dataSource = new ComboPooledDataSource(&quot;dev&quot;);//调用标签dev：&lt;named-config name=&quot;dev&quot;&gt;的配置
</code></pre><h3 id="Druid-德鲁伊"><a href="#Druid-德鲁伊" class="headerlink" title="Druid(德鲁伊)"></a>Druid(德鲁伊)</h3><p>导包：</p>
<pre><code>druid-1.1.10.jar
</code></pre><p>//测试</p>
<pre><code>public class DruidTest {
  public static void main(String[] args) {
    Connection connection = null;
    PreparedStatement preparedStatement = null;
    ResultSet resultSet = null;
    try {
      connection = DruidUtils.getConnection();
      preparedStatement = connection.prepareStatement(&quot;select * from account&quot;);
      resultSet = preparedStatement.executeQuery();
      resultSet.next();
      String name = resultSet.getString(&quot;name&quot;);
      System.out.println(name);
    } catch (SQLException e) {
        e.printStackTrace();
    } finally {
      try {
          connection.close();
          if(preparedStatement != null){
              preparedStatement.close();
          }
          if(resultSet != null){
              resultSet.close();
          }
      }catch (Exception e){
          e.printStackTrace();
      }
    }
  }
}
</code></pre><p>DruidUtil.java</p>
<pre><code>public class DruidUtil {
  private static DataSource dataSource;
  static {
    InputStream resourceAsStream = DruidUtils.clas.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);
    Properties properties = new Properties();
    try {
      properties.load(resourceAsStream);
      dataSorce = new DruidDataSourceFactory().createDataSource(properties);
    } catch (IOException e) {
      e.printStackTrace();
    } catch (Exception e) {
      e.printStackTrace();
    }
  }

  public static Connection getConnection() throws SQLException {
    return dataSource.getConnection();
  }
}
</code></pre><p><strong>小结</strong><br>三种connectionPool 第三种最常用，阿里自己的连接池，光平简单的操作。看不出来他们之间的差异，第一种和第三种感觉写法是很类似的。使用了工厂类来创建dataSource，第二种方法全部给你搞好了。只需要自己创建，连配置文件都给你弄好了。三种写法再总结一下创建连接池dataSource：<br>DBCP：</p>
<pre><code>private static DataSource dataSource;
dataSource = new BasicDataSourceFactory().createDataSource(properties);
</code></pre><p>C3P0</p>
<pre><code>private static ComboPooledDataSource dataSource;
dataSource = new ComboPooledDataSource(&quot;dev&quot;);
</code></pre><p>Druid<br>    private static DataSource dataSource;<br>    dataSorce = new DruidDataSourceFactory().createDataSource(properties);</p>
<h2 id="Dbutils"><a href="#Dbutils" class="headerlink" title="Dbutils"></a>Dbutils</h2><p>Commons DbUtils是Apache组织提供的一个对JDBC进行简单封装的开源工具类库，使用它能够简化JDBC应用程序的开发，同时也不会影响程序的性能。(百度百科)</p>
<p>DbUtils is a very small library of classes so it won’t take long to go through the javadocs for each class. The core classes/interfaces in DbUtils are <strong>QueryRunner</strong> and <strong>ResultSetHandler</strong>. You don’t need to know about any other DbUtils classes to benefit from using the library. The following example demonstrates how these classes are used together.（apache官方的介绍）</p>
<p>导包</p>
<pre><code>mysql-connector-java-5.1.17.jar (还是需要这个包的)
commons-dbutils-1.4.jar
</code></pre><h3 id="QueryRunner"><a href="#QueryRunner" class="headerlink" title="QueryRunner"></a>QueryRunner</h3><p>构造函数有带datasource和无参两种。<br>所有的API也都有带Connection参数和无Connection参数两种。<br>如果使用的是无Connection参数的API，则必须提供一个datasource，这样DBUtil才知道你用的是哪个connection</p>
<p>构造函数：</p>
<pre><code>QueryRunner()
          Constructor for QueryRunner.
QueryRunner(DataSource ds)
    Constructor for QueryRunner which takes a DataSource.
</code></pre><p>看例子</p>
<pre><code>public class QueryRunnerTest {
  public static void main(String[] args) {
    QueryRunner runner = new QueryRunner(DruidUtils.getDataSource());
    //如果构造函数使用的是带datasource的，则query方法用不带connection的
    try {
      Account account = (Account) runner.query(&quot;select * from account&quot;, new ResultSetHandler&lt;Object&gt;() {
        @Override
        public Object handle(ResultSet resultSet) throws SQLException {
          //应该怎么写呢？？？ ---&gt;这里应该是runner.query返回的对象
          //这是自己写的ResultSetHandler，但是这TM肯定是错误的用法
          resultSet.next();
          int id = resultSet.getInt(&quot;id&quot;);
          String name = resultSet.getString(&quot;name&quot;);
          double money = resultSet.getDouble(&quot;money&quot;);
          Account account = new Account();
          account.setUid(id);
          account.setName(name);
          account.setMoney(money);
          //这里面return的东西将作为整个query函数的返回值
          return account;
        }
      });
    } catch (SQLException e) {
      e.printStackTrace();
    }
  }
}
</code></pre><p>我们看到里面QueryRunner 有个方法query</p>
<pre><code>query(Connection conn, String sql, ResultSetHandler&lt;T&gt; rsh)
  Execute an SQL SELECT query without any replacement parameters.
</code></pre><p>ResultSetHandler是什么？</p>
<h3 id="ResultSetHandler"><a href="#ResultSetHandler" class="headerlink" title="ResultSetHandler"></a>ResultSetHandler</h3><p>Interface ResultSetHandler<t><br>Type Parameters:<br>    T - the target type the input ResultSet will be converted to.</t></p>
<p>All Known Implementing Classes:</p>
<pre><code>AbstractKeyedHandler, AbstractListHandler, ArrayHandler, ArrayListHandler, BeanHandler, BeanListHandler, ColumnListHandler, KeyedHandler, MapHandler, MapListHandler, ScalarHandler
</code></pre><p>方法：</p>
<pre><code>handle(ResultSet rs)
Turn the ResultSet into an Object.
</code></pre><p>上面那些已知的子类肯定是已经重写好ResultSet方法了，不需要我们再写了；直接用即可<br>例如</p>
<pre><code>QueryRunner qr = new QueryRunner(DruidUtil.getDataSource());给他一个dataSource就不用我们自己设置了
List&lt;Emp&gt; list = qr.query(sql,new BeanListHandler&lt;Emp&gt;(Emp.class));//获取得到查询的结果包装成bean集合，需要自己先创建一个bean类，然后他会自己去找对应的setXX方法，
</code></pre><p><strong>注意1</strong>这里的setXX()方法的XX 必须和数据库的字段一样，要不然找不到。可以和类里的成员变量不一样。但是必须和数据库的字段名一样<br>例如：(如果mysql保存的字段是id)</p>
<pre><code>emp.java
void setId(int cid){
  this.cid = cid; //成功，因为setXX和数据库中的一致
}
void setCid(int cid){
  this.cid = cid; //失败这就找不到
}
</code></pre><p><strong>注意2</strong><br>我们建议在创建 QueryRunner 时候还是给一个dataSource 给他构造，这样DButil会帮我们关掉connection 要不然要我们自己需要关，当使用事务的时候，我们就需要自己设置connection的setAutoCommit,commit,rollback等等，就需要我们自己去创建一个connection了</p>
<p>我们去QueryRunner源码看看就知道了：假设就看query方法：<br>//我们已经写了dataSorce不带connection写法：</p>
<pre><code>public &lt;T&gt; T query(String sql, ResultSetHandler&lt;T&gt; rsh) throws SQLException {
    Connection conn = this.prepareConnection(); //自动给我从dataSource里面取出连接
    return this.query(conn, true, sql, rsh, (Object[])null);
}
</code></pre><p>//没有写dataSorce自己写了一个getConnection()获得一个connection传进去</p>
<pre><code>public &lt;T&gt; T query(Connection conn, String sql, ResultSetHandler&lt;T&gt; rsh) throws SQLException {
    return this.query(conn, false, sql, rsh, (Object[])null);
}
</code></pre><p>我们发现最终调用了：</p>
<pre><code>private &lt;T&gt; T query(Connection conn, boolean closeConn, String sql, ResultSetHandler&lt;T&gt; rsh, Object... params) throws SQLException {
</code></pre><p>如果我们自己没有传connection,他会自己去找dataSorce里面拿一个connection,看prepareConnection()方法</p>
<pre><code>protected Connection prepareConnection() throws SQLException {
    if (this.getDataSource() == null) {
        throw new SQLException(&quot;QueryRunner requires a DataSource to be invoked in this way, or a Connection should be passed in&quot;);
    } else {
        return this.getDataSource().getConnection(); //他自己去用我们传的dataSorce里面去拿一个
    }
}
</code></pre><p>而query方法里这里有一个布尔值的参数： <strong>closeCon</strong>，这个标签就控制了是否会帮我们关闭connection连接,当我们没有传connection是true,当我们传connection时候是false;</p>
<p>一起来解析一下这个函数：</p>
<pre><code>private &lt;T&gt; T query(Connection conn, boolean closeConn, String sql, ResultSetHandler&lt;T&gt; rsh, Object... params) throws SQLException {
    //如果连接是conn
    if (conn == null) {
        throw new SQLException(&quot;Null connection&quot;);
        //如果sql语句是null
    } else if (sql == null) {
        if (closeConn) {
            this.close(conn);
        }
        throw new SQLException(&quot;Null SQL statement&quot;);
        //如果resultSetHandler是null就关闭
    } else if (rsh == null) {
        if (closeConn) {
            this.close(conn);
        }
        throw new SQLException(&quot;Null ResultSetHandler&quot;);

    //这里才开始判断
    } else {
        PreparedStatement stmt = null;
        ResultSet rs = null;
        Object result = null;
        try {
            stmt = this.prepareStatement(conn, sql);
            this.fillStatement(stmt, params);  //就是我们的setXX(index,value)那个方法
            rs = this.wrap(stmt.executeQuery()); //这一步啥也没干
            result = rsh.handle(rs);
        } catch (SQLException var33) {
            this.rethrow(var33, sql, params);
        } finally {
            try {
                //关闭resultSet
                this.close(rs);
            } finally {
                //关闭statement
                this.close(stmt);
                //如果设置了closeConn为true则把他放会到池子里
                if (closeConn) {
                    this.close(conn);
                }
            }
        }
        return result;
    }
}
</code></pre><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>//junit单元测试<br>//如何做到的?  反射调用某个方法<br>//rsh内部通过反射然后调用相应类的set方法，将数据库的相应字段的值赋给对应的成员变量<br>//javabena中的某个成员变量的名称可以不与表中的列名保持一致，但是相应的set方法一定要一致<br>在方法上面写：    @Test<br>就会运行这个方法，<br>但是要记得先导入java.junit.Test;例如测试一下ResultSetHandler的 子类beanListHandler就可以这样写：</p>
<pre><code>@Test
public void test1(){
    QueryRunner runner = new QueryRunner(DruidUtil.getDataSource());
    try {
        List&lt;Dept&gt; list = runner.query(&quot;select * from Dept where id &gt; ?&quot;, new BeanListHandler&lt;Dept&gt;(Dept.class),2);
        for (Dept Dept : list) {
            System.out.println(Dept);
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
}
</code></pre><p>后面几天都是在讲前端的东西，但是讲的不好，我自己总结了，但是很多东西都忘记。所以等我整理出来在发前端的知识吧</p>
<h2 id="星期三（8-7）"><a href="#星期三（8-7）" class="headerlink" title="星期三（8.7）"></a>星期三（8.7）</h2><h2 id="星期四（8-8）"><a href="#星期四（8-8）" class="headerlink" title="星期四（8.8）"></a>星期四（8.8）</h2><h2 id="星期五（8-9）"><a href="#星期五（8-9）" class="headerlink" title="星期五（8.9）"></a>星期五（8.9）</h2><h2 id="星期六（8-10）"><a href="#星期六（8-10）" class="headerlink" title="星期六（8.10）"></a>星期六（8.10）</h2><h3 id="本周小总结："><a href="#本周小总结：" class="headerlink" title="本周小总结："></a>本周小总结：</h3><p>1.关于批处理问题：报错</p>
<pre><code>java.sql.BatchUpdateException: No value specified for parameter 1
在使用prepareStatement.addBatch()；
在addBatch之前，最好setXX 对之前的sql语句进行修改，而不要空过，这样会报错不懂为啥
如果之前没有占位符，那就手动加一个占位符

例如：
    String s1 = &quot;insert into student () value ()&quot;;
    PreparedStatement preparedstatement = connection.preparedstatement(s1);
    preparestatement.addBatch();//这里可能报错

    String s1 = &quot;insert into student (id,math) value (null,?)&quot;;
    PreparedStatement preparedstatement = connection.preparedstatement(s1);
    preparedstatement.setDouble(1,100);
    preparestatement.addBatch();//这就不会报错了
</code></pre><p>2.debug窗口可以移动。有几个页面注意<br>watch 和 variable不一样 ，variable才是我们debug能看到的变量的参数</p>
<p>3.java.sql.SQLException: com.mysql.jdbc.Driver<br>今天讲的三个连接池，还有DBUtil必须还要添加mysql-connection<br>要不然还是会报错找不到driver</p>
<p>4.主键被删了好像不能再设置成主键？<br>报错<br>ALTER TABLE causes auto_increment resequencing, resulting in duplicate entry ‘1’ for key ‘PRIMARY’<br>设置主键字段为自动递增时报错：<br>解答：需要把数据中已存在主键值为0的记录，改成不为0且不重复的任意数字，而且要包装数字是自增的</p>
<p>5一些内容：</p>
<pre><code>SEO（Search Engine Optimization）
https://baike.baidu.com/item/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BC%98%E5%8C%96/3132?fromtitle=seo&amp;fromid=102990&amp;fr=aladdin

2.html——a标签与base标签
base已经淘汰了。就用a标签好了

3.Go语言
了解了一下

4.安排
把前端先过完一遍，再回顾之前写的东西

5。
一些技术栈：
quasarchs
http://www.quasarchs.com/guide/index.html
vue

6. HTML标准
https://html.spec.whatwg.org/multipage/

7 做作业忘记的标签，也就是还没复习到的标签
    1、input radio设置默认选中值 加checked
    2、label 能够点击能够跳转到对应的输入框
    &lt;form&gt;
      &lt;label for=&quot;male&quot;&gt;Male&lt;/label&gt;
      &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;male&quot; /&gt;
      &lt;br /&gt;
      &lt;label for=&quot;female&quot;&gt;Female&lt;/label&gt;
      &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;female&quot; /&gt;
    &lt;/form&gt;
    3、获取DOM getElementById()
    4、监听事件addEventListener() //注意要window.onload 之后才可以
    5、单选框radio 复选框checkbox
    6、下拉列表
    &lt;selection&gt;
      &lt;option value = &quot;1&quot;&gt;1&lt;/option&gt;
      &lt;option value = &quot;2&quot;&gt;2&lt;/option&gt;
      &lt;option value = &quot;3&quot;&gt;3&lt;/option&gt;
    &lt;/selection&gt;

8.前端技术栈：
vscode
</code></pre><p>6.关于反射：</p>
<pre><code>Constructor&lt;T&gt;getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)
Constructor&lt;?&gt;[] getDeclaredConstructors()
</code></pre><p>如果是getDeclaredConstructors（）获取Constructor数组不需要设置</p>
<pre><code>void setAccessible(boolean flag)
</code></pre><p>将此对象的 accessible 标志设置为指示的布尔值，为true，就可以拿到所有的自己Declared的构造函数。<br>那么可以立即推：我相信所有的getDeclaredFields()和getDeclaredMethods()也不需要设置，能拿到所有自己定义的；</p>
<p>7.其他<br>        2、&nbsp;表示英文空格， 两个英文空格是一个汉字长度</p>
<pre><code>3.误删IDEA的out中的字节码文件，把整个module都删了就能重新生成一个out的module文件夹

4flutter
谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。

5.select 选择触发事件 onchange

6.如何设置默认选项
  &lt;option  selected=&quot;selected&quot;&gt;&lt;/option&gt;
</code></pre><p>8.CSS3相关 动画布局<br>        1.背景颜色的透明度，设置RGBA<br>         background-color:rgba(255,45,81,0); color: #fff;</p>
<pre><code>2.动画属性
animation:animation_name 2s;
在下面再定义
@keyframes{
  0% {}
  100% {}
}

div.show{
  animation:myAnimation 0.5s;
  border-radius: 5px;
  background: #ff2d51;
  color: #fff;
}
@keyframes myAnimation {
  0%   { background-color:rgba(255,45,81,0); color: #fff; }
  100% { background-color:rgba(255,45,81,1); color: #fff;}
}

3.flex属性
container 和 里面的item
</code></pre><p><strong>我觉得这些东西一定要天天搞，熟能生巧</strong></p>
<p>9.margin塌陷问题<br>父元素使用：</p>
<pre><code>overflow ： hidden;
</code></pre><p><a href="https://www.cnblogs.com/syp172654682/p/7671830.html" target="_blank" rel="external">文章</a></p>
<p>10.css 如何让test-align : justify生效<br>不能是只有一行的，或者是最后一行<br>需要给他再加一行</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/04/Java总结（六）下/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王邸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路要坚持">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/04/Java总结（六）下/" itemprop="url">Java总结（六）下</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-04T23:18:31+08:00">
                2019-08-04
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/08/04/Java总结（六）下/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/08/04/Java总结（六）下/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>接下来JAVAEE，一开始先学习mysql数据库的语言（sql）操作的语言四种（DDL,DML,DQL,DCL(没讲之后我补上),TPL），数据库主要进行的是查询Query一定要会，JDBC（JAVA DB CONNECTIVITY）三连(connection preparedstatement,resultset)</p>
<h2 id="星期四-8-01"><a href="#星期四-8-01" class="headerlink" title="星期四(8.01)"></a>星期四(8.01)</h2><h2 id="MYSQL学习"><a href="#MYSQL学习" class="headerlink" title="MYSQL学习"></a>MYSQL学习</h2><p>总结指令的编写：</p>
<p>登录本机mysql:</p>
<pre><code>mysql -u 用户名 -p 输入密码。默认的root;
</code></pre><p>注意：请正确认识 “SQL 不区分大小写“</p>
<p>组成：</p>
<pre><code>DDL：数据定义语言
DML：数据操作语言
DQL： 数据查询语言
DCL： 数据控制语言
TPL： 事务处理语言
</code></pre><h2 id="DDL：Data-Definition-Language"><a href="#DDL：Data-Definition-Language" class="headerlink" title="DDL：Data Definition Language"></a>DDL：Data Definition Language</h2><p>作用：创建 &amp; 管理 数据库和表 的结构。<br>常用关键字：</p>
<pre><code>CREATE  SHOW  ALTER   DROP
</code></pre><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="创建数据库-create"><a href="#创建数据库-create" class="headerlink" title="创建数据库(create)"></a>创建数据库(create)</h3><p>1.默认方式创造数据库</p>
<pre><code>CREATE database db_name;
</code></pre><p>2.创建有参数的数据库</p>
<pre><code>CREATE database db_name CHARACTER SET UTF8 COLLEATE UTF8_GENERAL_CI;
</code></pre><p>create_specification:</p>
<pre><code>[DEFAULT] CHARACTER SET charset_name | [DEFAULT] COLLATE collation_name
</code></pre><p><strong>注意事项</strong>: utf-8在数据库里面写的是utf8</p>
<p>collection_name;<br>utf8_general_ci（不区分大小写）, utf8_bin（区分大小写）</p>
<h3 id="查看数据库-show-："><a href="#查看数据库-show-：" class="headerlink" title="查看数据库(show)："></a>查看数据库(show)：</h3><p>1.显示数据库的语句</p>
<pre><code>SHOW databases;
</code></pre><p>2.显示数据库创建语句</p>
<pre><code>SHOW CREATE DATABASE db_name;
</code></pre><h3 id="删除数据库-DROP"><a href="#删除数据库-DROP" class="headerlink" title="删除数据库(DROP)"></a>删除数据库(DROP)</h3><pre><code>DROP DATABASE db_name;
</code></pre><h3 id="修改数据库（ALTER）"><a href="#修改数据库（ALTER）" class="headerlink" title="修改数据库（ALTER）"></a>修改数据库（ALTER）</h3><p>1.修改数据库名字<br>很遗憾地告诉你，官方并没有提供直接修改数据库名称的命令。但网上有提供各种修改数据库名称的脚本，感兴趣的同学可以自己去研究~~~</p>
<p>2.修改数据库创建的参数；</p>
<pre><code>ALTER  DATABASE   db_name   
[alter_specification [, alter_specification] ...]

ALTER DATABASE DB_NAME CHARACTER utf8; //修改字符编码格式
</code></pre><h3 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h3><pre><code>USE db_name;
</code></pre><h2 id="表"><a href="#表" class="headerlink" title="表"></a>表</h2><h3 id="创建表-create"><a href="#创建表-create" class="headerlink" title="创建表(create)"></a>创建表(create)</h3><pre><code>CREATE TABLE table_name
(
  field1  datatype,
  field2  datatype,
  field3  datatype
)[CHARACTER SET 字符集 COLLATE 校对规则]
field：指定列名　datatype：指定列类型
</code></pre><p>问题：表名是否可以和数据库名字相同？<br>可以创建和数据库名字相同的表名；</p>
<h4 id="datatype（创建表参数）"><a href="#datatype（创建表参数）" class="headerlink" title="datatype（创建表参数）:"></a>datatype（创建表参数）:</h4><p><strong>注意：这里以MySQL为例，不同的DBMS的都支持数值类型，字符串类型以及日期类型，但他们的实现可能不一样。</strong></p>
<p>整数类型<br>数据类型|占用字节|说明<br>-:|:-:|:-<br>TINYINT   |1| 很小的整数<br>SMALLINT  |2| 小的整数<br>MEDIUMINT |3| 中等大小的整数<br>INT       |4| 普通大小的整数<br>BIGINT    |8| 大整数</p>
<p>浮点数类型和定点数类型<br>类型名称|占用字节|说明<br>-:|:-:|:-<br>FLOAT(M,D)    |4   |单精度浮点数<br>DOUBLE(M,D)   |8   |双精度浮点数<br>DECIMAL(M,D)  |M+2 |定点数<br>其中</p>
<pre><code>M 称为精度，表示总共的位数;
D 称为标度，表示小数的位数。
DECIMAL 类型不同于 FLOAT &amp; DOUBLE，DECIMAL 实际是以字符串存放的，它的存储空间并不固定，而是由精度 M 决定的。
</code></pre><p>例如：</p>
<pre><code>CREATE TABLE float_data(float1 FLOAT(5,3),double1 DOUBLE(5,3),decimal1 decimal(5,3));
</code></pre><p><strong><em>这三个有什么区别？</em></strong><br>（回答）<br>1.默认不设置MD,FLOAT显示6位，DOUBLE全部 显示。DECIMAL 只显示整数部分。他们小数部分都四舍五入；</p>
<h3 id="日期与时间类型"><a href="#日期与时间类型" class="headerlink" title="日期与时间类型"></a>日期与时间类型</h3><table>
<thead>
<tr>
<th style="text-align:right">类型名称</th>
<th style="text-align:center">日期格式</th>
<th style="text-align:left">占用字节</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">YEAR</td>
<td style="text-align:center">YYYY       (2018)</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:right">TIME</td>
<td style="text-align:center">HH:MM:SS   (10:20:00)</td>
<td style="text-align:left">3</td>
</tr>
<tr>
<td style="text-align:right">DATE</td>
<td style="text-align:center">YYYY-MM-DD (2018-7-23)</td>
<td style="text-align:left">3</td>
</tr>
<tr>
<td style="text-align:right">DATETIME</td>
<td style="text-align:center">YYYY-MM-DD HH:MM:SS</td>
<td style="text-align:left">8</td>
</tr>
<tr>
<td style="text-align:right">TIMESTAMP</td>
<td style="text-align:center">YYYY-MM-DD HH:MM:SS</td>
<td style="text-align:left">4</td>
</tr>
</tbody>
</table>
<p>DATETIME 和 TIMESTAMP 虽然显示的格式是一样的，但是它们有很大的区别：</p>
<pre><code>1.DATETIME 的系统默认值是 NULL, 而 TIMESTAMP 的系统默认值是 当前时间 NOW();
2.DATETIME 存储的时间与时区无关，而 TIMESTAMP 与时区有关
</code></pre><p>例子：</p>
<pre><code>CREATE table time1(t4 datetime, t5 timestamp);
INSERT INTO time1 values (now(),now());

INSERT INTO time1 values（）; //datetime默认值是null

set time_zone = &apos;+10:00&apos;;
//里面的timestamp会动态的更改成+10时区的时间，而datetime不变
</code></pre><p>字符串类型</p>
<table>
<thead>
<tr>
<th style="text-align:right">类型名称</th>
<th style="text-align:center">占用字节</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">CHAR(M)</td>
<td style="text-align:center">M, 1 &lt;= M &lt;= 255</td>
<td style="text-align:left">固定长度字符串</td>
</tr>
<tr>
<td style="text-align:right">VARCHAR(M)</td>
<td style="text-align:center">L+1, L &lt;=M, 1 &lt;=M &lt;=255</td>
<td style="text-align:left">变长字符串</td>
</tr>
<tr>
<td style="text-align:right">TINYTEXT</td>
<td style="text-align:center">L+1, L &lt; 2^8</td>
<td style="text-align:left">非常小的文本字符串</td>
</tr>
<tr>
<td style="text-align:right">TEXT</td>
<td style="text-align:center">L+2, L &lt; 2^16</td>
<td style="text-align:left">小的文本字符串</td>
</tr>
<tr>
<td style="text-align:right">MEDIUMTEXT</td>
<td style="text-align:center">L+3, L &lt; 2^24</td>
<td style="text-align:left">中等大小的文本字符串</td>
</tr>
<tr>
<td style="text-align:right">LONGTEXT</td>
<td style="text-align:center">L+4, L &lt; 2^32</td>
<td style="text-align:left">大的文本字符串</td>
</tr>
<tr>
<td style="text-align:right">ENUM</td>
<td style="text-align:center">1 或者 2个字节，</td>
<td style="text-align:left">取决于枚举的数目，最大 65535个  枚举类型</td>
</tr>
<tr>
<td style="text-align:right">SET</td>
<td style="text-align:center">1,2,3,4或8个字节</td>
<td style="text-align:left">集合类型</td>
</tr>
</tbody>
</table>
<p>ENUM 类型总有一个默认值，当ENUM 列声明为NULL，则默认值为NULL。如果 ENUM 列被声明为 NOT NULL，<br>则其默认值为列表的第一个元素。</p>
<p>ENUM 和 SET有什么区别</p>
<pre><code>CREATE TABLE enum_set(enum1 ENUM(&apos;1&apos;,&apos;2&apos;,&apos;3&apos;), set1 SET(&apos;1&apos;,&apos;2&apos;,&apos;3&apos;));
mysql&gt; insert into enum_set values(&apos;1&apos;,&apos;1,2,3&apos;);      //这样就能成功
mysql&gt; insert into enum_set values(&apos;1，2&apos;,&apos;1,2,3&apos;);   //这样就会失败
</code></pre><p>ENUM 设置多个备选项，但是只能选择一个<br>SET  设置多个备选项，也可以选择多个，但是不能选择声明外的<br>注意在插入时候两个写的格式是： ‘ ， ，’;而不是单独括号括起来<br>    mysql&gt; insert into enum_set values((‘1’),(‘1,2,3’));      //这是错误示范，没有括号，直接写引号；</p>
<h3 id="查询表-desc"><a href="#查询表-desc" class="headerlink" title="查询表(desc)"></a>查询表(desc)</h3><p>简单描述表结构</p>
<pre><code>DESC 表名
DESCRIBE 表名
</code></pre><p>查看生成数据定义语言的语句</p>
<pre><code>show create table table_name;
</code></pre><p>打印之后看到如下的属性页面，我之后会一个一个解释<br>Field|Type    | Null | Key | Default | Extra<br>id   | int(11)| YES  |     | NULL    |</p>
<pre><code>Field:属性名字
type:数据类型
Null:应该是是否可以为null
key:比如主键、外键。这个是用来建立索引的。
Default:默认约束。输入数据时，如果不指定该列的值，那么就使用默认约束规定的值。
Extra:对字段额外的说明
</code></pre><h3 id="修改表-ALTER"><a href="#修改表-ALTER" class="headerlink" title="修改表(ALTER)"></a>修改表(ALTER)</h3><h3 id="ALTER-TABLE-table-name-ADD-增加一列"><a href="#ALTER-TABLE-table-name-ADD-增加一列" class="headerlink" title="ALTER TABLE table_name ADD //增加一列"></a>ALTER TABLE table_name ADD //增加一列</h3><pre><code>ALTER TABLE table_name
ADD      (column datatype [DEFAULT expr]
       [,ADD column datatype]...);
</code></pre><h3 id="ALTER-TABLE-table-name-CHANGE-改变一列的name和datatype"><a href="#ALTER-TABLE-table-name-CHANGE-改变一列的name和datatype" class="headerlink" title="ALTER TABLE table_name CHANGE  改变一列的name和datatype"></a>ALTER TABLE table_name CHANGE  改变一列的name和datatype</h3><pre><code>ALTER TABLE table_name
change old_col_name new_col_name datatype [DEFAULT expr]
[,change col_name new_col_name datatype [DEFAULT ...] ]...;
</code></pre><h3 id="ALTER-TABLE-table-name-MODIFY-改变一列的datatype"><a href="#ALTER-TABLE-table-name-MODIFY-改变一列的datatype" class="headerlink" title="ALTER TABLE table_name MODIFY  改变一列的datatype"></a>ALTER TABLE table_name MODIFY  改变一列的datatype</h3><pre><code>ALTER TABLE table_name
MODIFY column datatype [DEFAULT expr]
       [,MODIFY column datatype]...;
</code></pre><h3 id="ALTER-TABLE-table-name-DROP-删除一列"><a href="#ALTER-TABLE-table-name-DROP-删除一列" class="headerlink" title="ALTER TABLE table_name DROP; 删除一列"></a>ALTER TABLE table_name DROP; 删除一列</h3><pre><code>ALTER TABLE table_name
DROP        (column);
</code></pre><h3 id="ALTER-TABLE-TABLE-NAME-RENAME-TABLE-table-name-to-new-name-修改表名"><a href="#ALTER-TABLE-TABLE-NAME-RENAME-TABLE-table-name-to-new-name-修改表名" class="headerlink" title="ALTER TABLE TABLE_NAME RENAME TABLE table_name to new_name 修改表名"></a>ALTER TABLE TABLE_NAME RENAME TABLE table_name to new_name 修改表名</h3><p>修改表的名称：RENAME TABLE 表名 TO 新表名</p>
<p>RENAME TABLE 语句的另一个用法是移动该表到另一个数据库<br>语法为：<br>RENAME TABLE 旧数据库名.旧表名 TO 新数据库名.新表名<br>提示：我们可以把 RENAME TABLE 的这两种用法很好地统一起来，如果我们把 “重命名” 理解为 “在同一数据库里的移动”。甚至我们可以省略数据库名，如果你恰好正在使用该数据库。<br>这个就好像Field的重命名一样，也有剪切的效果</p>
<pre><code>File的方法：
boolean renameTo(File dest)
重新命名此抽象路径名表示的文件。
</code></pre><p><strong>注意事项：</strong>只有添加的方法ADD 需要加（） 因为可以增加多个列，要设置括号。<br>其他都是</p>
<pre><code>ALTER TABLE table_name 操作；
</code></pre><h3 id="修改字符集"><a href="#修改字符集" class="headerlink" title="修改字符集"></a>修改字符集</h3><p>修改表的字符集：alter table student character set utf8;<br><strong>注意</strong>这应该要把数据库的字符集也要改了吧 要不然肯定还是不行的；</p>
<h3 id="删除表-DROP"><a href="#删除表-DROP" class="headerlink" title="删除表(DROP)"></a>删除表(DROP)</h3><pre><code>DROP TABLE table_name;
</code></pre><h2 id="DML数据操纵语言结合DQL"><a href="#DML数据操纵语言结合DQL" class="headerlink" title="DML数据操纵语言结合DQL"></a>DML数据操纵语言结合DQL</h2><p>DML:Data Manipulation Language<br>作用：用于向数据库表中插入、删除、修改数据。<br>常用关键字：<br>INSERT UPDATE DELETE</p>
<h3 id="插入（INSERT）"><a href="#插入（INSERT）" class="headerlink" title="插入（INSERT）"></a>插入（INSERT）</h3><pre><code>INSERT INTO table_name [(column [, column...])]
VALUES    (value [, value...]);
</code></pre><p>插入的数据应与字段的数据类型相同。<br>数据的大小应在列的规定范围内，例如：不能将一个长度为80的字符串加入到长度为40的列中。<br>在values中列出的数据 。<br><strong>字符串和日期型数据应包含在单引号中。</strong><br>插入空值 insert into table value(null)  //注意之前设置table时候有可以设置是否可以为null;默认是yes;</p>
<h3 id="更新（UPDATE）"><a href="#更新（UPDATE）" class="headerlink" title="更新（UPDATE）"></a>更新（UPDATE）</h3><p>使用 update语句修改表中数据。</p>
<pre><code>UPDATE  table_name   
  SET col_name1 = expr1 [, col_name2=expr2 ...]    
  [WHERE where_definition]   
</code></pre><p><strong>注意事项</strong></p>
<ol>
<li>UPDATE语法可以用新值更新原有表行中的各列。</li>
<li>SET子句指示要修改哪些列和要给予哪些值。</li>
<li>WHERE子句指定应更新哪些行。如没有WHERE子句，则更新所有的行。</li>
</ol>
<p><strong>特别要注意的是： NULL+任何数的结果都是NULL 这里并不会报错</strong></p>
<h3 id="删除（DELETE）"><a href="#删除（DELETE）" class="headerlink" title="删除（DELETE）"></a>删除（DELETE）</h3><p>使用 delete语句删除表中数据。</p>
<pre><code>DELETE  from  table_name       
  [WHERE where_definition]   
</code></pre><p>如果不使用where子句，将删除表中所有数据。<br>Delete语句不能删除某一列的值，可使用update把一列的值都改了。或者直接 ALTER TABLE table_name drop colname;删除一列<br>delete删除的单位是行<br>使用delete语句仅删除记录，不删除表本身。如要删除表，使用drop  table语句。<br><strong>同insert和update一样，从一个表中删除记录将引起其它表的参照完整性问题，在修改数据库数据时，头脑中应该始终不要忘记这个潜在的问题。</strong></p>
<h2 id="DQL数据查询语言（简单查询）"><a href="#DQL数据查询语言（简单查询）" class="headerlink" title="DQL数据查询语言（简单查询）"></a>DQL数据查询语言（简单查询）</h2><p>DQL：Data Query Language<br>作用：查询表中的数据。<br>关键字：<br>    SELECT</p>
<h3 id="查询-SELECT"><a href="#查询-SELECT" class="headerlink" title="查询(SELECT)"></a>查询(SELECT)</h3><pre><code>SELECT column_name1 From table_name;
SELECT column_name1,column_name2 From table_name;
SELECT * From table_name;
</code></pre><h3 id="使用-WHERE-子句过滤记录"><a href="#使用-WHERE-子句过滤记录" class="headerlink" title="使用 WHERE 子句过滤记录"></a>使用 WHERE 子句过滤记录</h3><pre><code>SELECT * | {column_names}
FROM table_name
WHERE &lt;filter_condition&gt;;
</code></pre><p>filter_condition 是一个逻辑表达式，即表达式的结果是布尔类型</p>
<h3 id="常见运算符介绍"><a href="#常见运算符介绍" class="headerlink" title="常见运算符介绍"></a>常见运算符介绍</h3><p>算术运算符</p>
<pre><code>+    -    *    /     %
</code></pre><table>
<thead>
<tr>
<th style="text-align:right">运算符</th>
<th style="text-align:center">作用</th>
<th style="text-align:center">运算符</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">=</td>
<td style="text-align:center">等于</td>
<td style="text-align:center">&lt;=&gt;</td>
<td style="text-align:left">安全的等于</td>
</tr>
<tr>
<td style="text-align:right">&lt;&gt; (!=)</td>
<td style="text-align:center">不等于</td>
<td style="text-align:center">&lt;=</td>
<td style="text-align:left">小于等于</td>
</tr>
<tr>
<td style="text-align:right">&gt;=</td>
<td style="text-align:center">大于等于</td>
<td style="text-align:center">&gt;</td>
<td style="text-align:left">大于</td>
</tr>
<tr>
<td style="text-align:right">IS NULL</td>
<td style="text-align:center">是否为NULL</td>
<td style="text-align:center">IS NOT NULL</td>
<td style="text-align:left">是否不为NULL</td>
</tr>
<tr>
<td style="text-align:right">BETWEEN AND</td>
<td style="text-align:center">是否在闭区间内</td>
<td style="text-align:center">IN</td>
<td style="text-align:left">是否在列表内</td>
</tr>
<tr>
<td style="text-align:right">NOT IN</td>
<td style="text-align:center">是否不在列表内</td>
<td style="text-align:center">LIKE</td>
<td style="text-align:left">通配符匹配</td>
</tr>
</tbody>
</table>
<p>逻辑运算符<br>      NOT(!)       AND(&amp;&amp;)      OR(||)<br>位操作运算符<br>      &amp;     |     ~     ^     &lt;&lt;     &gt;&gt;</p>
<h3 id="lt-gt-安全的等于"><a href="#lt-gt-安全的等于" class="headerlink" title="&lt;=&gt; 安全的等于"></a>&lt;=&gt; 安全的等于</h3><p>可以找到值为null的数据<br>= 找不到值为null的数据</p>
<h3 id="LIKE"><a href="#LIKE" class="headerlink" title="LIKE"></a>LIKE</h3><p>模糊匹配</p>
<pre><code>select * from student where NAME LIKE &apos;陆%&apos;;
</code></pre><p>通配符规则：</p>
<pre><code>‘%’ 匹配任何数目的字符，甚至包括零字符
‘_’ 只能匹配一个字符
</code></pre><h3 id="DISTINCT-过滤相同的记录"><a href="#DISTINCT-过滤相同的记录" class="headerlink" title="DISTINCT 过滤相同的记录"></a>DISTINCT 过滤相同的记录</h3><pre><code>SELECT DISTINCT {column_names}
FROM table_name;
</code></pre><p><strong>注意事项：</strong>过滤不能和聚合函数连用</p>
<pre><code>select distinct (gender) count(gender) from student; //报错
</code></pre><h3 id="LIMIT-限制结果-分页"><a href="#LIMIT-限制结果-分页" class="headerlink" title="LIMIT 限制结果(分页)"></a>LIMIT 限制结果(分页)</h3><p>SELECT 语句返回所有匹配的记录。但是如果我们只想返回第一行或者一定数量的行，这该怎么办呢？<br>在 MySQL 中，我们可以用 LIMIT 关键字实现这一要求。</p>
<pre><code>SELECT * FROM file_name LIMIT offset, nums;     -- LIMIT 3, 4;
--OR
SELECT * FROM file_name LIMIT nums OFFSET offset;（建议第二种）
</code></pre><p>注意：offset是指偏移量，当我们从第1行查起，偏移量自然为0。此时，可以写成 LIMIT nums;<br>扩展：我们可以使用 LIMIT 关键字实现分页查询。 LIMIT (page_num – 1) * page_size, page_size;</p>
<h3 id="ORDER-BY-排序"><a href="#ORDER-BY-排序" class="headerlink" title="ORDER BY 排序"></a>ORDER BY 排序</h3><p>我们可以使用 ORDER BY 子句对查询结果进行排序。</p>
<pre><code>select * from file_name order by column_name asc); //升序asc 降序desc
</code></pre><p>默认是升序asc</p>
<p><strong>注意事项</strong> ORDER BY 和LIMIT 同时存在的时候，ORDER BY 要写在 LIMIT前面;我发现的；</p>
<pre><code>SELECT * FROM EMPLOYEE ORDER BY math LIMIT 3 OFFSET 1;
</code></pre><p>功能全部加上</p>
<pre><code>SELECT DISTINCT {column_name} from file_name ORDER BY math LIMIT num OFFSET offset;
</code></pre><h2 id="星期五-8-02"><a href="#星期五-8-02" class="headerlink" title="星期五(8.02)"></a>星期五(8.02)</h2><p>MYSQL的控制：<br><a href="http://makaidong.com/linguoguo/148551_1704957.html" target="_blank" rel="external">链接</a></p>
<p>2.ppt设置的超链接的文档打不开<br>把pptx的格式设置成ppt格式就可以了；<br>原理我也不知道- -</p>
<h2 id="今日学习总结"><a href="#今日学习总结" class="headerlink" title="今日学习总结"></a>今日学习总结</h2><p>昨天学习到order by 今天我们继续；</p>
<h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>当然，我们可以给 Chinese + math + english 起一个更简单直接一点的名字。AS 关键字就可以做到这一点。</p>
<pre><code>SELECT name, chinese + math + english AS total FROM t_students;
</code></pre><p>注意：在很多DBMS中，AS关键字是可选的，不过最好使用它，这被视为一条最佳实践。<br>提示：AS 关键字不仅能给列起别名，还可以给表起别名。在多表查询中，我们会这样使用它。</p>
<h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p>位置：在select后面</p>
<p>COUNT()</p>
<p>COUNT(*) 计算表中的总行数;<br>COUNT(column_name) 计算指定列下的总行数，<br>计算时将忽略值为NULL的行。<br>这里计算的是总的行数，下面计算的是一列的总和。</p>
<p>SUM():返回指定<strong>列</strong>的所有值之和<br>    计算时将忽略值为NULL的行;<br>AVG():返回指定<strong>列</strong>的平均值<br>    计算时将忽略值为NULL的行;<br><strong>注意事项</strong>： AVG()求平均值的个数，并不是里面数据的条数，而是有值非null的个数，当我插入一个math为null的数据。求出平均值和之前的相同</p>
<p>MAX():返回指定<strong>列</strong>的最大值<br>    计算时将忽略值为NULL的行;<br>MIN():返回指定<strong>列</strong>的最小值<br>    计算时将忽略值为NULL的行;</p>
<p>查询全班平均成绩</p>
<pre><code>select avg(math) as &apos;数学&apos;, avg(chinese) as &apos;中文 &apos;,avg(english) as &apos;英语&apos; from t_students;
</code></pre><h3 id="分组查询GROUP-BY"><a href="#分组查询GROUP-BY" class="headerlink" title="分组查询GROUP BY"></a>分组查询GROUP BY</h3><p>比如：我们想统计各班学生的人数，该怎么办？这时候我们就得用到分组的概念。在 SQL 中，我们使用 GROUP BY 关键字对数据进行分组。<br>位置：加在from table_name的后面</p>
<pre><code>[GROUP BY {column_names}] [HAVING &lt;filter_condition&gt;]
使用 HAVING 过滤分组
</code></pre><h3 id="having-and-where"><a href="#having-and-where" class="headerlink" title="having and where"></a>having and where</h3><pre><code>Where  语句在分组之前，执行完where语句再去对数据进行分组
Having 语句在分组之后，执行完分组之后，再对分组数据进行一个过滤筛选。
and    最先执行，在where之前

select class,name from t_students group by class;
</code></pre><p>例子：获取每个班的人数，并且找出人数大于2的班级</p>
<pre><code>select count(id) as &apos;人数&apos; ,class ,group_concat(id) from t_students group by class having 人数 &gt; 2;
+------+-------+------------------+
| 人数 | class | group_concat(id) |
+------+-------+------------------+
|    3 | 一班  | 1,6,7            |
</code></pre><p>GROUP BY 关键字后可以接多个列名，其意思是从左到右，按层次分组。即先按第一个字段分组，然后在第一个字段值相同的记录中，再根据第2个字段的值进行分组…<strong>（多个字段看成一个整体）</strong></p>
<p>分组和排序<br>我们经常发现，用 GROUP BY 分组的数据确实是以分组顺序输出的。此外，即使特定的 DBMS 总是按给出的 GROUP BY 子句排序数据，用户也可能会要求以不同的顺序排序。应该提供明确的 ORDER BY 子句，即使其效果等同于GROUP BY子句。<br>例如：统计每个班多少人，然后按班级人数升序排列(默认升序排列)：</p>
<pre><code>SELECT COUNT(id) AS &apos;人数&apos; , class , group_concat(id) from t_students group by class order by 人数 asc;
</code></pre><h3 id="SELECT语句执行顺序"><a href="#SELECT语句执行顺序" class="headerlink" title="SELECT语句执行顺序"></a>SELECT语句执行顺序</h3><p>顺序表示写法 括号的序号，表示指令执行的顺序；</p>
<p><em>(5)</em> SELECT column_name, 聚合函数…<br><em>(1)</em> FROM table_name, …<br><em>(2)</em> [WHERE …]<br><em>(3)</em> [GROUP BY …]<br><em>(4)</em> [HAVING …]<br><em>(6)</em> [ORDER BY …];<br><em>(7)</em> [LIMIT nums OFFSET offset …];//分页是最后的</p>
<h3 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h3><p>数据完整性是为了保证插入到数据库中的数据是正确的，它防止了用户可能的输入错误。<br>数据完整性主要分为以下三类：</p>
<p>实体完整性 （唯一性）</p>
<pre><code>规定表的一行（即每一条记录）在表中是唯一的实体。实体完整性通过表的主键来实现。
</code></pre><p>域完整性：</p>
<pre><code>指数据库表的列（即字段）必须符合某种特定的数据类型或约束。比如NOT NULL。
</code></pre><p>参照完整性：</p>
<pre><code>保证一个表的外键和另一个表的主键对应。
</code></pre><h3 id="数据主键：表中经常有一个列或列的组合，其值能唯一地标识表中的每一行。这样的一列或多列称为表的主键，通过它可强制表的实体完整性。当创建或更改表时可通过定义PRIMARY-KEY-约束来创建主键。一个表只能有一个-PRIMARY-KEY-约束，而且-PRIMARY-KEY-约束中的列不能接受空值。由于-PRIMARY-KEY-约束确保唯一数据，所以经常用来定义标识列。-作用"><a href="#数据主键：表中经常有一个列或列的组合，其值能唯一地标识表中的每一行。这样的一列或多列称为表的主键，通过它可强制表的实体完整性。当创建或更改表时可通过定义PRIMARY-KEY-约束来创建主键。一个表只能有一个-PRIMARY-KEY-约束，而且-PRIMARY-KEY-约束中的列不能接受空值。由于-PRIMARY-KEY-约束确保唯一数据，所以经常用来定义标识列。-作用" class="headerlink" title="数据主键：表中经常有一个列或列的组合，其值能唯一地标识表中的每一行。这样的一列或多列称为表的主键，通过它可强制表的实体完整性。当创建或更改表时可通过定义PRIMARY KEY 约束来创建主键。一个表只能有一个 PRIMARY KEY 约束，而且 PRIMARY KEY 约束中的列不能接受空值。由于 PRIMARY KEY 约束确保唯一数据，所以经常用来定义标识列。 作用 :"></a>数据主键：表中经常有一个列或列的组合，其值能唯一地标识表中的每一行。这样的一列或多列称为表的主键，通过它可强制表的实体完整性。当创建或更改表时可通过定义<strong>PRIMARY KEY</strong> 约束来创建主键。一个表只能有一个 PRIMARY KEY 约束，而且 PRIMARY KEY 约束中的列不能接受空值。由于 PRIMARY KEY 约束确保唯一数据，所以经常用来定义标识列。 作用 :</h3><pre><code>1）保证实体的完整性;
2）加快数据库的操作速度
3） 在表中添加新记录时，会自动检查新记录的主键值，不允许该值与其他记录的主键值重复。
4) 自动按主键值的顺序显示表中的记录。如果没有定义主键，则按输入记录的顺序显示表中的记录。
</code></pre><h3 id="新建表的时候创建（CREATE）"><a href="#新建表的时候创建（CREATE）" class="headerlink" title="新建表的时候创建（CREATE）"></a>新建表的时候创建（CREATE）</h3><pre><code>create table people(
  id int primary key auto_increment, //auto_increment默认自增
  name varchar(30)
)
</code></pre><h3 id="修改表创建主键-ALTER"><a href="#修改表创建主键-ALTER" class="headerlink" title="修改表创建主键(ALTER)"></a>修改表创建主键(ALTER)</h3><pre><code>ALTER TABLE table_name modify id int primary key auto_increment;
</code></pre><h3 id="主键的删除"><a href="#主键的删除" class="headerlink" title="主键的删除"></a>主键的删除</h3><p><strong>注意事项</strong> 主键要删除，必须先删除自增</p>
<pre><code>ALTER TABLE table_name modify id int;    //删除自增
ALTER TABLE table_name drop primary key; //丢弃主键
</code></pre><h3 id="主键的注意事项"><a href="#主键的注意事项" class="headerlink" title="主键的注意事项"></a>主键的注意事项</h3><p>1.主键默认自增，而且你修改id大于当前自增最大值，默认会把id自增的指针为现在最大值。<br>2.如果当前删除一个元素id = 9, 下次添加元素id = 10,id并不等于9。表中会默认记录曾经最大的id的值，<strong>但是id = 9的地方依旧可以插入</strong>，如果不设置id的值，默认还是最高指针的下一个地方。</p>
<h3 id="唯一约束（-UNIQUE-）"><a href="#唯一约束（-UNIQUE-）" class="headerlink" title="唯一约束（ UNIQUE ）"></a>唯一约束（ UNIQUE ）</h3><p>可以添加多个null值</p>
<h3 id="unique-的新建表的时候创建"><a href="#unique-的新建表的时候创建" class="headerlink" title="unique 的新建表的时候创建"></a>unique 的新建表的时候创建</h3><pre><code>CREATE TABLE table_name(
  email varchar(50) unique;
)
</code></pre><h3 id="unique-修改表创建-ALTER"><a href="#unique-修改表创建-ALTER" class="headerlink" title="unique 修改表创建(ALTER)"></a>unique 修改表创建(ALTER)</h3><pre><code>ALTER TABLE table_name modify email varchar(50) unique;
</code></pre><h3 id="unique的删除"><a href="#unique的删除" class="headerlink" title="unique的删除"></a>unique的删除</h3><pre><code>ALTER TABLT table_name drop index email;
</code></pre><p><strong>注意</strong> 这就表明了 unique是通过index来确认是否是唯一的。</p>
<h3 id="非空约束（not-null）"><a href="#非空约束（not-null）" class="headerlink" title="非空约束（not null）"></a>非空约束（not null）</h3><h3 id="非空的新建表的时候创建"><a href="#非空的新建表的时候创建" class="headerlink" title="非空的新建表的时候创建"></a>非空的新建表的时候创建</h3><pre><code>CREATE TABLE table_name(
  email varchar(50) not null;
)
</code></pre><h3 id="非空的修改表创建-ALTER"><a href="#非空的修改表创建-ALTER" class="headerlink" title="非空的修改表创建(ALTER)"></a>非空的修改表创建(ALTER)</h3><pre><code>ALTER TABLE table_name modify email varchar(50) not null;
</code></pre><h3 id="非空的删除"><a href="#非空的删除" class="headerlink" title="非空的删除"></a>非空的删除</h3><pre><code>ALTER TABLE table_name modify email varchar(50);
</code></pre><h3 id="外键约束（constrain）-重点"><a href="#外键约束（constrain）-重点" class="headerlink" title="外键约束（constrain）!!重点"></a>外键约束（constrain）!!重点</h3><p>比如有两张表，一张学生选课表，另外一张课程表，学生选择的课程必须是课程表中出现的课程，这个时候可以用外键来约束。如果不是课程表内的课程，则无法插入。</p>
<h3 id="外键的新建表的时候创建"><a href="#外键的新建表的时候创建" class="headerlink" title="外键的新建表的时候创建"></a>外键的新建表的时候创建</h3><pre><code>create table course(
  id int primary key auto_increment,
  cname varchar(30),
)

create table students(
  id int primary key auto_increment;
  cid int,
  constraint student_course_FK foreign key (cid) references course (id)
)
</code></pre><h3 id="外键的修改表创建-ALTER"><a href="#外键的修改表创建-ALTER" class="headerlink" title="外键的修改表创建(ALTER)"></a>外键的修改表创建(ALTER)</h3><pre><code>ALTER TABLE table_name add(constraint student_course_FK foreign key (cid) references course id);
</code></pre><h3 id="外键的删除"><a href="#外键的删除" class="headerlink" title="外键的删除"></a>外键的删除</h3><p><strong>删除外键的时候，需要用到新建外键时取的名称。</strong></p>
<pre><code>ALTER TABLE table_name drop foreign key student_course_FK;
ALTER TABLE TABLE_NAME DROP INDEX UNIQUE_NAME;
</code></pre><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><pre><code>SELECT * FROM t_students;  -- This is a annotation
SELECT * FROM t_students;  # This is a annotation
/* Hello World!
     Hello Kitty~  */
SELECT * FROM t_students
</code></pre><h2 id="DQL数据查询语言（多表）"><a href="#DQL数据查询语言（多表）" class="headerlink" title="DQL数据查询语言（多表）"></a>DQL数据查询语言（多表）</h2><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><pre><code>Select *
from TABLE1 join_type TABLE2  [on (join_condition)]
               [where (query_condition)]
</code></pre><h3 id="交叉连接查询"><a href="#交叉连接查询" class="headerlink" title="交叉连接查询"></a>交叉连接查询</h3><p>不带on子句，返回连接表中所有数据行的笛卡儿积。<br>可以写成不带cross的写法，不过用的不多</p>
<pre><code>Select * from table1 cross join table2;
Select * from table1 join table2;
Select * from table1 , table2; //这个速度偏慢
</code></pre><h3 id="内部连接查询"><a href="#内部连接查询" class="headerlink" title="内部连接查询"></a>内部连接查询</h3><p>返回连接表中符合连接条件及查询条件的数据行。</p>
<pre><code>SELECT * FROM customer    c INNER JOIN orders    o ON c.id=o.customer_id;
SELECT * FROM customer as  c INNER JOIN orders as o  ON c.id=o.customer_id;
</code></pre><p><strong>注意事项</strong> 表名的别名不需要加as</p>
<h3 id="外连接查询"><a href="#外连接查询" class="headerlink" title="外连接查询"></a>外连接查询</h3><p>分为左外连接（left out join）、右外连接（right outer join）。与内连接不同的是，外连接不仅返回连接表中符合连接条件及查询条件的数据行，也返回左表（左外连接时）或右表（右外连接时）中仅符合查询条件但不符合连接条件的数据行。</p>
<h3 id="左外连接查询"><a href="#左外连接查询" class="headerlink" title="左外连接查询"></a>左外连接查询</h3><pre><code>SELECT * FROM customer c LEFT OUTER JOIN orders o ON c.id=o.customer_id;
不仅包含符合c.id=o.customer_id连接条件的数据行，还包含左表中的其他数据行
</code></pre><p>带查询条件的左外连接查询，在where子句中设定查询条件</p>
<pre><code>SELECT * FROM customer c LEFT OUTER JOIN orders o ON c.id=o.customer_id WHERE o.price&gt;250;
</code></pre><h3 id="右外连接查询"><a href="#右外连接查询" class="headerlink" title="右外连接查询"></a>右外连接查询</h3><pre><code>SELECT * FROM customer c RIGHT OUTER JOIN orders o ON c.id=o.customer_id;
不仅包含符合c.id=o.customer_id连接条件的数据行，还包含orders右表中的其他数据行
</code></pre><p>带查询条件的右外连接查询，在where子句中设定查询条件</p>
<pre><code>SELECT * FROM customer c RIGHT OUTER JOIN orders o ON c.id = o.customer_id WHERE o.price&gt;250;
</code></pre><p><strong>注意事项</strong>:这里注意一定要用where 不要用成and<br>select * from emp right join dept on emp.deptno = dept.deptno and job = ‘clerk’;<br>+——-+——-+——-+——+——+——–+——–+——–+<br>| empno | ename | job   | mgr  | sal  | deptno | deptno | dname  |<br>+——-+——-+——-+——+——+——–+——–+——–+<br>| 01    | jacky | clerk | tom  | 1000 | 1      | 1      | 事业部 |<br>| 02    | tom   | clerk |      | 2000 | 1      | 1      | 事业部 |<br>| 07    | biddy | clerk |      | 2000 | 1      | 1      | 事业部 |<br>| NULL  | NULL  | NULL  | NULL | NULL | NULL   | 2      | 销售部 |<br>| NULL  | NULL  | NULL  | NULL | NULL | NULL   | 3      | 技术部 |<br>+——-+——-+——-+——+——+——–+——–+——–+</p>
<p>因为在join …on 。。。 之前会先执行and 】<br>就把所有的clerk找出来<br>| empno | ename | job   | mgr  | sal  | deptno | deptno | dname  |<br>| 01    | jacky | clerk | tom  | 1000 | 1      | 1      | 事业部 |<br>| 02    | tom   | clerk |      | 2000 | 1      | 1      | 事业部 |<br>| 07    | biddy | clerk |      | 2000 | 1      | 1      | 事业部 |</p>
<p>然后再和右外连接，拼接<br>+——–+——–+<br>| deptno | dname  |<br>+——–+——–+<br>| 1      | 事业部 |<br>| 2      | 销售部 |<br>| 3      | 技术部 |<br>+——–+——–+</p>
<p>因为左边先and就没有了deptno = 2,3的数据。就出现了两个幽灵行，因为左边没有deptno = 2,3的<br>最后又发现 and 可以先找到 左边表 和 右边表，新建一个新的表 符合and的判断，然后再和另一个表拼接；</p>
<p>当没有join…on 时候。 and 就会变成where</p>
<h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>子查询也叫嵌套查询，是指在where子句或from子句中又嵌入select查询语句（一般写在where字句）<br>练习：<br>查询“郭靖”的所有订单信息</p>
<pre><code>SELECT * FROM orders WHERE customer_id=(SELECT id FROM customer WHERE name LIKE ‘%郭靖%&apos;);
select * from customer c inner join orders o on c.id = o.customer_id and c.name like &apos;%郭靖%&apos;;
</code></pre><h3 id="联合查询（取并集）"><a href="#联合查询（取并集）" class="headerlink" title="联合查询（取并集）"></a>联合查询（取并集）</h3><p>联合查询能够合并两条查询语句的查询结果，去掉其中的重复数据行，然后返并没有重复数据行的查询结果。联合查询使用union关键字<br>SELECT <em> FROM orders WHERE price&gt;100 UNION SELECT </em> FROM orders WHERE customer_id=1;<br>注意：联合查询的各子查询使用的表结构应该相同，同时两个子查询返回的列也应相同。</p>
<h3 id="报表查询"><a href="#报表查询" class="headerlink" title="报表查询"></a>报表查询</h3><p>对数据行进行分组统计，其语法格式为：</p>
<pre><code>select …  from … [where…] [ group by … [having… ]] [ order by … ]
其中group by 子句指定按照哪些字段分组，having子句设定分组查询条件。
</code></pre><h3 id="数据库的备份和还原-（-gt-）"><a href="#数据库的备份和还原-（-gt-）" class="headerlink" title="数据库的备份和还原 （ &gt; ）"></a>数据库的备份和还原 （ &gt; ）</h3><p>在说备份和还原之前，先要知道数据库备份的路径在哪里：</p>
<pre><code>show global variables like &apos;%datadir%&apos;;
datadir： C:\ProgramData\MySQL\MySQL Server 5.7\Data\
</code></pre><p><strong>数据库备份： cmd命令下</strong></p>
<pre><code>mysqldump -u root -p test(数据库名称) &gt; test.sql   在执行这条语句的路径下面创建一个.sql的文件，
</code></pre><p>1) 备份整个数据库</p>
<pre><code>mysqldump -u root -p --all-databases &gt; alldump.sql;
</code></pre><p>2）备份部分数据库（不带–databases的备份语句在生成的.sql文件中没有create database和use 语句，需要手动建立数据库，可能导致数据库名与之前不一致）</p>
<pre><code>mysqldump -u root -p --databases yekai &gt; yekai.sql
</code></pre><p>3）备份数据库中的几张表</p>
<pre><code>mysqldump -u root -p yekai emp &gt; emp.sql
</code></pre><p><strong>注意事项</strong>： mysqldump不需要加分号，因为是在cmd命令中</p>
<p>数据库恢复：<br><strong>创建数据库并选择该数据库</strong>注意，如果备份文件没有自动创建数据库，需要自己创一个数据库</p>
<pre><code>在cmd命令下：mysql -u root -p test &lt; test.sql
</code></pre><p>或者：<br>在mysql &gt;命令行下 执行  SOURCE 数据库文件</p>
<pre><code>先创建一个空的数据库
Mysql&gt;create databse mydb7;
Mysql&gt;use mydb7;
mysql &gt; source c:\user\zhao\test.sql
</code></pre><p><strong>注意事项</strong>：如果文件放在c盘，可能由于权限原因无法访问。更换到其他盘符再试。</p>
<h3 id="数据库三大范式"><a href="#数据库三大范式" class="headerlink" title="数据库三大范式"></a>数据库三大范式</h3><h3 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h3><p>每列应当保证原子性。即不可以再进行分割。</p>
<p>比如收货地址这列，就不是原子性的，如果需要经常统计到省份或者城市信息，则该列的设计就不符合第一范式的要求，仍然可以进一步拆分为省份，城市。。。。</p>
<h3 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h3><p>表：学号、课程号、姓名、学分;<br>学分依赖课程，姓名依赖学号</p>
<p>这个时候，如果删除一条学分数据，会导致相应的课程数据也会被删除。同时这张表还存在数据冗余的情况。<br>如果数据存在部分依赖的情形，需要将字段进行拆分，拆成多个表。这样删除一个数据时，就不会把其他的需要的数据项删除，<br><strong>注意</strong> 这里说的删数据是删一条数据，而不是删除一列，列是一个字段，字段一般不能删除。最好把依赖的字段分成两个表<br>需要重新拆分表：<br>学生表：学号、姓名<br>课程表：课程号<br>选课表：课程号、学号、学分</p>
<h3 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h3><p>不要存在冗余数据，虽然说可能有潜在的关系，但是最好使用外链关系起来，而不是放在一起你<br>表: 学号, 姓名, 年龄, 学院名称, 学院电话<br>学生表：学号、姓名、年龄、学院号<br>学院表：学院名称、学院电话、学院号<br>每一张表在设计的时候，都应该遵循着，只关注最小的一块功能，如统计学生信息，就仅停留在学生信息中，不要过多去延伸。分工而治的思想</p>
<h2 id="星期六-8-03"><a href="#星期六-8-03" class="headerlink" title="星期六(8.03)"></a>星期六(8.03)</h2><p>（太忙了没时间写了，我明天补上8.4记录）</p>
<h3 id="数据库的访问过程"><a href="#数据库的访问过程" class="headerlink" title="数据库的访问过程"></a>数据库的访问过程</h3><p>根据之前我们所学过的知识，其实不难知道，数据库的访问过程如下：</p>
<pre><code>客服端与Mysql服务器之间建立连接
客户端向Mysql服务器发送数据库请求
Mysql服务器处理客户端请求，并返回结果给客户端
客户端接受Mysql服务器的响应，并按照自己的业务逻辑做响应处理。
释放相关资源。
</code></pre><h3 id="数据库驱动"><a href="#数据库驱动" class="headerlink" title="数据库驱动"></a>数据库驱动</h3><p>java定义的访问数据库的接口（jdbc）<br>SUN公司为了简化、统一对数据库的操作，定义了一套Java操作数据库的规范，称之为JDBC。这套接口由数据库厂商去实现，这样，开发人员只需要学习jdbc接口，并通过jdbc加载具体的驱动，就可以操作数据库。</p>
<p>JDBC全称为：Java Data Base Connectivity（java数据库连接），它主要由接口组成。组成JDBC的２个包：java.sql  javax.sql</p>
<pre><code>java.sql.*;  是核心包里的
java.sql.*是jdbc2.0之前的东西
javax.sql.*; 是扩展包中的
javax.sql.*包括了jdbc3.0的特性
</code></pre><p>开发JDBC应用需要以上2个包的支持外，还需要导入相应JDBC的数据库实现(即数据库驱动)</p>
<h3 id="JDBC第一个程序"><a href="#JDBC第一个程序" class="headerlink" title="JDBC第一个程序"></a>JDBC第一个程序</h3><p>1、搭建实验环境</p>
<pre><code>1、在mysql中创建一个库，并创建user表和插入表的数据。
2、新建一个Java工程，并导入数据驱动。(mysql-connector-xx.jar)
</code></pre><p>2、编写程序，在程序中加载数据库驱动（二选一）</p>
<pre><code>DriverManage.registerDiver(new Driver);
Class.forName(com.mysql.jdbc.Driver);
</code></pre><p>3、建立连接</p>
<pre><code>Connection conn = DriverManage.getConnection(url,username,password);
url = &quot;jdbc:mysql://localhost:3306/database_name?characterEncoding=utf8&quot;;
</code></pre><p>4、创建用于向数据库发送sql的Statement对象并发送sql</p>
<pre><code>Statement statement = conn.createStatement();
</code></pre><p>5、从代表结果集的ResultSet中取出数据，打印</p>
<pre><code>ResultSet resultSet = statement.executeQuery(sql)
statement.executeUpdate(sql);
</code></pre><p>6、断开与数据库的链接</p>
<pre><code>conn.close();//必须要关闭，而且必须先关闭
statement.close();
resultSet.close();
</code></pre><h3 id="程序详解"><a href="#程序详解" class="headerlink" title="程序详解"></a>程序详解</h3><p>URL编写：<br>URL用于标识数据库的位置，程序员通过URL地址告诉JDBC程序连接哪个数据库，URL的写法为：</p>
<pre><code>jdbc:mysql:［］//localhost:3306/test ?参数名=参数值
</code></pre><p>常用数据库URL地址的写法：<br>Oracle写法：jdbc:oracle:thin:@localhost:1521:dbname<br>SqlServer：jdbc:microsoft:sqlserver://localhost:1433; DatabaseName=dbname<br>MySql：jdbc:mysql://localhost:3306/dbname<br>Mysql的url地址的简写形式： jdbc:mysql:///sid如果你的主机地址默认是localhost  端口是3306</p>
<h3 id="程序详解—Connection"><a href="#程序详解—Connection" class="headerlink" title="程序详解—Connection"></a>程序详解—Connection</h3><p>Jdbc程序中的Connection，它用于代表数据库的连接（桥梁）， Connection是数据库编程中最重要的一个对象，客户端与数据库所有交互都是通过connection对象完成的，这个对象的常用方法：</p>
<pre><code>createStatement()：创建向数据库发送sql的statement对象。
prepareStatement(sql) ：创建向数据库发送预编译sql的PrepareSatement对象。
setAutoCommit(boolean autoCommit)：设置事务是否自动提交。
commit() ：在链接上提交事务。
rollback() ：在此链接上回滚事务。
</code></pre><h3 id="程序详解—Statement"><a href="#程序详解—Statement" class="headerlink" title="程序详解—Statement"></a>程序详解—Statement</h3><p>Jdbc程序中的Statement对象用于向数据库发送SQL语句， Statement对象常用方法：</p>
<pre><code>boolean execute(String sql)：用于向数据库发送任意sql语句
ResultSet executeQuery(String sql) ：用于向数据发送查询语句。
int executeUpdate(String sql)：用于向数据库发送insert、update或delete语句
</code></pre><p><strong>execute注意！</strong><br>一般execute用来判断是向数据库发送查询信息，或者是发送insert、update或delete语句，<br>查询信息返回的true，修改返回的是false;<strong>现在的问题是</strong>查询失败是否会返回false,经过试验证明查找不存在的数据execute返回的还是true，所以并不能用execute判断是否插入</p>
<p>executeQuery:返回的是计数的值 大于0表示操作成功</p>
<pre><code>1) 对于 SQL 数据操作语言 (DML) 语句，返回行计数
(2) 对于什么都不返回的 SQL 语句，返回 0
</code></pre><h3 id="程序详解—ResultSet"><a href="#程序详解—ResultSet" class="headerlink" title="程序详解—ResultSet"></a>程序详解—ResultSet</h3><p>Jdbc程序中的ResultSet用于代表Sql语句的执行结果。Resultset封装执行结果时，采用的类似于表格的方式。ResultSet 对象维护了一个指向表格数据行的游标，初始的时候，游标在第一行之前，调用ResultSet.next() 方法，可以使游标指向具体的数据行，进行调用方法获取该行的数据。<br>ResultSet既然用于封装执行结果的，所以该对象提供的都是用于获取数据的get方法：</p>
<pre><code>获取任意类型的数据
getObject(int index)
getObject(string columnName)
获取指定类型的数据，(封装数据时方便)例如：
getString(int index)
getString(String columnName)
....
还有getInt(),getDouble(),等等的方法
</code></pre><p>提问：数据库中列的类型是 varchar，获取该列的数据调用什么方法？Int类型呢？bigInt类型呢？Boolean类型？<br>我TM用getString()全都可以拿到，没毛病</p>
<p>Tip：常用数据类型转换表</p>
<table>
<thead>
<tr>
<th style="text-align:right">SQL类型 数据库</th>
<th style="text-align:center">Jdbc对应方法</th>
<th style="text-align:left">返回类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">TINYINT</td>
<td style="text-align:center">getByte()</td>
<td style="text-align:left">byte</td>
</tr>
<tr>
<td style="text-align:right">SMALLINT</td>
<td style="text-align:center">getShort()</td>
<td style="text-align:left">short</td>
</tr>
<tr>
<td style="text-align:right">INT</td>
<td style="text-align:center">getInt()</td>
<td style="text-align:left">int</td>
</tr>
<tr>
<td style="text-align:right">BIGINT</td>
<td style="text-align:center">getLong()</td>
<td style="text-align:left">long</td>
</tr>
<tr>
<td style="text-align:right">DOUBLE</td>
<td style="text-align:center">getDouble()</td>
<td style="text-align:left">double</td>
</tr>
<tr>
<td style="text-align:right">CHAR,VARCHAR,LONG VARCHAR</td>
<td style="text-align:center">getString()</td>
<td style="text-align:left">String</td>
</tr>
<tr>
<td style="text-align:right">text(clob) Blob</td>
<td style="text-align:center">getClob,getBlob()</td>
<td style="text-align:left">clob blob</td>
</tr>
<tr>
<td style="text-align:right">DATE</td>
<td style="text-align:center">getDate()</td>
<td style="text-align:left">java.sql.Date</td>
</tr>
<tr>
<td style="text-align:right">TIME</td>
<td style="text-align:center">getTime()</td>
<td style="text-align:left">java.sql.Time</td>
</tr>
<tr>
<td style="text-align:right">TIMESTAMP</td>
<td style="text-align:center">getTimestamp()</td>
<td style="text-align:left">java.sql.Timestamp</td>
</tr>
</tbody>
</table>
<p>注意事项：这里date返回类似并不是java.util.date而是java.mysql.date他们之间方法可能有差异，所以要注意</p>
<p>和迭代器类似ResultSet还提供了对结果集的游标进行滚动的方法：</p>
<pre><code>next()：移动到下一行
Previous()：移动到前一行
absolute(int row)：移动到指定行
beforeFirst()：移动resultSet的最前面。
afterLast() ：移动到resultSet的最后一行之后。
</code></pre><p>程序详解—释放资源</p>
<p>Jdbc程序运行完后，切记要释放程序在运行过程中，创建的那些与数据库进行交互的对象，这些对象通常是ResultSet, Statement和Connection对象。<br>特别是Connection对象，它是非常稀有的资源，用完后必须马上释放，如果Connection不能及时、正确的关闭，极易导致系统宕机。Connection的使用原则是尽量晚创建，尽量早的释放。<br>为确保资源释放代码能运行，资源释放代码也一定要放在finally语句中。</p>
<p>数据库存放数据，那么数据库安全吗？</p>
<h3 id="数据库注入问题"><a href="#数据库注入问题" class="headerlink" title="数据库注入问题"></a>数据库注入问题</h3><p>对于数据库注入，我们来看一个登陆的例子：</p>
<pre><code>假设有一个登陆界面，让我们输入用户名和密码进行登陆，我们这样输入用户名和密码：
用户名：name = &quot;xxxx&apos; (用户名随便输入)OR 0==0 --&quot;;
密码：密码=“xxxx”（随便输入一串）
此时我们可以试一下，我们是否可以登陆成功。
让我们看一下，在我们的代码中，最终拼接而成的，发送给数据库执行的sql语句
String sql = &quot;select * from t_user where name =&apos;&quot;+ name +&quot;&apos; AND PASSWORD = &apos;&quot;+ password +&quot;&apos;&quot;;
</code></pre><p>不管写什么都能直接登陆。问题来了，如何规避这种情况呢？<br>仔细分析一下，数据库注入成功的根本原因是，<br>我们把sql语句中的参数(用户的输入)和sql命令拼接成了一个sql语句，因为一个sql语句中既可以有sql的命令又可以有参数，因此，用户的输入也可以被当做sql的语句来解析执行。<br>那么，既然知道了sql注入成功的原因，我们就反其道而行之，不让用户输入的参数被当做sql命令解析，而是只把它当做普通字符串来解析。<br>由此，java中引入了prepareStatement，利用preparestatement来防止sql注入的核心思想就是，不把用户的输入当做sql命令来解析和执行。</p>
<h3 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h3><p>PreparedStatement继承自Statement，可以通过Connection的prepareStatement方法得到。<br>prepareStatement很明显的将sql命令语句与参数分开处理，其执行过程是，首先在sql语句真正执行之前，先把sql命令送到数据库中进行预编译，生成相应 的数据库命令，然后在获取sql中的参数，然后真正执行该sql语句。<br>这样一来，用户输入的参数，只被当做参数而非命令来解析，就可以避免数据库注入这样的问题发生。<br><strong>不过，这样一来，单次执行PreparedStatement需要与数据库通信两次，效率，比之于单词执行Statement要低。</strong><br>PreparedStatement用法：</p>
<pre><code>DriverManager.register(New Driver());
Connection connection = DriverManager.getConnection(url,username,password);
String sql = &quot;select * from emp where id = ?&quot;
PreparedStatement preparedstatement = connection.prepareStatement(sql);
preparedstatement.setInt(1,i); //注意下标从1开始的
preparedstatement.executeQuery();
connection.close();
preparedstatement.close();
</code></pre><h3 id="一些小总结"><a href="#一些小总结" class="headerlink" title="一些小总结"></a>一些小总结</h3><p>原来是学习JMS的，后来发现不懂MQ真的学不了</p>
<p><a href="https://blog.csdn.net/guanghuichenshao/article/details/79546140" target="_blank" rel="external">传送门</a></p>
<h3 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h3><p>消息队列（MQ）是一种应用程序对应用程序的通信方法。应用程序通过写和检索出入列队的针对应用程序的数据（消息）来通信，而无需专用连接来链接它们。</p>
<h3 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h3><pre><code>JMS即Java消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。
</code></pre><h3 id="JNDI"><a href="#JNDI" class="headerlink" title="JNDI"></a>JNDI</h3><pre><code>JNDI(Java Naming and Directory Interface,Java命名和目录接口)是SUN公司提供的一种标准的Java命名系统接口，JNDI提供统一的客户端API，通过不同的访问提供者接口JNDI服务供应接口(SPI)的实现，由管理者将JNDI API映射为特定的命名服务和目录系统，使得Java应用程序可以和这些命名服务和目录服务之间进行交互。目录服务是命名服务的一种自然扩展。两者之间的关键差别是目录服务中对象不但可以有名称还可以有属性（例如，用户有email地址），而命名服务中对象没有属性 [1]  。
</code></pre><h3 id="mysql5-7设置允许外部访问"><a href="#mysql5-7设置允许外部访问" class="headerlink" title="mysql5.7设置允许外部访问"></a>mysql5.7设置允许外部访问</h3><p>JDBC设置外部访问<br><a href="https://blog.csdn.net/qq_17810899/article/details/90642207" target="_blank" rel="external">https://blog.csdn.net/qq_17810899/article/details/90642207</a></p>
<p>登陆进去mysql</p>
<pre><code>update user set host = &apos;%&apos; where user = &apos;root&apos;;
FLUSH PRIVILEGES;
</code></pre><h3 id="数据库显示链接不上问题"><a href="#数据库显示链接不上问题" class="headerlink" title=".数据库显示链接不上问题"></a>.数据库显示链接不上问题</h3><p>还原系统设置；</p>
<h3 id="命令行执行java用到jar包"><a href="#命令行执行java用到jar包" class="headerlink" title="命令行执行java用到jar包"></a>命令行执行java用到jar包</h3><p><a href="https://blog.csdn.net/vaq37942/article/details/86654217" target="_blank" rel="external">传送门</a><br>需要使用命令行<br>编译</p>
<pre><code>javac -Djava.ext.dirs=D:\lib test.java
</code></pre><p>执行</p>
<pre><code>java  -Djava.ext.dirs=D:\lib test
</code></pre><p>这个方法需要在jdk1.6以上支持</p>
<h3 id="如何共享包"><a href="#如何共享包" class="headerlink" title="如何共享包"></a>如何共享包</h3><p>把jar包添加到module中共用可以右键点击module 然后setting把jar添加到module中<br>或者按F4也有相同的效果</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/04/Java总结（六）上/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王邸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路要坚持">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/04/Java总结（六）上/" itemprop="url">Java总结（六）上</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-04T23:17:39+08:00">
                2019-08-04
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/08/04/Java总结（六）上/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/08/04/Java总结（六）上/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>线程的通讯，阻塞队列（BlockingQue），生产者消费者问题，线程池(Executor)，定时任务，网络编程（UTP传输（DatagramSocket，DatagramPacket<br>）,TCP（Socket，ServerSocket））,反射（重点）,注解，GC回收机制。接下来先讲数据库的一些操作和原理，然后讲了一点JDBC的东西。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>这周把JAVASE部分都搞完了，接下来需要学习EE的部分，SE的知识决定是否能找一个好的工作，所以这一部分是非常非常重要的。并不是简简单单的知识点，涵盖了所有Java底层的东西，虽然没有全都弄懂，但是任重而道远。而且为了赶课程，这周的最后SE的部分并没有讲的很详细，所以主要总结的还是SE的内容：线程、网络编程、反射、GC回收机制。EE的内容就讲了数据库的一些操作和原理，然后讲了一点JDBC的东西。知识都比较乱和复杂，所以必须每天都总结，要不然容易忘记。</p>
<h2 id="星期一-7-29"><a href="#星期一-7-29" class="headerlink" title="星期一(7.29)"></a>星期一(7.29)</h2><h3 id="线程间通信："><a href="#线程间通信：" class="headerlink" title="线程间通信："></a>线程间通信：</h3><pre><code>只有在同步的情况下，线程间才有必要通信。
</code></pre><h3 id="等待唤醒机制："><a href="#等待唤醒机制：" class="headerlink" title="等待唤醒机制："></a>等待唤醒机制：</h3><p>Object (锁) :</p>
<pre><code>void notify()   // 随机一个唤醒等待这把锁的线程
void notifyAll() // 唤醒所以等待这把锁的线程
void wait() // 当前正在执行的线程进入等待状态, 并且释放锁资源，等待被唤醒。
void wait(long timeout) // 支持超时机制，如果在指定的时间内没有被唤醒，就会自动唤醒。
void wait(long timeout, int nanos)
</code></pre><p>为什么 wait() 方法和 notify() 方法不定义在 Thread 类中，而定义在 Object 中呢？<br>    线程间通信是通过锁对象实现的 (锁对象是线程间通信的媒介),又因为任何对象都可以做为锁，所以这些方法定义在Object类中</p>
<p>注意事项：</p>
<pre><code>a. notify(), notifyAll(): 申请的资源曾经可以利用的。
b. 慎用 notify(), 除非确实考虑周全了，否则都用 notifyAll();
</code></pre><p>回到上礼拜银行转账的例子：</p>
<h3 id="解决死锁问题—-拿到全部资源"><a href="#解决死锁问题—-拿到全部资源" class="headerlink" title="解决死锁问题—-拿到全部资源"></a>解决死锁问题—-拿到全部资源</h3><p>从上个礼拜的解决死锁问题开始，第一种方法拿到全部资源，这里有一句</p>
<pre><code>while(!Apply.apply(this,target));
</code></pre><p>是要一直while等待是否可以同时拿到所有资源。还好这个apply方法是同步的，不会发生死锁问题，如果不是同步的，就很可能出现两边一直等待的问题。<br>之前的apply的方法</p>
<pre><code>public class Apply {
  private static List&lt;Account&gt; list = new ArrayList&lt;&gt;();
  //方法也要是同步的，这样才能一次进入一个
  public synchronized static boolean apply(Account accountA, Account accountB) {
    //如果里面有就要判断不能进入
    if(list.contains(accountA) || list.contains(accountB)) {
        return false;
    }
    list.add(accountA);
    list.add(accountB);
    return true;
  }
  //释放资源
  public synchronized static void free(Account accountA, Account accountB) {
    list.remove(accountA);
    list.remove(accountB);
  }
}
</code></pre><p>修改后的经典做法，使用wait(),nodifyAll() ,但是要是使用的同一把锁，写在不同两个方法里面，所以锁只能是class文件，<br>注意这里需要使用while来判断 while (list.contains(accountA) || list.contains(accountB))，因为唤醒的时候就怕又有其他的线程进来，所以必须要重新判断。</p>
<pre><code>public synchronized static boolean apply(Account accountA, Account accountB) {
  // 经典做法
  while (list.contains(accountA) || list.contains(accountB)) {
      // return false;
      try {
          Apply.class.wait(); // 阻塞
      } catch (InterruptedException e) {
          e.printStackTrace();
      }
  }
  list.add(accountA);
  list.add(accountB);
  return true;
}
</code></pre><p>在free()资源的时候唤醒其他线程</p>
<pre><code>public synchronized static void free(Account accountA, Account accountB) {
  list.remove(accountA);
  list.remove(accountB);
  Apply.class.notifyAll();
}
</code></pre><p><strong>注意事项</strong>：wait 和 notify 需要使用同一把锁来进行判断，这两个方法必须要在同步代码中才能使用。所以锁是任意对象也就证明了watit和 notify是Object类型上的两个方法。这种感觉就好像，一个人在一扇门里面，一个人在同一扇门的外面，他们中间就间隔了一把锁，只有通过这把锁，里面的人才能叫醒外面的人进来，外面的人才能等待。为了让线程的同步，我们引入了阻塞队列。</p>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>组赛队列其实也就是生产者消费者模型的核心的东西，生产者只能在东西没满的时候生产，消费者只能在生产有东西的时候消费。这就是简单的BlockingQueue</p>
<pre><code>enque: 当队列满了，会阻塞，等待队列不满的时候，再入队列，并返回。
deque: 当队列为空，会阻塞，等待队列不空的时候，再出队列，并返回。
</code></pre><h4 id="自己手写的阻塞队列"><a href="#自己手写的阻塞队列" class="headerlink" title="自己手写的阻塞队列"></a>自己手写的阻塞队列</h4><p>思路：<br>1.阻塞队列必须是一个<strong>循环队列</strong>，所以循环队列需要一个front 一个 rear指针<br>2.阻塞队列当然需要一个数组去存储数据。但是这个长度是固定的<br>3.注意使用同一把锁来确定入队和出队的操作，因为是在对象上操作，所以可以写成同步方法<br>4.记得判断size == 0 和 size == length时候的阻塞问题</p>
<pre><code>//简单的实现阻塞队列
public class MyBlockingQue {
  //属性
  int front;
  int rear;
  String[] elements;
  int size;

  //构造方法
  public MyBlockingQue(){
    elements = new String[10];
    front = 0;
    rear = elements.length-1;
  }

  //方法
</code></pre><p>//入队操作</p>
<pre><code>public synchronized void enque(String input) {
  while(size == elements.length) {
    try{
      wait();     //如果满了就等待
    } catch (InterruptedException e){
      e.printStackTrace();
    }
  }
  rear = (rear+1) % elements.length;
  element[rear] = input;
  size++;
  notifyAll();  //唤醒其他所有线程
}
</code></pre><p>//出栈操作</p>
<pre><code>public synchronized void deque() {
  while(size == 0) {
    try{
      wait(); //如果没有元素就等待出队
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
  }
  String oldValue = elements[front];
  front = (front + 1) % elements.length;
  size--;
  notifyAll(); //唤醒所有线程
  return oldValue;
}
</code></pre><p>//测试阻塞队列</p>
<pre><code>  public static void main(String[] args) {
    MyBlockingQueue1 bq1 = new MyBlockingQueue1();
    new Thread(){
      @Override
      public void run(){
        int i = 1;
        while(true){
          bq1.enque(i+&quot;进来了&quot;);
          System.out.println(bq1);
          i++;
          try {
              Thread.sleep(100);
          } catch (InterruptedException e) {
              e.printStackTrace();
          }
        }
      }
    }.start();
  }
  new Thread(){
    @Override
    public void run(){
      while(true){
        System.out.println(&quot;我出队了&quot; + bq1.deque());
       try {
           Thread.sleep(1000);
       } catch (InterruptedException e) {
           e.printStackTrace();
       }
      }
    }
  }.start();
}
</code></pre><h3 id="BlockingQue-类"><a href="#BlockingQue-类" class="headerlink" title="BlockingQue 类"></a>BlockingQue 类</h3><p>public interface BlockingQueue<e> extends Queue<e><br>阻塞方法：<br>    void put(E e);<br>    E take();</e></e></p>
<p>子类：ArrayBlockingQueue，LinkedBlockingDeque</p>
<p><strong>注意事项</strong>这两个阻塞方法显示是有点问题的，因为put()，take()方法和size()方法不是同步的，所以为了在显示生产消费的时候，只能确保他是阻塞的运行put 和 take方法，而不能去判断他里面有多少个，队满的时候依旧可能显示:</p>
<pre><code>生产了一个包子, 还剩9个
生产了一个包子, 还剩10个
消费了一个包子，还剩10个
生产了一个包子, 还剩10个
</code></pre><p>显示有问题的源码：</p>
<pre><code>public class BunStore {

BlockingQueue&lt;Bun&gt; bq = new BlockingQue(10); //长度10
public void produce() {
  try {
    bq.put(new Bun());
    Thread.sleep(100);
  } catch (InterruptedException e) {
    e.printStackTrace();
  }
  System.out.println(&quot;生产了一个包子, 还剩&quot; + bq.size() + &quot;个&quot;);
}

public  Bun consume() {
  Bun bun = null;
  try {
    bun = bq.take();
    Thread.sleep(500);
  } catch (InterruptedException e) {
    e.printStackTrace();
  }
  System.out.println(&quot;消费了一个包子，还剩&quot; + bq.size() + &quot;个&quot;);
  return bun;
}
</code></pre><p>//main 方法</p>
<pre><code>public static void main(String[] args) {
    BunStore store = new BunStore(&quot;陈妍希牌小笼包&quot;, 10);
    new Thread() {
        @Override
        public void run() {
            while(true) {
                store.produce();
            }
        }
    }.start();

    new Thread() {
        @Override
        public void run() {
            while (true) {
                store.consume();
            }
        }
    }.start();
}
</code></pre><h3 id="解决办法1-上锁"><a href="#解决办法1-上锁" class="headerlink" title="解决办法1 上锁"></a>解决办法1 上锁</h3><pre><code>因为我们已经知道是put 和size方法没有同步的问题，所以现在要解决这个问题，我想到的第一个方法是把put size锁在bq中
把take 和 size锁在同一个bq中，如下所示：
</code></pre><p>生产</p>
<pre><code>public void produce() {
    try {
        //锁在一个bq中
        synchronized (bq){
            bq.put(new Bun());
            System.out.println(&quot;生产了一个包子, 还剩&quot; + bq.size() + &quot;个&quot;);
        }
        Thread.sleep(100);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
</code></pre><p>消费</p>
<pre><code>public Bun consume() {
    Bun bun = null;
    try {
        synchronized (bq){
            bun = bq.take();
            System.out.println(&quot;消费了一个包子，还剩&quot; + bq.size() + &quot;个&quot;);
        }
        Thread.sleep(500);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    return bun;
}
</code></pre><p>这失败了，这显示到第一次出现阻塞队列就死锁了，因为put 和 take本来就是阻塞的方法，但是这样又设置了一把锁。导致put方法外层的锁进去了，内层的锁进去了，内层的锁阻塞了，进不去内层的锁了，put被锁在内层锁的外面。但是另一个方法还take阻塞在外层的锁外面呢，他肯本不知道外层锁里面是什么样子的。所以两个方法都在等待就都进不去。他们等待锁的地方不同。虽然两把锁都是bq，但是地方不同。</p>
<h3 id="解决办法2（同步方法）"><a href="#解决办法2（同步方法）" class="headerlink" title="解决办法2（同步方法）"></a>解决办法2（同步方法）</h3><p>为了使得put 和 size 同步，我们可以在这个BunStore上做文章，如果给consume和produce上锁不就能保证他们同步的了吗？所以就引出了第二个方法：<br>//回复之前的写法，在两个方法使用同步方法；</p>
<pre><code>public  synchronized void produce() {
    try {
        bq.put(new Bun());
        Thread.sleep(100);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    System.out.println(&quot;生产了一个包子, 还剩&quot; + bq.size() + &quot;个&quot;);
}

public  synchronized Bun consume() {
    Bun bun = null;
    try {
        bun = bq.take();
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    System.out.println(&quot;消费了一个包子，还剩&quot; + bq.size() + &quot;个&quot;);
    return bun;
}
</code></pre><p>同样的又失败了，也是一样的问题，也是上了两把锁，虽然保证了size 和 put是同步的，但是consume 和 produce方法如果是同步的就会有问题：和上面的问题一样，一个方法被困在外层锁外面（这个BunStore对象）,一个被困在内层锁（bq）外面。外面的进不来，里面的出不去，所以又死锁了。而且这个死锁很容易发生，比不上锁更容易发生。也是两把锁的问题，但是和上一种方法上锁的对象不同，上面两层都是bq锁，这个外层是这个对象的锁，内层锁才是bq锁。他就很容易发生连续调用consume 或者produce方法直到其中一种方法内层进入阻塞。</p>
<h3 id="解决办法3"><a href="#解决办法3" class="headerlink" title="解决办法3"></a>解决办法3</h3><p>首先我们可以肯定 size 和 put必须要满足同步，size 和take也要满足同步。 所以必须要使得consume和produce方法是满足同步的，然后我们就不用put和take方法的同步的锁了，我们自己使用wait和notify方法，告诉别的线程你可以开始操作了。<strong>而put 和 take就仅仅是使用了入队和出队的操作。</strong></p>
<p>//生产包子</p>
<pre><code>public synchronized void produce() {
    try {
        while (bq.size() == 10){
            wait();
        }
        bq.put(new Bun());
        System.out.println(&quot;生产，目前有&quot; + bq.size() + &quot;个包子&quot;);
         notifyAll();
        Thread.sleep(500);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
</code></pre><p>//消费包子</p>
<pre><code>public synchronized Bun consume() {
    Bun bun = null;
    try{
        while(bq.size() == 0){
            wait();
        }
        bun = bq.take();
        System.out.println(&quot;卖出，目前有&quot; + bq.size() + &quot;个包子&quot;);
        notifyAll();
        Thread.sleep(600);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    return bun;
}
</code></pre><h3 id="线程池的初步了解"><a href="#线程池的初步了解" class="headerlink" title="线程池的初步了解"></a>线程池的初步了解</h3><p>启动一个新线程的成本是比较高的，因为它涉及到与操作系统进行交互。这种情况下使用线程池可以更好的提高性能，尤其在当前程序需要创建大量的生存周期很短的线程时，更应该考虑使用线程池。<br>原理</p>
<pre><code>线程池里每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，等待下一次被使用。
</code></pre><p>从原理可以看出：线程池应该是以集合的形式保存的，而线程应该是相同的，需要把线程和任务进行解耦，把任务放在阻塞队列中，而不是把任务写成Thread的子类来进行运行。这样有任务就拿出线程，没任务就在线程池里待着，这样就不用频繁的创建线程和销毁线程了。<br>一个简单的线程池的实现如下：</p>
<p>思路：<br>1.首先要实现线程池，需要一个容器来装线程，这里就简单的使用ArrayList<br>2.需要使用一个阻塞队列来存储任务，这样就能把任务都缓存起来依次执行</p>
<pre><code>public class MyThreadPool {
    //属性
    //阻塞队列存放任务
    BlockingQueue&lt;Runnable&gt; bq = new ArrayBlockingQueue&lt;&gt;(10);
    //一个简单的线程池
    Collection&lt;WorkThread&gt; threads;

    //构造函数
    public MyThreadPool(int size) {
        threads = new ArrayList&lt;&gt;(size);
        for (int i = 0; i &lt; size; i++) {
            //初始化工作线程，并启动线程放入线程池
            WorkThread wt = new WorkThread();
            wt.start();
            threads.add(wt);
        }
    }
</code></pre><p>// 获取任务放进阻塞队列</p>
<pre><code>public void execute(Runnable task) {
    try {
        bq.put(task);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
</code></pre><p>//工作线程</p>
<pre><code>private class WorkThread extends Thread {
    @Override
    public void run() {
      // 线程一直执行，不会进入死亡状态
        while (true) {
            try {
                Runnable task = bq.take(); //如果没有任务就会阻塞在这；
                task.run();                //执行任务
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre><p>//主函数，包括要执行的任务</p>
<pre><code>    public static void main(String[] args) {
        MyThreadPool pool = new MyThreadPool(10);
        Runnable task1 = new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i &lt; 100; i++) {
                    System.out.println(Thread.currentThread().getName() + &quot;: &quot; + i);
                    try {
                        Thread.sleep(50);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        };
        Runnable task2 = new Runnable() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName() + &quot;: begin&quot;);
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + &quot;: end&quot;);
            }
        };
        pool.execute(task1);
        pool.execute(task2);
    }
}
</code></pre><p>这只是一个简单的线程池，让线程在创建的时候全部启动，然后WorkThread线程内的run方法都阻塞在阻塞队列bq这里，有任务就执行，没有任务就一直空转，虽然会提高效率，如果不用的时候还是建议把线程池关了，以免造成资源的浪费。</p>
<h3 id="JAVA简单线程池ThreadPoolExecutor"><a href="#JAVA简单线程池ThreadPoolExecutor" class="headerlink" title="JAVA简单线程池ThreadPoolExecutor:"></a>JAVA简单线程池ThreadPoolExecutor:</h3><pre><code>Executor: void execute(Runnable command)  执行任务
    |-- ExecutorService:
        |-- ThreadPoolExecutor:
</code></pre><p>继承关系</p>
<pre><code>public class ThreadPoolExecutor extends AbstractExecutorService
</code></pre><p>构造方法</p>
<pre><code>ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler)
用给定的初始参数和默认的线程工厂创建新的 ThreadPoolExecutor。
</code></pre><p>参数的解释:</p>
<p>int corePoolSize: 核心线程，           项目组的核心成员<br>int maximumPoolSize: 项目组很忙的时候  人数的最大上线<br>long keepAliveTime: 线程最长的空闲时间 撤销线程<br>TimeUnit unit: 时间单位               设置线程空闲时间<br>BlockingQueue<runnable> workQueue：  缓存任务的队列<br>RejectedExecutionHandler handler：   当缓存队列满的时候，拒绝策略</runnable></p>
<p>TimeUnit: 枚举类型</p>
<pre><code>DAYS
HOURS
MINUTES
SECONDS
MILLISECONDS
MICROSECONDS
NANOSECONDS
</code></pre><p>RejectedExecutionHandler：</p>
<pre><code>|-- ThreadPoolExecutor.AbortPolicy  抛出一个异常 RejectedExecutionException（默认是这个）
|-- ThreadPoolExecutor.CallerRunsPolicy 往线程池添加任务的线程执行该任务
|-- ThreadPoolExecutor.DiscardOldestPolicy 丢弃最早的任务，添加该任务
|-- ThreadPoolExecutor.DiscardPolicy 直接丢弃任务
</code></pre><p>问题：如何停止应用程序？</p>
<pre><code>void shutdown()：不接受新任务, 把缓存队列中的任务执行完毕后就关闭线程池。
List&lt;Runnable&gt; shutdownNow(): 尝试立刻关闭线程池，返回等待任务的队列
</code></pre><p>看了JDK有下面几句话：</p>
<pre><code>强烈建议程序员使用较为方便的 Executors 工厂方法
Executors.newCachedThreadPool()（无界线程池，可以进行自动线程回收）、
Executors.newFixedThreadPool(int)（固定大小线程池）和
Executors.newSingleThreadExecutor()（单个后台线程），它们均为大多数使用场景预定义了设置。
</code></pre><p>接下来就来讨论一下这些工厂方法</p>
<h3 id="Executors"><a href="#Executors" class="headerlink" title="Executors:"></a>Executors:</h3><pre><code>public static ExecutorService newCachedThreadPool()
    corePoolSize = 0 //没有核心线程，都是来打临时工的

public static ExecutorService newFixedThreadPool(int nThreads)
    corePoolSize = maximumPoolSize = nThreads //全都是核心线程，需要自己设置

public static ExecutorService newSingleThreadExecutor()  //只有一个核心线程
    corePoolSize = maximumPoolSize = 1
</code></pre><p>这里首先要注意的是这三个工厂函数的返回值是ExecutorService，而ExecutorService是一个接口,继承了Executor<br>而之前上面说的ThreadPoolExcutor则是ExecutorService的子类：</p>
<h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor:"></a>Executor:</h3><pre><code>void execute(Runnable task)

|-- ExecutorService:
    Future&lt;?&gt; submit(Runnable task)
    &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result)
    &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)
    关闭线程池
    void shutdown()
    List&lt;Runnable&gt; shutdownNow()
</code></pre><p><strong>注意事项</strong> 注execute方法是没有返回值的，但是子接口三个方法都有返回值，而<t> Future<t> submit(Runnable task, T result)还有返回的结果。 咩有返回结果，他的用法就和直接调用execute相同；</t></t></p>
<h3 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h3><pre><code>继承关系
public interface ExecutorService extends Executor
所有已知实现类：
AbstractExecutorService, ScheduledThreadPoolExecutor, ThreadPoolExecutor
</code></pre><p> 方法：</p>
<pre><code>void shutdown()   启动一次顺序关闭，执行以前提交的任务，但不接受新任务。
List&lt;Runnable&gt; shutdownNow()   试图停止所有正在执行的活动任务，暂停处理正在等待的任务，并返回等待执行的任务列表。
&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)   提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future。
Future&lt;?&gt; submit(Runnable task)   提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。
&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result)   提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。
</code></pre><p>关于后面三个方法的返回值类型和传入参数Callable 的说明：</p>
<h3 id="Future"><a href="#Future" class="headerlink" title="Future:"></a>Future:</h3><p>   Future 表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并获取计算的结果。<br>   计算完成后只能使用 get 方法来获取结果，如有必要，计算完成前可以阻塞此方法。</p>
<pre><code>V get(): 获取异步结果，如果异步线程还没计算完，主线程就阻塞，直到异步线程计算完成。
V get(long timeout, TimeUnit unit)：获取异步结果，如果异步线程还没计算完，主线程就阻塞，支持超时机制。
boolean isDone()
</code></pre><h3 id="Callable-有返回值的任务"><a href="#Callable-有返回值的任务" class="headerlink" title="Callable: (有返回值的任务)"></a>Callable: (有返回值的任务)</h3><pre><code>V call()
</code></pre><p>时间问题下面就举一个ExecutorSerivce的一个工厂函数 <t> Future<t> submit(Runnable task, T result)<br>// <t> Future<t> submit(Runnable task, T result) 执行任务，并把结果放入 result 中</t></t></t></t></p>
<pre><code>ExecutorService pool1 = Executors.newCachedThreadPool(); //（无界线程池，可以进行自动线程回收）
List&lt;String&gt; result = new ArrayList&lt;&gt;(); //存放结果
Future&lt;List&gt; future = pool1.submit(new Runnable() {
    @Override
    public void run() {
        for (int i = 0; i &lt; 10; i++) {
            result.add(&quot;&quot; + i);
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}, result);

// 主线程执行其他任务....
List list = null;
try {
    list = future.get();
} catch (InterruptedException e) {
    e.printStackTrace();
} catch (ExecutionException e) {
    e.printStackTrace();
}
System.out.println(list);
</code></pre><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>使用线程池，一般都会用以上的三个Executor的工厂函数构造ExecutorSerivce然后再根据自己的实际应用来用线程池。而一开始说的ThreadPoolExecutor并没有实际的意义，只是让我们跟容易的立即线程池需要的参数。例如核心线程个数，缓冲任务队列，线程撤销时间，和任务拒绝策略等等。</p>
<h3 id="中场休息时间："><a href="#中场休息时间：" class="headerlink" title="中场休息时间："></a>中场休息时间：</h3><pre><code>上面的东西有一些多而且并不是看到的那么容易的，所以不要掉以轻心。
</code></pre><h3 id="定时器（Timer）和定时任务（TimerTask）"><a href="#定时器（Timer）和定时任务（TimerTask）" class="headerlink" title="定时器（Timer）和定时任务（TimerTask）"></a>定时器（Timer）和定时任务（TimerTask）</h3><p>构造方法：</p>
<pre><code>Timer()
Timer(boolean isDaemon): 是否以守护线程去指定定时任务，默认是false
Timer(String name)
Timer(String name, boolean isDaemon)
</code></pre><p>方法：</p>
<pre><code>void schedule(TimerTask task, Date time) 在指定的时间执行指定的任务(一次)
void schedule(TimerTask task, Date firstTime, long period)
void schedule(TimerTask task, long delay) 延迟多少时间后，执行指定的任务(一次)
void schedule(TimerTask task, long delay, long period)
void cancel() 关闭定时器
</code></pre><p>abstract TimerTask: 定时任务(注意他是一个抽象类)</p>
<p>方法：</p>
<pre><code>boolean cancel() 取消定时任务
abstract void run() 要执行的任务
long scheduledExecutionTime() 上一次执行的时间
</code></pre><p>一个简单的例子,每隔1秒打印一次爆炸</p>
<pre><code>Timer timer = new Timer();
String s = &quot;2019-07-29 15:31:00&quot;; //开始时间
SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
Date date = sdf.parse(s);

//void schedule(TimerTask task, Date firstTime, long period)

timer.schedule(new TimerTask() {
    @Override
    public void run() {
        System.out.println(&quot;boom!&quot;);
    }
}, date, 1000);
</code></pre><p><strong>注意事项</strong><br>这个定时任务有点蠢，好像并没有参数确定循环执行的次数，如果有需要手动关闭需要自己设置一个计数器，然后次数到了自己timer.cancel()。</p>
<p>小小总结：<br>多线程有几种实现方案，分别是哪几种?</p>
<pre><code>a. 继承Thread
b. 实现Runnable接口
c. 线程池(callable)
</code></pre><p>同步有几种方式，分别是什么?</p>
<pre><code>a. synchronize  同步代码块 同步方法(this) 静态同步方法(字节码文件对象)
b. 锁 Lock --&gt; lock() unlock()
</code></pre><p>启动一个线程是run()还是start()?它们的区别?</p>
<pre><code>start()
run: 封装的线程要执行的任务, 直接调用相当于普通方法调用，并不会创建一个线程
start: 创建一个线程，并执行该Thread对象的run方法
</code></pre><p>sleep()和wait()方法的区别</p>
<pre><code>sleep() 和 wait() 让当前线程进入阻塞状态。
a. sleep() Thread类中一个静态方法。表示线程休眠，不会释放锁。有时间参数，支持超时机制。
b. wait() Object中的成员方法。 表示当前线程进入等待状态，释放锁。可以有时间参数，也可以没有时间参数。
</code></pre><p>为什么wait(),notify(),notifyAll()等方法都定义在Object类中</p>
<pre><code>因为线程间的通信是通过锁对象实现的，并且锁可以是任意对象，因此这些方法定义在Object类中。
</code></pre><p>线程的生命周期图</p>
<pre><code>NEW : 新建
RUNNABLE: 就绪, 运行
BLOCKED: 等待阻塞(等待唤醒)
WAITING: 无限期的等待
TIMED_WAITING: 有时间限制的等待
TERMINATED： 死亡
</code></pre><h2 id="星期二-7-30"><a href="#星期二-7-30" class="headerlink" title="星期二(7.30)"></a>星期二(7.30)</h2><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><pre><code>一些概念的东西，可能很枯燥，但是还是要了解，多看几遍。
</code></pre><h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><pre><code>计算机网络之间以何种规则进行通信，就是网络模型研究问题。
</code></pre><p>网络模型一般是指</p>
<pre><code>OSI（Open System Interconnection开放系统互连）参考模型
TCP/IP参考模型
</code></pre><p>网络模型7层概述：<br>1.<strong>物理层</strong>：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。</p>
<ol>
<li><strong>数据链路层</strong>：主要将从物理层接收的数据进行MAC地址（网卡的地址）的封装与解封装。常把这一层的数据叫做帧。在这一层工作的设备是交换机，数据通过交换机来传输。</li>
<li><strong>网络层</strong>：主要将从下层接收到的数据进行IP地址（例192.168.0.1)的封装与解封装。在这一层工作的设备是路由器，常把这一层的数据叫做数据包。</li>
<li><strong>传输层</strong>：定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。<br>5.<strong>会话层</strong>：通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）<br>6.<strong>表示层</strong>：主要是进行对接收的数据进行解释、加密与解密、压缩与解压缩等（也就是把计算机能够识别的东西转换成人能够能识别的东西（如图片、声音等）。<br>7.<strong>应用层</strong>： 主要是一些终端的应用，比如说FTP（各种文件下载），WEB（IE浏览），QQ之类的（可以把它理解成我们在电脑屏幕上可以看到的东西．就是终端应用）。</li>
</ol>
<h3 id="网络通信三要素"><a href="#网络通信三要素" class="headerlink" title="网络通信三要素"></a>网络通信三要素</h3><p>IP地址:InetAddress（类）</p>
<pre><code>网络中设备的标识，不易记忆，可用主机名
</code></pre><p>端口号</p>
<pre><code>用于标识进程的逻辑地址，不同进程的标识
</code></pre><p>传输协议</p>
<pre><code>通讯的规则
常见协议：TCP，UDP
</code></pre><h3 id="IP地址：-InetAddress类"><a href="#IP地址：-InetAddress类" class="headerlink" title="IP地址： InetAddress类:"></a>IP地址： InetAddress类:</h3><pre><code>此类表示互联网协议 (IP) 地址
</code></pre><p>常用方法：</p>
<pre><code>static InetAddress getLocalHost()
static InetAddress getByName(String host)
String getHostName()
String getHostAddress()
</code></pre><p><strong>注意事项</strong><br>以上方法都是静态的方法<br>getByName()里面写的是主机名，写ip地址应该不行。</p>
<h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>逻辑端口 我们指的就是逻辑端口</p>
<pre><code>A:每个网络程序都会至少有一个逻辑端口
B:用于标识进程的逻辑地址，不同进程的标识
C:有效端口：0~65535，其中0~1023系统使用或保留端口。(2字节)
通过安全软件等工具可以查看端口号
</code></pre><h3 id="协议UDP和TCP-传输层协议"><a href="#协议UDP和TCP-传输层协议" class="headerlink" title="协议UDP和TCP(传输层协议)"></a>协议UDP和TCP(传输层协议)</h3><p>UDP</p>
<pre><code>将数据源地址和目的地址封装成数据包中，不需要建立连接；每个数据报的大小在限制在64k；因无连接，是不可靠协议；不需要建立连接，速度快（传输小量数据）
</code></pre><p>TCP</p>
<pre><code>将数据源地址和目的地址封装成数据包中，建立连接，形成传输数据的通道；在连接中进行大数据量传输；通过三次握手完成连接，是可靠协议；必须建立连接，效率会稍低
</code></pre><h3 id="实现网络编程"><a href="#实现网络编程" class="headerlink" title="实现网络编程"></a>实现网络编程</h3><h3 id="Socket（所有的高级语言都支持）"><a href="#Socket（所有的高级语言都支持）" class="headerlink" title="Socket（所有的高级语言都支持）"></a>Socket（所有的高级语言都支持）</h3><p>Socket套接字：</p>
<pre><code>网络上具有唯一标识的IP地址和端口号组合在一起才能构成唯一能识别的标识符套接字。Socket屏蔽了协议的具体细节（不同类型的socket使用不同的协议）
</code></pre><p>Socket原理机制：</p>
<pre><code>通信的两端都有Socket。
网络通信其实就是Socket间的通信。
</code></pre><p>数据在两个Socket间通过<strong>IO传输</strong></p>
<h3 id="实现UDP传输"><a href="#实现UDP传输" class="headerlink" title="实现UDP传输"></a>实现UDP传输</h3><pre><code>DatagramSocket与DatagramPacket
建立发送端，接收端。
建立数据包。
调用Socket的发送接收方法。
关闭Socket。
发送端与接收端是两个独立的运行程序。
</code></pre><h3 id="套接字：DatagramSocket"><a href="#套接字：DatagramSocket" class="headerlink" title="套接字：DatagramSocket"></a>套接字：DatagramSocket</h3><p>构造方法：</p>
<pre><code>DatagramSocket() 默认ip:本机  port:随机端口
DatagramSocket(int port)
DatagramSocket(int port, InetAddress laddr)
</code></pre><p>发送方法：</p>
<pre><code>void send(DatagramPacket p)
void close()  释放资源
</code></pre><p>接收方法：<br>     void receive(DatagramPacket p)<br>     void close()  释放资源</p>
<h3 id="DatagramPacket-数据报包"><a href="#DatagramPacket-数据报包" class="headerlink" title="DatagramPacket:数据报包"></a>DatagramPacket:数据报包</h3><p>构造方法：</p>
<pre><code>DatagramPacket(byte[] buf, int length) //用于接收
DatagramPacket(byte[] buf, int length, InetAddress address, int port) //用于发哦少年宫
</code></pre><p>DatagramPacket</p>
<pre><code>InetAddress getAddress(): 获取发送端的ip地址
int getPort(): 获取发送端的端口
byte[] getData(): 获取缓冲区数组
int getLength(): 实际接收字节的长度
</code></pre><p>我们看到：<br>发送端的DatagramSocket可以不用设置初始值，但是DatagramPacket要设置发送的内容，长度，发送的ip，和发送的端口号。<br>接受端的DatagramSocket设置接收的端口，而接收的DatagramPacket就设置接收的数组，和数组长度即可。<br>我们写了一个例子，设计一个聊天室，两个人可以聊天。<br>分析：<br>1.这个例子需要接收别的数据，也要发送数据给别人，所以要设置两个线程来完成不同的任务。<br>2.注意发送端和接收端两个任务的差异</p>
<pre><code>public static void main(String[] args) {
  Runnable sendTask = new Runnable() {
    @Override
    public void run(){
      //try...with...resource 自动close
      try(DatagramSocket ds = new DatagramSocket()){
        InetAddress local = InextAddress.getLocalHost();
        Scanner scanner = neww Scanner(System.in);
        while(true){
          String meassage = scanner.nextLine();
          byte[] bytes = new s.getBytes();
          DatagramPacket dp  = new DatagramPacket(bytes,bytes.length.local,10086);
          ds.send(dp);
          if(&quot;886&quot;.equals(meassage)){
            break;//推出聊天
          }
        }
      } catch (Exception e) {
        e.printStackTrace();
      }
    }
  };

  //接收方法
  Runnable receiveTask = new Runnable() {
    @Override
    public void run(){
      try(DatagramSocket ds = new DatagramSocket(10086)){
        byte[] bytes = new byte[1024];
        DatagramPacket dp = new DatagramPacket(bytes,bytes.length);
        while (true) {
          //阻塞方法
          ds.receive(dp);
          String ip = dp.getAddress().getHostAddress();
          int port = dp.getPort();
          byte[] data = dp.getData();
          int length = dp.getLength();
          String s = new String(bytes,0,length);
          System.out.println(&quot;from &quot;+ ip + &quot;/&quot; + port + &quot;:&quot; + s);
          if(&quot;886&quot;.equals(s)){
              break;
          }
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
    }
  };
}

new Thread(receiveTask).start();
try {
    Thread.sleep(100);
} catch (InterruptedException e) {
    e.printStackTrace();
}
new Thread(sendTask).start();
</code></pre><h3 id="实现TCP传输"><a href="#实现TCP传输" class="headerlink" title="实现TCP传输"></a>实现TCP传输</h3><pre><code>Socket和ServerSocket
建立客户端和服务器端
建立连接后，通过Socket中的IO流进行数据的传输
关闭socket
同样，客户端与服务器端是两个独立的应用程序。
</code></pre><h3 id="客户端套接字：Socket"><a href="#客户端套接字：Socket" class="headerlink" title="客户端套接字：Socket"></a>客户端套接字：Socket</h3><p>构造方法：</p>
<pre><code>Socket() 未连接的套接字
Socket(InetAddress address, int port)
Socket(String host, int port)
</code></pre><p>方法：</p>
<pre><code>InputStream getInputStream()
OutputStream getOutputStream()
</code></pre><h3 id="ServerSocket-服务器套接字"><a href="#ServerSocket-服务器套接字" class="headerlink" title="ServerSocket: 服务器套接字"></a>ServerSocket: 服务器套接字</h3><pre><code>ServerSocket() 没有绑定端口
ServerSocket(int port) 绑定指定的端口
</code></pre><p>方法：<br>    Socket accept()： 侦听并接受到此套接字的连接。</p>
<p>例子如下：</p>
<p>//客户端代码：</p>
<pre><code>public class ClientDemo1 {
  public static void main(String[] args) throws IOException {
    InetAddress local = InetAddress.getLocalHost();
    Socket socket = new Socket(local, 12345); // java.net.ConnectException:
    OutputStream outputStream = socket.getOutputStream();
    String s = &quot;Hello, tcp!&quot;;
    outputStream.write(s.getBytes());
    // 释放资源
    // outputStream.close();
    socket.close();
  }
}
</code></pre><p>//服务端代码</p>
<pre><code>public class ServerDemo1 {
  public static void main(String[] args) throws Exception{
    ServerSocket ss = new ServerSocket(12345);
    // 监听请求，并通过三次握手，形成数据传输的通道, 阻塞方法
    Socket socket = ss.accept(); //获取Socket对象 然后就可以使用流了
    InputStream inputStream = socket.getInputStream();
    byte[] bytes = new byte[1024];
    int length = inputStream.read(bytes);
    String s = new String(bytes, 0, length);
    System.out.println(s);
    socket.close();
    // ss.close(); //服务器一般不会关闭
  }
}
</code></pre><p><strong>注意事项：TCP传输容易出现的问题</strong><br>1.客户端连接上服务端，两端都在等待，没有任何数据传输。<br>通过例程分析：</p>
<pre><code>因为read方法或者readLine方法是阻塞式。
</code></pre><p>解决办法：</p>
<pre><code>自定义结束标记
使用shutdownInput，shutdownOutput方法。
</code></pre><p>2.Socket在传输数据的时候使用的是字节流，所以只能用byte[] 保存和传输，或者一个字节一个字节的操作;</p>
<h3 id="反射reflection"><a href="#反射reflection" class="headerlink" title="反射reflection"></a>反射reflection</h3><p>在说反射之前，我们先要了解什么是类的加载</p>
<h3 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h3><p>当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载，连接，初始化三步来实现对这个类进行初始化。</p>
<p>加载</p>
<pre><code>就是指将class文件读入内存，并为之创建一个Class对象。
任何类被使用时系统都会建立一个Class对象。(字节码文件对象)
</code></pre><p>连接</p>
<pre><code>验证 确保被加载类的正确性
准备 负责为类的静态成员分配内存，并设置默认初始化值。给给对象分配空间
</code></pre><p>解析</p>
<pre><code>将类中的符号引用替换为直接引用
</code></pre><p>初始化</p>
<pre><code>就是我们以前讲过的初始化步骤
</code></pre><h3 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h3><pre><code>创建类的实例
访问类的静态变量
调用类的静态方法
使用反射方式来强制创建某个类或接口对应的java.lang.Class对象
初始化某个类的子类，子类父类都加载
直接使用java.exe命令来运行某个主类
</code></pre><h3 id="类的加载器"><a href="#类的加载器" class="headerlink" title="类的加载器"></a>类的加载器</h3><p>类加载器</p>
<pre><code>负责将.class文件加载到内存中，并为之生成对应的Class对象。
虽然我们不需要关心类加载机制，但是了解这个机制我们就能更好的理解程序的运行。
</code></pre><p>类加载器的组成</p>
<h3 id="Bootstrap-ClassLoader-根类加载器"><a href="#Bootstrap-ClassLoader-根类加载器" class="headerlink" title="Bootstrap ClassLoader 根类加载器"></a>Bootstrap ClassLoader 根类加载器</h3><pre><code>也被称为引导类加载器，负责Java核心类的加载
比如System,String等。在JDK中JRE的lib目录下rt.jar文件中
</code></pre><h3 id="Extension-ClassLoader-扩展类加载器"><a href="#Extension-ClassLoader-扩展类加载器" class="headerlink" title="Extension ClassLoader 扩展类加载器"></a>Extension ClassLoader 扩展类加载器</h3><pre><code>负责JRE的扩展目录中jar包的加载。
在JDK中JRE的lib目录下ext目录
</code></pre><h3 id="System-ClassLoader-系统类加载器"><a href="#System-ClassLoader-系统类加载器" class="headerlink" title="System  ClassLoader  系统类加载器"></a>System  ClassLoader  系统类加载器</h3><pre><code>Sysetm ClassLoader 系统类加载器（应用类加载器）
负责在JVM启动时加载来自java命令的class文件
</code></pre><p>到目前为止我们已经知道把class文件加载到内存了，那么，如果我们仅仅站在这些class文件的角度，我们如何来使用这些class文件中的内容呢?<br>这就是我们反射要研究的内容。</p>
<h2 id="反射（非常重要）"><a href="#反射（非常重要）" class="headerlink" title="反射（非常重要）"></a>反射（非常重要）</h2><pre><code>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。
要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类对象。从而得到其中的方法或成员.所以先要获取到每一个字节码文件对应的Class类型的对象。
</code></pre><p><strong>反射的前提：获取类的字节码文件对象</strong></p>
<p>获取字节码文件对象的方式：<br>方式一：</p>
<pre><code>Object: getClass()
</code></pre><p>方式二：</p>
<pre><code>类名.class
</code></pre><p>方式三：</p>
<pre><code>static Class&lt;?&gt; forName(String className)
</code></pre><p>Class:</p>
<pre><code>Class类的实例表示正在运行的Java应用程序中的类和接口。枚举是一种类，注解是一种接口。
</code></pre><h3 id="通过反射获取构造的对象"><a href="#通过反射获取构造的对象" class="headerlink" title="通过反射获取构造的对象"></a>通过反射获取构造的对象</h3><p>得到了类的字节码文件对象，如何利用它创建对象？</p>
<pre><code>Class&lt;T&gt;：T newInstance() 创建此 Class 对象所表示的类的一个新实例。调用的类的无参构造方法。
</code></pre><p>AccessibleObject（）</p>
<pre><code>void setAccessible(boolean flag) 将此对象的 accessible 标志设置为指示的布尔值。
|--Constructor&lt;T&gt;
直接已知子类：
Constructor, Field, Method
</code></pre><h3 id="反射获取构造器-Constructor"><a href="#反射获取构造器-Constructor" class="headerlink" title="反射获取构造器(Constructor)"></a>反射获取构造器(Constructor)</h3><p>Class:</p>
<pre><code>Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)  获取公共的构造器
Constructor&lt;?&gt;[] getConstructors()  获取所有的公共构造器
Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)  获取在类中声明的构造器(包括私有的)
Constructor&lt;?&gt;[] getDeclaredConstructors()  获取类中声明的所有构造器
</code></pre><p>Constructor:</p>
<pre><code>T newInstance(Object... initargs)
constructor.setAccessible(true); // 暴力访问私有构造方法
</code></pre><h3 id="反射获取成员变量-Field"><a href="#反射获取成员变量-Field" class="headerlink" title="反射获取成员变量(Field)"></a>反射获取成员变量(Field)</h3><p>a. 通过类的字节码文件对象Class获取类的成员变量</p>
<pre><code>Field getField(String name) 获取公共的成员变量(包括父类)
Field[] getFields() 获取所有公共的成员变量(包括父类)
Field getDeclaredField(String name)  获取在本类中声明的成员变量(包括私有的)
Field[] getDeclaredFields()  获取在本类中声明的所有的成员变量(包括私有的)
</code></pre><p>b. Field的两个操作：<br>读取：读取对象的该属性的值</p>
<pre><code>Object get(Object obj) obj查看的对象
boolean getBoolean(Object obj)
byte getByte(Object obj)
char getChar(Object obj)
double getDouble(Object obj)
float getFloat(Object obj)
short getShort(Object obj)
int getInt(Object obj)
long getLong(Object obj)
</code></pre><p>写入：设置对象的该属性的值</p>
<pre><code>void set(Object obj, Object value)
void setBoolean(Object obj, boolean z)
void setByte(Object obj, byte b)
...
</code></pre><p>暴力访问修改：</p>
<pre><code>aField.setAccessible(true);
</code></pre><h3 id="反射获取成员方法-Method"><a href="#反射获取成员方法-Method" class="headerlink" title="反射获取成员方法(Method)"></a>反射获取成员方法(Method)</h3><p>a. 通过字节码文件对象获取方法</p>
<pre><code>Method getMethod(String name, Class&lt;?&gt;... parameterTypes) 获取公共的方法(包括父类的)
Method[] getMethods() 获取所有公共的方法(包括父类的)
Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) 获取本类中声明的方法(包括私有的)
Method[] getDeclaredMethods()  获取本类中声明的所有方法(包括私有的)
</code></pre><p>b. ：如果调用该方法</p>
<pre><code>Object invoke(Object obj, Object... args) Object obj: 调用该方法的对象
</code></pre><h3 id="说了这么多到底反射的作用是什么？"><a href="#说了这么多到底反射的作用是什么？" class="headerlink" title="说了这么多到底反射的作用是什么？"></a>说了这么多到底反射的作用是什么？</h3><p>通过配置文件，动态的生成对象，把要生成的对象放在配置文件中，这样可以通过反射创建我们需要的对象。框架的底层都是这样做的，所以必须要知道，这里就写一个简单的例子创建，通过Class.forName(classname)创建对象；</p>
<pre><code>//Test2.java
public class Test2 {
    public static void main(String[] args) throws Exception{
        Properties properties = new Properties();
        properties.load(new FileReader(&quot;class.properties&quot;));
        String className = properties.getProperty(&quot;className&quot;);
        Class&lt;?&gt; cl = Class.forName(className);
        Person person = (Person) cl.newInstance();
    }
}

//class.properties
className=com.cskaoyan.exercise.Student
</code></pre><h3 id="注解-不是注释"><a href="#注解-不是注释" class="headerlink" title="注解(不是注释)"></a>注解(不是注释)</h3><pre><code>一种Java语言用来在代码中添加额外信息的形式化方法，使得Java程序可以在编译或者运行之后的某个时刻很方便的去使用这些额外信息（数据）引入的时间：JDK5之后引入。
</code></pre><h3 id="两个我们见过的注解"><a href="#两个我们见过的注解" class="headerlink" title="两个我们见过的注解"></a>两个我们见过的注解</h3><pre><code>@Override：检查子类确实是覆盖了父类的方法
@Deprecated：说明已经过时了。

我们看到两个注解的源码
</code></pre><p>// @Override</p>
<pre><code>@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface Override {
}
</code></pre><p>//@Deprecated</p>
<pre><code>@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})
public @interface Deprecated {
}
</code></pre><p>这些@来@去的到底是一些什么东西呀？<br>这里就引出了注解的核心：元注解<br>有了元注解我们才能去自定义的去描述我们需要的注解</p>
<h3 id="元注解-meta-描述注解的注解"><a href="#元注解-meta-描述注解的注解" class="headerlink" title="元注解(meta): 描述注解的注解"></a>元注解(meta): 描述注解的注解</h3><p>@Target：作用，指定该注解能用在什么地方。</p>
<pre><code>ElementType:  TYPE, METHOD, FIELD, CONSTRUCTOR...
</code></pre><p>@Retention:作用。改变自定义的注解的存活范围。</p>
<p>RetentionPolicy</p>
<pre><code>1.SOURCE:在源文件中有效（即源文件保留）
2.CLASS:在class文件中有效（即class保留）
3.RUNTIME:在运行时有效（即运行时保留
</code></pre><p>明天我们将来介绍一下到底怎么用注解–&gt;自定义注解</p>
<h2 id="星期三-7-31"><a href="#星期三-7-31" class="headerlink" title="星期三(7.31)"></a>星期三(7.31)</h2><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>1.声明</p>
<pre><code>定义注解格式：public @interface 注解名 {
    定义体
}
</code></pre><p>注意事项：</p>
<pre><code>a. @必不可少
b. 自定义注解继承了Annotation这个接口，由编译期完成细节
c. 不能继承任何接口
</code></pre><p>说明：<strong>前两点最重要</strong></p>
<pre><code>1.方法的名称就是参数的名称，
2.返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum, 以及它们的数组类型）。
3.方法不用写具体实现
4.一个方法表示一个配置
5.当只需要给 value 配置的时候，可以省略名称
6.方法之后可以使用 default 默认值
</code></pre><p>一个简单的例子：</p>
<pre><code>public @interface MyAnnotation  {
    int value() default 18;
    String method() default &quot;Henson_z&quot;;
    //...
}

@MyAnnotation()     // 创建了注解对象
public class AnnotationTest {
}
</code></pre><h3 id="properties-和-自定义注解？"><a href="#properties-和-自定义注解？" class="headerlink" title="properties 和 自定义注解？"></a>properties 和 自定义注解？</h3><p>这两个之间有什么关系？我们看下面的例子:<br>假如我们要创建一个账户。要记录账户的姓名和年龄，那么我们是否需要对用户输入的信息去判断一下</p>
<pre><code>//用户input: name 、 age
int minLength = 10;
int maxLength = 20;
int minAge = 18;
int maxAge = 100;

if (name.length() &lt; minLength || name.length() &gt; maxLength) {
  throw new IllegalArgumentException(&quot;名字太长了&quot;);
}
if (age &lt; minAge || age &gt; maxAge) {
  throw new IllegalArgumentException(&quot;age=&quot; + age);
}
</code></pre><h3 id="properties存放判断配置文件"><a href="#properties存放判断配置文件" class="headerlink" title="properties存放判断配置文件"></a>properties存放判断配置文件</h3><p>如果minLength maxLength minAge maxAge要经常改变怎么办？我们又不能经常去修改代码。这时候机智的我们就想到把这四个参数放在properties配置文件嘛，要用时候直接load进来判断就好了，以后要改也是改配置文件</p>
<pre><code>//student.properties
minAge=6
maxAge=1000
minLength=2
maxLength=10

Properties properties = new Properties();
try {
  properties.load(new FileReader(&quot;student.properties&quot;));
} catch (Exception e) {
  e.printStackTrace();
}

int minAge = Integer.parseInt(properties.getProperty(&quot;minAge&quot;));
int maxAge = Integer.parseInt(properties.getProperty(&quot;maxAge&quot;));
int minLength = Integer.parseInt(properties.getProperty(&quot;minLength&quot;));
int maxLength = Integer.parseInt(properties.getProperty(&quot;maxLength&quot;));
</code></pre><p>然后再进行判断就好了。但是这里有个问题，如果以后配置文件多了的话，如果要修改配置文件中哪一个成员，我们很容易找不到需要修改的是哪个，到时候还要去一个一个的判断进入类中去看是否是这个参数。 这时候有个老哥出来的说：能不能在这个类上面就判断好了每个参数的范围。就在类对应成员上面确定参数的值，这样就很好确定，要修改的参数，直接在这个成员上修改即可。这时候就引出了<strong>自定义的注解</strong></p>
<h3 id="自定义注解实现判断功能"><a href="#自定义注解实现判断功能" class="headerlink" title="自定义注解实现判断功能"></a>自定义注解实现判断功能</h3><p>1.先创建两个自定义的注解：</p>
<pre><code>// 大括号表示数组，如果只有一个元素可以省略大括号
@Target({ElementType.FIELD, ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface AgeConstraint {
    int minAge();
    int maxAge();
}

@Retention(RetentionPolicy.RUNTIME)
public @interface NameConstraint {
    int minLength();
    int maxLength();
}
</code></pre><p>注意这里的Retention一定要设置成RetentionPolicy.RUNTIME 已确保这个注解在程序运行的时候还可以用，要不然编译完就拉闸了，实际运行用不了。</p>
<p>2.在对应的成员变量上加上注解</p>
<pre><code>public class Student {
    @NameConstraint(minLength = 2, maxLength = 10)
    private String name;

    @AgeConstraint(minAge = 6, maxAge = 1000)
    private int age;
。。。。
</code></pre><p>3.如何使用的问题；<br>我们刚刚学过反射，但是之前有个东西没有讲，可以通过反射的以下方法，获取到注释的对象，然后在使用即可。类，构造器，属性，方法都有这个方法</p>
<pre><code>getAnnotation(Class&lt;A&gt; annotationClass) 如果存在该元素的指定类型的注释，则返回这些注释，否则返回 null。
</code></pre><p>具体代码如下：</p>
<pre><code>Class&lt;Student&gt; cl = Student.class;
int minLength = 0;
int maxLength = Integer.MAX_VALUE;
int minAge = 0;
int maxAge = Integer.MAX_VALUE;
try {
  Field nameField = cl.getDeclaredField(&quot;name&quot;);
  NameConstraint nameAnnotation = nameField.getAnnotation(NameConstraint.class);
  minLength = nameAnnotation.minLength();
  maxLength = nameAnnotation.maxLength();
  Field ageField = cl.getDeclaredField(&quot;age&quot;);
  AgeConstraint ageAnnotation = ageField.getAnnotation(AgeConstraint.class);
  minAge = ageAnnotation.minAge();
  maxAge = ageAnnotation.maxAge();
} catch (Exception e) {
  e.printStackTrace();
}
//如果构造方法私有化，还可以反射创建对象
Student s = null;
try {
  Constructor&lt;Student&gt; c = cl.getDeclaredConstructor(String.class, int.class);
  c.setAccessible(true);
  s = c.newInstance(name, age);
} catch (Exception e) {
  e.printStackTrace();
}
</code></pre><h3 id="两者的优劣"><a href="#两者的优劣" class="headerlink" title="两者的优劣"></a>两者的优劣</h3><p>配置文件：</p>
<pre><code>优点：可配置，不用改源码。
缺点：不直观，开发效率低
</code></pre><p>注解：</p>
<pre><code>优点：直观，开发效率高
缺点：硬编码，修改之后需要重新编译运行
</code></pre><h3 id="GC与内存泄漏。。"><a href="#GC与内存泄漏。。" class="headerlink" title="GC与内存泄漏。。"></a>GC与内存泄漏。。</h3><p>这一部分没有代码，都是理论的东西，如果要深入理解还是需要一些功底的。就简单概括一下以后有机会在学习</p>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>1) 判断什么是垃圾</p>
<pre><code>垃圾：不能再访问到的对象就是垃圾。
算法：
a. 引用计数法
  给堆中的每一个对象增加一个引用计数器，当每一次创建一个对象并赋值给一个变量是，
  引用计数器就加1.当对象不再使用时（出了作用域），引用计数机减一。一但引用计数器为0，
  对象就满足了垃圾回收的条件。

b. 该算法的基本思路就是通过一系列的名为GC Root的对象作为起始点，从这些节点开始向下搜索，
  搜索所走的路径称为引用链（Reference chain）。当一个对象到所有的GC root之间没有任何引用链相连
  （用图论的话来说就是没GC  roots到这些对象不可达）时，证明该对象是不可用的，GC程序即可回收这些对象。
GCroots:
  JAVA虚拟机栈中的引用对象
  方法区中的静态属性引用的对象
  方法区中常量引用的对象
  Shallow size 就是对象本身占用的内存大小，也就是对象头加成员变量占用内存大小的总和
  Retained size 是该对象自己的shallow size 加上仅可以从该对象访问（直接或者间接访问）的对象的shallow size之和。
  Retained size是该对象被GC之后所能回收的内存的总和。
</code></pre><p>2) 回收垃圾</p>
<pre><code>a. 标记清除算法  先把要丢的垃圾全部都打上标记，然后统一把打标记的全部移除。
缺点：产生空间碎片，创建大对象和数组出现空间不够，而且创建对象很慢
b. 标记整理算法  分为标记和整理两个阶段：首先标记出所有需要回收的对象，让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

c. 标记复制算法
它先将可用的内存按容量划分为大小相同的两块，每次只是用其中的一块。当这块内存用完了，就将还存活着的对象复制到另一块上面，然后把已经使用过的内存空间一次清理掉。
d. 分代收集算法
据对象存活的周期的不同将内存划分为几块，然后再选择合适的收集算法。一般是把java堆分成新生代和老年代，这样就可以根据各个年待的特点采用最适合的收集算法。在新生代中，每次垃圾收集都会有大量的对象死去，只有少量存活，所以选用复制算法。老年代因为对象存活率高，没有额外空间对他进行分配担保，所以一般采用标记整理或者标记清除算法进行回收。
</code></pre><p><a href="https://blog.csdn.net/FateRuler/article/details/81158510" target="_blank" rel="external">四种收集算法</a><br>  3) GC触发的时机<br>    a.申请heap space失败后会触发GC回收<br>    b.系统进入idle后一段时间会进行回收<br>    c.主动调用GC进行回收 System.gc();</p>
<h3 id="内存泄露-VS-内存溢出"><a href="#内存泄露-VS-内存溢出" class="headerlink" title="内存泄露 VS 内存溢出"></a>内存泄露 VS 内存溢出</h3><p>—— 内存泄露可能导致内存溢出，但不是必然导致内存溢出</p>
<h3 id="JAVASE考试总结"><a href="#JAVASE考试总结" class="headerlink" title="JAVASE考试总结"></a>JAVASE考试总结</h3><p>一些踩过的坑</p>
<p>1静态方法</p>
<pre><code>class Dog {
    public static void bark() {System.out.print(&quot;woof &quot;);
}
class Basenji extends Dog{public static void bark(){}}
public class quest5 {
    public static void main(String args[]) {
        Dog woofer = new Dog();
        Dog nipper = new Basenji();
        woofer.bark();
        nipper.bark();
    }
}
结果 woof woof
</code></pre><p>静态方法并不是编译看左边，运行看右边，而是方法属于类，两个都是Dog类所以调用都是Dog类的方法</p>
<p>2下列说法正确的有（C）</p>
<pre><code>A．class中的constructor不可省略
B．constructor必须与class同名，但方法不能与class同名
C．constructor在一个对象被new时执行
D．一个class只能定义一个constructor
</code></pre><p>可以有方法与class同名，而且不是构造方法，而是成员方法</p>
<p>3表示double类型变量d<br>因为浮点数默认就是d类型的所以很容易忽视，这次有一个警醒吧</p>
<pre><code>public class quest10 {
    public static void main(String[] args) {
        double num = getNum(1.4f);
    }
    public static double getNum(float d) {
        //这两个d不是一个意思
        // 第一个d是参数
        // 第二个d表示的是double类型

        System.out.println(d);
        System.out.println(4.0d);
        return 4.0d;
    }
}
</code></pre><h3 id="JAVASE结束"><a href="#JAVASE结束" class="headerlink" title="JAVASE结束"></a>JAVASE结束</h3><pre><code>考试完了SE部分结束了，接下来的部分更加重要和需要总结，不要慌，虽然很累但是学习就是逆水行舟。加油，后面的总结放在下期
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/28/Java总结（五）下/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王邸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路要坚持">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/28/Java总结（五）下/" itemprop="url">Java总结（五）下</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-28T23:13:20+08:00">
                2019-07-28
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/07/28/Java总结（五）下/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/07/28/Java总结（五）下/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>具体讲解银行转账例子，如何实现线程安全的，接着之前的银行转账问题来说，我们先搞不弄那么复杂，一步一步的来，先把问题简化，有三个账户A,B,C，每个账户上有1000大洋。现在实现：</p>
<pre><code>A -&gt; C 转100块
B -&gt; C 转200块
</code></pre><p>如果是单线程的程序肯定没有问题。但是银行肯定不会等你一个一个转账的。肯定要使用多线程的还解决问题。那么多线程就会出现线程安全的问题。这个情景是否会出现线程安全的问题？</p>
<p>答：那是肯定的，线程安全的问题在多线程肯定会出现，这里出现的地方就是：</p>
<pre><code>在转钱的时候，当A 和 C 同时向B转钱，因为转钱之前需要获取到B应该接收多少钱，在多线程的情况下就会出现A给B转钱的结果没有放回到内存，C去读取B的钱的时候就可能发生错误，读到的可能并不是A转完给B的结果。
</code></pre><p>//首先先还原问题<br>Account.java</p>
<pre><code>public class Account {
  private int id; //表示资源的优先级为了拿资源的顺序都一样
  private int balance;
  private String username;
  private String password;
  public Account(int balance, String username) {
      this.balance = balance;
      this.username = username;
  }
  public Account(int id, int balance, String username) {
      this.id = id;
      this.balance = balance;
      this.username = username;
  }
  //省略geter setter
  //出问题的transfer方法
  public void transfer(Account target, int amount) {
    this.balance -= amount;
    int value = target.balance; //把B的钱先拿出来，睡100毫秒再给他转账
    try {
        Thread.sleep(100);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    value += amount;
    target.balance = value;
  }
}
</code></pre><p>main</p>
<pre><code>Account accountA = new Account(1000,&quot;A&quot;);
Account accountB = new Account(1000, &quot;B&quot;);
Account accountC = new Account(1000, &quot;C&quot;);

//创建两个进程
new Thread(){
    @Override
    public void run() {
        accountA.transfer(accountB,100);
    }
}.start();

new Thread(){
    @Override
    public void run() {
        accountC.transfer(accountB,200);
    }
}.start();

Thread.sleep(2000); //为了给两个线程都执行完
System.out.println(accountA.getBalance()); // 900
System.out.println(accountB.getBalance()); // 1200 出现问题，结果不是1300
System.out.println(accountC.getBalance()); // 800
</code></pre><p>发现问题了。结果并不是：</p>
<pre><code>900
1300
800
</code></pre><h3 id="第一次的解决办法："><a href="#第一次的解决办法：" class="headerlink" title="第一次的解决办法："></a>第一次的解决办法：</h3><p>重写transfer 用 synchronized（）{}代码块 以字节码文件作为锁来使线程安全，</p>
<p>修改后的transfer</p>
<pre><code>public void transfer(Account target, int amount) {
  synchronized(Account.class){
    this.balance -= amount;
    int value = target.balance; //把B的钱先拿出来，睡100毫秒再给他转账
    try {
        Thread.sleep(100);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    value += amount;
    target.balance = value;
  }
}
</code></pre><p>实现是可以实现了，<br>优点是：只使用了一把锁，不会发生线程死锁的问题，<br>缺点：这就很蠢，直接对整个类都上锁一次只能执行一次。淘宝双11用这个肯定拉闸。和单线程有的一拼了。</p>
<h3 id="第二次解决办法"><a href="#第二次解决办法" class="headerlink" title="第二次解决办法"></a>第二次解决办法</h3><p>第二种尝试就使用两个锁，也就是synchronized代码块就给this和target上锁</p>
<pre><code>public void transfer(Account target, int amount) {
  synchronized(this){
    //这个延迟很致命，可能会产生死锁
    try {
      Thread.sleep(100);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
    synchronized (target){
      this.balance -= amount;
      int value = target.balance; //记录转钱的账户的金额
      try {
        Thread.sleep(100);
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
      value += amount;
      target.balance = value;
    }
  }
}


Thread.sleep(2000); //为了给两个线程都执行完
System.out.println(accountA.getBalance()); // 900
System.out.println(accountB.getBalance()); // 1300
System.out.println(accountC.getBalance()); // 800
</code></pre><p>终于解决了问题，但是这就引出了今天的重点 <strong>死锁问题</strong><br>如果两个synchronized之间有延迟的话。就可能出线死锁的问题。当两个进程同时给自己上锁，第一个休眠了，第二个就锁不了第一个。第二个休眠之后，第一个醒来也锁不上第二个。 两个就在互相等待出现死锁</p>
<p>之前提到解决死锁的三个方法：</p>
<pre><code>a. 一次性获取所有的资源
b. 释放占有的资源（这个JAVA语言自己不能做到）
c. 按照一定的顺序申请资源
</code></pre><p>我们就使用ac来解决死锁问题：</p>
<h3 id="解决死锁1：一次获取所有资源，"><a href="#解决死锁1：一次获取所有资源，" class="headerlink" title="解决死锁1：一次获取所有资源，"></a>解决死锁1：一次获取所有资源，</h3><p>思路：为了获取所有的资源，我们需要使用一个中间类，用一个集合获取所有的资源,而且获取资源也是一个同步的过程</p>
<pre><code>//Apply
public class Apply {
  private static List&lt;Account&gt; list = new ArrayList&lt;&gt;();
  //方法也要是同步的，这样才能一次进入一个
  public synchronized static boolean apply(Account accountA, Account accountB) {
    //如果里面有就要判断不能进入
    if(list.contains(accountA) || list.contains(accountB)) {
        return false;
    }
    list.add(accountA);
    list.add(accountB);
    return true;
  }
  //释放资源
  public synchronized static void free(Account accountA, Account accountB) {
    list.remove(accountA);
    list.remove(accountB);
  }
}

//transfer
public void transfer(Account target, int amount) {
  //先判断是否有人在申请全部资源,自己能否申请到
  while(!Apply.apply(this,target));//一次性获取全部资源
  synchronized(this){
    try {
      Thread.sleep(100);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
    synchronized (target){
      this.balance -= amount;
      //记录转钱的账户的金额
      int value = target.balance;
      try {
        Thread.sleep(100);
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
      value += amount;
      target.balance = value;
    }
  }
  //用完资源要free要不然还是会出现死锁
  Apply.free(this, target);
}

//main
new Thread(){
    @Override
    public void run() {
        accountA.transfer(accountB,100);
    }
}.start();

new Thread(){
    @Override
    public void run() {
        accountB.transfer(accountA,200);
    }
}.start();

Thread.sleep(3000); //为了给两个线程都执行完
System.out.println(accountA.getBalance()); // 1100
System.out.println(accountB.getBalance()); // 900
</code></pre><p>可以是可以，但是在transfer之前有一句</p>
<pre><code>while(!Apply.apply(this,target));
</code></pre><p>如果有人在获取资源，他就获取不到就要一直在这等着，这里需要线程之间的通讯来解决，让其中一个thread告诉别人。</p>
<h3 id="解决死锁2：按照一定顺序拿资源"><a href="#解决死锁2：按照一定顺序拿资源" class="headerlink" title="解决死锁2：按照一定顺序拿资源"></a>解决死锁2：按照一定顺序拿资源</h3><p>  按照一定的顺序获取资源，这个方法就很简单了。简单的说就是两层synchronized代码块进去的锁顺序是一样的，这就需要给对象设置一个ID<br>以确定两个对象拿资源的顺序都是一样的。这样就不会发生相互等待的情况，也是最人性化的。因为我们做一件事情有序，不就是每个人都按照顺序去做吗?</p>
<pre><code>public void transfer(Account target, int amount) {
   Account left = this;
   Account right = target;
   //默认为了left id 小于 right的id
   //先拿小的资源，再拿大的资源
   if(left.id - right.id &gt; 0){
        left = target;
        right = this;
   }
   synchronized(left){
      try {
        Thread.sleep(100);
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
      synchronized (right){
        this.balance -= amount;
        int value = target.balance; //记录转钱的账户的金额
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        value += amount;
        target.balance = value;
      }
   }
}
</code></pre><p>这个方法还有几率发生死锁的，如果两个人id一样，那么id的判断就无效了。估计很少概率但是还是会发生，那么这样做就不行了</p>
<h3 id="本周小知识："><a href="#本周小知识：" class="headerlink" title="本周小知识："></a>本周小知识：</h3><p>1复制文件File，总是找不到路径<br>原因：没有创建对应了路径：<br>所以需要先创建路径才能复制到对应的地方（mkdir）<br>创建路径之后又出现拒绝访问的情况，是创建路径错了<br>需要创建路径要准确。<br>只有在一个确定的路径才能进行读写操作。不然需要创建路径</p>
<p>2.注意properties.store(OutputStream out, String comments) comments不能是中文因为：<br>“如果 comments 变量非 null，则首先将 ASCII # 字符、注释字符串和一个行分隔符写入输出流。因此，该 comments 可用作一个标识注释。”<br>comments这就是一注释,你要不想写注释进properties,传递个null好了</p>
<h2 id="最后："><a href="#最后：" class="headerlink" title="最后："></a>最后：</h2><pre><code>每周都有很多东西JAVASE马上要结束了，所以加油吧
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/28/Java总结（五）上/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王邸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路要坚持">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/28/Java总结（五）上/" itemprop="url">Java总结（五）上</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-28T22:09:38+08:00">
                2019-07-28
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/07/28/Java总结（五）上/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/07/28/Java总结（五）上/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Map:HashMap、TreeMap，自己实现HashMap（拉链法），文件（路径），字节流（输入、输出、缓冲流），字符流（转换流、输入、输出、缓冲流），设计模式（装饰者模式），Data流，Object流，序列化流，打印流，标准输入输出流，错误流，Properties类，hashTable方法，线程，多线程的实现（两种方法创建线程），线程的控制（sleep,join,yeild,setDamon,interrupt)，线程安全问题，线程同步，银行转账案例</p>
<h2 id="星期一（0722）"><a href="#星期一（0722）" class="headerlink" title="星期一（0722）"></a>星期一（0722）</h2><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>public interface Map:<br>  将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。<br>方法：<br>  增：</p>
<pre><code>V put(K key, V value)
void putAll(Map&lt;? extends K,? extends V&gt; m)
</code></pre><p>  删：</p>
<pre><code>V remove(Object key)
void clear()
</code></pre><p>  改：</p>
<pre><code>V put(K key, V value)
void putAll(Map&lt;? extends K,? extends V&gt; m)
</code></pre><p>  查：</p>
<pre><code>V get(Object key)
boolean containsKey(Object key)
boolean containsValue(Object value)
</code></pre><p>  获取集合的属性：</p>
<pre><code>int size();
boolean isEmpty()
</code></pre><p>  遍历：</p>
<pre><code>方式1：Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()
Map.Entry&lt;K,V&gt; 键-值对
    K getKey()
    V getValue()
    V setValue(V value)  返回原来的值
方式2：Set&lt;K&gt; keySet() + V get(key)
方式3：Collection&lt;V&gt; values()
</code></pre><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>注意事项：<br>    键的唯一性和存储键的equals() 和 hashCode()方法有关<br>    HashMap的键和值可以 null.</p>
<h3 id="自己构造-HashMap-MyHashMap-java"><a href="#自己构造-HashMap-MyHashMap-java" class="headerlink" title="自己构造 HashMap (MyHashMap.java)"></a>自己构造 HashMap (MyHashMap.java)</h3><p>思路：<br>1.首先HashMap是键值对存储的，单纯的数组肯定是不行的。需要一个Node对象保存key 和 value。</p>
<p>2.为了解决冲突容易所以使用拉链法（链地址法）来解决冲突。原理就是一个Table数组放每一个单链表的头指针。然后出现冲突，就把结点以头插法的形式插入到每一个Table[index]中。所以这里需要给每一个Node一个next属性</p>
<p>3.关于加载因子和阈值，这两个指标其实表示的就是一个意思：</p>
<pre><code>加载因子*Table长度 = 阈值
</code></pre><p>表示的是这个Table的放元素的密度，加载因子默认值设置成0.75，作为Table是否需要扩容的指标。当扩容到最大值时，就必须把阈值设置成整个数组长度，不再扩容。此时加载因子就为1。关于扩容还想说的一点是，此时的的每个元素的index下标需要重新计算，然后放到对应的位置。这时候使用的就是头插法。而且会改变元素的位置。所以不能保证顺序。</p>
<p>4.最关键的一点，关于每个Node应该放哪里的问题。我们hashMap是通过equals和hashCode确定每个Node应该放在哪里的。而且对于每个Node我们最好不要修改他的元素值。因为他一开始的位置就又hashCode计算好了。所以修改值会发现找不到的情况。这和List集合是不一样的。</p>
<p>5.还有一点是，关于数组长度的问题，因为hashCode需要对数组长度取余。这样才能保证的出来的index在数组长度里面。我们最好把数组的长度设置成2^n，因为我们知道取余是一个非常复杂的操作。所以设置成2^n取余操作就能变成对2^n-1的相与的操作了。接下来的操作是如何把一个数转成比他大最近的二进制数</p>
<p><strong>那我们就开始吧！默认不保存null值</strong><br>public class MyHashMap<k,v> {</k,v></p>
<p>//属性</p>
<pre><code>private static final int MAX_CAPACITY = 1 &lt;&lt; 30;//最大的长度是2^30次方一共31位
private static final int DEFAULT_CAPACITY = 16;//默认最大长度，是2^n次方
private static final double DEFAULT_LOAD_FACTOR = 0.75;//给一个默认的加载因子
private Node&lt;K,V&gt;[] table;
private int size;  //保存结点的个数
private double loadFactor; //保存加载因子
private int threshold;//设置阈值
private static class &lt;K,V&gt; {
  int hash;
  Node&lt;K,V&gt; next;
  K key;
  V value;
  //子类构造方法
  public Node(int hash, Node&lt;K,V&gt; next, K key ,V  value)
  this.hash = hash;
  this.next = next;
  this.key = key;
  this.value = value;
}
</code></pre><p>//构造方法</p>
<pre><code>public MyHashMap() {
  this(DEFAULT_CAPACITY,DEFAULT_LOAD_FACTOR);
}

public MyHashMap(int capcity){
  this.(capacity,DEFALUT_LOAD_FACTOR);
}

public MyHashMap(int initialCapacity,double loadFactor){
  if(initialCapacity &lt;= 0 || initialCapacity &gt; MAX_CAPACITY) {
    throw new IllegalArugmentException(&quot;initialCapacity=&quot; + intialCapacity);
  }
  if(Double.isNaN(loadFactor) || loadFactor &lt;=0) {
    throw new IllegalArugmentException(&quot;loadFactor=&quot; + loadFactor);
  }
  //初始化tableLength 这个很炫酷
  int length = tableLength(initialCapacity);
  table = (Node&lt;K,V&gt;[])new Node[lenght];
  this.loadFactor = loadFactor;
  //不想再添加initialCapacity 个元素的时候扩容
  threshold = initialCapactiry;
}
</code></pre><p>//求给定cap的大于等于的最小的2的n次幂的值作为长度<br>//思路：就把cap的所有位置都和1相或（|）这样数的二进制表示就会全部都变成了1然后再给这个数加一，就可以变成比这个数大的最近的2的n的值</p>
<pre><code>private int tableLength(int cap) {
  int n = cap-1;//避免cap就是2的n次方的情况
  //从n最高位为1的地方开始和n无符号右移一位之后进行或，这样最高的两位就变成了1；
  n = n | n &gt;&gt;&gt; 1;
  n = n | n &gt;&gt;&gt; 2; //使得最高的四位都变成1；
  n = n | n &gt;&gt;&gt; 4: //使得最高的八位变成1；
  n = n | n &gt;&gt;&gt; 8; //使得最高的十六位变成1；
  n = n | n &gt;&gt;&gt; 16;//使得这个大于0的数的变成比他大的数的最小的2^n-1的形式
  return (n &lt; 0) ? 1 : (n &gt;= MAX_CAPACITY ? MAX_CAPACITY : n+1);
}
</code></pre><p>//方法:主要是增删改查；<br>//增加和修改：put(key,value)<br>//删除：delete<br>//查：contains(key) get(key)</p>
<p>但是要先搞清楚一件事：<strong>如何获取hash的值</strong></p>
<pre><code>public int hash(K key) {
  int h;
  //调用了对应类型的的求hashCode的方法
  //最终的hashCode是C写的-&gt;public native int hashCode();
  return key == null ? 0 : (h = key.hashCode())^(h &gt;&gt;&gt; 16);
}

public int indexFor(int hash , int lenght) {
  //位运算的优先级是最低的所以加不加括号都行
  return hash &amp; (lenght-1)
}
</code></pre><p>//查找</p>
<pre><code>public V get(K key) {
  int hash = hash(key); //获取这个key的哈希值
  int index = indexFor(hash,table.length);
  //对找到的单链表进行遍历
  for(Node&lt;K,V&gt;node = table[index]，node != null; node = node.next) {
    //判断hash值相同，而且key相同或者key的值相同，如果key是对象比较的就是对象的内容
    if(hash == node.hash &amp;&amp; (node.key == key || node.key.equals(key))){
      return node.value;
    }
  }
  return null;
}
public V contiansKey(K key) {
  return get(key) != null;
}
</code></pre><p>//增加或修改：</p>
<pre><code>public V put(K key, V value) {
  //默认不存储null
  if(key == null) throw new NullPointerException;
  int hash = hash(key);
  int index = indexFor(hash,table.length);
  V oldValue;
  for(Node&lt;k,V&gt; node = table[index]; node != null ;node = node.next) {
      //如果找到了里面有元素
      if(hash == node.hash &amp;&amp; (key == node.key || key.equals(node.key))) {
        //修改元素的值
        oldValue = node.value;
        node.value = value;
        return oldValue;
      }
  }
  //如果没有找到就有别的情况，需要通过函数判断来增加一个元素
  addNode(hash, key, value, index);
  return null;
}


public addNode(int hash ,int key, int value ,int index) {
  //先判断是否满了，
  if(threshold  == size) {
    resize(table.length&lt;&lt;1); //扩充一倍看看能不能加
    index = indexFor(hash,table.length);//重新计算index
  }
  Node&lt;K,V&gt; node = new Node&lt;&gt;(hash,key,value,table[index]);
  //头插法插入
  node.next = table[index];
  table[index] = node;
  size++;
}

//扩容
public resize(int newLength) {
  if(table.length = MAX_CAPACITY) {
    //不能再扩容了只能修改阈值
    threshold = MAX_CAPACITY;
    return;
  }

  Node&lt;K,V&gt;[] newTable = (Node&lt;V,K&gt;[])new Node[newLength];
  //修改阈值；
  threshold = newLength * loadFactor;
  //把旧的table上的元素迁移到新的table上
  for(int i = 0; i &lt; table.length; i ++) {
    Node&lt;K,V&gt; node = table[index];
    if(node != null) {
      do{
        //获取他在新的table的位置
        int index = indexFor(hash,newLength);
        int temp = node;
        node.next = newTable[index];
        newTable[index] = node;
        node = temp.next;
      }
      while(node != null)
    }//if
  }//for
  table = newTable;
}
</code></pre><p>//删除元素</p>
<pre><code>public V delete(K key) {
  int hash = hash(key);
  int index = indexFor(hash,table.length);
  Node&lt;K,V&gt; pre = null;//保存他的前驱结点
  V oldValue;
  //找到这个元素
  for(Node&lt;K,V&gt;node = table[index]; node!=null; node = node.next) {
    //找到这个元素
    if(hash == node.hash &amp;&amp;(key == node.key || key.equals(node.key))) {
      //找到了
      oldValue = node.value;
      //说明就是头结点
      if(pre == null) {
        table[index] = node.next;
      } else {
        pre.next = node.next;
      }
      size--;
      return oldValue;
    }
    pre = node;
  }
  return null;
}
</code></pre><p>}//public class MyHashMap</p>
<p>hashMap不是很难。也就是存储null的判断需要麻烦一点。</p>
<h3 id="HashMap应用（test1-java）"><a href="#HashMap应用（test1-java）" class="headerlink" title="HashMap应用（test1.java）"></a>HashMap应用（test1.java）</h3><p>为什么有HashMap的应用，他有一个最牛皮的特点就是，寻找一个数的时间复杂度是O(1) ，也就是寻找的上限是O(1)，而且他和数组不同的地方是，他可以通过key来寻找value而不仅仅是下标。就很方便。增删也很快。我们来看一个例子:体现出有多快<br>问题：给一个target 在数组中找是否存在不同的两个数相加得这个数，返回他的下标。</p>
<pre><code>TwoSum:
    int[] arr = {1, 2, 3, 4, 7}  int target = 9.
    arr[1] + arr[4] = target
    返回 {1, 4}
</code></pre><p>正常的思路：遍历两遍，然后去找是否有这两个数，写法如下：</p>
<pre><code>public static int[] find(int[] arr, int target) {
  for (int i = 0; i &lt; arr.length - 1; i++) {
      for (int j = i + 1; j &lt; arr.length; j++) {
          if (arr[i] + arr[j] == target) {
              return new int[] {i , j};
          }
      }
  }
  return new int[] {-1, -1};
}
</code></pre><p>很明显时间复杂度是O(n^2)。</p>
<p><strong>用hashMap怎么做？</strong><br>分析： arr[i] + arr[j] == target 那么我们是否可以换一下</p>
<pre><code>arr[i] == target - arr[j];
</code></pre><p>这样不就可以了吗？key = arr[i], value = i;<br>然后遍历一次在hashMap寻找是否存在 target - arr[j] 的key值。那么j和value值就是结果。</p>
<p>我们可以用两次循环来做这件事，时间复杂度上限为O(n);<br>第一次循环：存数<br>第二次循环：去找</p>
<pre><code>public static int[] find(int[] arr, int target) {
  HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
  for (int i = 0; i &lt; arr.length; i++) {
      map.put(arr[i], i);
  }
  for (int i = 0; i &lt; arr.length; i++) {
      int key = target - arr[i];
      if (map.containsKey(key)) {
          int value = map.get(key);
          if (value != i) {
              return new int[]{i, value};
          }
      }
  }
  return new int[] {-1, -1};
}
</code></pre><p>当然我们也可以优化一下，一次循环就搞定了。<br>一次循环，判断里面是否有我们需要的数：<br>    没有 ， 把数put进去<br>    有， 结果就拿到了</p>
<pre><code>public static int[] find(int[] arr, int target) {
  HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
  for(int i = 0; i &lt; arr.length, i ++) {
      if(!map.containsKey(target - arr[i])) {
        map.put(arr[i],i);
      } else {
        int j = get(target - arr[i])
        return new int[]{i,j};
      }
  }


  return new int[]{-1,-1};
}
</code></pre><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>基于红黑树（Red-Black tree）的 NavigableMap 实现。<br>该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法.</p>
<p>构造方法：<br>    TreeMap() 有序的符号表<br>    TreeMap(Comparator&lt;? super K&gt; comparator)</p>
<p>方法：<br>     Map.Entry<k,v> ceilingEntry(K key<br>     K ceilingKey(K key)<br>     Map.Entry<k,v> floorEntry(K key)<br>     K floorKey(K key)<br>     Map.Entry<k,v> firstEntry()<br>     K firstKey()<br>     Map.Entry<k,v> lastEntry()<br>     K lastKey()<br>     SortedMap<k,v> subMap(K fromKey, K toKey)<br>     NavigableMap<k,v> subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)</k,v></k,v></k,v></k,v></k,v></k,v></p>
<p><strong>注意：如果总结完有时间就过来看看TreeMap底层怎么实现的，以及红黑树是怎么旋转的</strong></p>
<h2 id="星期二（7-23）"><a href="#星期二（7-23）" class="headerlink" title="星期二（7.23）"></a>星期二（7.23）</h2><h3 id="File"><a href="#File" class="headerlink" title="File"></a>File</h3><pre><code>文件和目录路径名的抽象表示形式。
</code></pre><p>属性：</p>
<pre><code>static String pathSeparator
与系统有关的路径分隔符，为了方便，它被表示为一个字符串。

static char pathSeparatorChar
与系统有关的路径分隔符。

static String separator
与系统有关的默认名称分隔符，为了方便，它被表示为一个字符串。

static char separatorChar
与系统有关的默认名称分隔符。
</code></pre><p>构造方法：</p>
<pre><code>File(String pathname)
//后面这两种对于复制文件非常有用
File(String parent, String child)
File(File parent, String child),
</code></pre><h3 id="一些常用的方法："><a href="#一些常用的方法：" class="headerlink" title="一些常用的方法："></a>一些常用的方法：</h3><p>创建功能：</p>
<pre><code>public boolean createNewFile()
public boolean mkdir()
public boolean mkdirs()
</code></pre><p>删除：</p>
<pre><code>public boolean delete()
</code></pre><p><strong>注意事项：delete不能删除非空的文件夹，只能把里面的文件删除了才能删除文件夹</strong></p>
<p>重命名/剪切：</p>
<pre><code>public boolean renameTo(File dest)
</code></pre><p>重命名：调用的file的路径和dest的File路径相同名字不同就是重命名<br>剪切：调用的file对象和dest对象目录路径不同就是剪切。给个例子看看挺好玩的</p>
<pre><code>// D:\\temp\\a.txt 剪切到 D:\\b.txt 并改了名字
File file = new File(&quot;D:\\temp\\a.txt&quot;);
File dest = new File(&quot;D:\\b.txt&quot;);
System.out.println(file.renameTo(dest));
</code></pre><p>判断功能：</p>
<pre><code>public boolean exists()
public boolean isFile()
</code></pre><p>基本的获取功能：</p>
<pre><code>public File getAbsoluteFile()
public String getAbsolutePath()
public String getPath()
public String getName()  //常用
public long length()
public long lastModified()
</code></pre><p><strong>高级获取功能（必须掌握）：</strong><br>    罗列当前文件夹下面所有的文件和子文件夹</p>
<pre><code>public String[] list()
public File[] listFiles()  //非常常用
public File[] listFiles(FileFilter filter) //带过滤器的获取File数组
public File[] listFiles(FilenameFilter filter)
</code></pre><p><strong>注意事项： 必须是文件夹，并且有相应的相应的权限。</strong></p>
<h3 id="字节流："><a href="#字节流：" class="headerlink" title="字节流："></a>字节流：</h3><pre><code>可以传入任何数据
</code></pre><h3 id="字节输入流inputStream"><a href="#字节输入流inputStream" class="headerlink" title="字节输入流inputStream"></a>字节输入流inputStream</h3><p>此抽象类是表示字节输入流的所有类的超类。<br>需要定义 InputStream 子类的应用程序必须总是提供返回下一个输入字节的方法。</p>
<p>InputStream的方法（所有子类都能用）：</p>
<pre><code>void close()  关流, 释放资源
abstract int read() // 读取一个字节
int read(byte[] b) // 把读取的数据放入字节数组中
int read(byte[] b, int off, int len) // 把读取的数据放入部分数组中
</code></pre><h3 id="读取的方式（重点）："><a href="#读取的方式（重点）：" class="headerlink" title="读取的方式（重点）："></a>读取的方式（重点）：</h3><p>1.按一个字节一个字节读取（注意读取的是<strong><em>int值</em></strong>）<br>2.用一个字节数组保存读取</p>
<p>例子如下：<br>//这里使用了try… with…resource的语句</p>
<pre><code>try(FileInputStream in = new FileInputStream(&quot;a.txt&quot;)) {

  //一个字节一个字节读
  int read；
  while((read = in.read()) != -1) {
    System.out.println(read);
  }

  //一个字节文件一个字节文件读
  int len;
  byte[] bytes = new byte[1024];//默认给1024
  while((len = in.read(bytes)) != -1) {
    //这里遍历并不是到arr.len而是读取的len,因为读取的数组重新读取后面的内容并不会被覆盖
    for(int i = 0; i &lt; len; i++) {
      System.out.println(bytes[i]);
    }
    //注意或者可以拼接成字符串输出
    String s = new String(bytes,0,len);
    System.out.println(s);
  }
}catch(IOException e) {
  e.printStackTrace();
}
</code></pre><p><strong>注意事项：<br>如果读到文件末尾，返回-1</strong></p>
<p>直接已知子类：</p>
<pre><code>AudioInputStream
ByteArrayInputStream
FileInputStream （目前最常用！！）
FilterInputStream
InputStream
ObjectInputStream
PipedInputStream
SequenceInputStream
StringBufferInputStream
</code></pre><h3 id="FileInputStream-子类"><a href="#FileInputStream-子类" class="headerlink" title="FileInputStream(子类)"></a>FileInputStream(子类)</h3><p>构造方法：<br>    FileInputStream(File file)<br>    FileInputStream(String name)</p>
<h3 id="字节输出流"><a href="#字节输出流" class="headerlink" title="字节输出流"></a>字节输出流</h3><pre><code>public abstract class OutputStream extends Object
</code></pre><p>方法：</p>
<pre><code>void close()
void flush()
abstract void write(int b) 写入一个字节
void write(byte[] b) 写入字节数组
void write(byte[] b, int off, int len)  写入字节数组的一部分
</code></pre><h3 id="字节流写入的方式（重点）"><a href="#字节流写入的方式（重点）" class="headerlink" title="字节流写入的方式（重点）"></a>字节流写入的方式（重点）</h3><p>1.一个字节一个字节写入（注意写入的是<strong><em>int值</em></strong>）<br>2.一个字节数组一个字节数组的写入；</p>
<pre><code>try(FileOutputStream fos = new FileOutputStream(&quot;a.txt&quot;)){
  //一个字节一个字节的写
  fos.write(97);//a
  //一个字节数组一个字节数组的写
  byte[] bytes = {97, 98, 99, 100};
  fos.write(bytes);
}catch(IOException e) {
  e.printStackTrace();
}
</code></pre><h3 id="FileOutputStream："><a href="#FileOutputStream：" class="headerlink" title="FileOutputStream："></a>FileOutputStream：</h3><p>构造方法：<br>    FileOutputStream(File file)<br>    FileOutputStream(String name)<br>    FileOutputStream(File file, boolean append)<br>    FileOutputStream(String name, boolean append)<br>    默认 append 是 false</p>
<p>字节流的输入输出的过程：<br>步骤：</p>
<pre><code>1. 创建流对象
2. 读数据或者写数据
3. 关流，释放资源
</code></pre><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>我上面写的读写字节流的时候并没有close()。因为使用了try…with…resource的语句，所以会自动的释放资源，不需要自己再去close;</p>
<p>如何实现数据的换行<br>  Window：\r\n<br>  Linux: \n<br>  Mac: \r<br>  <strong>Java提供了一个统一的API进行换行</strong></p>
<pre><code>字符流的：newLine() 和 readLine()方法
</code></pre><p>  高级记事本能够自动识别不同平台的换行符，<br>  notepad是 Windows 自带的记事本，只能识别 \r\n</p>
<h3 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h3><h3 id="字节缓冲输入流"><a href="#字节缓冲输入流" class="headerlink" title="字节缓冲输入流"></a>字节缓冲输入流</h3><p>BufferedInputStream:<br>读取字节流更快,是一个包装流，里面实际还是FileOutputStream在进行读入数据的操作</p>
<pre><code>为另一个输入流添加一些功能，即缓冲输入以及支持 mark 和 reset 方法的能力。在创建 BufferedInputStream 时，会创建一个内部缓冲区数组。在读取或跳过流中的字节时，可根据需要从包含的输入流再次填充该内部缓冲区，一次填充多个字节。mark 操作记录输入流中的某个点，reset 操作使得在从包含的输入流中获取新字节之前，再次读取自最后一次 mark 操作后读取的所有字节。

BufferedInputStream(InputStream in) 默认缓冲区  8K
BufferedInputStream(InputStream in, int size) 指定大小的缓冲区
</code></pre><h3 id="字节缓冲输出流"><a href="#字节缓冲输出流" class="headerlink" title="字节缓冲输出流"></a>字节缓冲输出流</h3><p>BufferedOutputStream:<br>构造方法:</p>
<pre><code>BufferedOutputStream(OutputStream out) 默认大小 8K
BufferedOutputStream(OutputStream out, int size)
</code></pre><p>也是一个包装流，速度比FileOutputStream速度快很多；</p>
<h3 id="四种方式写出数据比较复制效率"><a href="#四种方式写出数据比较复制效率" class="headerlink" title="四种方式写出数据比较复制效率"></a>四种方式写出数据比较复制效率</h3><p>数据源：D:\temp\lesson1.mp4<br>目的地：D:\temp\lesson2.mp4</p>
<p>方式一：使用FileOutputSteam 一个字节一个字节的写<strong>时间太长，没心情等了</strong><br>方式二：使用FileOutputSteam 一个字节数组写入, 1353ms<br>方式三：使用BufferedOutputSteam 一个字节一个字节的写, 7453ms<br>方式四：使用BufferedOutputSteam 一个字节数组一个字节数组写入, 348ms</p>
<p>练习：判断 D:\temp 下 所有以 .java 结尾的文件</p>
<pre><code>public class Test1 {
  public static void main(String[] args) {
    File file = new File(&quot;D:\\temp&quot;);
    File[] files = file.listFiles();
    List&lt;File&gt; list = new ArrayList&lt;&gt;();

    if (files != null) { // 如果不是一个路径就位null或者出现IO流的问题

      for (File f : files) {
        if (f.isFile() &amp;&amp; f.getName().endsWith(&quot;.java&quot;)) {
          list.add(f);
        }
      }

    }
    // System.out.println(list);
    for (File f : list) {
        System.out.println(f);
    }
  }
}
</code></pre><h2 id="星期三-7-24"><a href="#星期三-7-24" class="headerlink" title="星期三(7.24)"></a>星期三(7.24)</h2><h3 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h3><p>编码表</p>
<pre><code>由字符及其对应的数值组成的一张表
</code></pre><p>常见编码表</p>
<pre><code>ASCII/Unicode 字符集
ISO-8859-1 &lt;-&gt;  Latin-1
GB2312/GBK/GB18030(包含的中文字符的数量)
BIG5   繁体中文
UTF-8 变长的
</code></pre><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><p>由于字节流操作中文不是特别方便，所以，java就提供了字符流。为什么说不方便我们举个例子：</p>
<pre><code>public static void main(String[] args) throws IOException {
  FileInputStream in = new FileInputStream(&quot;a.txt&quot;);
  byte[] bytes = new byte[3];
  int len;
  while ((len = in.read(bytes)) != -1) {
    for (int i = 0; i &lt; len; i++) {
        System.out.print((char)(bytes[i]));
    }
  }
  in.close();
}
</code></pre><p>这个例子就能看出，如果是字符就没问题，如果是中文，一个中文是两个字节表示的。但是字节数组的长度就只有3。那么就有一个中文两个字节就被分开了。这样就不会正确读出中文字符，从而显示出来就乱码，然后就引入了字符，就很稳：</p>
<pre><code>字符流 = 字节流 + 编码表
</code></pre><p>使用字符流的时候，默认读入和写出都是使用的UTF-8的格式。UTF-8就是代替Unicode出现的。但是JAVA在里面是Unicode编码的。读取文件的格式和写出的格式可以不同。直接看例子</p>
<pre><code>/*
数据源：D:\temp\Demo.java
目的地：D:\temp\Copy.java
数据源和目标地的编码格式可以不同。因为在存在JAVA中的char[]数组就已经把编码格式默认转换成Unicode编码了。再从Unicode编码转换出去。所以可以不同
 */

public class CopyDemo1 {
  public static void main(String[] args) throws IOException {
    InputStreamReader in = new InputStreamReader(new FileInputStream(&quot;D:\\temp\\Demo.java&quot;), &quot;GBK&quot;);
    OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(&quot;D:\\temp\\Copy.java&quot;), &quot;UTF-8&quot;);
    char chars[] = new char[1024];
    int len;
    while ((len = in.read(chars)) != -1) {
        out.write(chars, 0, len);
    }
    in.close();
    out.close();
  }
}
最后的运行结果并不会乱码
</code></pre><h3 id="字符输入流Reader"><a href="#字符输入流Reader" class="headerlink" title="字符输入流Reader"></a>字符输入流Reader</h3><p>abstract class Reader:</p>
<p>方法：</p>
<pre><code>int read()  读取一个字符
int read(char[] cbuf) 把读取的数据放入字符数组中
abstract int read(char[] cbuf, int off, int len) 把读取的数据放入字符数组的一部分中
</code></pre><h3 id="字符输出流Writer"><a href="#字符输出流Writer" class="headerlink" title="字符输出流Writer"></a>字符输出流Writer</h3><p>方法：</p>
<pre><code>void write(int c) // 写一个字符
void write(char[] cbuf) // 写一个字符数组
abstract void write(char[] cbuf, int off, int len) // 写一个字符数组的一部分
void write(String str)
void write(String str, int off, int len)
</code></pre><h3 id="转换流："><a href="#转换流：" class="headerlink" title="转换流："></a>转换流：</h3><p>转换流：字节流 –&gt; 字符流</p>
<h3 id="InputStreamReader："><a href="#InputStreamReader：" class="headerlink" title="InputStreamReader："></a>InputStreamReader：</h3><p>概述：是字节流通向字符流的桥梁</p>
<p>构造方法：<br><strong>注意只有转换流可以设置编码格式，默认编码格式就是UTF-8</strong></p>
<pre><code>InputStreamReader(InputStream in) 默认编码表
InputStreamReader(InputStream in, String charsetName) 指定编码表
</code></pre><h3 id="OutputStreamWriter"><a href="#OutputStreamWriter" class="headerlink" title="OutputStreamWriter:"></a>OutputStreamWriter:</h3><p>概述：是字符流通向字节流的桥梁</p>
<p>构造方法：</p>
<pre><code>OutputStreamWriter(OutputStream out)
    创建使用默认字符编码的 OutputStreamWriter。
OutputStreamWriter(OutputStream out, Charset cs)
    创建使用给定字符集的 OutputStreamWriter。
OutputStreamWriter(OutputStream out, CharsetEncoder enc)
    创建使用给定字符集编码器的 OutputStreamWriter。
OutputStreamWriter(OutputStream out, String charsetName)
    创建使用指定字符集的 OutputStreamWriter。
</code></pre><h3 id="刷新缓冲区的时机："><a href="#刷新缓冲区的时机：" class="headerlink" title="刷新缓冲区的时机："></a>刷新缓冲区的时机：</h3><pre><code>a. 使用flush
b. 缓冲区满了
c. 关闭流的时候也会刷新缓冲区
</code></pre><h3 id="flush-和close-的区别："><a href="#flush-和close-的区别：" class="headerlink" title="flush()和close()的区别："></a>flush()和close()的区别：</h3><pre><code>flush: 强制刷新缓冲区, flush之后还能写数据
close: 关流，释放系统资源. close之后不能再写数据了
</code></pre><h3 id="字符流-便捷流-："><a href="#字符流-便捷流-：" class="headerlink" title="字符流(便捷流)："></a>字符流(便捷流)：</h3><h3 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h3><pre><code>public class FileReader extends InputStreamReader
</code></pre><p>用来读取字符文件的便捷类。此类的构造方法假定默认字符编码和默认字节缓冲区大小都是适当的。要自己指定这些值，可以先在 FileInputStream 上构造一个 InputStreamReader。<br>FileReader 用于读取字符流。要读取原始字节流，请考虑使用 FileInputStream。</p>
<p>构造方法：</p>
<pre><code>FileReader(File file) 能直接对文件操作，采用的是默认编码
FileReader(String fileName)
</code></pre><p><strong>注意可以直接对文件操作，就方便很多</strong></p>
<h3 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h3><pre><code>public class FileWriter extends OutputStreamWriter
</code></pre><p>用来写入字符文件的便捷类。此类的构造方法假定默认字符编码和默认字节缓冲区大小都是可接受的。要自己指定这些值，可以先在 FileOutputStream 上构造一个 OutputStreamWriter。</p>
<p>构造方法：</p>
<pre><code>FileWriter(File file) 能够直接对文件操作，采用的是默认编码
FileWriter(File file, boolean append)
FileWriter(String fileName)
FileWriter(String fileName, boolean append)
</code></pre><h3 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h3><pre><code>/*
数据源：D:\temp\xx.jpg
目的地：D:\temp\lyf.jpg

注意事项：非文本数据不能用字符流处理
 */
 public static void main(String[] args) {
   try(Reader reader = new FileReader(&quot;D:\\temp\\xx.jpg&quot;);Writer writer = new FileWriter(&quot;D:\\temp\\lyf.jpg&quot;)){
         char[] chars = new char[1024];
         int len;
         while((len = reader.read(chars)) != -1) {
            writer.writer(chars,0,len);
         }
    }catch(IOException e) {
      e.printStackTrace();
    }
 }
</code></pre><p><strong>这里就发现图片是乱码而且打不开</strong>因为除了字符外，其他数据类型都是二进制存储的和编码格式是没有任何关系的。所以不能使用字符流去处理任何非文本的文件。需要去处理的文件必须是文本的文件。</p>
<h2 id="星期四（7-25）"><a href="#星期四（7-25）" class="headerlink" title="星期四（7.25）"></a>星期四（7.25）</h2><h3 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h3><h3 id="BufferedReader-缓冲字符输入流"><a href="#BufferedReader-缓冲字符输入流" class="headerlink" title="BufferedReader:缓冲字符输入流"></a>BufferedReader:缓冲字符输入流</h3><p>构造方法：</p>
<pre><code>BufferedReader(Reader in) 默认大小的缓冲区(8K)
BufferedReader(Reader in, int sz) 指定缓冲区大小
</code></pre><p>方法：</p>
<pre><code>String readLine()
</code></pre><p>注意事项：不包含行终止符，如果读到流的末尾返回null</p>
<h3 id="BufferedWriter-缓冲字符输出流"><a href="#BufferedWriter-缓冲字符输出流" class="headerlink" title="BufferedWriter:缓冲字符输出流"></a>BufferedWriter:缓冲字符输出流</h3><p>构造方法：</p>
<pre><code>BufferedWriter(Writer out) 默认大小是8K
BufferedWriter(Writer out, int sz)
</code></pre><p>方法：</p>
<pre><code>void newLine()  可以根据不同的操作系统写入不同的换行符
</code></pre><h3 id="字节缓冲流拷贝-Copy"><a href="#字节缓冲流拷贝-Copy" class="headerlink" title="字节缓冲流拷贝 Copy"></a>字节缓冲流拷贝 Copy</h3><p>一个简单的字节缓冲流拷贝</p>
<pre><code>public void main(String[] args) {
  try(
  BufferedReader BR = new BufferedReader(new FileReader(&quot;D:\\temp\\MyHashMap.java&quot;))
  ){
    BufferedWriter BW = new BufferedWriter(new FileWriter(&quot;D:\\temp\\MyHashMap.java&quot;));
    String s;
    while((s = BR.readLine()) != null) {
      //三连
      bw.write(s);
      bw.newLine();
      bw.flush();
    }
  }catch(IOException e) {
    e.printStackTrace();
  }
}
</code></pre><h3 id="一些其他的流"><a href="#一些其他的流" class="headerlink" title="一些其他的流"></a>一些其他的流</h3><p>这里总结一下规律，后面是InputStream都是属于是字节流的。只有Writer Reader是属于字符流；</p>
<h3 id="DataInputStream-amp-amp-DataOutputStream"><a href="#DataInputStream-amp-amp-DataOutputStream" class="headerlink" title="DataInputStream &amp;&amp; DataOutputStream"></a>DataInputStream &amp;&amp; DataOutputStream</h3><p>能操作基本数据类型，但是我们看不懂，保存的都是二进制的</p>
<p>构造方法：<br>  DataInputStream(InputStream in);<br>  DataOutputStream(OutputStream out);</p>
<p><strong>注意事项：<br>    数据是按照什么顺序写的，就必须按照什么的顺序读</strong></p>
<h3 id="装饰者模式-包装模式"><a href="#装饰者模式-包装模式" class="headerlink" title="装饰者模式(包装模式)"></a>装饰者模式(包装模式)</h3><p>把功能组合,而不是一个类单独把所有的功能全部写完<br>例如要实现<br>“1: content”<br>或<br>1:”content”</p>
<p>我们不应该是只写一个类实现这两个功能，万一又搞点花的。那不是又要写，我们应该用两个类单独实现：<br>1：content<br>和<br>“content”<br>然后再把reader作为两个的成员变量。在初始化的时候传进来，就可以按照加工的顺序实现相应的效果；</p>
<p>例如实现:”1:content”<br>我们有两个类<br>//实现了每行加序号</p>
<pre><code>public class MyLineReader extends BufferedReader {
    private int LineNumber;
    private BufferedReader br;
    public MyLineReader(BufferedReader reader) {
        super(reader);
        br = reader;
    }

    @Override
    public String readLine() throws IOException {
        // String s = super.readLine();
        String s = br.readLine();
        if (s != null) {
            LineNumber++;
            return LineNumber + &quot;: &quot; + s;
        }
        return null;
    }

    @Override
    public void close() throws IOException {
        br.close();
    }
}
</code></pre><p>// 实现了添加引号写出</p>
<pre><code>public class MyQuoteReader extends BufferedReader {
  private BufferedReader br;
  public MyQuoteReader (BufferedReader reader) {
      super(reader);
      br = reader;
  }

  @Override
  public String readLine() throws IOException {
      // String s = super.readLine();
      String s = br.readLine();
      if (s != null) {
          return &quot;\&quot;&quot; + s + &quot;\&quot;&quot;;
      }
      return null;
  }

  @Override
  public void close() throws IOException {
      br.close();
  }
}
</code></pre><p>//最后实现写出”1:content”<br>  先读入加序号，后加引号</p>
<pre><code>public static void main(String[] args) {
  MyLineReader mlr = new MyLineReader(new BufferedReader(new FileReader(&quot;a.txt&quot;)));
  MyQueteReader mqr = new MyQueteReader(mlr);
  String s;
  s = mqr.readLine();
}
</code></pre><p><strong>注释：mqr.readLine()时候，会调用br.readLine();从而进入到mlr的readLine()方法，先添加上序号，然后再回到mqr的readLine()方法。然后加上引号；</strong></p>
<h3 id="ObjectStream"><a href="#ObjectStream" class="headerlink" title="ObjectStream"></a>ObjectStream</h3><p>从名字就可以看出是以字节流来操作的；</p>
<h3 id="ObjectOutputStream"><a href="#ObjectOutputStream" class="headerlink" title="ObjectOutputStream:"></a>ObjectOutputStream:</h3><pre><code>能够将对象持久化到磁盘或者网络等设备
</code></pre><p>构造方法：</p>
<pre><code>ObjectOutputStream(OutputStream out)
</code></pre><p>方法：<br>    <strong>void writeObject(Object obj)</strong><br>    void writeByte(int val)<br>    void writeShort(int val)<br>    void writeInt(int val)<br>    void writeLong(long val)<br>    void writeFloat(float val)<br>    void writeDouble(double val)<br>    void writeChar(int val)<br>    void writeBoolean(boolean val)</p>
<p><strong>注意事项：</strong>这里写入的基本数据类型是可以看懂的和dataOutputStream是不同的所以要注意；</p>
<h3 id="ObjectInputStream"><a href="#ObjectInputStream" class="headerlink" title="ObjectInputStream:"></a>ObjectInputStream:</h3><pre><code>能够从磁盘或者网略等设备读取二进制，并将它还原成对象
</code></pre><p>构造方法：<br>    ObjectInputStream(InputStream in)</p>
<p>方法：<br>    <strong>Object readObject()</strong></p>
<h3 id="序列化流"><a href="#序列化流" class="headerlink" title="序列化流"></a>序列化流</h3><p>序列化就是为了将对象持久化</p>
<p>Serializable(标记接口):<br>    只有实现了这个接口类的对象才可以被序列化，才能把对象永久保存在磁盘上；看下面的例子：</p>
<pre><code>public class Student implements Serializable {
    private static final long serialVersionUID = -1L; //
    private String name;
    private transient int age;
    // private String gender;
    public Student() {
    }
    public Student(String name, int age) {
        this.name = name;
        this.age = age;
        // this.gender = gender;
    }
}
</code></pre><p>这个例子不仅实现了可序列化的接口，而且有一个serialVersionUID的属性</p>
<pre><code>private static final long serialVersionUID = -1L;
</code></pre><p>他表示的是这个类的ID，也就是这个类如果发生了变化，然后和已经存储的序列化文件中的类不一致时也能判断出来这是同一个类；</p>
<p>例如我之前序列化的文件时候，没有  private String name;这个属性的。后来我因为需要添加了一个属性，同时也修改了里面的构造方法，所以我现在的类和序列化的不一样。当我从本地读出序列化文件时候：</p>
<pre><code>ObjectInputStream OIS = new ObjectInputStream(new FileInputStream(&quot;objext.txt&quot;));
</code></pre><p>如果我在序列化文件的时候没有加上</p>
<pre><code>pravate static final long serialVersionUID = -1l；
</code></pre><p>就会在读取的时候报错：</p>
<pre><code>java.io.InvalidClassException: com.cskaoyan.pojo.Student; local class incompatible:
</code></pre><p>这时候加上serivalVersionUID 再重新序列化一遍就好了</p>
<h3 id="transient"><a href="#transient" class="headerlink" title="transient:"></a>transient:</h3><p>在例子中还看到了：</p>
<pre><code>private transient int age;
</code></pre><p>transient：修饰成员变量，表示该变量不会被持久化。也就是不会被持久化到文件中。应该是为了可能每次都要修改，所以没有放进去；就看上面的例子</p>
<pre><code>public static void main(String[] args) throws IOException {
  Student s = new Student(&quot;剑客阿飞&quot;, 16);
  ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;object.txt&quot;));
  oos.writeObject(s); // NotSerializableException: com.cskaoyan.pojo.Student
  oos.close();

  ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;object.txt&quot;));

  try{
      Object o = ois.readObject();
      System.out.println(o);
  }catch (ClassNotFoundException e) {
      e.printStackTrace();
  }
  ois.close();
}
</code></pre><p>因为age没有序列化放在object.txt中，所以读出来的时候会得到：</p>
<pre><code>{剑客阿飞，0};//就是age的默认值；
</code></pre><p><strong><em>另外:通过序列化和反序列化可以实现拷贝对象(深拷贝)</em></strong></p>
<h2 id="星期五（7-26）"><a href="#星期五（7-26）" class="headerlink" title="星期五（7.26）"></a>星期五（7.26）</h2><h3 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h3><pre><code>打印流都不能append
打印字节流: PrintStream
打印字符流：PrintWriter
</code></pre><p>特点：</p>
<pre><code>a. 只有输出流，没有对应的输入流
b. 可以打印任意类型的数据,而且我们能看得懂和DataOutputStream不同
c. 可以自动刷新, 只有特定的方法才能自动刷新(PrintWriter: println、printf、format)
d. 字节流默认都能自动刷新，字符流只有特定的方法才能自动刷新(PrintWriter: println、printf、format)
</code></pre><p>构造方法：</p>
<pre><code>PrintStream(File file)
PrintStream(String fileName)
PrintStream(OutputStream out)
PrintStream(OutputStream out, boolean autoFlush)
</code></pre><p>方法：</p>
<pre><code>print() : 参数：基本数据类型、char[]、Object
println()
println(): 参数：基本数据类型、char[]、Object
</code></pre><h3 id="标准输出流（System-out）"><a href="#标准输出流（System-out）" class="headerlink" title="标准输出流（System.out）"></a>标准输出流（System.out）</h3><p>标准输出流：<br>    PrintStream: System.out, 默认向控制台输出数据</p>
<pre><code>// 对标准输出流包装
/*BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
bw.write(&quot;Hello, world!&quot;);
bw.newLine();
bw.close();*/

// 标准输出流重定向
System.setOut(new PrintStream(&quot;out.txt&quot;));
System.out.println(&quot;Hello, world!&quot;);
System.out.close();
</code></pre><h3 id="标准输入流（System-in）"><a href="#标准输入流（System-in）" class="headerlink" title="标准输入流（System.in）"></a>标准输入流（System.in）</h3><p>标准输入流：<br>    InputStream: System.in 默认的标准输入设备：键盘</p>
<pre><code>//包装标准输入流
/*BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
String s = br.readLine();
System.out.println(s);
br.close();*/

//重定向
System.setIn(new FileInputStream(&quot;in.txt&quot;));
Scanner scanner = new Scanner(System.in);
System.out.println(scanner.nextLine());
</code></pre><h3 id="标准错误流"><a href="#标准错误流" class="headerlink" title="标准错误流"></a>标准错误流</h3><pre><code>PrintStream: System.rrr, 默认输出设备控制台(颜色是红色的)
</code></pre><h3 id="Properties类"><a href="#Properties类" class="headerlink" title="Properties类"></a>Properties类</h3><p>Hashtable<object, object=""><br>    |– Properties<br>    概述：Properties 类表示了一个持久的属性集。Properties 可保存在流中或从流中加载。属性列表中每个键及其对应值都是一个<strong>字符串</strong>。</object,></p>
<p>构造方法：<br>    Properties()<br>    Properties(Properties defaults)</p>
<p>方法：增删改查获取数组和hashMap一样虽然不是同一个子类<br>hashMap把hashTable重做了。</p>
<h3 id="hashTable方法"><a href="#hashTable方法" class="headerlink" title="hashTable方法"></a>hashTable方法</h3><pre><code>void clear()   将此哈希表清空，使其不包含任何键。
Object clone()   创建此哈希表的浅表副本。
boolean contains(Object value)   测试此映射表中是否存在与指定值关联的键。
boolean containsKey(Object key)   测试指定对象是否为此哈希表中的键。
boolean containsValue(Object value)   如果此 Hashtable 将一个或多个键映射到此值，则返回 true。
Enumeration&lt;V&gt; elements()   返回此哈希表中的值的枚举。
Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()   返回此映射中包含的键的 Set 视图。
boolean equals(Object o)   按照 Map 接口的定义，比较指定 Object 与此 Map 是否相等。
V get(Object key)   返回指定键所映射到的值，如果此映射不包含此键的映射，则返回 null. 更确切地讲，如果此映射包含满足 (key.equals(k)) 的从键 k 到值 v 的映射，则此方法返回 v；否则，返回 null。
int hashCode()   按照 Map 接口的定义，返回此 Map 的哈希码值。
boolean isEmpty()   测试此哈希表是否没有键映射到值。
Enumeration&lt;K&gt; keys()   返回此哈希表中的键的枚举。
Set&lt;K&gt; keySet()   返回此映射中包含的键的 Set 视图。
V put(K key, V value)   将指定 key 映射到此哈希表中的指定 value。
void putAll(Map&lt;? extends K,? extends V&gt; t)   将指定映射的所有映射关系复制到此哈希表中，这些映射关系将替换此哈希表拥有的、针对当前指定映射中所有键的所有映射关系。
protected  void rehash()   增加此哈希表的容量并在内部对其进行重组，以便更有效地容纳和访问其元素。
V remove(Object key)   从哈希表中移除该键及其相应的值。
int size()   返回此哈希表中的键的数量。
String toString()   返回此 Hashtable 对象的字符串表示形式，其形式为 ASCII 字符 &quot;, &quot; （逗号加空格）分隔开的、括在括号中的一组条目。
Collection&lt;V&gt; values()   返回此映射中包含的键的 Collection 视图。
</code></pre><h3 id="Porperties自己特有方法："><a href="#Porperties自己特有方法：" class="headerlink" title="Porperties自己特有方法："></a>Porperties自己特有方法：</h3><pre><code>String getProperty(String key)
String getProperty(String key, String defaultValue)
Object setProperty(String key, String value)
Enumeration&lt;?&gt; propertyNames()  // 键
Set&lt;String&gt; stringPropertyNames()
</code></pre><h3 id="和流相关的一些方法："><a href="#和流相关的一些方法：" class="headerlink" title="和流相关的一些方法："></a>和流相关的一些方法：</h3><pre><code>//输出
void store(Writer writer, String comments)
void store(OutputStream out, String comments)
void storeToXML(OutputStream os, String comment)
//输入
void load(InputStream inStream)
void load(Reader reader)
void loadFromXML(InputStream in)
</code></pre><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>1：要想说线程，首先必须得聊聊进程，因为线程是依赖于进程存在的。<br>2：那么，什么是进程呢?通过任务管理器我们就可以看到进程的存在。</p>
<pre><code>给出一个概念：进程就是正在运行的程序，是系统进行资源分配和调用的独立单位。每一个进程都有它自己的内存空间和系统资源。
</code></pre><p>3：多进程有什么意义呢?</p>
<pre><code>单进程计算机只能做一件事情。而我们现在的计算机都可以一边玩游戏(游戏进程),一边听音乐(音乐进程)，所以我们常见的操作系统都是多进程操作系统。比如：Windows，Mac和Linux等，能在同一个时间段内执行多个任务。
对于单核计算机来讲，游戏进程和音乐进程是同时运行的吗?不是。
因为CPU在某个时间点上只能做一件事情，计算机是在游戏进程和音乐进程间做着频繁切换，且切换速度很快，所以，我们感觉游戏和音乐在同时进行，其实并不是同时执行的。
多进程的作用不是提高执行速度，而是提高CPU的使用率。
</code></pre><p>4：那么什么又是线程呢?</p>
<pre><code>在一个进程内部又可以执行多个任务，而这每一个任务我们就可以看成是一个线程。线程是程序中单个顺序的控制流，是程序使用CPU的基本单位。
</code></pre><p>5：多线程有什么意义呢？</p>
<pre><code>多线程的作用不是提高执行速度，而是为了提高应用程序的使用率。
而多线程却给了我们一个错觉：让我们认为多个线程是并发执行的。其实不是。
因为多个线程共享同一个进程的资源(堆内存和方法区)，但是栈内存是独立的，一个线程一个栈。所以他们仍然是在抢CPU的资源执行。一个时间点上只有能有一个线程执行。而且谁抢到，这个不一定，所以，造成了线程运行的随机性。
</code></pre><p>6：那么什么又是并发呢？</p>
<pre><code>大家注意两个词汇的区别：并发和并行。
前者是逻辑上同时发生，指在某一个时间内同时运行多个程序。
后者是物理上同时发生，指在某一个时间点同时运行多个程序。
那么，我们能不能实现真正意义上的并发呢，是可以的，多个CPU就可以实现，不过你得知道如何调度和控制它们。
</code></pre><h3 id="JAVA程序的运行原理"><a href="#JAVA程序的运行原理" class="headerlink" title="JAVA程序的运行原理"></a>JAVA程序的运行原理</h3><p>Java命令会启动JVM，即启动了一个进程<br>(JVM 就是一个进程)<br>该进程会启动一个主线程，然后主线程调用某个类的main方法，所以main方法都是运行在主线程里。（之前我们写的基本都是单线程程序）</p>
<p>思考 JVM是单线程还是多线程<br>几个JVM？ 每个Java进程 分配一jvm个实例<br>JVM是多线程的，至少会创建一个main线程<br>和 一个GC线程。<br>Java 字节码 解释器。管理内存。</p>
<h3 id="如何实现多线程"><a href="#如何实现多线程" class="headerlink" title="如何实现多线程"></a>如何实现多线程</h3><h3 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h3><pre><code>a.继承thread类
b.重写子类的run方法
c.创建子类的对象
d.启动线程start()
</code></pre><p>//自己写一个类继承Thread类</p>
<pre><code>public class MyThread extends Thread{
  public MyThread() {
      super();
  }
  public MyThread(String name) {
      super(name);
  }
  @Override
  public void run() {
      // System.out.println(&quot;线程启动了&quot;);
      for (int i = 1; i &lt;= 100; i++) {
          System.out.println(getName() + &quot;: &quot; + i);
      }
  }
}
//然后在创建对象start线程
public static void main(String[] args) {
  MyThread mt = new MyThread();
  mt.start();//启动
}
</code></pre><p>几个小问题：<br>为什么要重写run()方法？<br>    run()里面的代码是线程要执行的代码(任务)<br>启动线程使用的是那个方法？<br>    start()<br>同一个线程能不能多次启动？<br>    不能，如果启动多次会报 IllegalThreadStateException，线程运行完会自动死亡<br>run()和start()方法的区别<br>    run(): 封装的是线程要执行的代码, 执行调用run()方法是普通的方法调用，不会启动新线程。<br>    start(): 启动一个新线程，该线程会执行run()里面的代码</p>
<h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h3><pre><code>public class Thread extends Object implements Runnable
</code></pre><p>方法：<br>    long getId()<br>    String getName()<br>    void setName(String name)<br>    public static Thread currentThread() 获取当前线程<br>    int getPriority()<br>    void setPriority(int newPriority)</p>
<h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><pre><code>public static final int MAX_PRIORITY 10
public static final int MIN_PRIORITY 1
public static final int NORM_PRIORITY 5
</code></pre><p>构造方法：<br>    Thread(String name)<br>    Thread(Runnable target) 分配新的 Thread 对象。<br>    Thread(Runnable target, String name) 配新的 Thread 对象。</p>
<p>问题：如何获取main方法所在线程的名字？<br>    Thread thread = Thread.currentThread();<br>    thread.getName() //main主线程</p>
<p>线程调度模型：<br>    分时调度模型：平均分配<br>    抢占式调度模型：不公平（JAVA的线程调度模式）</p>
<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><pre><code>a.创建一个类，实现Runable接口
b.重写run()方法
c.创建对象
c.创建thread对象，把之前创建的对象作为参数传递
d.启动线程start();
</code></pre><p>//方法二创建线程</p>
<pre><code>//实现Runnable接口的类
public class MyRunnable implements Runnable {
  @Override
  public void run() {
    for (int i = 0; i &lt; 100; i++) {
        System.out.println(Thread.currentThread().getName() + &quot;: &quot; + i);
    }
  }
}
public static void main(String[] args) {
  Runnable mr = new MyRunnable();
  Thread thread = new Thread(mr);
  thread.start();
}
</code></pre><p>两个问题：<br>1.为什么可以有两种创建Thread的方法？<br>第一种方法，直接继承Thread类，重写了run方法，我们知道run方法是启动线程执行的方法。<br>在Thread类中的方法如下：</p>
<pre><code>public void run() {
  if (target != null) {
      target.run();
  }
}
</code></pre><p>看起来没什么用这个target 如果为null就是一个空函数，继承Thread类实现run方法来创建启动一个线程肯定没毛病。那么看看这个target到底是什么</p>
<pre><code>/* What will be run. */
private Runnable target;
</code></pre><p> 然后我发现里里面有个init()方法是Thread构造函数中调用的方法：</p>
<pre><code> public Thread(Runnable target) {
    init(null, target, &quot;Thread-&quot; + nextThreadNum(), 0);
}
</code></pre><p>这个构造方法对应的就是方法二创建线程的过程，传入一个实现Runnable接口的子类对象。然后再来看看这个init怎么用的</p>
<pre><code>  private void init(ThreadGroup g, Runnable target, String name,
                  long stackSize, AccessControlContext acc,
                  boolean inheritThreadLocals) {
    if (name == null) {
        throw new NullPointerException(&quot;name cannot be null&quot;);
    }
    this.name = name;
    Thread parent = currentThread();
    SecurityManager security = System.getSecurityManager();
    if (g == null) {
        /* Determine if it&apos;s an applet or not */
        /* If there is a security manager, ask the security manager
           what to do. */
        if (security != null) {
            g = security.getThreadGroup();
        }

        /* If the security doesn&apos;t have a strong opinion of the matter
           use the parent thread group. */
        if (g == null) {
            g = parent.getThreadGroup();
        }
    }
    /* checkAccess regardless of whether or not threadgroup is
       explicitly passed in. */
    g.checkAccess();
    /*
     * Do we have the required permissions?
     */
    if (security != null) {
        if (isCCLOverridden(getClass())) {
            security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);
        }
    }
    g.addUnstarted();
    this.group = g;
    this.daemon = parent.isDaemon();
    this.priority = parent.getPriority();
    if (security == null || isCCLOverridden(parent.getClass()))
        this.contextClassLoader = parent.getContextClassLoader();
    else
        this.contextClassLoader = parent.contextClassLoader;
    this.inheritedAccessControlContext =
            acc != null ? acc : AccessController.getContext();
    //这句才是重点
    this.target = target;

    setPriority(priority);
    if (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != null)
        this.inheritableThreadLocals =
            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);
    /* Stash the specified stack size in case the VM cares */
    this.stackSize = stackSize;
    /* Set thread ID */
    tid = nextThreadID();
}
</code></pre><p>其中有一句代码</p>
<pre><code>this.target = target;
</code></pre><p>就把创建的target传进来给了Thread对象。按照Thread方法可知，就能执行target.run()方法，那么也是可以启动线程的。所以两种方法都能run。</p>
<p><strong>注意：</strong>这个线程初始化的代码我觉得非常重要。对于理解多线程是非常重要的，但是目前还有很多东西不了解。所以还有很多东西还要学习。</p>
<p>2.哪种方法更好<br>很明显方法二更好</p>
<p>方式一的缺陷<br>如果某个类已经有父类，则无法再继承Thread类</p>
<p>方式二的优点<br>解决了单继承的局限性<br>还有一个优点，便于多线程共享数据<br><strong>将线程和任务解耦</strong><br>方法二的实现Runable的类就能看成是一个任务。这样就能把任务和线程分开，自己负责自己的领域</p>
<h3 id="线程的控制"><a href="#线程的控制" class="headerlink" title="线程的控制"></a>线程的控制</h3><h3 id="void-sleep-线程休眠：使当前线程休眠"><a href="#void-sleep-线程休眠：使当前线程休眠" class="headerlink" title="void sleep() 线程休眠：使当前线程休眠"></a>void sleep() 线程休眠：使当前线程休眠</h3><pre><code>static void sleep(long millis)
static void sleep(long millis, int nanos) 可以精确到纳秒级别
</code></pre><h3 id="void-join"><a href="#void-join" class="headerlink" title="void join()"></a>void join()</h3><pre><code>当前线程等待调用join()方法的线程执行完毕再执行
void join(long millis) 指定等待期限
void join(long millis, int nanos)
</code></pre><p>例子：学习在睡觉前执行</p>
<pre><code>//JoinThread.java
public class JoinThread extends Thread {
  private Thread first;
  public JoinThread(Thread t) {
    super();
    this.first = t;
  }
  public JoinThread(String name, Thread t) {
    super(name);
    this.first = t;
  }
  @Override
  public void run() {
    if(first != null) {
      try{
        first.join();//先执行
      }catch(InterruptedException e) {
        e.printStackTrace();
      }
    }
  }
}
//demo
public static void main(String[] args) {
  Thread t1 = new JoinTread(&quot;学习&quot;，null);
  Thread t2 = new JoinTread(&quot;睡觉&quot;，t1);
  t1.start();
  t2.start();
}
</code></pre><h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><p>放弃当前时间片，重新加入抢夺时间片的行列中</p>
<pre><code>void join()  等待该线程终止。
void join(long millis)  等待该线程终止的时间最长为 millis 毫秒。
</code></pre><h3 id="setDamon"><a href="#setDamon" class="headerlink" title="setDamon"></a>setDamon</h3><pre><code>void setDaemon(boolean on)将该线程标记为守护线程或用户线程。
</code></pre><p>守护线程就是。这个线程被标记为守护线程之后，他保护的线程死亡他也跟着死亡看例子</p>
<pre><code>//DaemonThread.java
public class DaemonThread extends Thread {
  private Thread t;
  public DaemonThread(Thread t) {
      super();
      this.t = t;
  }
  public DaemonThread(String name, Thread t) {
      super(name);
      this.t = t;
  }
  @Override
  public void run() {
    if (t != null) {
        t.setDaemon(true);
    }
    for (int i = 0; i &lt; 100; i++) {
      System.out.println(getName() + &quot;: &quot; + i);
      try {
          Thread.sleep(102);
      } catch (InterruptedException e) {
          e.printStackTrace();
      }
    }
  }
}
//t2 为 t1的守卫线程
public class DaemonDemo1 {
  public static void main(String[] args) throws InterruptedException {
    Thread t2 = new DaemonThread(&quot;Henson_z&quot;, null);
    Thread t1 = new DaemonThread(&quot;刘亦菲&quot;, t2);
    t1.start();
    Thread.sleep(1000);//有延迟才能看得出t1停了 t2会停
    t2.start();
    System.out.println(&quot;main end&quot;);
  }
}
</code></pre><p><strong><em>问题：这样做的目的是什么？为什么有这个daemon方法</em></strong></p>
<h3 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h3><p>void interrupt() 中断线程。</p>
<h3 id="线程的生命周期（必会）"><a href="#线程的生命周期（必会）" class="headerlink" title="线程的生命周期（必会）"></a>线程的生命周期（必会）</h3><p>新建</p>
<pre><code>创建线程对象
</code></pre><p>就绪  start() 之后  sleep()睡醒之后 yield()之后</p>
<pre><code>有执行资格，等待cpu调度
</code></pre><p>运行</p>
<pre><code>取得执行权，开始执行
</code></pre><p>阻塞：</p>
<pre><code>无执行资格，无执行权
</code></pre><p>死亡</p>
<pre><code>执行完毕，等待垃圾回收
</code></pre><h2 id="星期六（7-27）"><a href="#星期六（7-27）" class="headerlink" title="星期六（7.27）"></a>星期六（7.27）</h2><p>由一个问题引出的线程安全的问题<br>练习：某电影院正在上映《哪吒》，共有100张票。它有三个售票窗口正在售票<br>第一种创建线程的写法：</p>
<pre><code>public class MyThread extends Thread {
  private static int tickets = 100;//需要设置成静态的变量需要进程共享
  public MyThread() {
    super();
  }
  public MyThread(String name) {
    super(name);
  }
  @Override
  public void run() {
    while(tickets &gt; 0) {
      tickets--;
      System.out.println(getName() + &quot;: 售出了一张票，还剩&quot; + tickets + &quot;张票&quot;);
    }
  }
}
//main
Thread t1 = new MyThread(&quot;窗口1&quot;);
Thread t2 = new MyThread(&quot;窗口2&quot;);
Thread t3 = new MyThread(&quot;窗口3&quot;);

t1.start();
t2.start();
t3.start();
</code></pre><p>//第二种写法实现卖票</p>
<pre><code>public class MyRunnable implements Runnable {
  private int tickets = 100;
  @Override
  public void run() {
    while(tickets &gt; 0) {
      ticket--;
      System.out.println(Thread.currentThread().getName() + &quot;: 售出了一张票，还剩&quot; + tickets + &quot;张&quot;);
    }
  }
}

//main
public static void main(String[] args) {
  Runnable runnable = new MyRunnable();
  Thread t1 = new Thread(&quot;窗口1&quot;,runnable);
  Thread t2 = new Thread(&quot;窗口2&quot;,runnable);
  Thread t3 = new Thread(&quot;窗口3&quot;,runnable);
  t1.start();
  t2.start();
  t3.start();
}
</code></pre><p><strong>两种方法比较，发现第二种方法不仅不需要设置静态的变量，而且他有一个很明显的优点，他实现了任务和线程的解耦，一个任务多个线程同时完成。而第一种方法，需要去创建三个独立的线程去共享数据，而且这个数据是静态的才能共享就很蠢。</strong><br><strong><em>注意一点：任务和线程的解耦非常重要</em></strong></p>
<p>注意：这里有可能看到控制台打印的内容不是按顺序的：</p>
<pre><code>窗口3: 售出了一张票，还剩1张票
窗口3: 售出了一张票，还剩0张票
窗口1: 售出了一张票，还剩29张票
窗口2: 售出了一张票，还剩30张票
</code></pre><p><strong>但是</strong>这并不能代表出现了线程安全的问题，因为这是多线程的程序，编译器在执行的时候发生了<strong>指令重排序</strong>的功能。所以多线程的程序不能用debug来调试，因为指令执行顺序是未知的。只有出现了同时卖出了多张相同的票例如：</p>
<pre><code>窗口3: 售出了一张票，还剩1张票
窗口2: 售出了一张票，还剩1张票
窗口1: 售出了一张票，还剩30张票
窗口2: 售出了一张票，还剩30张票
</code></pre><p>这才能证明发生了线程安全的问题。接下来就要去讨论下线程安全的问题；</p>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><h3 id="线程安全问题出现的原因"><a href="#线程安全问题出现的原因" class="headerlink" title="线程安全问题出现的原因"></a>线程安全问题出现的原因</h3><p>CPU缓存：可见性，一个线程修改了共享变量，另外的线程必须马上知道<br>编译器：指令重排序，为了更好利用CPU<br>CPU原子性操作：一组CPU指令，要么都被执行，要么都不执行不能中断。</p>
<p>回到之前的问题：</p>
<pre><code>实现多个线程抢电影票功能
</code></pre><p>解决线程安全的办法：</p>
<h3 id="方法1：同步代码块：（锁）"><a href="#方法1：同步代码块：（锁）" class="headerlink" title="方法1：同步代码块：（锁）"></a>方法1：同步代码块：（锁）</h3><p>Synchronized(对象){  （对象就是锁，同步代码块开始时，上锁）<br>   对象共享资源的操作<br>}   同步代码块结束时，释放锁</p>
<pre><code>public class SyncDemo {
  public static void main(String[] args) {
    Runnable runnable = new Runnable() {
      int tickets = 100;
      Object lock = new Object();
      @Override
      public void run() {
        //这样只能由一个进程执行run，上锁放在while外面其他人根本进不去循环
        /*synchronized (lock) {
          while (tickets &gt; 0) {
            try {
                Thread.sleep(99);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            tickets--;
            System.out.println(Thread.currentThread().getName() + &quot;: 售出了一张票，还剩&quot; + tickets + &quot;张&quot;);
          }
        }*/
        while (true) {
          // 窗口一、窗口二
          synchronized (lock) {
            if (tickets &gt; 0) {
              try {
                  Thread.sleep(99);
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
              tickets--;
              System.out.println(Thread.currentThread().getName() + &quot;: 售出了一张票，还剩&quot; + tickets + &quot;张&quot;);
            } else {
                break;
            }
          }
        }
      }
    };
    Thread t1 = new Thread(runnable, &quot;窗口一&quot;);
    Thread t2 = new Thread(runnable, &quot;窗口二&quot;);
    Thread t3 = new Thread(runnable, &quot;窗口三&quot;);
    t1.start();
    t2.start();
    t3.start();
  }
}
</code></pre><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><p>比下面的注意事项重要的多，这里有一个问题就是为什么在size–前面加了一个100毫秒的延迟，这就是为了表示一下同步是只有一个进去的，如果不加会发现卖票的只有一个窗口，并没有其他窗口，这不是线程安全的问题。这是因为<strong>运算速度太快了根本没表现出来</strong>，这里加个延迟size–把这个程序的速度放慢，他们才会出现强占时间片的可能，因为速度太快，一个时间片就搞完了。那肯定是测试不出来的。或者把票改成10000张，也能看出效果。所以这里要注意。一定要有这种意识。</p>
<p>注意事项：<br>    锁可以是任意对象<br>    不同线程的锁对象必须是同一个对象<br>    <strong>锁的释放对同一把锁的获取是可见的。</strong></p>
<p>同步的总结：</p>
<pre><code>同步：只有一个线程可以操作共享数据 (互斥的)
优点：解决了多线程的安全性问题
缺点：效率低
</code></pre><h3 id="方法2：同步方法："><a href="#方法2：同步方法：" class="headerlink" title="方法2：同步方法："></a>方法2：同步方法：</h3><p>当同步代码块表示一个方法时，就可以把同步代码块升级成同步方法，也就是方法从第一句到最后一句都需要上锁<br>看这个例子：</p>
<pre><code>public class Calc {
  static int value;
  private Object lock = new Object();
  public void addOne() {
    if(value % 2 == 0) {
      // synchronized (lock) {
      // synchronized (this) {
      synchronized (Calc.class) {
          value++;
      }
    } else {
      add1();
    }
  }
  private static synchronized void add1() { // 一进方法就上锁，结束方法时才释放锁
    value++;
  }
  public int getValue() {
    return value;
  }
}
public class SyncDemo2 {
  public static void main(String[] args) throws InterruptedException {
    Calc calc = new Calc();
    Runnable runnable = new Runnable() {
      @Override
      public void run() {
        for (int i = 0; i &lt; 10000; i++) {
           calc.addOne();
        }
      }
    };
    Thread t1 = new Thread(runnable);
    Thread t2 = new Thread(runnable);
    t1.start();
    t2.start();
    t1.join();
    t2.join();
    System.out.println(calc.getValue()); // 20000
  }
}
</code></pre><p>这个例子就想说明以下问题：<br>1.同步方法的锁对象是什么呢？ this对象<br>2.同步静态方法锁对象是什么呢？  Class clazz = getClass();  字节码文件对象 Calc.class<br>3.这里addOne使用了两种方法来加，一个是在addOne 一个是add1 ,addOne在++的地方上了锁。add1是一个同步方法。<br>这里就在匹配使用通一把锁解决线程安全的问题；</p>
<h3 id="方法3：Lock接口"><a href="#方法3：Lock接口" class="headerlink" title="方法3：Lock接口"></a>方法3：Lock接口</h3><p>ReentrantLock子类来实现，能够控制开锁和关锁的时间。<br>public class ReentrantLockextends Objectimplements Lock, Serializable</p>
<pre><code>public class Calc {
  int value;
  Lock lock = new ReentrantLock();
  public void addOne() {
    lock.lock();
    value++;
    lock.unlock();
  }
  public int getValue() {
    return value;
  }
}
</code></pre><h3 id="同步产生的问题—死锁"><a href="#同步产生的问题—死锁" class="headerlink" title="同步产生的问题—死锁"></a>同步产生的问题—死锁</h3><p>模拟转账业务<br>A -&gt; B 转账<br>B- &gt; A 转账</p>
<p>可能会发生死锁</p>
<p>死锁问题：一组线程争夺资源的时候，可能出现相互等待的现象<br>在转账业务中出现死锁，相互之间等待获取对方的锁而一直无限等待下去</p>
<pre><code>a. 一次性获取所有的资源
b. 释放占有的资源
c. 按照一定的顺序申请资源
</code></pre><p>具体做法由下来解决；</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/21/Java总结（四）下/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王邸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路要坚持">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/21/Java总结（四）下/" itemprop="url">Java总结（四）下</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-21T23:27:37+08:00">
                2019-07-21
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/07/21/Java总结（四）下/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/07/21/Java总结（四）下/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>接上一篇，上一篇我们总结了：冒泡，插入，希尔，选择，快排，归并排序。这一篇介绍的主要内容是堆和堆排序应用，二分法，以及二分法的变形，以及hashSet,treeSet集合的知识，以及一些还没学习的知识,红黑树，动态规划等等。。</p>
<h2 id="星期五7-19"><a href="#星期五7-19" class="headerlink" title="星期五7.19"></a>星期五7.19</h2><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>就是一个完全二叉树，分为大顶堆小顶堆，<br>注意二叉搜索树不一定是完全二叉树哦；</p>
<h3 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h3><pre><code>public class Heap {
    //属性
    private int[] elements;
    private int size;

    //构造方法
    public Heap(){
        elements = new int[10]; //0的位置不存元素
    }

    //方法

    /**
     * 添加一个元素，先把元素放在末尾然后在判断是否需要往上移动
     * 只用比较该结点和父亲结点，然后再和父亲的父亲比较
     * 假设是大根堆
     * @param value
     * @return
     */
    public boolean add(int value) {
        if(size &gt; elements.length){
            return false;
        }
        size++;
        elements[size] = value;
        // 判断是否需要移动
        int i = size;
        //从下往上进行比较
        while(i &gt; 1) {  //根节点是1 只有大于1才能比较根节点和子结点
            int parent = i/2;
            //短路与这个要放前面
            if(parent &gt; 0 &amp;&amp; elements[i] &gt; elements[parent]) {
                swap(elements,i,parent);
            }
            i = parent;
        }
        return true;
    }

    /**
     * remove只能remove根节点，
     * 然后把最最后一个元素放到堆顶的位置。再从新构造一个堆
     * 这时候需要从上到下进行调整；先从交换的结点开始向下调整
     * @return
     */
    public boolean remove() {
        if(size == 0) return false;
        //交换头节点和最后一个元素的结点
        swap(elements,1,size); //这里size就是表示最后一个数
        size--;//最后一个元素已经出局
        //然后从上到下调整
        //i的左孩子 2*i 右孩子2*i+1;
        int i = 1;
        while(i &lt; size) {
            int left = 2*i;
            int right = 2*i+1;
            int maxIndex = i;
            //先比较左边再比较右边 没有先后顺序
            if(left &lt;= size &amp;&amp; elements[maxIndex] &lt; elements[left]) {
                maxIndex = left;
            }
            if(right &lt;= size &amp;&amp; elements[maxIndex] &lt; elements[right]) {
                maxIndex = right;
            }
            if(maxIndex == i) break; //不用调了
            //交换元素
            swap(elements,maxIndex,i);
            i = maxIndex;
        }
        return true;
    }
}
</code></pre><p>堆的应用：<br>堆排序<br>  a.先进行建堆操作<br>    从第一个非叶子结点开始向下进行建堆操作，一直循环到根节点<br>  b.开始排序<br>    把根节点和最后一个无序元素交换<br>  c.重新构造成一个堆从上到下调整</p>
<pre><code>public class HeapSort {

    public static void sort(int[] arr) {
        //首先进行建堆的过程
        buildHeap(arr);
        //开始排序，把第一个数和最后一个数交换然后再重新调整堆

        int i = 0;
        while(i &lt; arr.length-1){ //最后一次就是两个元素比较吧
            int temp = arr[0];
            arr[0] = arr[arr.length-1-i];
            arr[arr.length-1-i] = temp;
            heapify(arr,0,arr.length-1-i);
            System.out.println(Arrays.toString(arr));
            i++;
        }

    }

    /**
     * 建堆过程
     * @param arr
     */
    private static void buildHeap(int[] arr) {
        // 建堆过程从第一个非叶子结点开始。因为下标从0开始
        // 因为parent(i) = (i - 1)/2;
        //所以第一个非叶子结点就是 (arr.len-2)/2

        for (int i = (arr.length-2)/2; i &gt;=0; i--) {
            heapify(arr, i, arr.length);
        }
    }

    /**
     * 校对是否是堆
     * @param arr
     * @param i
     * @param length
     */
    private static void heapify(int[] arr, int i, int length) {
        while(i &lt; length) {
            int maxIndex = i;
            int left = 2*i+1;
            int right = 2*i+2;
            if(left &lt; length &amp;&amp; arr[left] &gt; arr[maxIndex]) { //left &lt; length防止下标越界 而且必须要放前面 不然下标越界
              maxIndex = left;
            }
            if(right &lt; length &amp;&amp; arr[right] &gt; arr[maxIndex]) {
                maxIndex = right;
            }
            if(maxIndex == i) break;//如果不用换就break;
            // 交换两个元素；
            int temp = arr[i];
            arr[i] = arr[maxIndex];
            arr[maxIndex] = temp;

            i = maxIndex;//对孩子也比较
        }
    }

    public static void main(String[] args) {
        int[] arr = {5, 1, 2, 9, 0, 8, 7, 6, 4, 3};
        System.out.println(Arrays.toString(arr));
        System.out.println(&quot;------------------------------&quot;);
        sort(arr);
    }
}
</code></pre><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>算法很简单但是变种却很有趣：<br>最原始的算法：</p>
<pre><code>public static int search(int[] arr, int value) {
    // 循环
    if (arr == null || arr.length == 0) return -1;
    int low = 0;
    int high = arr.length - 1;
    while (low &lt;= high) {
        int mid = low + ((high - low) &gt;&gt; 1);
        if (arr[mid] &lt; value) {
            low = mid + 1;
        } else if (arr[mid] &gt; value) {
            high = mid - 1;
        } else {
            return mid;
        }
    }
    return -1;
}
</code></pre><h3 id="二分查找的变种"><a href="#二分查找的变种" class="headerlink" title="二分查找的变种"></a>二分查找的变种</h3><p>查找第一个相等的元素</p>
<p>就在while里面多加一个条件就好了</p>
<pre><code>while (low &lt;= high) {
    int mid = low + ((high - low) &gt;&gt; 1);
    if (arr[mid] &lt; value) {
      low = mid + 1;
    } else if (arr[mid] &gt; value) {
      high = mid - 1;
    } else {
      if(mid == 0 || arr[mid-1] &lt; value) {
        return mid;
      }
      high = mid-1; //其他情况把相等看成大于
    }
}
</code></pre><p>查找最后一个相等的元素<br>最后一个相等的元素有两种情况：第一种，这个数就是最后一个数，或者后面的数比他大</p>
<pre><code>while (low &lt;= high) {
   int mid = low + ((high - low) &gt;&gt; 1);
   if (arr[mid] &lt; key) {
       low = mid + 1;
   } else if (arr[mid] &gt; key) {
       high = mid - 1;
   } else {
       if (mid == arr.length - 1 || arr[mid + 1] &gt; key) {
           return mid;
       }
       //找到这个数但是不是最后一个
       low = mid + 1; //找到了但是不能证明是最后一个所以还要向后找
   }
}
</code></pre><p>查找最后一个小于等于的元素<br>如果找到小于等于的数，然后去判断是否是最后一个：<br>要么是最后一个元素，要么后一个元素比他大</p>
<pre><code>while (low &lt;= high) {
    int mid = low + ((high - low) &gt;&gt; 1);
    if (arr[mid] &lt;= key) {
        if (mid == arr.length - 1 || arr[mid + 1] &gt; key) {  //如果是最后一个或者下一个数大于value，就确定是最后一个小于等于value的值
            return mid;
        }
        low = mid + 1;
    } else {
        high = mid - 1;
    }
}

查找第一个大于等于的元素

while (low &lt;= high) {
    int mid = low + ((high - low) &gt;&gt; 1);
    if (arr[mid] &lt; key) {
        low = mid + 1;
    } else {
        if (mid == 0 || arr[mid - 1] &lt; key) { //如果是第一个，或者前一个数小于value就能证明mid就是要找的数
            return mid;
        }
        high = mid - 1;
    }
}
</code></pre><h2 id="星期六7-20"><a href="#星期六7-20" class="headerlink" title="星期六7.20"></a>星期六7.20</h2><p>Collection:<br>  |– List：可以包含重复元素的有序集合.<br>    |– ArrayList: 底层是数组, 增删慢, 查找快, 线程不安全, 效率高。<br>    |– LinkedList 底层是链表, 增删快, 查找慢, 线程不安全, 效率高。<br>    |– Vector 底层是数组, 增删慢, 查找块, 线程安全, 效率低。<br>  |– Set 不可以包含重复元素的集合(可以有序，也可以无序)<br>    |– HashSet 不保证迭代顺序, 底层是HashMap, 元素的唯一性依赖于存储对象的 equals(), hashCode();<br>      |– LinkedHashSet 迭代顺序和插入的顺序一致, 底层是HashMap和链表, HashMap保证元素的唯一性，链表保证迭代的有序性。<br>    |– TreeSet 元素是从小到大排序的。底层是TreeMap, TreeMap的底层是红黑树。如果构造方法没有传递比较器，就要求元素Comparable接口。</p>
<h3 id="HashSet-存储是无序的"><a href="#HashSet-存储是无序的" class="headerlink" title="HashSet:存储是无序的"></a>HashSet:存储是无序的</h3><p>不保证 set 的迭代顺序<br>特别是它不保证该顺序恒久不变。<br>HashSet如何保证元素唯一性</p>
<pre><code>底层数据结构是哈希表(元素是链表的数组)
哈希表依赖于哈希值存储
添加功能底层依赖两个方法：
int hashCode()
boolean equals(Object obj)
</code></pre><p>所以在添加元素之后，修改了元素的属性值，contains就会找不到元素。而出现false;虽然属性名没有变但是属性变了也不行。看下面源码：contains方法调用了map的containsKey方法</p>
<pre><code>//HashSet.java
public boolean contains(Object o) {
    return map.containsKey(o);
}

//HashMap.java
public boolean containsKey(Object key) {
    return getNode(hash(key), key) != null;
}
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
}

public final int hashCode() {
    return Objects.hashCode(key) ^ Objects.hashCode(value);
}

final Node&lt;K,V&gt; getNode(int hash, Object key) {
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;
    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
        (first = tab[(n - 1) &amp; hash]) != null) {
        if (first.hash == hash &amp;&amp; // always check first node
            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))
            return first;
        if ((e = first.next) != null) {
            if (first instanceof TreeNode)
                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);
            do {
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    return e;
            } while ((e = e.next) != null);
        }
    }
    return null;
}
</code></pre><h3 id="TreeSet-这是有序的（如何确定排序的规则？）"><a href="#TreeSet-这是有序的（如何确定排序的规则？）" class="headerlink" title="TreeSet:这是有序的（如何确定排序的规则？）"></a>TreeSet:这是有序的（如何确定排序的规则？）</h3><p>使用元素的自然顺序对元素进行排序需要实现comparable接口</p>
<p>或者根据创建 set 时提供的 Comparator 进行排序<br>具体取决于使用的构造方法。看下面例子：输入五个学生进行排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public class HomeWork3 &#123;</div><div class="line">    public static void main(String[] args) &#123;</div></pre></td></tr></table></figure></p>
<p>下面是实现了comparator的匿名内部类<br>因为接口只用实现一个compare方法所以可以使用lambda表达式</p>
<pre><code>// TreeSet&lt;ScutStudent&gt; set = new TreeSet&lt;&gt;((t1, t2) -&gt; t2.total - t1.total);
</code></pre><p>正常的匿名内部类写法应该是：</p>
<pre><code>TreeSet&lt;ScutStudent&gt; set = new TreeSet&lt;&gt;(new Comparator&lt;ScutStudent&gt;() {
    @Override
    //注意如果这里总分一样需要比较其他科目的分数
    public int compare(ScutStudent t1, ScutStudent t2) {
         // 客户往往给你的主要需求，需要自己分析次要需求,只要比较结果为0就应该继续比较
        int n1 = t2.getTotalScore() - t1.getTotalScore();
        int n2 = n1 != 0 ? n1 : t2.getChinese() - t1.getChinese();
        int n3 = n2 != 0 ? n2 : t2.getMath() - t1.getMath();
        int n4 = n3 != 0 ? n3 : t2.getEnglish() - t1.getEnglish();
        int n5 = n4 != 0 ? n4 : t1.getName().compareTo(t2.getName());
        return n5;
    }
});
Scanner scan = new Scanner(System.in);
System.out.println(&quot;请输入五个学生的名字和各科成绩&quot;);
for (int i = 1; i &lt; 4; i++) {
    System.out.println(&quot;输入第 &quot;+ i +&quot; 学生的姓名&quot;);
    String name = scan.nextLine();
    System.out.println(&quot;输入第&quot;+ i +&quot;学生的语文成绩&quot;);
    int chinese = Integer.valueOf(scan.nextLine());
    System.out.println(&quot;输入第&quot;+ i +&quot;学生的数学成绩&quot;);
    int math = Integer.valueOf(scan.nextLine());
    System.out.println(&quot;输入第&quot;+ i +&quot;学生的英语成绩&quot;);
    int english = Integer.valueOf(scan.nextLine());
    ScutStudent ss = new ScutStudent(name,chinese,math,english);
    set.add(ss);
}
for (ScutStudent s : set) {
    System.out.println(s);
}
</code></pre><p>继承了 comparable 接口写法：重写 comparaTo 方法</p>
<pre><code>class ScutStudent implements Comparable{
    String name;
    int chinese;
    int math;
    int english;
    int total;

    public ScutStudent() {
    }

    public ScutStudent(String name, int chinese, int math, int english) {
        this.name = name;
        this.chinese = chinese;
        this.math = math;
        this.english = english;
        this.total = this.math + this.chinese + this.english;
    }

    @Override
    public String toString() {
        return &quot;ScutStudent{&quot; +
                &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +
                &quot;, chinese=&quot; + chinese +
                &quot;, math=&quot; + math +
                &quot;, english=&quot; + english +
                &quot;, total=&quot; + total +
                &apos;}&apos;;
    }

    @Override
    public int compareTo(Object o) {
        ScutStudent s = (ScutStudent)o;
        return s.total - this.total;
    }
}
</code></pre><h3 id="下午开会："><a href="#下午开会：" class="headerlink" title="下午开会："></a>下午开会：</h3><p>每天知道自己应做什么事情，时间管理，以下内容是否需要调整？<br>时间管理：<br>  例如星期三，星期六下午；<br>  要有自己思考的时间；<br>提前预习<br>  老师讲的自己总是不记得代码，自己去知道今天讲东西的思路，而不是copy书上代码；<br>  提前找题去做<br>上课<br>  认真互动<br>课后复习<br>  总结<br>作业<br>  中午能不能写一些代码？</p>
<p>总结：<br>  bug总结：错题本<br>  项目总结；</p>
<h3 id="冷门小总结"><a href="#冷门小总结" class="headerlink" title="冷门小总结"></a>冷门小总结</h3><p>1.如何判断string是一个数可以是一个小数</p>
<pre><code>正则：
^-?\\d+(\\.\\d+)?$
 Pattern.compile(&quot;^-?\\d+(\\.\\d+)?$&quot;);
 Pattern.mathes(&quot;^-?\\d+(\\.\\d+)?$&quot;);
</code></pre><p>2.对于一些知识点的拓展<br>红黑树，广义平衡二叉树；<br>红黑树是每个节点都带有颜色属性的二叉查找树，颜色或红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求:</p>
<pre><code>性质1. 节点是红色或黑色。
性质2. 根节点是黑色。
性质3 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
性质4. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。
</code></pre><p>3.动态规划：这个东西有点意思，之和部分状态有关，并不是所有的状态<br><a href="https://blog.csdn.net/sinat_34022298/article/details/77653693" target="_blank" rel="external">背包问题</a></p>
<p>4.测试时间的问题<br><a href="https://www.cnblogs.com/jpfss/p/9674054.html" target="_blank" rel="external">测试时间</a></p>
<pre><code>long startTime = System.nanoTime() //纳秒
long startTime = System.currentTimeMillis(); //毫秒
long endTime = System.currentTimeMillis();
System.out.println(&quot;运行时间:&quot; + (endTime - startTime) + &quot;ms&quot;);
</code></pre><p>5.注意IDEA里的绿色波浪线，可能有问题；</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/21/Java总结（四）上/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王邸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路要坚持">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/21/Java总结（四）上/" itemprop="url">Java总结（四）上</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-21T23:27:33+08:00">
                2019-07-21
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/07/21/Java总结（四）上/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/07/21/Java总结（四）上/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这周学习的是数据结构，主要还是学习代码的实现，结构的应用的实现等等。二叉排序树的增加和删除，还有一些递归操作用循环实现，最后讲了冒泡，插入，希尔，选择，快排，归并排序，以及他们的比较。</p>
<h2 id="星期一（7-15）："><a href="#星期一（7-15）：" class="headerlink" title="星期一（7.15）："></a>星期一（7.15）：</h2><p>线性表<br>顺序印象 非顺序印象</p>
<p>栈:先进后出<br>顺序印象 非顺序印象<br>栈的应用：<br>1.反转<br>2.括号匹配<br>3.浏览器history<br>4.深度优先遍历(非递归的写法需要记录走过的结点)<br>5.表达式求值<br>首先先知道前缀表达式 中缀表达式 后缀表达式<br>前缀表达式：运算符放在前面 +1*23<br>中缀表达式：运算符放中间，就是我们人类熟知的写法 1+2*3<br>后缀表达式：运算符方后面123*+</p>
<p>默认就用后缀表达式进行计算<br>这里就有两个问题：<br>1.后缀表达式如何进行计算<br>  需要把操作数入栈<br>  a.遍历字符串<br>  b.遇到操作数入栈<br>  c.遇到操作符就进行计算。从栈中取出两个数进行计算，先出栈的放后面，后出栈的放前面。再把计算结果放回到栈中。<br>  例如：123*+</p>
<pre><code>1,2,3入栈
* :则3先出栈，2后出栈进行计算 2 * 3 = 6;
6入栈，栈中元素为1,6
- :6先出栈，然后1出栈。 1 + 6 = 7；
</code></pre><p>2.如何把中缀表达式转成后缀表达式<br>  需要把运算符入栈<br>  a.遍历字符串<br>  b.遇到数字就略过<br>  c.遇到操作符如下操作：<br>      栈中没有操作符：入栈<br>      栈中有操作符：比较操作符优先级<br>        1）栈中运算符优先级大于等于当前运算符，则栈中运算符出栈，然后再比较栈中运算符和当前运算符<br>        2）栈中运算符优先级小于当前运算符,就进行入栈操作<br>  d.遍历完字符串检查栈中是否还有运算符<br>      有运算符：全部出栈</p>
<p>  可以这么想栈底的运算符优先级是很低的，栈顶优先级很高，所以出栈时越靠近操作数的运算符优先级更高</p>
<p>那么问题来了如何直接计算一个表达式：<br>（两个栈）<br>一个栈放操作数，一个栈放操作符操作步骤如下：<br>  a.遍历字符串<br>  b.遇到操作数就进操作数栈<br>  c.遇到操作符就进行如下操作<br>    栈中没有操作符：入栈<br>    栈中有操作符：比较操作符优先级<br>        1）栈中运算符优先级大于等于当前运算符，则栈中运算符出栈,从操作数栈中出数进行计算，结果放回操作数栈<br>        然后再比较栈中运算符和当前运算符<br>        2）栈中运算符优先级小于当前运算符,就进行入栈操作</p>
<p>  d.遍历完字符串，判断运算符栈是否还有元素<br>  有元素：则依次出栈进行运算操作，直到运算符栈为空<br>具体实现:</p>
<pre><code>public class HomeWork2 {
    public static void main(String[] args) {
        String s1 = &quot;2+3*10-3&quot;;
        String s2 = &quot;((1+(2*3))+10)*10&quot;; //为什么匹配全角和半角括号都可以
        String a = computeNum(s2);
        System.out.println(a);
    }

    private static String computeNum(String s1) {
        String splitArr[] = s1.split(&quot;&quot;); //一开始获取的数组
        String strArrCache[] = new String[s1.length()]; //通过合并后的数组
        List&lt;String&gt; list = new ArrayList&lt;&gt;(); //使用集合代替数组

        String scache = &quot;&quot;;   //表示合并的值
        //int index = 0;        //表示合并后数组的下标
        MyStack numStack = new MyStack();
        MyStack operStack = new MyStack();

        //方法1分成数字数组和运算符数组，但是之后就找不到位置了
        //方法2先把数字放前面然后，判断找到运算符然后移动数组发现不行
        //方法3字符串拼接 可以但是感觉不够好

        // i表示split的指针j表示strArr的指针
        for (int i = 0; i &lt; splitArr.length; i++) {
            if(splitArr[i].matches(&quot;\\d&quot;) &amp;&amp; i != splitArr.length-1){ //非最后一位是数字
                scache += splitArr[i]; //缓存字符串
            } else if(splitArr[i].matches(&quot;\\d&quot;) &amp;&amp; i == splitArr.length-1){ //最后一位是数字
                scache += splitArr[i];
                list.add(scache);
//                strArrCache[index++] = scache;

            } else if(scache != &quot;&quot;){    //这一位是非数字如果上一位是数字的缓存，就先把数字入数组，然后再把当前的符号入数组
                list.add(scache);
                list.add(splitArr[i]);
//                strArrCache[index++] = scache;
//                strArrCache[index++] = splitArr[i];

                scache  = &quot;&quot;; //清零
            } else {   //其他情况，可能是第一个左括号，右括号后面的右括号等情况
                list.add(splitArr[i]);
//                strArrCache[index++] = splitArr[i];
            }
        }

        //获取最后的数组
//        String strArr[] = new String[index];
//        for (int i = 0; i &lt; strArr.length; i++) {
//            strArr[i] = strArrCache[i];
//            System.out.println(&quot;i= &quot;+ i +&quot;  &quot; + strArr[i]+&quot; &quot;);
//        }

        //遍历字符串
//        for (int i = 0; i &lt; strArr.length; i++) {
          for(ListIterator it = list.listIterator();it.hasNext();){
//            String value = strArr[i];
            String value = (String) it.next();

            //如果是数字就入运算符栈
            if(value.matches(&quot;^\\d+&quot;)){  //判断是一个数或者多位数
                numStack.push(value);
            }
            //左括号直接入操作数栈
            if(value.matches(&quot;\\(&quot;)){
                operStack.push(value);
            }

            //如果是运算符判断：
            // 栈空入站 ，
            // 栈不空 判断运算符优先级，1）栈中的优先级大则出栈，从数栈取数进行计算
            //然后重复上面操作，直到栈中的优先级小于当前运算符则入栈
            if(value.matches(&quot;\\-|\\+|\\*|\\/|\\)&quot;)){
                if(operStack.isEmpty()){
                    operStack.push(value);
                } else if(!value.equals(&quot;)&quot;)){
                    String top = operStack.peek();//获取栈顶进行比较

                    while(compareOper(top,value) &gt; 0){ //如果是栈顶元素优先级高
                        String oper = operStack.pop(); //运算符出栈；

                        double last = Double.valueOf(numStack.pop());
                        double first = Double.valueOf(numStack.pop());
                        String result = String.valueOf(getResult(first,last,oper));
                        numStack.push(result); //结果入栈

                        if(operStack.isEmpty()){
                            break; //跳出while 在外面运算符入栈不然会报错
                        } else {
                            top = operStack.peek(); //再比较优先级
                        }
                    }
                    operStack.push(value);
                }//else if
                else {  //说明是右括号 ，直接弹运算符
                    //while 判断括号多个数
                    while(!operStack.peek().equals(&quot;(&quot;)){
                        String oper = operStack.pop(); //运算符出栈；
                        double last = Double.valueOf(numStack.pop());
                        double first = Double.valueOf(numStack.pop());
                        String result = String.valueOf(getResult(first,last,oper));
                        numStack.push(result); //结果入栈
                    }
                    operStack.pop(); //左括号出栈；
                }
            }//if 是运算符
        }//for
        //最后再判断运算符栈是否还有元素在进行计算操作
        while(!operStack.isEmpty()) {
            String oper = operStack.pop(); //运算符出栈；
            double last = Double.valueOf(numStack.pop());
            double first = Double.valueOf(numStack.pop());
            String result = String.valueOf(getResult(first,last,oper));
            numStack.push(result); //结果入栈
        }
        return numStack.pop();
    }

    private static double getResult(double first, double last, String oper) {
        double result = 0;
        switch (oper){
            case &quot;+&quot;:
                result = first + last;
                break;
            case &quot;-&quot;:
                result = first - last;
                break;
            case &quot;*&quot;:
                result = first * last;
                break;
            case &quot;/&quot;:
                result = first / last;
                break;
        }
        return result;
    }

    private static int compareOper(String top, String value) {

        if(top.equals(&quot;*&quot;)|| top.equals(&quot;/&quot;)){          //如果里面的是乘除
            return 1;
        } else if(value.equals(&quot;*&quot;)|| value.equals(&quot;/&quot;)){  //里面不是乘除，外面是乘除
            return -1;
        } else if(top.equals(&quot;(&quot;)){   //如果栈顶是左括号，运算符就入栈；
            return -1;
        }
        return 1; //说明里面是加减外面也是加减，里面优先级高
    }
}
</code></pre><p>队列:先进先出<br>队列应用场景：<br>    a. 普通队列应用场景十分有限<br>    b. 阻塞队列(BlockingQueue)<br>        enque: 当队列满了，会阻塞，等待队列不满的时候，在执行操作，并返回。<br>        deque: 当队列为空，会阻塞，等待队列不空的时候，再出队列，并返回。<br>    c. 并发队列<br>        线程安全的队列。<br>    d. 缓存<br>    e. 广度优先遍历。<br>顺序印象 非顺序印象</p>
<h2 id="星期二（7-16）："><a href="#星期二（7-16）：" class="headerlink" title="星期二（7.16）："></a>星期二（7.16）：</h2><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>今天介绍了树，当然也是学过的，但是希望当人家问你什么是树的时候，你能说出点东西来；<br>树的定义：树(Tree)是n( n&gt;=0 )个结点的有限集合。n=0就是一颗空树。<br>在任意一颗非空树中：<br>  有且仅有一个特定的称为根(root)的节点<br>  当n&gt;1的时，其余节点可分为m( m&gt;0 )个互不相交的有限集T1，T2，…, Tm，其中每一个集合本身又是一棵树，并且称之为根的子树。<br>  互不相交的有限级其实也就是子树之间没有任何相连的关系</p>
<p>在树中，还有一些基本术语：<br>  <strong>树的结点</strong>：包含一个数据元素以及若干指向其子树的分支。节点拥有的子树的数目，称之为结点的度（degree）。<br>  <strong>叶子结点</strong>：度为0的节点称为叶子，或终端节点。度不为0的结点称为非终端结点或分支节点<br>  <strong>孩子结点、双亲结点和兄弟结点</strong>：节点的子树，称为该节点的孩子（child），相应的该节点称为孩子的双亲（parent）同一个双亲的孩子之间互称兄弟（sibling）<br>  <strong>祖先结点和子孙结点</strong>节点的祖先是从根到该节点所经分支上所有的节点。以某节点为根的子树中的任意一节点都称为该结点的子孙<br>  <strong>结点的层次（Level）</strong>从根开始定义，根为第一层，根的孩子为第二层。若某节点在第l层，则其子树的根就在l+1层<br>  <strong>结点的路径</strong>从节点ni 到 nk 的路径定义为节点 n1 n2 … nk (都不在同一层)的一个序列，使得对于 1 &lt;= i &lt; k，节点 ni 是 ni+1 的父亲。这条路径的长是为该路径上边的条数，即 k-1。从每一个节点到它自己有一条长为 0 的路径。注意，在一棵树中从根到每个节点恰好存在一条路径。<br>  <strong>深度</strong>对任意节点ni，ni的深度为从根到ni 的唯一路径的长。因此，根的深度为0。<br>  <strong>高度</strong>ni 的高度是从ni到一片树叶的最长路径的长（可能不是平衡树所以长的才算高度和深度）。因此，所有树叶的高都为0。一颗树的高等于它根的高。</p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>二叉树具有以下重要特性：<br>二叉树，在第i层至多有2^(i-1)个结点（主要是在理论上使用的比较多）<br>层次为k的二叉树至多有2^k-1个结点<br>对任何一颗二叉树T，如果其终端结点数为n0 ,度为2的结点数为n2，则n0 = n2 + 1</p>
<pre><code>n0+n1+n2 = n1+2*n2+1 =&gt; n0 = n2 + 1;
</code></pre><p>具有n个结点的完全二叉树，根节点的深度为log2(n)<br>如果对一颗有n个结点的完全二叉树的节点按层序编号，则对任意一结点，i从1开始<br>1)如果i=1，则结点i是二叉树的根，无双亲；如果i &gt; 1，则其双亲parent(i)的节点：i/2<br>2)如果2i &gt; n，则结点i无左孩子（结点i为叶子结点）；否则其左孩子lchild(i)是节点 2i。<br>3)如果2i+1 &gt; n，则结点i无右孩子，否则，其右孩子rchild(i)是结点2i+1。</p>
<h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><p>二叉树的顺序映像（完全二叉树）<br>用数组来存储元素，使用了连续的存储空间来存储。这里需要有一点进行说明。因为是连续的空间，用数组作为下标。所以下标是从0开始编号的。那么对于之前二叉树的父子结点的下标需要有修正的地方。这里主要是用在堆上，因为堆就是一个完全二叉树。<br>i从0开始<br>i的左孩子结点为： 2*i+1<br>i的右孩子结点为：2*i+2<br>结点i的父亲结点为 (i-1)/2<br>二叉树的非顺序映像<br>二叉树的非顺序映像，是以链表的形式，存储数据元素以及数据元素之间的关系。但是由于数据元素的关系变得更加复杂，因此，链表结点的结构，与线性表中链表的结点有有所不同。因为线性表的是一对一的关系。而树中是一对多的关系；</p>
<h2 id="星期三（7-17）："><a href="#星期三（7-17）：" class="headerlink" title="星期三（7.17）："></a>星期三（7.17）：</h2><h3 id="二叉搜索树（二叉排序树BST）："><a href="#二叉搜索树（二叉排序树BST）：" class="headerlink" title="二叉搜索树（二叉排序树BST）："></a>二叉搜索树（二叉排序树BST）：</h3><p>  左子树结点小于根节点的值<br>  右子树结点大于根节点的值<br>  左右子树同时也是二叉搜索树</p>
<h3 id="二叉搜索树的构建"><a href="#二叉搜索树的构建" class="headerlink" title="二叉搜索树的构建"></a>二叉搜索树的构建</h3><p>  我差点忘记了这一部分的内容，这一部分是非常重要的，对于理解递归和二叉树都非常重要。BST最主要的功能当然是增删改查。以非顺序印象存储值<br>  思路：思路都是类似的，首先判断是否有根节点，然后判断一下根节点和你需要查找，添加的结点的大小，以确定去左边添加还是去右边添加，不讨论相等的情况；删除一个结点时，首先也是同样的思路去找到那个结点，然后在判断：1.是度为2的结点 2.是度为1的结点 3.是叶子结点 ，然后把第一种情况转换为第二种第三种情况；</p>
<pre><code>public class BinarySearchTree {
</code></pre><p>属性</p>
<pre><code>//属性
TreeNode root;  //表示根节点
int size;
static class TreeNode {
    TreeNode leftChild; //指向左孩子
    char val;
    TreeNode rightChild;//指向右孩子
    public TreeNode(char val) {
        this.val = val;
    }
}
</code></pre><p>构造方法</p>
<pre><code>//构造方法
public BinarySearchTree(){
}
</code></pre><p>方法：<br>添加结点：迭代的方法和循环的方法</p>
<pre><code>/**
 * 树中添加结点
 * @param c 添加的值
 * @return
 * 判断：
 *   1.空树newNode 给 root
 *   2.需要两个指针分别指向要添加的地方和添加地方的父节点
 *   最后把父节点和要添加的结点链接，需要在判断一次是在左边添加还是在右边添加
 *   3,如果遇到重复值return false不添加
 */
//使用循环
public boolean add(char c) {
    //添加的是根节点
    if(root == null){
       root = new TreeNode(c);
       return true;
    }
    TreeNode pre = null;
    TreeNode node = root;
    while(node != null) {
        int i = c - node.val; //和父节点比较谁大
        if(i &gt; 0) {    //加入的元素比父节点大
            pre = node;
            node = node.rightChild;
        } else if(i &lt; 0){ //加入的元素比父节点小
            pre = node;
            node = node.leftChild;
        } else {
            return false; //找到一样的拉闸
        }
    }
    //再判断一次pre到底指向的左子树还是右子树
    if(pre.val &gt; c) {
        size++;
        pre.leftChild = new TreeNode(c);
    } else if (pre.val &lt; c){
        size++;
        pre.rightChild = new TreeNode(c);
    } else {  //相同则取消
        return false;
    }
    return true;
}
</code></pre><p>//使用迭代</p>
<pre><code>/**
 * 递归添加元素
 * @param c
 * @return
 * 首先他自己不能递归，需要分成小的部分在哪个节点后面添加；
 * 而不是和整棵树进行比较
 * 所以需要再分一个小函数表示在哪个节点添加的元素
 * add_recursion（TreeNode node, char c）
 */
public boolean add_recursion(char c){
    int temp = size;
    root = add_recursion(root,c);
    return size &gt; temp;
}

/**
 * 这个小函数就是添加元素
 * @param node
 * @param c
 * @return
 * 三种情况：
 *   a.如果这个结点是空的，找到了要添加的位置；
 *   判断父节点和c哪个那
 *     b.父节点大：在node.left添加c
 *     c.c大：在node.right添加c
 */
private TreeNode add_recursion(TreeNode node, char c) {
    if(node == null) {
        size++;  //添加结点
        return new TreeNode(c);
    }
    int cmp = c - node.val;
    if(cmp &gt; 0) { //如果是c大
        //这里要连上，不然新加的不知道连哪里
        node.rightChild = add_recursion(node.rightChild,c);
    } else if(cmp &lt; 0) {
        node.leftChild =  add_recursion(node.leftChild,c);
    }
    //如果有相同的就不加
    return node;
}
</code></pre><p>删除结点</p>
<pre><code>/**
 * 循环实现删除
 * @param c
 * @return
 * 先判断树是否为空
 * 非空就继续
 * 找到那个要删除的结点，同样要保存父节点，有三种情况：
 * 1.该结点是度为2：把他和他前驱的值交换然后去删掉他前驱的，
 * 删前驱就变成下面两种情况
 *   2.度为1,删掉把父节点指向删掉结点的子节点
 *   3.度为0,直接删掉以除后患
 * **注意**
 * 这里不仅需要两个指针来表示要删除的结点和删除结点的父亲节点
 * 而且需要两个结点去表示删除结点的前驱结点和前驱结点的父亲的结点。
 * 然后才能把要删除的结点转化成删除他的前驱结点的过程；
 *
 */
boolean remove(char c){
    //空节点异常
    if(size == 0) {
        throw new EmptyTreeException();
    }
    //说明有结点
    TreeNode parent = null;//要删除结点的父节点
    TreeNode node = root; //要删除的结点
    //先找到那个要删除的结点
    while(node != null &amp;&amp; node.val != c) {
        int cmp = c - node.val;
        if(cmp &gt; 0){  //删除的数比父节点大
            parent = node;
            node = node.rightChild;
        } else if(cmp &lt; 0) {
            parent = node;
            node = node.leftChild;
        }
    }
    if(node == null) return false; //表示没有找到

    //找到要删除的结点
    //删除的是两个结点
    if(node.leftChild != null &amp;&amp; node.rightChild != null) {
        //去找左边的前驱交换值
        // TreeNode tn =getMaxNode(node.leftChild); 因为要获取父节点不能直接拿最大结点

        TreeNode ppNode = node; //删除结点前驱的父节点
        TreeNode pNode = node.leftChild;//删除结点的前驱
        while(pNode.rightChild != null){
            ppNode = pNode;
            pNode = pNode.rightChild;
        }
        把删除转化成删除前驱结点的过程
        node.val = pNode.val;
        parent = ppNode;
        node = pNode;
    }

    //删除的是度为1 或者 叶节点 或者删除结点的子节点
    TreeNode child = node.leftChild != null ? node.leftChild : node.rightChild;
    if(parent == null) { //要删除的根节点，parent没有赋值。可能度为1可能度为0
        root = child;
    }
    if(parent.leftChild == node) {
        parent.leftChild = child;
    }
    if(parent.rightChild == node) {
        parent.rightChild = child;
    }
    size--;
    return true;
}
</code></pre><p>//递归删除</p>
<pre><code>/**
 * 递归实现删除一个结点
 * @param c
 * @return
 * 当然也需要一个子方法来判断删除的结点
 */
boolean remove_recursion(char c){
    int tem = size;
    root = remove_recursion(root,c);
    return tem &gt; size;
}

/**
 * 需要要删除的子方法，为了判断node是否是要删除的
 * @param node
 * @param c
 * @return
 * 判断：
 *  一样的三种情况
 */
private TreeNode remove_recursion(TreeNode node, char c) {
    if(node == null) {
        return null;
    }
    int cmp = c - node.val;
    if(cmp &gt; 0) {
        node.rightChild = remove_recursion(node.rightChild,c);
    } else if(cmp &lt; 0) {
        node.leftChild = remove_recursion(node.leftChild,c);
    } else {
        //说明找到了又是三种判断；
        if(node.leftChild != null &amp;&amp; node.rightChild != null){
            //获取最大值；
            TreeNode maxOfLeft = getMaxNode(node.leftChild);
            node.val = maxOfLeft.val;
            node.leftChild = remove_recursion(node.leftChild,maxOfLeft.val);//改成对前驱删除

        } else if(node.leftChild == null &amp;&amp; node.rightChild == null){
            //叶节点
            size--;
            return null;
        } else {
            //度为1的结点
            size--;
            return node.leftChild != null ? node.leftChild : node.rightChild;
        }
    }
    return node;
}
</code></pre><p>获取树的最大最小值</p>
<pre><code>/**
 * 获取最大最小值
 * @return
 */
public char max(){
    return getMaxNode(root).val;
}
public char min(){
    return getMinNode(root).val;
}

/**
 * 获取最大值的结点就是当前结点最右边的子节点结点
 * @param tn
 */
private TreeNode getMaxNode(TreeNode tn) {
    if(tn.rightChild == null) return tn;
    return getMaxNode(tn.rightChild);
}
private TreeNode getMinNode(TreeNode tn) {
    if(tn.leftChild == null) return tn;
    return getMinNode(tn.leftChild);
}
</code></pre><p>判断是否存在</p>
<pre><code>/**
 * 判断是否有值；
 * @param c
 * @return
 */
boolean contains(char c){
    TreeNode node = root;
    if(node == null) return false;
    while(node != null) {
        int cmp = c - node.val;
        if(cmp &gt; 0) {
            node = node.rightChild;
        }else if(cmp &lt; 0) {
            node = node.leftChild;
        } else {
            return true;
        }
    }
    return false;
}
</code></pre><p>//递归判断是否存在</p>
<pre><code>/**
 * 迭代寻找是否存在
 * @param c
 * @return
 * 同样也需要一个子函数来判断root是否和c相同
 */
boolean contains_recursion(char c) {
    return contains_recursion(root,c);
}
private boolean contains_recursion(TreeNode node, char c) {
  //找不到
    if(node == null) {
        return false;
    }
    int cmp = c - node.val;
    if(cmp &gt; 0) {
        return contains_recursion(node.rightChild,c);
    } else if(cmp &lt; 0) {
        return contains_recursion(node.leftChild,c);
    } else {
        return true;
    }
}
</code></pre><p>求树的层次</p>
<pre><code>/**
 * 使用队列进行层序遍历
 * @return
 * 就是层序遍历把元素放进队列，这里需要注意的是需要去记录每一层的元素有多少个；
 */
public int depth() {
    if(root == null) return 0;
    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
    queue.add(root);//先把根节点入栈
    int deep = 0;
    while(!queue.isEmpty()){
      deep++;
      int length = queue.size();//获取每一层有几个元素入队
      for (int i = 0; i &lt; length; i++) {
          TreeNode node = queue.remove();
          if(node.leftChild != null) {
              queue.add(node.leftChild);
          }
          if(node.rightChild != null) {
              queue.add(node.rightChild);
          }
      }
    }
    return deep;
}
</code></pre><p>//求树高度</p>
<pre><code>/**
 * 递归求深度，后序遍历然后左右结点较高的+1；
 * @return
 */
public int depth_recursion(TreeNode node){
    if(node == null) {
        return 0;
    }
    int left = depth_recursion(node.leftChild);
    int right = depth_recursion(node.rightChild);
    return left &gt; right ? left+1 : right+1;
}
</code></pre><p>先序遍历：两种方法</p>
<pre><code>/**
 * 先序遍历递归
 * @param root
 */
void preOrder_recurion(TreeNode root){
    if(root == null) {
        return;
    }

    System.out.print(root.val + &quot; &quot;);
    if(root.leftChild != null) {
        preOrder(root.leftChild);
    }
    if(root.rightChild != null) {
        preOrder(root.rightChild);
    }
}
</code></pre><p>//非递归先序：<br>思路：用栈，右子树先进栈，后出栈。</p>
<pre><code>/**
 * 先序遍历使用非递归的方法：使用栈
 * 先把根节点入栈，然后判断栈是否为空，出栈。先把右子树入栈，然后再把左子树入栈。因为左子树要先出来，所以要先把右子树入栈后出来；
 * @param root
 */
 List&lt;Character&gt; PreOrder(TreeNode root) {
  List&lt;Character&gt; list = new ArrayList&lt;&gt;();
  if (root == null) return list; //最好是直接返回list以防调用空指针异常
  Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();
  stack.push(root);
  while (!stack.isEmpty()) {
      TreeNode node = stack.pop();
      list.add(node.val);
      if (node.right != null) {
          stack.push(node.right);
      }
      if (node.left != null) {
          stack.push(node.left);
      }
  }
  return list;
 }
</code></pre><p>中序遍历：三种方法</p>
<pre><code>/**
 * 中序迭代
 * @param root
 */
void inOrder_recursion(TreeNode root){
    if(root == null) {
        return;
    }
    if(root.leftChild != null) {
        inOrder(root.leftChild);
    }
    System.out.print(root.val + &quot; &quot;);
    if(root.rightChild != null) {
        inOrder(root.rightChild);
    }
}
</code></pre><p>//中序遍历非递归</p>
<pre><code>/**
 * 中序循环1：模拟栈的实现的过程使用循环：
    a.先根节点入栈判断栈是否为空，
    b.左子树全部入栈
    c.然后出栈，就是第一个元素然后再循环
 * @param root
 */
public List&lt;Character&gt; inOrder() {
  List&lt;Character&gt; list = new ArrayList&lt;&gt;();
  Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();

  if(root == null) return;
  TreeNode curr = root;
  while(curr != null &amp;&amp; !list.isEmpty()){
    //左边的的结点全部进栈
    while(curr!=null) {
      stack.push(curr);
      curr = curr.left;
    }
    //这时栈顶就是第一个结点
    curr = stack.pop();
    list.add(curr);//保存下来
    curr = curr.right;
  }
  return list;
}
</code></pre><p>//中序遍历非遍历2</p>
<pre><code>/**
 * 中序遍历循环2:
  Morris 遍历 不用栈(线索二叉树，利用左前驱右后继) 一个指针代替一个栈
  就是把根节点的前驱结点连接到根节点。在中序遍历过程中：每一个根节点都应该有前驱结点，如果前驱结点遍历过了，下一个遍历的当然就是根节点；

  1.curr = root;
  2.while(curr != null) {  //去找第一个结点
      if(curr.leftChild == null) {  //如果找到了第一个节点
          list.add(curr.val);
          curr = curr.rightChild;   //去第一个结点右边找第二个结点 或者会链接回到curr
      }
      else
          找到左子树的最大节maxNode,就是他的前驱，然后把前驱连接给他
          getMaxNode().rightChild = curr;
          curr = curr.leftChild;
  }
 * @param root
 */
  public List&lt;Character&gt; inOrder3() {
    TreeNode curr = root;
    List&lt;Character&gt; list = new ArrayList();
    if(root == null) return list;

    while(curr != null) {
      //找到第一个结点
      if(curr.leftChild ==null){
        list.add(curr.val);
        curr = curr.rightChild;
      } else {
        //当没有找到第一个结点时，找他的前驱并把前驱连接到这个结点上,为了保证左子树全部遍历完了再遍历curr结点
        TreeNode max = curr.leftChild;
        while(max.rightChild != null &amp;&amp; max.rightChild != curr) { //去找最大的结点,而且确认没有连接到curr上
          max = max.rightChild;
        }
        if(max.rightChild == null) { //确认没有连接
          max.right = curr;
          curr = curr.leftChild;//可以去左子树里面连接了，子树的前驱肯定和根节点的前驱不同
        }

        if(max.rightChild == curr) { //说明左边都遍历过了到curr结点遍历了
          list.add(curr.val);
          max.rightChild == null; //还原
          curr = curr.rightChild;
        }
      }
    }
    return list;
  }
</code></pre><p>后序遍历：两种方法</p>
<pre><code>/**
 * 后序迭代
 * @param root
 */
void postOrder_recursion(TreeNode root){
    if(root == null) {
        return;
    }
    if(root.leftChild != null) {
        postOrder(root.leftChild);
    }
    if(root.rightChild != null) {
        postOrder(root.rightChild);
    }
    System.out.print(root.val + &quot; &quot;);
}
</code></pre><p>//后序非递归</p>
<pre><code>/**
 * 后序非迭代：使用双端队列，入栈的时候就是正常的先栈顶出栈，左子树入栈，然后右子树入栈。进保存的队列时候可以头插法，最先加入的元素就会出现在最后，就相当于后序遍历；
 * @param root
 */
public List&lt;Character&gt; postOrder(){
    LinkedList&lt;Character&gt; list = new LinkedList();
    if(root == null) return list;
    Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();
    stack.push(root);
    while(!stack.isEmpty()) {
        TreeNode node= stack.pop();
        //左子树先进去后出来
        if(node.leftChild != null) {
            stack.push(node.leftChild);
        }
        if(node.rightChild != null) {
            stack.push(node.rightChild);
        }
        list.addFirst(node.val);//头插法
    }
    return list;
}
</code></pre><p>层序遍历</p>
<pre><code>/**
 * 层序；
 */
void levelOrder(TreeNode root){
    if(root == null) {
        return;
    }
    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
    queue.add(root);
    while(!queue.isEmpty()) {
        TreeNode node = queue.remove();
        System.out.print(node.val+&quot; &quot;);
        if(node.leftChild != null){
            queue.add(node.leftChild);
        }
        if(node.rightChild != null) {
            queue.add(node.rightChild);
        }
    }
}
</code></pre><p><strong>注意：这里没有调整二叉树成为一个平衡的二叉树，只是简单的讨论了一下到底应该怎么增删改查；</strong></p>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>前序，中序，后序，层序<br>顾名思义：<br>前序遍历：先遍历根节点，然后遍历左子树然后遍历右子树<br>中序遍历：有左子树先遍历左子树，然后遍历根节点最后遍历有节点<br>后序遍历：先遍历左子树，然后遍历右子树最后遍历根节点；<br>层序遍历：一层一层的遍历，从根节点进行遍历</p>
<h3 id="构建二叉树"><a href="#构建二叉树" class="headerlink" title="构建二叉树"></a>构建二叉树</h3><p>如何构建二叉树？<br>1）前序和中序构建二叉树（可以）<br>2）中序和后序构建二叉树（可以）<br>3）前序和后序构建二叉树（不可以）<br>问题1：为什么前序和后序不能构建唯一的二叉树？<br>首先需要了解构建二叉树的原理：<br>这也是一个遍历的过程，首先你要找到根节点。然后分出来根节点的左子树和右子树是什么<br>然后分别在左子树和右子树在去找他们分别的根节点；一层一层的下去；<br>但是只知道前序和后序是不能去判断哪个节点是根节点。</p>
<p>问题2：层序遍历能否去构建二叉树？<br>答:中序和层序可以构建唯一二叉树，而和前序，后序遍历不能得到唯一的二叉树。<br>理由和上面一样，每次建树操作都要区分出左子树和右子树的结点有哪些。只有层序和中序遍历可以得到，而和其他两种得不到唯一的左子树和右子树；<br>层序和中序构建二叉树的代码如下：</p>
<pre><code>public class CreateTree {
    public static void main(String[] args) {
        String[] level = &quot;ABC&quot;.split(&quot;&quot;);
        String[] in = &quot;BAC&quot;.split(&quot;&quot;);
        int root = 0; //记录根节点下标

        TreeNode head = CreateBinaryTreeByLevelOrderInOrder(level,0,level.length-1,in,0,in.length-1,root);
        System.out.println(head.val);
        InOrder(head);
    }
    public static TreeNode CreateBinaryTreeByLevelOrderInOrder(String[] level,int s1, int e1, String[] in, int s2, int e2,int root){
        boolean isFindRoot =  false;
        boolean isFindLTree = false;
        boolean isFindRTree = false;
        TreeNode node = new TreeNode();
        //遍历字符串
        for (int i = s1; i &lt;=e1; i++) {
            for (int j  = s2; j &lt;= e2; j++) {
                //构建根节点
                if(!isFindRoot &amp;&amp; level[s1].equals(in[j])){
                    root = j;
                    isFindRoot = true;
                    node.val = level[s1];
                    node.leftChild = null;
                    node.rightChild = null;
                    break;
                }
                //在层序中查找中序中左子树的根节点
                if(!isFindLTree &amp;&amp; level[i].equals(in[j]) &amp;&amp; j &lt; root) {
                    node.leftChild = CreateBinaryTreeByLevelOrderInOrder(level, i, e1, in, s2, root - 1, root);
                    isFindLTree = true;
                    break;
                }
                //在层序中查找中序中右子树的根节点
                if(!isFindRTree &amp;&amp; level[i].equals( in[j]) &amp;&amp; j &gt; root) {
                    node.rightChild = CreateBinaryTreeByLevelOrderInOrder(level, i, e1, in, root + 1, e2, root);
                    isFindRTree = true;
                    break;
                }
                //建立完成
                if(isFindRoot &amp;&amp; isFindLTree &amp;&amp; isFindRTree) {
                    break;
                }
            }
        }
        return node;
    }

    private static class TreeNode {
        TreeNode leftChild;
        String val;
        TreeNode rightChild;

        public TreeNode(){

        }
        public TreeNode(String val) {
            this.val = val;
        }
    }
}
</code></pre><p><a href="https://blog.csdn.net/kfyty725/article/details/82808097" target="_blank" rel="external">参考</a></p>
<h2 id="星期四-7-18-："><a href="#星期四-7-18-：" class="headerlink" title="星期四(7.18)："></a>星期四(7.18)：</h2><p>排序:<br>主要是要知道怎么去写，注意一些边界条件。思路都不同很有特点<br>冒泡 简单选择 插入排序 希尔排序 归并排序 快排</p>
<h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1 冒泡排序"></a>1 冒泡排序</h3><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
<p>  1.1 算法描述</p>
<pre><code>比较相邻的元素。如果第一个比第二个大，就交换它们两个；
对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
针对所有的元素重复以上的步骤，除了最后一个；
重复步骤1~3，直到排序完成。每次排序完，最大的数都会沉底到达他最终的位置，
</code></pre><p>  1.2 算法分析</p>
<pre><code>时间复杂度：T(n) = O(n^2)   最好情况O(n)  最坏情况O（n^2）
空间复杂度：O(1)
稳定性：稳定
</code></pre><p>  1.3实现：<br>  需要使用两层循环:<br>  外层循环的边界调节是i包含在：[0，arr.length-2]因为最后一个数不需要在和他后面的比，他前面是有序的他一定是有序的<br>  内层循环需要比较相邻两个元素他的边界j包含[i,arr.length-2-i];表示是是从i开始和后一个数进行比较当然最后一个数没有后一个数，所以只循环到倒数第二个数即可</p>
<pre><code>public static void BubbleSort(int[] arr) {
  for(int i = 0; i &lt; arr.length-2; i++) {
    boolean isOrder = true;//表示一个标志是否需要排序
    for(int j = i; j &lt; arr.length-2-i; j++) {
      if(arr[j] &gt; arr[j+1]) {
        swap(arr,j,j+1)
        isOrder = false;
      }
    }
    if(isOrder == true) {
      return ; //排序完成
    }
  }
}
</code></pre><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><p>  1.1 算法描述<br>    表现最稳定的排序算法之一，因为无论什么数据进去都是O(n^2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。<br>    它的工作原理：首先在未排序序列中找到最小（大）元素，交换到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后交换已排序序列的末尾。以此类推，直到所有元素均排序完毕。<br>  1.2 算法分析<br>    时间复杂度：平均情况 O(n2)  最好情况 O(n^2)  最坏情况 O(n^2)<br>    空间复杂度： O(1)<br>    稳定性：不稳定<br>  1.3实现：</p>
<pre><code>就写核心的两个for循环
for(int i = 0; i &lt; arr.length-1; i++) {
  int minIndex = i;//要去找无序序列当中的最小值
  for(int j = i + 1; j &lt; arr.length; j++) {  //寻找当前最小值的下标
    if(arr[minIndex] &gt; arr[j]) {
      minIndex = j;
    }
  }
  swap(arr,i,minIndex); //i 和 minIndex交换
}
</code></pre><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，<strong>因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位</strong>，为最新元素提供插入空间。<br>  1.1 算法描述</p>
<pre><code>1从第一个元素开始，该元素可以认为已经被排序；
2取出下一个元素，在已经排序的元素序列中从后向前扫描；
3如果该元素（已排序）大于新元素，将该元素移到下一位置；
4重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
5将新元素插入到该位置后；
</code></pre><p>  1.2 算法分析</p>
<pre><code>时间复杂度：平均情况 O(n2)  最好情况 O(n^2)  最坏情况 O(n^2)
空间复杂度： O(1)
稳定性：不稳定,可以稳定
</code></pre><p>  1.3实现：<br>    就写两层循环，第一层遍历数组，第二层j开始去前面的有序的序列去找无序序列第一个元素应该放哪里</p>
<pre><code>for(int i = 1; i &lt; arr.length-1; i++) { //i指向的是无序的第一个元素
  int j;
  int value = arr[i];
  for(j = i-1; j &gt;=0 &amp;&amp; arr[j] &gt; value; j--){ //找到value能插入的地方 只有&gt; 为了稳定
    arr[j+1] = arr[j];//移动
  }
  arr[j+1] = value;
}
</code></pre><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>  1.1 算法描述<br>在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2…1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。<br>先将整个待排序的记录序列分割成为若干子序列分别进行<strong>直接插入排序</strong>，具体算法描述：</p>
<pre><code>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；
按增量序列个数k，对序列进行k 趟排序；
每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列
，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理
，表长度即为整个序列的长度。
</code></pre><p>  1.2 算法分析</p>
<pre><code>时间复杂度：O(nlogn)
空间复杂度：O(1)
稳定性：不稳定
</code></pre><p>  1.3实现：三层循环，一层确定gap 两层直接插入排序</p>
<pre><code>int gap = arr.length/2;
while(gap != 0) {
  for(int i = gap; i &lt; arr.length; i++) {
    int value = arr[gap];
    int j;
    for(j = i - gap; j &gt;=0 &amp;&amp; arr[j]&gt;value; j=j-gap){
      arr[j+gap] = arr[j];
    }
    arr[j+gap] = value;
  }
  gap = gap/2;
}
</code></pre><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>  1.1 算法描述</p>
<pre><code>把长度为n的输入序列分成两个长度为n/2的子序列；
对这两个子序列分别采用归并排序；
将两个排序好的子序列合并成一个最终的排序序列。
</code></pre><p>  1.2 算法分析</p>
<pre><code>最佳情况：T(n) = O(nlogn)
空间复杂度： O(n)
稳定性： 稳定
</code></pre><p>  1.3实现：</p>
<pre><code>public static void sort(int[] arr) {
    if(arr ==null || arr.length &lt;=1) return;
    mergeSort(arr,0,arr.length-1);
}
private static void mergeSort(int[] arr, int low, int high) {
    if(low &gt;= high) return ;
    int mid = low + ((high - low)&gt;&gt;1);
    //对左边进行排序
    mergeSort(arr,low,mid);
</code></pre><p>//        右边排序<br>        mergeSort(arr,mid+1,high);<br>        //合并两个有序数组；<br>        merge(arr,low,mid,high);<br>    }</p>
<pre><code>private static void merge(int[] arr, int low, int mid, int high) {
    //需要额外的内存空间，创建一个数组；
    int left = low;
    int right = mid+1;
    int[] temp = new int[high-low+1];
    int i = 0;
    //左右两个数组都有元素
    while(left &lt;= mid &amp;&amp; right &lt;= high) {
        if(arr[left] &lt;= arr[right]){  // =需要为了稳定性 相同左边先进
            temp[i++] = arr[left++];
        } else {

            temp[i++] = arr[right++];
            count  = count + (mid - left + 1); //可以获取逆序度

        }
    }
    //左边数组还有元素
    while(left &lt;= mid) temp[i++] = arr[left++];
    //右边数组还有元素
    while(right &lt;= high) temp[i++] = arr[right++];

    //把temp数组的元素重新赋值给对应的区间
    for(int j = 0; j &lt; temp.length; j++){
        arr[low+j] = temp[j];
    }
}
</code></pre><h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><p>  1.1 算法描述<br>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>
<pre><code>从数列中挑出一个元素，称为 “基准”（pivot）；
重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。
</code></pre><p>  1.2 算法分析</p>
<pre><code>最佳情况：平均情况：T(n) = O(nlogn)
空间复杂度： O(logn) （栈占用的空间）
稳定性： 不稳定
</code></pre><p>  1.3实现：</p>
<pre><code>private static void quickSort(int[] arr, int low, int high) {
  int left = low;
  int right = hight;
  int pivot = arr[low]; //以第一个元素为轴值
  while(left &lt; right) {
    while(left &lt; right &amp;&amp; pivot &lt;= arr[right]) right--; //必须要写等号不然有可能死循环，这样
    arr[left] = arr[right];;
    while(left &lt; right &amp;&amp; pivot &gt;= arr[left]) left++;
    arr[right] = left;
  }
  arr[left] = pivot;
  //分别对左边和右边进行快排
  quickSort(arr,low,left-1);
  //右边进行排序
  quickSort(arr,left+1,high);
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/14/Java总结（三）下/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王邸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路要坚持">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/14/Java总结（三）下/" itemprop="url">Java总结（三）下</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-14T21:11:14+08:00">
                2019-07-14
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/07/14/Java总结（三）下/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/07/14/Java总结（三）下/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="星期六"><a href="#星期六" class="headerlink" title="星期六"></a>星期六</h2><h3 id="学习数据结构List"><a href="#学习数据结构List" class="headerlink" title="学习数据结构List"></a>学习数据结构List</h3><p>主要就是学习源码为什么这样写。有几点需要注意：<br>1）我们只学习核心的方法和迭代器的方法<br>2）迭代器的指针是指向两个结点之间的位置上的。这一定要注意；<br>3）一些细节上的问题我会说清楚</p>
<h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><p>1）我们需要一个List接口。两个list都继承这个接口的方法<br>2）我们需要一个iterator接口，两个类的子类对象要继承这个接口的方法<br>3）这个类的子类要和父类数据互通，不想被其他类访问最好就放在内部类<br>4）出现的异常<br>IllegalArgumentException   抛出的异常表明向方法传递了一个不合法或不正确的参数。<br>ArrayStoreException       试图将错误类型的对象存储到一个对象数组时抛出的异常。<br>IndexOutOfBoundsException 指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。<br>ConcurrentModificationException ： 当方法检测到对象的并发修改，但不允许这种修改时，抛出此异常。<br>IllegalStateException  在非法或不适当的时间调用方法时产生的信号。换句话说，即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下。<br>NoSuchElementException  由 Enumeration 的 nextElement 方法抛出，表明枚举中没有更多的元素。</p>
<h3 id="实现的步骤（以ArrayList为例）；"><a href="#实现的步骤（以ArrayList为例）；" class="headerlink" title="实现的步骤（以ArrayList为例）；"></a>实现的步骤（以ArrayList为例）；</h3><p>1）先定义出List接口和iterator接口<br>2）然后写ArrayList<br>    1.属性<br>    2.构造方法<br>    3.重写List方法<br>3）实现iterator接口<br>    1.属性<br>    2.构造方法<br>    3.重写方法</p>
<h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public interface MyList &#123;</div><div class="line">    boolean add(String s);</div><div class="line">    void add(int index, String s);</div><div class="line">    void clear();</div><div class="line">    boolean contains(String s);</div><div class="line">    String get(int index);</div><div class="line">    int indexOf(String s);</div><div class="line">    boolean isEmpty();</div><div class="line">    MyIterator iterator();</div><div class="line">    int lastIndexOf(String s);</div><div class="line">    String remove(int index);</div><div class="line">    boolean remove(String s);</div><div class="line">    String set(int index, String s);</div><div class="line">    int size();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="ListIterator接口"><a href="#ListIterator接口" class="headerlink" title="ListIterator接口"></a>ListIterator接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public interface MyIterator &#123;</div><div class="line">    void add(String s);</div><div class="line">    boolean hasNext();</div><div class="line">    boolean hasPrevious();</div><div class="line">    String next();</div><div class="line">    String previous();</div><div class="line">    int nextIndex();</div><div class="line">    int previousIndex();</div><div class="line">    void remove();</div><div class="line">    void set(String s);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="源码解析ArrayList"><a href="#源码解析ArrayList" class="headerlink" title="源码解析ArrayList"></a>源码解析ArrayList</h3><p>  1.属性<br>    分析：首先ArrayList是顺序存储的，而且是一个动态的数组，所以我们需要一个数组装元素elements[]，一个属性表示容量。还需要属性来表示长度（size）,<strong>为了处理并发修改异常还需要一个属性来记录在迭代器迭代时候，集合有没有修改元素modCount</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//属性</div><div class="line">public static final int MAX_CAPACITY = Integer.MAX_VALUE - 8; //最大长度</div><div class="line">public static final int DEFAULT_CAPACITY = 10; //默认长度</div><div class="line">private int size;</div><div class="line">private String[] elements;</div><div class="line">private int modCount; // modification count 统计修改的次数</div></pre></td></tr></table></figure>
<p>  2.构造方法<br>    分析：构造方法没有参数，就用默认容量还作为长度。或者用户会手动输入一个长度，对这个长度判断。是否超过最大长度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 构造方法</div><div class="line">public MyArrayList() &#123;</div><div class="line">    elements = new String[DEFAULT_CAPACITY];</div><div class="line">&#125;</div><div class="line"></div><div class="line">public MyArrayList(int capacity) &#123;</div><div class="line">    if (capacity &lt; 0 || capacity &gt; MAX_CAPACITY) &#123;</div><div class="line">        throw new IllegalArgumentException(&quot;capacity=&quot; + capacity);</div><div class="line">    &#125;</div><div class="line">    elements = new String[capacity];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  3.方法<br>  这里有两点要说明：<br>  <strong>1.先挑软柿子捏，至于为什么等下告诉你</strong><br>  <strong>2.在写方法时不一定全部都要自己动手，可以调用本类其他方法，当然内部类（iterator）可以调用外部类来实现自己的功能。当然这些方法一般都是软柿子，一个大的功能由小功能组成的</strong></p>
<p>add(s)调用同名的兄弟解决<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 在线性表末尾添加元素</div><div class="line"> * @param s 要添加的元素</div><div class="line"> * @return 添加成功返回true, 否则返回false</div><div class="line"> */</div><div class="line">@Override</div><div class="line">public boolean add(String s) &#123;</div><div class="line">    add(size, s);</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法比较难了，主要难点在于<br>1.添加是否会使得数组本身就满了需要扩容<br>2.扩容的过程会不会出现大于集合最大长度的情况<br>3.扩容的最佳分配是什么（这里就默认扩容1.5倍）<br>4.同样需要进行modCount++ size++;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 在指定的索引位置添加元素</div><div class="line"> * @param index 索引</div><div class="line"> * @param s 添加的元素</div><div class="line"> */</div><div class="line">@Override</div><div class="line">public void add(int index, String s) &#123;</div><div class="line">    checkIndexForAdd(index);</div><div class="line">    // 确保容量够大</div><div class="line">    int minCapacity = size + 1;</div><div class="line">    if (minCapacity &gt; elements.length) &#123;   //需要扩容</div><div class="line">        // 计算新数组的长度</div><div class="line">        int newLength = calculateCapacity(minCapacity);</div><div class="line">        // 扩容</div><div class="line">        grow(newLength);</div><div class="line">    &#125;</div><div class="line">    // 添加元素</div><div class="line">    for(int i = size; i &gt; index; i--) &#123;</div><div class="line">        elements[i] = elements[i-1];</div><div class="line">    &#125;</div><div class="line">    elements[index] = s;</div><div class="line">    size++;</div><div class="line">    modCount++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private void grow(int newLength) &#123;</div><div class="line">    String[] newArr = new String[newLength];</div><div class="line">    for(int i = 0; i &lt; size; i++) &#123;</div><div class="line">        newArr[i] = elements[i];</div><div class="line">    &#125;</div><div class="line">    // 将elements指向新的数组</div><div class="line">    elements = newArr;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private int calculateCapacity(int minCapacity) &#123;</div><div class="line">    if (minCapacity &gt; MAX_CAPACITY || minCapacity &lt; 0) &#123;</div><div class="line">        throw new IllegalArgumentException();//不是ArrayStoreException异常</div><div class="line">    &#125;</div><div class="line">    // 一定能存下这么多数据</div><div class="line">    int len = elements.length + (elements.length &gt;&gt; 1); //扩容1.5倍</div><div class="line">    if (len &gt; MAX_CAPACITY || len &lt; 0) &#123;</div><div class="line">        len = MAX_CAPACITY;</div><div class="line">    &#125;</div><div class="line">    // 返回minCapacity和len的较大值</div><div class="line">    return len &gt; minCapacity ? len : minCapacity;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>检查index是否符合添加的条件注意可以在size位置添加的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">private void checkIndexForAdd(int index) &#123;</div><div class="line">    if (index &lt; 0 || index &gt; size) &#123;</div><div class="line">        throw new IndexOutOfBoundsException(&quot;index=&quot; + index + &quot;, size=&quot; + size);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意清空操作算是修改链表长度的操作。需要modCount++<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 清空线性表</div><div class="line"> */</div><div class="line">@Override</div><div class="line">public void clear() &#123;</div><div class="line">    // elements = null;</div><div class="line">    modCount++;</div><div class="line">    for(int i = 0; i &lt; size; i++) &#123;</div><div class="line">        elements[i] = null;</div><div class="line">    &#125;</div><div class="line">    size = 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>contains调用indexOf(s)解决<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 判断元素是否在线性表中存在</div><div class="line"> * @param s 元素</div><div class="line"> * @return 如果存在返回true, 否则返回false</div><div class="line"> */</div><div class="line">@Override</div><div class="line">public boolean contains(String s) &#123;</div><div class="line">    int index = indexOf(s);</div><div class="line">    if (index == -1) &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>直接返回数组元素值就行，软柿子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 获取指定索引位置的值</div><div class="line"> * @param index 索引</div><div class="line"> * @return 值</div><div class="line"> */</div><div class="line">@Override</div><div class="line">public String get(int index) &#123;</div><div class="line">    checkIndex(index);</div><div class="line">    return elements[index];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">private void checkIndex(int index) &#123;</div><div class="line">    if (index &lt; 0 || index &gt;= size) &#123;</div><div class="line">        throw new IndexOutOfBoundsException(&quot;index=&quot; + index + &quot;, size=&quot; + size);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>indexOf是很多兄弟都要用到，所以这个方法是否正确就很重要了，不能马虎<br>需要判断用户给的String是不是null来判断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 查找元素在线性表中第一次出现的位置</div><div class="line"> * @param s 查找的元素</div><div class="line"> * @return 第一次出现的位置，如果不存在返回-1.</div><div class="line"> */</div><div class="line">@Override</div><div class="line">public int indexOf(String s) &#123;</div><div class="line">    if (s == null) &#123;</div><div class="line">        for(int i = 0; i &lt; size; i++) &#123;</div><div class="line">            if (elements[i] == null) &#123;</div><div class="line">                return i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        for(int i = 0; i &lt; size; i++) &#123;</div><div class="line">            if (s.equals(elements[i])) &#123;</div><div class="line">                return i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return -1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>软柿子+1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 判空</div><div class="line"> */</div><div class="line">@Override</div><div class="line">public boolean isEmpty() &#123;</div><div class="line">    return size == 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>迭代器后面具体说<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public MyIterator iterator() &#123;</div><div class="line">    return new Itr(0) ;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public MyIterator iterator(int index) &#123;</div><div class="line">    checkIndexForAdd(index);</div><div class="line">    return new Itr(index);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从后往前遍历也要判断一下用户传过来的null;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 查找元素在线性表中最后出现的索引</div><div class="line"> * @param s 查找的锇元素</div><div class="line"> * @return 最后一次的索引，如果不存在返回-1</div><div class="line"> */</div><div class="line">@Override</div><div class="line">public int lastIndexOf(String s) &#123;</div><div class="line">    if (s == null) &#123;</div><div class="line">        for(int i = size - 1; i &gt;= 0; i--) &#123;</div><div class="line">            if (elements[i] == null) &#123;</div><div class="line">                return i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        for(int i = size - 1; i &gt;= 0; i--) &#123;</div><div class="line">            if (s.equals(elements[i])) &#123;</div><div class="line">                return i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return -1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过下标找到位置<br>  1.拿出被删除的数<br>  2.然后移动数组<br>  3.记得modCount++因为修改了数组结构<br>  4.size–<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 删除指定索引位置的元素</div><div class="line"> * @param index 指定索引位置</div><div class="line"> * @return 被删除的元素</div><div class="line"> */</div><div class="line">@Override</div><div class="line">public String remove(int index) &#123;</div><div class="line">    checkIndex(index);</div><div class="line">    String oldValue = elements[index];</div><div class="line">    for(int i = index; i &lt; size - 1; i++) &#123;</div><div class="line">        elements[i] = elements[i+1];</div><div class="line">    &#125;</div><div class="line">    size--;</div><div class="line">    modCount++;</div><div class="line">    return oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过indexOf()找到下标然后给同名的兄弟remove(index)解决；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 删除第一个值等于s的元素</div><div class="line"> * @param s 给定的值</div><div class="line"> * @return 如果删除成功返回true，否则返回false.</div><div class="line"> */</div><div class="line">@Override</div><div class="line">public boolean remove(String s) &#123;</div><div class="line">    int index = indexOf(s);</div><div class="line">    if (index == -1) &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    remove(index);</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>软柿子，记得检查一下用户输入index是否有问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 把指定索引位置的值更新成新的值，并把旧的值返回</div><div class="line"> * @param index 索引</div><div class="line"> * @param s 新值</div><div class="line"> * @return 旧值</div><div class="line"> */</div><div class="line">@Override</div><div class="line">public String set(int index, String s) &#123;</div><div class="line">    checkIndex(index);</div><div class="line">    String oldValue = elements[index];</div><div class="line">    elements[index] = s;</div><div class="line">    return oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>软柿子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 线性表存储元素的个数</div><div class="line"> * @return 线性表存储元素的个数</div><div class="line"> */</div><div class="line">@Override</div><div class="line">public int size() &#123;</div><div class="line">    return size;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>软柿子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public String toString() &#123;</div><div class="line">    StringBuilder sb = new StringBuilder(&quot;[&quot;);</div><div class="line">    for (int i = 0; i &lt; size; i++) &#123;</div><div class="line">        sb.append(elements[i]);</div><div class="line">        if (i != size - 1) &#123;</div><div class="line">            sb.append(&quot;, &quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return sb.append(&quot;]&quot;).toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>—————————–内部类———————————————</p>
<p>接下来是内部类写迭代器也是老三样<br>  1.属性<br>  分析：首先需要cursor指向下一个元素，一个lastRet表示最近的访问的元素。还要校对是否出现并发修改异常设置一个exception<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">private int cursor; //后面元素的索引位置</div><div class="line">private int expModCount = modCount;</div><div class="line">private int lastRet = -1; // -1表示没有返回元素</div></pre></td></tr></table></figure></p>
<p>  2.构造方法 两种一种带index 一种不带。默认就调用index = 0 就行了<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public Itr(int index) &#123;</div><div class="line">    cursor = index;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3.方法（<strong>注意看清楚操作的指针</strong>）<br>注意：先找软柿子捏</p>
<p>add:这个方法需要注意几个地方<br>1.添加了新的元素可以调用父类的add方法<br>2.修改了集合长度记得expModCount = modCount<br>调用父类的add modCount++了为什么不是expModCount ++？<br>考虑到了添加是集合的情况，直接赋值也是一样的结果<br>3.要把lastRet给质空 ，因为元素之间的关系已经改变不能在操作刚返回的元素了；<br>4.cursor++ ，cursor不++就会指向你刚添加的元素，这样连续添加时候并不会按照你添加顺序添加进入集合，而是反向。所以需要cursor++;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void add(String s) &#123;</div><div class="line">    checkConcurrentModification();</div><div class="line">    MyArrayList.this.add(cursor, s);</div><div class="line">    expModCount = modCount;</div><div class="line">    cursor++;       // caution</div><div class="line">    lastRet = -1;    // caution</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>//判断是否会出现并发修改异常<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">private void checkConcurrentModification() &#123;</div><div class="line">    if (expModCount != modCount) &#123;</div><div class="line">        throw new ConcurrentModificationException();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>软柿子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public boolean hasNext() &#123;</div><div class="line">    return cursor &lt; size;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public boolean hasPrevious() &#123;</div><div class="line">    return cursor &gt; 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>核心方法：<br>1.首先判断是否有下一个元素<br>2.lastRet = cursor<br>3.cursor++<br>4.return elements[lastRet]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public String next() &#123;</div><div class="line">    checkConcurrentModification();</div><div class="line">    if (!hasNext()) &#123;</div><div class="line">        throw new NoSuchElementException();</div><div class="line">    &#125;</div><div class="line">    lastRet = cursor;</div><div class="line">    return elements[cursor++];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>核心方法<br>同上这里注意cursor–;<br>此时cursor和lastRet指向的同一个元素哦<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public String previous() &#123;</div><div class="line">    checkConcurrentModification();</div><div class="line">    if (!hasPrevious()) &#123;</div><div class="line">        throw new NoSuchElementException();</div><div class="line">    &#125;</div><div class="line">    lastRet = cursor - 1;</div><div class="line">    /*String retValue = elements[cursor - 1];</div><div class="line">    cursor--;</div><div class="line">    return retValue;*/</div><div class="line">    return elements[--cursor];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>软柿子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public int nextIndex() &#123;</div><div class="line">    return cursor;</div><div class="line">&#125;</div><div class="line">@Override</div><div class="line">public int previousIndex() &#123;</div><div class="line">    return cursor - 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>remove最近返回的元素<br>注意事项：<br>1.这里判断lastRet是否存在不然抛出异常不该调用这个函数<br>2.expModCount = modCount 需要同步 增加和删除都需要<br>3.<strong>cursor = lastRet</strong>这个是为了不管正向遍历还是逆向遍历都能使得cursor位置不变；<br><em>首先看正向遍历：</em><br>|1|2|3|4|5|6|7|8|9|10|<br>假设正向遍历删除的是5  L表示last C 表示cursor<br>|1|2|3|4|5|6|7|8|9|10|<br>L在4|5之间，C在5|6之间<br>把5删掉之后因为集合删除会自动向前移动并排满，5的位置被6取代以此类推。那么cursor就会指向7，所以正向遍历必须cursor-1;</p>
<p><em>看逆向遍历：</em><br>|1|2|3|4|5|6|7|8|9|10|<br>假设逆向遍历删除的是5  L表示last C 表示cursor<br>|1|2|3|4|5|6|7|8|9|10|<br>C，L都在4|5之间</p>
<p>此时cursor和lastRet是指向同一个的这种情况就不用-1<br>所以综合两种情况把cursor = lastRet就行<br>4.lastRet置空因为修改了元素不想能够一直删除；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void remove() &#123;</div><div class="line">    checkConcurrentModification();</div><div class="line">    if (lastRet == -1) &#123;</div><div class="line">        throw new IllegalStateException();</div><div class="line">    &#125;</div><div class="line">    MyArrayList.this.remove(lastRet);</div><div class="line">    expModCount = modCount;  //修改完就要同步count</div><div class="line">    cursor = lastRet; // caution: 正向遍历和逆向遍历的结果一致</div><div class="line">    lastRet = -1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>设置元素<br>这里需要注意的是：<br>lastRet也要置空只要元素有改变都应该置空<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">    @Override</div><div class="line">    public void set(String s) &#123;</div><div class="line">        // 判断迭代器是否有效</div><div class="line">        checkConcurrentModification();</div><div class="line">        if (lastRet == -1) &#123;</div><div class="line">            throw new IllegalStateException();</div><div class="line">        &#125;</div><div class="line">        elements[lastRet] = s;</div><div class="line">        lastRet = -1;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="ArrayList总结"><a href="#ArrayList总结" class="headerlink" title="ArrayList总结"></a>ArrayList总结</h3><p>1.难点在于ArrayList的扩容的机智<br>2.内部类的对指针的移动和判断并发修改异常</p>
<h3 id="源码解析linkedList"><a href="#源码解析linkedList" class="headerlink" title="源码解析linkedList"></a>源码解析linkedList</h3><p>直接看源码：因为之前没看过，所以今天就来学习一下</p>
<h3 id="List接口-1"><a href="#List接口-1" class="headerlink" title="List接口"></a>List接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">只看核心方法</div></pre></td></tr></table></figure>
<h3 id="ListIterator接口-1"><a href="#ListIterator接口-1" class="headerlink" title="ListIterator接口"></a>ListIterator接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">只看核心方法</div></pre></td></tr></table></figure>
<p>对于LinkedList来说应该没有什么难点，主要还是看迭代器里面的操作；因为是linkedList不需要考虑扩容的问题<br>先看看类名</p>
<pre><code>public class LinkedList&lt;E&gt;
extends AbstractSequentialList&lt;E&gt;
implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable
</code></pre><p>属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">transient int size = 0;</div><div class="line">transient Node&lt;E&gt; first;  //定义第一个结点可变</div><div class="line">transient Node&lt;E&gt; last;   //定义最后一个结点可变</div><div class="line">protected transient int modCount = 0; //AbstractList定义</div></pre></td></tr></table></figure></p>
<p>1这里出现了关键字transient。Java中transient关键字的作用，简单地说，就是让某些被修饰的成员属性变量不被序列化<br>2这里需要看看Node是什么:一个静态内部类；相当于外部类？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">private static class Node&lt;E&gt; &#123;</div><div class="line">    E item;</div><div class="line">    Node&lt;E&gt; next;</div><div class="line">    Node&lt;E&gt; prev;</div><div class="line"></div><div class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</div><div class="line">        this.item = element;</div><div class="line">        this.next = next;</div><div class="line">        this.prev = prev;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>构造方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public LinkedList() &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public LinkedList(Collection&lt;? extends E&gt; c) &#123;</div><div class="line">    this();</div><div class="line">    addAll(c);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Links e as first element.</div><div class="line"> */</div><div class="line">private void linkFirst(E e) &#123;</div><div class="line">    final Node&lt;E&gt; f = first;</div><div class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f);//这是头插法</div><div class="line">    first = newNode;</div><div class="line">    if (f == null)              // 说明里面一个结点都没有</div><div class="line">        last = newNode;</div><div class="line">    else</div><div class="line">        f.prev = newNode;       // first.prev = newNode;</div><div class="line">    size++;</div><div class="line">    modCount++;                 //在AbstractList定义</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在某个元素前面添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">void linkBefore(E e, Node&lt;E&gt; succ) &#123;</div><div class="line">    // assert succ != null;</div><div class="line">    final Node&lt;E&gt; pred = succ.prev;</div><div class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ);</div><div class="line">    succ.prev = newNode;</div><div class="line"></div><div class="line">    if (pred == null)</div><div class="line">        first = newNode;</div><div class="line">    else</div><div class="line">        pred.next = newNode;</div><div class="line"></div><div class="line">    size++;</div><div class="line">    modCount++;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>尾插法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Links e as last element.</div><div class="line"> */</div><div class="line">void linkLast(E e) &#123;</div><div class="line">    final Node&lt;E&gt; l = last;</div><div class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</div><div class="line">    last = newNode;</div><div class="line">    if (l == null)</div><div class="line">        first = newNode;</div><div class="line">    else</div><div class="line">        l.next = newNode;</div><div class="line">    size++;</div><div class="line">    modCount++;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>删除头结点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/</div><div class="line"> * Unlinks non-null first node f.</div><div class="line"> */</div><div class="line">private E unlinkFirst(Node&lt;E&gt; f) &#123;</div><div class="line">    // assert f == first &amp;&amp; f != null;</div><div class="line">    final E element = f.item;      //获取要删除的值</div><div class="line">    final Node&lt;E&gt; next = f.next;   //获取first的下一个结点（未知）</div><div class="line">    f.item = null;</div><div class="line">    f.next = null; // help GC</div><div class="line">    first = next;</div><div class="line">    //如果原本就只有一个结点，现在毛都没了</div><div class="line">    if (next == null)</div><div class="line">        last = null;</div><div class="line">    else</div><div class="line">        next.prev = null;    //next作为头结点把和之前first链接断开</div><div class="line">    size--;</div><div class="line">    modCount++;</div><div class="line">    return element;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>删除最后一个结点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">private E unlinkLast(Node&lt;E&gt; l) &#123;</div><div class="line">    // assert l == last &amp;&amp; l != null;</div><div class="line"></div><div class="line">    final E element = l.item;</div><div class="line">    final Node&lt;E&gt; prev = l.prev;</div><div class="line">    l.item = null;</div><div class="line">    l.prev = null; // help GC</div><div class="line">    last = prev;</div><div class="line"></div><div class="line">    if (prev == null)</div><div class="line">        first = null;</div><div class="line">    else</div><div class="line">        prev.next = null;</div><div class="line">    size--;</div><div class="line">    modCount++;</div><div class="line">    return element;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>删除任意一个结点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Unlinks non-null node x.</div><div class="line"> */</div><div class="line">E unlink(Node&lt;E&gt; x) &#123;</div><div class="line">    // assert x != null;</div><div class="line">    final E element = x.item;</div><div class="line">    final Node&lt;E&gt; next = x.next;</div><div class="line">    final Node&lt;E&gt; prev = x.prev;</div><div class="line"></div><div class="line">    if (prev == null) &#123;   //如果删除的是头结点</div><div class="line">        first = next;</div><div class="line">    &#125; else &#123;</div><div class="line">        prev.next = next;</div><div class="line">        x.prev = null;    //help GC</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (next == null) &#123;  //如果删除是最后一个结点</div><div class="line">        last = prev;</div><div class="line">    &#125; else &#123;</div><div class="line">        next.prev = prev;</div><div class="line">        x.next = null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    x.item = null;  //help GC</div><div class="line">    size--;</div><div class="line">    modCount++;</div><div class="line">    return element;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在index添加一个集合<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</div><div class="line">    checkPositionIndex(index);</div><div class="line"></div><div class="line">    Object[] a = c.toArray();</div><div class="line">    int numNew = a.length;</div><div class="line">    if (numNew == 0)</div><div class="line">        return false;</div><div class="line"></div><div class="line">    Node&lt;E&gt; pred, succ;</div><div class="line">    if (index == size) &#123;</div><div class="line">        succ = null;</div><div class="line">        pred = last;</div><div class="line">    &#125; else &#123;</div><div class="line">        succ = node(index);</div><div class="line">        pred = succ.prev;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for (Object o : a) &#123;</div><div class="line">        @SuppressWarnings(&quot;unchecked&quot;) E e = (E) o;</div><div class="line">        Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null);</div><div class="line">        if (pred == null)</div><div class="line">            first = newNode;</div><div class="line">        else</div><div class="line">            pred.next = newNode;</div><div class="line">        pred = newNode;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (succ == null) &#123;</div><div class="line">        last = pred;</div><div class="line">    &#125; else &#123;</div><div class="line">        //连接原版在index的元素</div><div class="line">        pred.next = succ;</div><div class="line">        succ.prev = pred;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    size += numNew;</div><div class="line">    modCount++;</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>indexOf和arrayList差不多<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public int indexOf(Object o) &#123;</div><div class="line">    int index = 0;</div><div class="line">    if (o == null) &#123;</div><div class="line">        for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;</div><div class="line">            if (x.item == null)</div><div class="line">                return index;</div><div class="line">            index++;</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;</div><div class="line">            if (o.equals(x.item))</div><div class="line">                return index;</div><div class="line">            index++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return -1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>寻找Node的index方法，就分半查找<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Node&lt;E&gt; node(int index) &#123;</div><div class="line">    // assert isElementIndex(index);</div><div class="line"></div><div class="line">    if (index &lt; (size &gt;&gt; 1)) &#123;</div><div class="line">        Node&lt;E&gt; x = first;</div><div class="line">        for (int i = 0; i &lt; index; i++)</div><div class="line">            x = x.next;</div><div class="line">        return x;</div><div class="line">    &#125; else &#123;</div><div class="line">        Node&lt;E&gt; x = last;</div><div class="line">        for (int i = size - 1; i &gt; index; i--)</div><div class="line">            x = x.prev;</div><div class="line">        return x;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来来看LinkedList的迭代器吧<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private class ListItr implements ListIterator&lt;E&gt; &#123;</div></pre></td></tr></table></figure></p>
<p>//属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">private Node&lt;E&gt; lastReturned;</div><div class="line">private Node&lt;E&gt; next;</div><div class="line">private int nextIndex;</div><div class="line">private int expectedModCount = modCount;</div></pre></td></tr></table></figure></p>
<p>//构造函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ListItr(int index) &#123;</div><div class="line">    // assert isPositionIndex(index);</div><div class="line">    next = (index == size) ? null : node(index);</div><div class="line">    nextIndex = index;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>//软柿子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public boolean hasNext() &#123;</div><div class="line">    return nextIndex &lt; size;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public E next() &#123;</div><div class="line">    checkForComodification();</div><div class="line">    if (!hasNext())</div><div class="line">        throw new NoSuchElementException();</div><div class="line"></div><div class="line">    lastReturned = next;</div><div class="line">    next = next.next;</div><div class="line">    nextIndex++;</div><div class="line">    return lastReturned.item;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public boolean hasPrevious() &#123;</div><div class="line">    return nextIndex &gt; 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public E previous() &#123;</div><div class="line">    checkForComodification();</div><div class="line">    if (!hasPrevious())</div><div class="line">        throw new NoSuchElementException();</div><div class="line"></div><div class="line">    //lastReturned = next = (next == null) ? last : next.prev;</div><div class="line">    next = (next == null) ? last : next.prev;</div><div class="line">    lastRetured = next;</div><div class="line"></div><div class="line">    nextIndex--;</div><div class="line">    return lastReturned.item;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public int nextIndex() &#123;</div><div class="line">    return nextIndex;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public int previousIndex() &#123;</div><div class="line">    return nextIndex - 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public void remove() &#123;</div><div class="line">    checkForComodification();</div><div class="line">    if (lastReturned == null)</div><div class="line">        throw new IllegalStateException();</div><div class="line"></div><div class="line">    Node&lt;E&gt; lastNext = lastReturned.next;</div><div class="line">    unlink(lastReturned);</div><div class="line"></div><div class="line">    if (next == lastReturned) //说明是逆序遍历的</div><div class="line">        next = lastNext;</div><div class="line">    else                      //正序遍历</div><div class="line">        nextIndex--;</div><div class="line">    lastReturned = null;</div><div class="line">    expectedModCount++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public void set(E e) &#123;</div><div class="line">    if (lastReturned == null)</div><div class="line">        throw new IllegalStateException();</div><div class="line">    checkForComodification();</div><div class="line">    lastReturned.item = e;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public void add(E e) &#123;</div><div class="line">    checkForComodification();</div><div class="line">    lastReturned = null;</div><div class="line">    if (next == null)</div><div class="line">        linkLast(e);</div><div class="line">    else</div><div class="line">        linkBefore(e, next);</div><div class="line">    nextIndex++;</div><div class="line">    expectedModCount++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public void forEachRemaining(Consumer&lt;? super E&gt; action) &#123;</div><div class="line">    Objects.requireNonNull(action);</div><div class="line">    while (modCount == expectedModCount &amp;&amp; nextIndex &lt; size) &#123;</div><div class="line">        action.accept(next.item);</div><div class="line">        lastReturned = next;</div><div class="line">        next = next.next;</div><div class="line">        nextIndex++;</div><div class="line">    &#125;</div><div class="line">    checkForComodification();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">    final void checkForComodification() &#123;</div><div class="line">        if (modCount != expectedModCount)</div><div class="line">            throw new ConcurrentModificationException();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这里写了ArrayList和LinkedList的源码，所以看起来有一点乱。但是两个类的作者肯定是不同的，我发现ArrayList用了很多try来想解决异常。但是LinkedList多了很多花哨的写法，所以看起来有一点费劲。总的来说学习LinkedList的思路，就是把head last设置成两个动态的结点，就只是一个标记。而不是定死的头和尾结点。所以判断时候就有一点难看懂，不过都还好。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/14/Java总结（三）上/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王邸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路要坚持">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/14/Java总结（三）上/" itemprop="url">Java总结（三）上</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-14T20:29:35+08:00">
                2019-07-14
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/07/14/Java总结（三）上/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/07/14/Java总结（三）上/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本周内容摘要：StringBuffer，Date对象，DateFormat类，Math，debug调试快捷键，异常，Collection集合，迭代器（iterator），ArrayList，LinkedList，泛型，foreach(有迭代器都可以)，可变参数variableParameter，基本数据类型的包装类，ArrayList 和linkedList的源码的编写</p>
<h2 id="星期一："><a href="#星期一：" class="headerlink" title="星期一："></a>星期一：</h2><h3 id="StringBuffer："><a href="#StringBuffer：" class="headerlink" title="StringBuffer："></a>StringBuffer：</h3><p>线程安全的可变字符序列。可以自动扩容</p>
<h4 id="构造方法："><a href="#构造方法：" class="headerlink" title="构造方法："></a>构造方法：</h4><pre><code>StringBuffer()
    创建空的字符序列，默认容量是16
StringBuffer(int capacity)
    创建空的字符序列，容量为capacity.
StringBuffer(String str)
    字符串转成StringBuffer
</code></pre><h4 id="成员方法："><a href="#成员方法：" class="headerlink" title="成员方法："></a>成员方法：</h4><pre><code>int capacity()     容量
int length()       实际存储字符的长度
</code></pre><p>添加功能</p>
<pre><code>public StringBuffer append(String str)
public StringBuffer insert(int offset,String str)
</code></pre><p>删除功能：</p>
<pre><code>public StringBuffer deleteCharAt(int index)删除指定位置的字符
public StringBuffer delete(int start,int end) 包左不包右删除连续的字符序列
</code></pre><p>替换（改）</p>
<pre><code>public StringBuffer replace(int start,int end,String str) 包左不包右把[start, end)之间的字符替换成str
</code></pre><p>反转功能</p>
<pre><code>public StringBuffer reverse()
</code></pre><p>截取功能：<strong>注意:返回值是String</strong></p>
<pre><code>public String substring(int start)
public String substring(int start,int end) 包左不包右
</code></pre><p>同步：synchronized 线程安全, 但是效率低。(你走我不走，我走你不走)<br>异步：线程不安全，但是效率高（你走你的，我走我的）</p>
<p>StringBuilder: 1.5<br>一个可变的字符序列。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。<br>在单线程环境下，或者不会出现线程安全问题的多线程程序中，应该使用 StringBuilder.<br>构造方法和方法和StringBuffer一样。</p>
<p>区别：String, StringBuffer, StringBuilder<br>String: 不可变的字符序列。<br>StringBuffer: 可变的字符序列，线程安全, 效率低。<br>StringBuilder: 可变的字符序列，线程不安全, 效率高</p>
<h4 id="String-和-StringBuffer-转化"><a href="#String-和-StringBuffer-转化" class="headerlink" title="String 和 StringBuffer 转化"></a>String 和 StringBuffer 转化</h4><pre><code>String --&gt; StringBuffer
    new StringBuffer(String)

StringBuffer --&gt; String
    sb.toString();（常用）
    new String(StringBuffer sb)
    sb.subString()
    String.ValueOf(sb)
</code></pre><p>看下面的例子：</p>
<pre><code>public class StringBufferDemo6 {
    public static void main(String[] args) {
        String s1 = &quot;Hello&quot;;
        String s2 = &quot;world&quot;;
        change(s1, s2);
        System.out.println(&quot;s1 = &quot; + s1);   // Hello
        System.out.println(&quot;s2 = &quot; + s2);   // world

        StringBuffer sb1 = new StringBuffer(&quot;Hello&quot;);
        StringBuffer sb2 = new StringBuffer(&quot;world&quot;);

        change(sb1, sb2);
        System.out.println(&quot;sb1 = &quot; + sb1); // Hello
        System.out.println(&quot;sb2 = &quot; + sb2); // worldworld
    }

    public static void change(String s1, String s2) {
        s1 = s2;
        s2 += s1;
    }

    public static void change(StringBuffer sb1, StringBuffer sb2) {
        sb1 = sb2;
        sb2 = sb2.append(sb1);
    }
}
打印的结果：
Hello
world
Hello
worldworld
</code></pre><p>这里注意StringBuffer如果append放在main函数中操作，再打印出来，就会两个都一样StringBuffer。因为都指向同一个StringBuffer了；</p>
<pre><code>StringBuffer sb1 = new StringBuffer(&quot;Hello&quot;);
StringBuffer sb2 = new StringBuffer(&quot;world&quot;);
sb1 = sb2;
sb2 = sb2.append(sb1);
System.out.println(&quot;sb1 = &quot; + sb1); // worldworld
System.out.println(&quot;sb2 = &quot; + sb2); // worldworld
</code></pre><p>这里想要说明String是不可变的对象，所以传递时候可以当成是值传递，而这里的值就是他的地址值。而StringBuffer是在原来的对象进行更改</p>
<p>看了一下StringBuffer源码append 会吧StringBuffer变成一个value的字符数组，<br>通过看源码打断点能看到这些：</p>
<pre><code>//进入主函数
public static void main(String[] args) {
  StringBuffer sb = new StringBuffer(&quot;&quot;);
  sb.append(&quot;你好旅行者&quot;);
  System.out.println(sb.length());
}

//StringBuffer.java
@Override
public synchronized StringBuffer append(String str) {
    toStringCache = null;
    super.append(str);
    return this;
}

//AbstractStringBuilder.java
public AbstractStringBuilder append(String str) {
    if (str == null)
        return appendNull();
    int len = str.length();
    ensureCapacityInternal(count + len);
    str.getChars(0, len, value, count);
    count += len;
    return this;
}

//确定容量是否足够
private void ensureCapacityInternal(int minimumCapacity) {
    // overflow-conscious code
    if (minimumCapacity - value.length &gt; 0) {
        value = Arrays.copyOf(value,
                newCapacity(minimumCapacity));
    }
}

public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin) {
    if (srcBegin &lt; 0) {
        throw new StringIndexOutOfBoundsException(srcBegin);
    }
    if (srcEnd &gt; value.length) {
        throw new StringIndexOutOfBoundsException(srcEnd);
    }
    if (srcBegin &gt; srcEnd) {
        throw new StringIndexOutOfBoundsException(srcEnd - srcBegin);
    }
    System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);
    //把字符添加进value数组
}
</code></pre><h4 id="StringBuffer-和数组的区别"><a href="#StringBuffer-和数组的区别" class="headerlink" title="StringBuffer 和数组的区别"></a>StringBuffer 和数组的区别</h4><p>StringBuffer: 可扩容, 可以添加任意数据(都会转成对应的文本表现形式)<br>数组：长度固定，只能存储同一类型的数据。</p>
<h3 id="Date"><a href="#Date" class="headerlink" title="Date:"></a>Date:</h3><pre><code>类 Date 表示特定的瞬间，精确到毫秒。
它允许把日期解释为年、月、日、小时、分钟和秒值。它也允许格式化和解析日期字符串.
</code></pre><h4 id="构造方法：-1"><a href="#构造方法：-1" class="headerlink" title="构造方法："></a>构造方法：</h4><pre><code>Date(): 表示创建对象的系统时间（精确到毫秒值）
Date(long date)
</code></pre><p>@Deprecated<br>过时的, 不推荐使用, 可能在以后的版本中删除。</p>
<p>问题1：长整数为什么可以转换成Date.<br>    标准基准时间(epoch): 1970 年 1 月 1 日 00:00:00 GMT<br>    可以用长整数表示离基准时间的毫秒值。</p>
<p>问题2：为什么时间选在 1970 年 1 月 1 日 00:00:00;<br>    用int表示秒值：    1902 ~ 1970 ~ 2038<br>    long表示毫秒值：<br>方法：<br>    long getTime() 返回自基准时间以来此 Date 对象表示的毫秒数。<br>    long setTime() 设置time的值</p>
<p>日期的格式化和解析(dateFormat)：<br>    2019-07-08 14:56:00<br>    2019/07/08 14:56:00<br>    2019年07月08日 14:56:00</p>
<h4 id="DateFormat类："><a href="#DateFormat类：" class="headerlink" title="DateFormat类："></a>DateFormat类：</h4><pre><code>public abstract class DateFormat
</code></pre><p>格式化：日期 –&gt; 文本   Date –&gt; String<br>解析：  文本 –&gt; 日期   String –&gt; Date</p>
<p>成员方法：<br>     String format(Date date)<br>     Date parse(String source)</p>
<p>SimpleDateFormat:<br>模式字母:<br>    y   年<br>    M   月<br>    d   日<br>    H   时<br>    m   分<br>    s   秒</p>
<p>构造方法：<br>    SimpleDateFormat()<br>        给定一个默认模式(不推荐使用)<br>    SimpleDateFormat(String pattern)<br>        给定一个指定的模式</p>
<p>注意事项：<br>    用什么模式格式化，就用该模式解析，否则会抛出ParseException<br>    看如下例子：</p>
<pre><code>public class DateDemo2 {
    public static void main(String[] args) throws ParseException {
        DateFormat df1 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
        DateFormat df2 = new SimpleDateFormat(&quot;yyyy/MM/dd HH:mm:ss&quot;);
        Date date1 = new Date();
        String s = df1.format(date1);
        Date date2 = df2.parse(s); //这里会报错，因为用了不同的模式来格式化和解析
        //使用了df1进行格式化
        //使用了df2来解析 报错
    }
}
</code></pre><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><pre><code>public final class Math
</code></pre><p>  概述：Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。<br>  字段：E: 自然对数的底；PI: 圆周率</p>
<p>  方法：<br>      工具类都是static方法，之前有介绍过，返回的都是浮点数的值；<br>      public static int abs(int a)<br>      public static double ceil(double a)<br>      public static double floor(double a)<br>      public static int max(int a,int b) min自学<br>      public static int round(float a)<br>      public static double pow(double a,double b)<br>      public static double random()<br>      public static double sqrt(double a)</p>
<h3 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h3><p>  这是一门大学问。并不是简单的就说清楚的，这里写一些简单的IDEA自带的快捷键<br>  shift + F9 debug模式运行程序，或者点左边的小虫子；<br>  Frames: 代表栈帧 写的入栈的方法；<br>  step over: 快捷键 F8，跳出方法执行完<br>  step into 快捷键 F7，进入你自己写的方法<br>  force step into 快捷键 alt + shift + f7可以进入java写的方法；<br>  step out : 快捷键 shift + F8<br>  ctrl + F2：结束当前debug</p>
<p>  其他还不怎么会用<br>  这里调试就遇到一个问题。<br>  两个StringBufferappend时候，使用IDEA进入append里面就出现问题了。</p>
<pre><code> StringBuffer s1 = new StringBuffer(&quot;hello&quot;);
 StringBuffer s2 = new StringBuffer(&quot;wowowowo&quot;);
 s1 = s2;
 s2 = s2.append(s1);
// change(s1,s2);
 System.out.println(&quot;s1: &quot; + s1);
 System.out.println(&quot;s2: &quot; + s2);
</code></pre><p>正常应该打印出两个wowowowowowowowo<br>如果debug进入了append里面就会出问题。<br>打印出两个只有wowowowo；</p>
<p>最后还是老师厉害，找到了问题的原因。就是因为IDEA在debug模式下会调用toString方法。<br>而StringBuffer里面有个toStringCache的属性一开始是要置null的。后来因为IDEA默认调用了toString()</p>
<pre><code>public synchronized String toString() {
    if (toStringCache == null) {
        toStringCache = Arrays.copyOfRange(value, 0, count);
    }
    return new String(toStringCache, true);
}
</code></pre><p>这就把toStringCache给修改了。</p>
<h2 id="星期二："><a href="#星期二：" class="headerlink" title="星期二："></a>星期二：</h2><h3 id="1-异常"><a href="#1-异常" class="headerlink" title="1.异常"></a>1.异常</h3><p>异常的分类：<br>Throwable<br>  |–Error: (a. 天灾人祸) 虚拟机出现了问题<br>  |–Exception:<br>      |–编译期异常：(b. 出发之前应该检查的异常) 必须处理，否则编译不通过<br>      |–RuntimeException:(c. 运行过程中出现的异常) 可<br>          以处理，也可以不处理。出现这个问题，一般都是代码逻辑有问题，建议修改代码逻辑。</p>
<p>JVM对异常的默认处理：<br>  a. 哪个线程出现了问题<br>  b. 异常的类型以及详细信息<br>  c. 调用栈信息<br>  d. 终止程序（这就是我们要自己处理异常的原因）</p>
<p>如何自己处理异常：<br>a. try…catch…finally  自己处理<br>b. throws  抛给调用处处理</p>
<p>try…catch…finally语句<br>try {<br>    要检查的代码<br>} catch (异常类型 对象名) {<br>    对异常的处理<br>} finally {<br>    释放资源<br>}<br>注意事项：<br>  a. try里面的代码越少越好,最好只放可能出现异常的代码<br>  b. try里面出现了异常，就不会执行try里面里面后序的代码<br>  c. ArithmeticException e 是局部变量, 作用范围是对应的catch语句。<br>  d. catch 捕获了异常，执行对应的处理，异常就不再存在了。</p>
<p>问题：为什么e局部变量会有值？<br>  如果try里面出现了异常, JVM会把异常信息封装成对应类型的异常对象。<br>  然后和catch语句依次匹配，找到对应的异常类型，然后把它赋值给引用变量e。e的作用域就只有catch里面切记！</p>
<p>多种异常的情况：<br>    a. 一个一个处理 写多个try…catch<br>    b. 一次性处理   写一个try…catch…catch…catch;<br>    c. JDK7 新特性<br>        把多个处理方式相同的catch语句，合成一个catch语句。<br>        catch(类型1 | 类型2 | 类型3… e)<br>注意事项：<br>  一个try语句中, 最多只会抛出一个异常，最多也只会执行一个catch语句<br>  如果异常没有兼容关系，谁先谁后没关系，如果有兼容关系，那么父类应该方法在子类之后。要不然会执行父类的catch不执行子类catch;</p>
<p>编译期异常和运行时异常：<br>Exception:<br>    |– 运行时异常: RuntimeException和其子类。<br>        可以显示处理，也可以不处理，<strong><em>一般出现运行时异常，都是代码逻辑有问题，推荐修改代码逻辑。</em></strong><br>    |– 编译期异常：其他类。无论运行时是否发生异常，都必须显示处理，否则无法通过编译。</p>
<p>Throwable:<br>    概述：Throwable 类是 Java 语言中所有错误或异常的超类。只有当对象是此类（或其子类之一）的实例时，<br>    才能通过 Java 虚拟机或者 Java throw 语句抛出。<br>    类似地，只有此类或其子类之一才可以是 catch 子句中的参数类型。</p>
<p>构造方法：<br>    Throwable():  构造一个将 null 作为其详细消息的新 throwable。<br>    Throwable(String message): 构造带指定详细消息的新 throwable。<br>成员方法：<br>     String getMessage() 返回此 throwable 的详细消息字符串。<br>     String toString():<br>        getClass().getName() + “: “ + getMessage();<br>     void printStackTrace()<br>     // void printStackTrace(PrintStream s) //日志文件</p>
<h3 id="throws-and-throw"><a href="#throws-and-throw" class="headerlink" title="throws and throw"></a>throws and throw</h3><p>throws: 把问题抛给调用者<br>    a. 编译期异常<br>    b. 运行时异常<br>注意事项：<br>    不要在main()方法抛出异常，如果抛出异常就会执行JVM的默认处理</p>
<p>throws 和 throw 的区别<br>throws<br>    用在方法声明后面，跟的是异常类名, 可以跟多个异常类名<br>    表示抛出异常，由该方法的调用者来处理<br>    throws表示出现异常的一种可能性，并不一定会发生这些异常<br>例如：<br>    private static void checkScore(int score) throws Exception</p>
<p>throw<br>    用在方法体内，跟的是异常对象<br>    只能抛出一个异常对象<br>    表示抛出异常，由方法体内的语句处理<br>    throw抛出了一个实实在在的异常<br>例如：<br>    throw new Exception(“score=” + score);</p>
<p>注意：一般throw和throws连用</p>
<h3 id="我们到底该怎么处理异常："><a href="#我们到底该怎么处理异常：" class="headerlink" title="我们到底该怎么处理异常："></a>我们到底该怎么处理异常：</h3><p>原则：如果该方法知道如何处理，那用try…catch, 如果不知道怎么处理，就抛给它的调用者去处理。<br>区别：<br>    如果try…catch，后续代码会执行。<br>    如果throws,后续代码不会被执行。</p>
<p>try语句的变形<br>    try…catch<br>    try…finally<br>    try…catch…finally<br>    try…catch…catch…<br>    try…catch…catch…finally</p>
<p>finally语句：<br>特点：<br>    被finally控制的语句体无论出现异常还是没有出现异常，都会执行。<br>    特殊情况：在执行到finally之前jvm退出了. System.exit();<br>作用：<br>    释放系统资源<br>面试题：<br>final: 最终的<br>    类：不能被继承<br>    方法：不能被重写<br>    变量：常量<br>finally:<br>    try语句的子句。<br>    finally里面的语句, 无论出现异常还是不出现异常，都会被执行。<br>    用来释放资源。<br>finalize:<br>    Object中的方法。<br>    对象被回收前，该方法会被自动执行。用来释放资源。<br>    手动调用该方法，对象不会被回收。</p>
<p>finally:<br>如果catch里面有return语句，请问finally的代码还会执行吗?如果会，请问结果是怎样的？<br>  <strong>finally语句会被执行</strong><br>  第一次执行return语句，就已经生成了返回路径, 并把返回值保存起来了。<br>  后面在finally语句中修改变量，不会影响返回值。</p>
<p>如果finally中也有return语句。<br>    最终执行的是finally中语句。</p>
<p>自定义异常：<br>    类名就代表异常的种类(信息)<br>    编译期异常：继承Exception<br>    运行时异常：继承RuntimeException</p>
<p>一般都会用到自定义的异常，这里有个自定义异常学习一下：</p>
<pre><code>public class CommonException extends RuntimeException {

  private static final long serialVersionUID = -1466743861132712630L;

  /** 默认业务异常 */
  private int level = 1;

  /** 异常编号 */
  private short code = 100;

  /** 异常信息 */
  private List&lt;Object&gt; paramsList = new ArrayList&lt;Object&gt;();

  /**
   * 创建一个 {@link CommonException}。
   *
   * @param message
   *            异常消息
   */
  public CommonException(String message) {
    super(message);
  }

  /**
   * 创建一个{@link CommonException}。
   *
   * @param code
   *            错误代码
   * @param message
   *            异常消息
   */
  public CommonException(short code, String message) {
    super(message);
    this.code = code;
  }
}
</code></pre><p>这里有几个知识点需要了解：<br>  1.序列化serialVersionUID，每个类都有自己的UID。可以看看这里：<br>  <a href="https://blog.csdn.net/qq_40670946/article/details/88106817" target="_blank" rel="external">序列化介绍</a><br>  2.把异常的信息放在ArrayList里面，这有点秀</p>
<p>异常注意的事项：(编译期异常)<br>    子类重写父类方法时，子类的方法必须抛出相同的异常或父类异常的子类。<br>    如果父类抛出了多个异常,子类重写父类时,只能抛出相同的异常或者是他的子集,子类不能抛出父类没有的异常<br>    如果被重写的方法没有异常抛出,那么子类的方法绝对不可以抛出异常,如果子类方法内有异常发生,那么子类只能try,不能throws</p>
<pre><code>儿子不能比父亲更坏。一代只能比一代强。
编译的时候，不检查运行时异常
</code></pre><h3 id="Collection集合"><a href="#Collection集合" class="headerlink" title="Collection集合"></a>Collection集合</h3><p>容器：<br>  集合：<br>      长度是可变的，但是只能存储引用数据类型的数据。<br>      内置了许多方法，可以方便操作容器里面的元素。<br>  数组：<br>      a. 长度固定。<br>      b. 只能存储同一类型的数据。<br>      c. 没有内置方法，以便操作容器里面的元素</p>
<p>public interface Collection: (JDK1.2)<br>  Collection 层次结构中的根接口。Collection 表示一组对象，这些对象也称为 collection 的元素。<br>  一些 collection 允许有重复的元素，而另一些则不允许。一些 collection 是有序的，而另一些则是无序的。</p>
<p>方法：（返回值都是boolean类型）<br>增：</p>
<pre><code>boolean add(Object e)
boolean addAll(Collection c)
</code></pre><p>删：</p>
<pre><code>void clear()
boolean remove(Object o)
boolean removeAll(Collection c)
boolean retainAll(Collection c)
</code></pre><p>改：</p>
<pre><code>collection没有修改的方法；
</code></pre><p>查：</p>
<pre><code>boolean contains(Object o)
boolean containsAll(Collection c)
</code></pre><p>遍历：</p>
<pre><code>Iterator iterator()
Object[] toArray()
</code></pre><p>获取集合的属性：</p>
<pre><code>boolean isEmpty()
int size()
</code></pre><p>集合遍历的两种方法：<br>Object[] toArray()<br>如下例子：</p>
<p>// 如果元素是”java”， 就将它换成“javaSE”<br>    public static void main(String[] args) {<br>            Collection c = new ArrayList();<br>            c.add(“Hello”);<br>            c.add(“world”);<br>            c.add(“java”);<br>            Object[] objects = c.toArray();</p>
<pre><code>// 改变objects里面的值，不会修改集合的值
for(int i = 0; i &lt; objects.length; i++) {
    String s = (String) objects[i];
    if (&quot;java&quot;.equals(s)) {
        objects[i] = &quot;javaSE&quot;;
    }
}
</code></pre><p><strong>注意事项：toArray()不改变集合的值</strong></p>
<p><strong><em>Iterator iterator()</em></strong><br>iterator并没有修改集合元素的方法，set()方法在子类list才有</p>
<pre><code>public static void main(String[] args) {
    Collection c = new ArrayList();
    c.add(&quot;Hello&quot;);
    c.add(&quot;world&quot;);
    c.add(&quot;java&quot;);
    //迭代器使用for循环
    for(Iterator it = c.iterator();it.hasNext();) {
      String s = (String) it.next();
      System.out.println(s);
    }
}
</code></pre><p>使用迭代器但是要使用子类的迭代器才有set()方法</p>
<p> @SuppressWarnings(“unchecked”)</p>
<pre><code>public class CollectionDemo3 {
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;Hello&quot;);
        list.add(&quot;world&quot;);
        list.add(&quot;java&quot;);

        for(ListIterator it = list.listIterator(); it.hasNext();) {
          String s = (String) it.next();
          if(&quot;java&quot;.equals(s)){
            it.set(&quot;javaSE&quot;);
          }
        }
        System.out.println(list);
    }
}
</code></pre><h4 id="public-interface-Iterator"><a href="#public-interface-Iterator" class="headerlink" title="public interface Iterator:"></a>public interface Iterator:</h4><pre><code>boolean hasNext()
E next()
void remove()
</code></pre><h4 id="Iterator-iterator"><a href="#Iterator-iterator" class="headerlink" title="Iterator iterator()"></a>Iterator iterator()</h4><pre><code>public interface Iterator:
boolean hasNext()
    判断是否有下一个元素
E next()
    将迭代器移动到下一个位置，并返回越过的元素
void remove()
    删除最近返回的元素
</code></pre><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><p>1.next()和nextline()不要混用，因为next()不会接收回车，如果next()用完直接用nextLine()就会接受不到第二个的内容<br>2.markdown语法 写超链接</p>
<pre><code>[简书](http://jianshu.com)
</code></pre><p>3.@SuppressWarnings(“unchecked”)<br>使用了未经检查或不安全的操作。这是因为没有用泛型导致的，需要在<br>类外面加上@SuppressWarnings(“unchecked”)后面没有分号<br>或者在定义集合的时候使用泛型<br><a href="https://www.jianshu.com/p/b6a818dbd99b" target="_blank" rel="external">点我了解更多</a></p>
<h2 id="星期三："><a href="#星期三：" class="headerlink" title="星期三："></a>星期三：</h2><p>1.List:<br>就简单介绍了一下List的方法和listIterator迭代器的方法，这周的后面几天我会一步一步的实现</p>
<h2 id="星期四："><a href="#星期四：" class="headerlink" title="星期四："></a>星期四：</h2><p>感觉今天讲的东西有点乱，所以需要来整理一下；</p>
<p>今天先讲了以下内容：<br>一些时间复杂度的东西<br>O(1) O(logn) O(n) O(nlogn) O(n^2)</p>
<h3 id="初识LinkedList"><a href="#初识LinkedList" class="headerlink" title="初识LinkedList"></a>初识LinkedList</h3><pre><code>public class LinkedList implements List, Deque;
</code></pre><p>特点：<br>    底层是链表实现：增删快，查找慢<br>    线程不安全，效率高</p>
<p>构造方法：(链表天然支持无限扩容)<br>    LinkedList() 构造一个空列表。<br>    LinkedList(Collection c) 构造一个包含指定 collection 中的元素的List</p>
<p>通过三个例子理解一下（重要）<br><strong><em>LinkedListDemo1</em></strong>： 求链表中间节点<br>分析：<br>a. 求链表的长度<br>b. 从头开始遍历，遍历到中间位置即可</p>
<pre><code>public static Node valueOfMid(Node head) {
    // 短路原则
    if (head == null || head.next == null) return head;
    int len = 0;
    Node node = head;
    while (node != null) {
        len++;
        node = node.next;
    }
    node = head;
    int count = 1;
    // 判断第一个节点是否小于中间的索引值
    while (count &lt; (len + 1) / 2) {
        node = node.next;
        count++;
    }
    return node;
}
</code></pre><p>count &lt; (len + 1) / 2) 能够稳定找到奇数和偶数中间那个数</p>
<p><strong><em>LinkedListDemo2</em></strong>：反转链表<br>a:<br>    输入：null<br>    返回：null<br>b:<br>    输入：1 –&gt; null<br>    返回：1 –&gt; null<br>c:<br>    输入：1 –&gt; 2 –&gt; 3 –&gt; null<br>    返回：3 –&gt; 2 –&gt; 1 –&gt; null</p>
<p>两种方法：<br>  方法一：正常的指针变换的思想<br>    指针翻转需要三个指针：<br>    设置一个pre一开始指向null<br>    null  head    nextNode<br>    pre   cursor  next</p>
<pre><code>public static Node reverse(Node head) {
  if(head == null|| head.next ==null) {
    return head;
  }
  Node pre = null;
  Node curr = head;
  while(curr != null){
    //只能改变一个指针的方向。改变两个会找不到next的下一个
    Node nextNode = head.next;  //先找到下一个结点
    curr.next = pre;
    pre = curr;
    curr = nextNode;
  }
  return pre;
}
</code></pre><p>  方法二：迭代的思想<br>  n个反转= head 和后面n-1个反转; 后面反转完成，再修改head的值<br>  画图解释一下<br>  第一步：reverse(n)<br>  head(0) -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; null;</p>
<p>  第二步：后面n-1反转reverse(n-1)<br>  head(0) -&gt; 1 &lt;- 2 &lt;- 3 &lt;- 4<br>  1 -&gt; null</p>
<p>  第三步：第一个反转：<br>  null &lt;- head(0) &lt;- 1 &lt;- 2 &lt;- 3 &lt;- 4</p>
<p>  head = head.next.next; //使1指向head<br>  head.next = null;      //使head指向null<br>  return 最后一个结点；</p>
<pre><code>public static Node reverse(Node head) {
      if (head == null || head.next == null) return head;
      Node node = reverse(head.next);   //返回的是最后的结点，就是最终的头节点
      head.next.next = head;
      head.next = null;
      return node;
}
</code></pre><p><strong><em>LinkedListDemo3</em></strong>:<br>判断一个链表是否存在环？以及入环的结点<br>两个方法：<br>  方法一：正常想法的放在集合里面遍历，当找到重复结点时，就是入环的结点：看一下复杂度：时间复杂度o(n) 空间复杂度O(n)<br>  具体步骤：<br>  a. 用一个集合存储已经遍历过的节点<br>  b. 每遍历一个新的节点, 首先判断是否在集合中存在？<br>      如果存在：return true<br>      如果不存在: 添加到集合。<br>  c. 当指针指向null<br>      return false;</p>
<pre><code>public static Node getCircle(Node head) {
  Collection c = new ArrayList();
  Node node = head;
  while(node.next != null){
    if(c.contains(node)) {
      return node;
    }
    c.add(node);
    node = node.next;
  }
  return null;
}
</code></pre><p>  方法二：快慢指针。<br>  设置两个指针一个指针快一个指针慢，如果两个指针能指向一个结点，那就证明有环<br>  那么如何找到那个入环的结点？</p>
<p>  快慢指针做：这有点难<br>  首先需要假设几个变量；</p>
<pre><code>从头走到入环地方需要走 A 步
从入环的结点走到两个第一次相遇的结点要走 X 步
我们假设环里面有 k 个结点
</code></pre><p>  然后我们知道两个指针的速度1:2</p>
<pre><code>slow = slow.next
fast = fase.next.next
</code></pre><p>  然后走的时间是相等的<br>  最后得出一个等式</p>
<pre><code>2（a + x） = a + x + nk
</code></pre><p>  n表示快的在里面走了n圈；<br>  得出一个结果</p>
<pre><code>a = nk -x;
</code></pre><p>  然后就能求出入环的结点；<br>  分为两个部分：<br>  1）两个在环中的一部分相遇<br>  2）把慢指针移动回到头，然后两个人速度都变成1<br>  通过式子a = nk -x;<br>  就知道慢指针走a步  快指针走nk-x步时候。两个人再次相遇。这时两个人相遇的结点就是入环的第一个结点，因为a就是头距离入环结点的距离<br>  时间复杂度o(n) 空间复杂度O(1)；</p>
<pre><code>public static Node getCircle(Node head) {
  if(head == null || head.next ==null) return null;
  Node fast = head.next.next;
  Node slow = head.next;
  //这里两个结点的比较用 == 就是为了比较地址
  while(fast != null &amp;&amp;fast.null != null &amp;&amp; fast != slow) {
    fast = fast.next.next;
    slow = slow.next;
  }
  if(fast == null || fast.null == null) {
    return null;
  }
  //说明有环而且已经相遇
  slow = head; //把slow放回第一个结点，然后大家都走一步
  while(fast != slow) {
    slow = slow.next;
    fast = fast.next;
  }
  return slow;
}
</code></pre><h2 id="初识ArrayList"><a href="#初识ArrayList" class="headerlink" title="初识ArrayList"></a>初识ArrayList</h2><p>之后会解析源码和linkedlist一起；</p>
<p><strong><em>注意去重的时候指针的问题，看下面例子：</em></strong><br>  输入：hello world java java hello<br>  输出：hello world java</p>
<p>方法一：<br>和判断是否环类似的思想，新建一个集合，从旧的集合里面取出元素。如果集合里面没有这个元素就把这个元素放进集合中。否则不放。这种方法简单快捷；<br>    时间复杂度：O(n^2) 空间复杂度：O(n)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public static List distinct(List list) &#123;</div><div class="line">    if (list == null) return null;</div><div class="line">    List newList = new ArrayList();</div><div class="line">    for (Iterator iterator = list.iterator(); iterator.hasNext(); ) &#123;</div><div class="line">        String s = (String) iterator.next();</div><div class="line">        if (!newList.contains(s)) &#123;</div><div class="line">            newList.add(s);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return newList;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>方法二：直接设置两个指针对里面的元素进行操作，类似于简单选择排序。<strong>然后移动指针即可但是这里注意一个问题。remove完了之后。他会自动把后面的元素都前移。所以j指针还要j–否则将会跳过一个元素判断</strong>；<br>  时间复杂度：O(n^3) 空间复杂度：O(1)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public static List distinct(List list) &#123;</div><div class="line">  if (list == null) return null;</div><div class="line">  // int size = list.size();</div><div class="line">  for(int i = 0; i &lt; list.size() - 1; i++) &#123;</div><div class="line">      String s = (String) list.get(i);</div><div class="line">      for (int j = i + 1; j &lt; list.size(); j++) &#123;</div><div class="line">          if (list.get(j).equals(s)) &#123;</div><div class="line">              list.remove(j);</div><div class="line">              j--; // caution ：这里必须要j-- 因为后一个元素已经移动了删除元素的位置，所以这个位置必须重新判断</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">  return list;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="学习Vector"><a href="#学习Vector" class="headerlink" title="学习Vector"></a>学习Vector</h3><p>线程安全但是不常用；</p>
<h3 id="最后学习了泛型"><a href="#最后学习了泛型" class="headerlink" title="最后学习了泛型"></a>最后学习了泛型</h3><p>三种： 泛型类 泛型方法 泛型接口</p>
<p>1.泛型类：</p>
<pre><code>class Generic&lt;T&gt;{
}
</code></pre><p>Generic<string> g = new Generic&lt;&gt;();</string></p>
<p>2.泛型方法<br>1）在普通类中</p>
<pre><code>class Normal{
  public &lt;T&gt; void show(T t){

  }
}
</code></pre><p>需要在返回值类型前面加<t> 要不然是不知道show(T t)是什么类型的<br>2）在泛型类中</t></p>
<pre><code>class Generic&lt;T&gt; {
  public void show(T t){

  }
}
</code></pre><p>就不需要写<t>在方法声明上，因为这个类是泛型了就知道T是什么了</t></p>
<p>3.泛型接口</p>
<pre><code>inferface GenericInterFace &lt;T&gt;{
  T f1(); //返回值是T类型的方法f1
  show(T t);
}
</code></pre><p>实现接口也有两种类<br>1）普通类实现泛型接口</p>
<pre><code>class Normal implements GenericInterFace&lt;String&gt; {  //这里就要确定泛型的类型是什么，因为这个类不知道&lt;T&gt;是什么
  @Override
  public String f1(){  //一定要写public 不然权限不够

  }
  @Override
  public void show(String s){ //一定要写public 不然权限不够

  }
}
</code></pre><p>main:<br>  Normal n = new Normal();<br>  n.show(“1234”);</p>
<p>2)泛型类实现泛型接口</p>
<pre><code>class GenericClass&lt;T&gt; implements GenericInterFace(T) {
  public T f1(){

  }
  public void show(T t){

  }
}
</code></pre><p>main:</p>
<pre><code>GenericClass GC&lt;String&gt; = new GenericClass&lt;&gt;();
GC.show(&quot;sadasdasd&quot;);
</code></pre><p>当然能设置多个泛型类的类型</p>
<pre><code>class GenericClass&lt;T,U&gt; implements GenericInterFace(T) {
  public T f1(){

  }
  public void show(T t){

  }
}
</code></pre><p>但是传给接口只能是一个类型；所以你要确定传给接口是什么类型的；</p>
<pre><code>GenericClass GC2&lt;String,Integer&gt; = new GenericClass&lt;&gt;();
// 在类里面已经写了
class GenericClass&lt;T,U&gt; implements GenericInterFace(T)；
传入的是T，所以是String类型的泛型；用的接口也是String类型的；
</code></pre><h2 id="星期五"><a href="#星期五" class="headerlink" title="星期五"></a>星期五</h2><pre><code>JDK1.5新特性
  a. 泛型
  b. foreach
  c. 可变参数
  d. 包装类（自动装箱和自动拆箱）
  e. 静态导入
</code></pre><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>除了之前介绍的三种类型还有以下几种需要注意一下：<br>第一个知识点：首先数组是可协变的类型；<br>什么是可协变的？<br><a href="https://blog.csdn.net/Just_keep/article/details/79482365" target="_blank" rel="external">简单的介绍协变和逆变</a><br>这里就说了剩下的几种用法，不过应该是用在接口的定义上的<strong>返回值</strong>可能比较多例如</p>
<pre><code>public &lt;? super Fruit&gt; getFruit(){
}
</code></pre><h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><p>增强for循环：<br>  简化数组和Collection集合的遍历<br>  格式：<br>    for(元素数据类型 变量名 : 数组或者集合) {<br>      使用变量即可，该变量就是元素<br>    }<br>  缺点：没有索引信息。<br>  foreach 的底层其实迭代器。<br>什么情况下可以使用增强for循环：<br>  只要有迭代器，就可以使用增强for循环<br>  Iterable: Iterator iterator();</p>
<h3 id="可变参数variableParameter"><a href="#可变参数variableParameter" class="headerlink" title="可变参数variableParameter"></a>可变参数variableParameter</h3><p>格式：修饰符 返回值类型 方法名(数据类型…  变量名){}<br>优点：<br>  不需要封装数据<br>  更加直观<br>缺点：<br>  只能有一个可变参数，并且只能在最后<br>注意事项：<br>  a. 可变参数底层其实是数组<br>  b. 可变参数必须方法最后</p>
<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><p>JDK1.5新特性 (语法糖，提高程序员的编码效率)<br>自动装箱： 基本数据类型 –&gt; 包装数据类型<br>   int i = 10;<br>   Integer itg = Integer.ValueOf(i);<br>自动拆箱： 包装数据类型 –&gt; 基本数据类型<br>   Integer itg = new Integer(10);<br>   int i = itg.intValue();</p>
<p>可以接着往下看，或者看下篇</p>
<h2 id="星期六"><a href="#星期六" class="headerlink" title="星期六"></a>星期六</h2><h3 id="学习数据结构List"><a href="#学习数据结构List" class="headerlink" title="学习数据结构List"></a>学习数据结构List</h3><p>主要就是学习源码为什么这样写。有几点需要注意：<br>1）我们只学习核心的方法和迭代器的方法<br>2）迭代器的指针是指向两个结点之间的位置上的。这一定要注意；<br>3）一些细节上的问题我会说清楚</p>
<h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><p>1）我们需要一个List接口。两个list都继承这个接口的方法<br>2）我们需要一个iterator接口，两个类的子类对象要继承这个接口的方法<br>3）这个类的子类要和父类数据互通，不想被其他类访问最好就放在内部类<br>4）出现的异常<br>IllegalArgumentException   抛出的异常表明向方法传递了一个不合法或不正确的参数。<br>ArrayStoreException       试图将错误类型的对象存储到一个对象数组时抛出的异常。<br>IndexOutOfBoundsException 指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。<br>ConcurrentModificationException ： 当方法检测到对象的并发修改，但不允许这种修改时，抛出此异常。<br>IllegalStateException  在非法或不适当的时间调用方法时产生的信号。换句话说，即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下。<br>NoSuchElementException  由 Enumeration 的 nextElement 方法抛出，表明枚举中没有更多的元素。</p>
<h3 id="实现的步骤（以ArrayList为例）；"><a href="#实现的步骤（以ArrayList为例）；" class="headerlink" title="实现的步骤（以ArrayList为例）；"></a>实现的步骤（以ArrayList为例）；</h3><p>1）先定义出 List 接口和 iterator 接口<br>2）然后写 ArrayList<br>    1.属性<br>    2.构造方法<br>    3.重写 List 方法<br>3）实现 iterator 接口<br>    1.属性<br>    2.构造方法<br>    3.重写方法</p>
<h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><pre><code>public interface MyList {
    boolean add(String s);
    void add(int index, String s);
    void clear();
    boolean contains(String s);
    String get(int index);
    int indexOf(String s);
    boolean isEmpty();
    MyIterator iterator();
    int lastIndexOf(String s);
    String remove(int index);
    boolean remove(String s);
    String set(int index, String s);
    int size();
}
</code></pre><h3 id="ListIterator接口"><a href="#ListIterator接口" class="headerlink" title="ListIterator接口"></a>ListIterator接口</h3><pre><code>public interface MyIterator {
    void add(String s);
    boolean hasNext();
    boolean hasPrevious();
    String next();
    String previous();
    int nextIndex();
    int previousIndex();
    void remove();
    void set(String s);
}
</code></pre><h3 id="源码解析ArrayList"><a href="#源码解析ArrayList" class="headerlink" title="源码解析ArrayList"></a>源码解析ArrayList</h3><p>  1.属性<br>  分析：首先ArrayList是顺序存储的，而且是一个动态的数组，所以我们需要一个数组装元素elements[]，一个属性表示容量。还需要属性来表示长度（size）,<strong>为了处理并发修改异常还需要一个属性来记录在迭代器迭代时候，集合有没有修改元素modCount</strong></p>
<pre><code>//属性
public static final int MAX_CAPACITY = Integer.MAX_VALUE - 8; //最大长度
public static final int DEFAULT_CAPACITY = 10; //默认长度
private int size;
private String[] elements;
private int modCount; // modification count 统计修改的次数
</code></pre><p>  2.构造方法<br>    分析：构造方法没有参数，就用默认容量还作为长度。或者用户会手动输入一个长度，对这个长度判断。是否超过最大长度</p>
<pre><code>// 构造方法
public MyArrayList() {
    elements = new String[DEFAULT_CAPACITY];
}

public MyArrayList(int capacity) {
    if (capacity &lt; 0 || capacity &gt; MAX_CAPACITY) {
        throw new IllegalArgumentException(&quot;capacity=&quot; + capacity);
    }
    elements = new String[capacity];
}
</code></pre><p>  3.方法<br>  这里有两点要说明：<br>  <strong>1.先挑软柿子捏，至于为什么等下告诉你</strong><br>  <strong>2.在写方法时不一定全部都要自己动手，可以调用本类其他方法，当然内部类（iterator）可以调用外部类来实现自己的功能。当然这些方法一般都是软柿子，一个大的功能由小功能组成的</strong></p>
<p>add(s)调用同名的兄弟解决<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 在线性表末尾添加元素</div><div class="line"> * @param s 要添加的元素</div><div class="line"> * @return 添加成功返回true, 否则返回false</div><div class="line"> */</div><div class="line">@Override</div><div class="line">public boolean add(String s) &#123;</div><div class="line">    add(size, s);</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法比较难了，主要难点在于<br>1.添加是否会使得数组本身就满了需要扩容<br>2.扩容的过程会不会出现大于集合最大长度的情况<br>3.扩容的最佳分配是什么（这里就默认扩容1.5倍）<br>4.同样需要进行modCount++ size++;</p>
<pre><code>/**
 * 在指定的索引位置添加元素
 * @param index 索引
 * @param s 添加的元素
 */
@Override
public void add(int index, String s) {
    checkIndexForAdd(index);
    // 确保容量够大
    int minCapacity = size + 1;
    if (minCapacity &gt; elements.length) {   //需要扩容
        // 计算新数组的长度
        int newLength = calculateCapacity(minCapacity);
        // 扩容
        grow(newLength);
    }
    // 添加元素
    for(int i = size; i &gt; index; i--) {
        elements[i] = elements[i-1];
    }
    elements[index] = s;
    size++;
    modCount++;
}

private void grow(int newLength) {
    String[] newArr = new String[newLength];
    for(int i = 0; i &lt; size; i++) {
        newArr[i] = elements[i];
    }
    // 将elements指向新的数组
    elements = newArr;
}

private int calculateCapacity(int minCapacity) {
    if (minCapacity &gt; MAX_CAPACITY || minCapacity &lt; 0) {
        throw new IllegalArgumentException();//不是ArrayStoreException异常
    }
    // 一定能存下这么多数据
    int len = elements.length + (elements.length &gt;&gt; 1); //扩容1.5倍
    if (len &gt; MAX_CAPACITY || len &lt; 0) {
        len = MAX_CAPACITY;
    }
    // 返回minCapacity和len的较大值
    return len &gt; minCapacity ? len : minCapacity;
}
</code></pre><p>检查index是否符合添加的条件注意可以在size位置添加的</p>
<pre><code>private void checkIndexForAdd(int index) {
    if (index &lt; 0 || index &gt; size) {
        throw new IndexOutOfBoundsException(&quot;index=&quot; + index + &quot;, size=&quot; + size);
    }
}
</code></pre><p>注意清空操作算是修改链表长度的操作。需要modCount++<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 清空线性表</div><div class="line"> */</div><div class="line">@Override</div><div class="line">public void clear() &#123;</div><div class="line">    // elements = null;</div><div class="line">    modCount++;</div><div class="line">    for(int i = 0; i &lt; size; i++) &#123;</div><div class="line">        elements[i] = null;</div><div class="line">    &#125;</div><div class="line">    size = 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>contains调用indexOf(s)解决<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 判断元素是否在线性表中存在</div><div class="line"> * @param s 元素</div><div class="line"> * @return 如果存在返回true, 否则返回false</div><div class="line"> */</div><div class="line">@Override</div><div class="line">public boolean contains(String s) &#123;</div><div class="line">    int index = indexOf(s);</div><div class="line">    if (index == -1) &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>直接返回数组元素值就行，软柿子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 获取指定索引位置的值</div><div class="line"> * @param index 索引</div><div class="line"> * @return 值</div><div class="line"> */</div><div class="line">@Override</div><div class="line">public String get(int index) &#123;</div><div class="line">    checkIndex(index);</div><div class="line">    return elements[index];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<pre><code>private void checkIndex(int index) {
    if (index &lt; 0 || index &gt;= size) {
        throw new IndexOutOfBoundsException(&quot;index=&quot; + index + &quot;, size=&quot; + size);
    }
}
</code></pre><p>indexOf是很多兄弟都要用到，所以这个方法是否正确就很重要了，不能马虎<br>需要判断用户给的String是不是null来判断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 查找元素在线性表中第一次出现的位置</div><div class="line"> * 注意这里需要判断是不是null</div><div class="line"> * @param s 查找的元素</div><div class="line"> * @return 第一次出现的位置，如果不存在返回-1.</div><div class="line"> */</div><div class="line">@Override</div><div class="line">public int indexOf(String s) &#123;</div><div class="line">    if (s == null) &#123;</div><div class="line">        for(int i = 0; i &lt; size; i++) &#123;</div><div class="line">            if (elements[i] == null) &#123;</div><div class="line">                return i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        for(int i = 0; i &lt; size; i++) &#123;</div><div class="line">            if (s.equals(elements[i])) &#123;</div><div class="line">                return i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return -1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>软柿子+1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 判空</div><div class="line"> */</div><div class="line">@Override</div><div class="line">public boolean isEmpty() &#123;</div><div class="line">    return size == 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>迭代器后面具体说<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public MyIterator iterator() &#123;</div><div class="line">    return new Itr(0) ;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public MyIterator iterator(int index) &#123;</div><div class="line">    checkIndexForAdd(index);</div><div class="line">    return new Itr(index);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从后往前遍历也要判断一下用户传过来的null;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 查找元素在线性表中最后出现的索引</div><div class="line"> * @param s 查找的锇元素</div><div class="line"> * @return 最后一次的索引，如果不存在返回-1</div><div class="line"> */</div><div class="line">@Override</div><div class="line">public int lastIndexOf(String s) &#123;</div><div class="line">    if (s == null) &#123;</div><div class="line">        for(int i = size - 1; i &gt;= 0; i--) &#123;</div><div class="line">            if (elements[i] == null) &#123;</div><div class="line">                return i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        for(int i = size - 1; i &gt;= 0; i--) &#123;</div><div class="line">            if (s.equals(elements[i])) &#123;</div><div class="line">                return i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return -1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过下标找到位置<br>  1.拿出被删除的数<br>  2.然后移动数组<br>  3.记得modCount++因为修改了数组结构<br>  4.size–<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 删除指定索引位置的元素</div><div class="line"> * @param index 指定索引位置</div><div class="line"> * @return 被删除的元素</div><div class="line"> */</div><div class="line">@Override</div><div class="line">public String remove(int index) &#123;</div><div class="line">    checkIndex(index);</div><div class="line">    String oldValue = elements[index];</div><div class="line">    for(int i = index; i &lt; size - 1; i++) &#123;</div><div class="line">        elements[i] = elements[i+1];</div><div class="line">    &#125;</div><div class="line">    size--;</div><div class="line">    modCount++;</div><div class="line">    return oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过indexOf()找到下标然后给同名的兄弟remove(index)解决；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 删除第一个值等于s的元素</div><div class="line"> * @param s 给定的值</div><div class="line"> * @return 如果删除成功返回true，否则返回false.</div><div class="line"> */</div><div class="line">@Override</div><div class="line">public boolean remove(String s) &#123;</div><div class="line">    int index = indexOf(s);</div><div class="line">    if (index == -1) &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    remove(index);</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>软柿子，记得检查一下用户输入index是否有问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 把指定索引位置的值更新成新的值，并把旧的值返回</div><div class="line"> * @param index 索引</div><div class="line"> * @param s 新值</div><div class="line"> * @return 旧值</div><div class="line"> */</div><div class="line">@Override</div><div class="line">public String set(int index, String s) &#123;</div><div class="line">    checkIndex(index);</div><div class="line">    String oldValue = elements[index];</div><div class="line">    elements[index] = s;</div><div class="line">    return oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>软柿子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 线性表存储元素的个数</div><div class="line"> * @return 线性表存储元素的个数</div><div class="line"> */</div><div class="line">@Override</div><div class="line">public int size() &#123;</div><div class="line">    return size;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>软柿子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public String toString() &#123;</div><div class="line">    StringBuilder sb = new StringBuilder(&quot;[&quot;);</div><div class="line">    for (int i = 0; i &lt; size; i++) &#123;</div><div class="line">        sb.append(elements[i]);</div><div class="line">        if (i != size - 1) &#123;</div><div class="line">            sb.append(&quot;, &quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return sb.append(&quot;]&quot;).toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>—————————–内部类———————————————</p>
<p>接下来是内部类写迭代器也是老三样<br>  1.属性<br>  分析：首先需要cursor指向下一个元素，一个lastRet表示最近的访问的元素。还要校对是否出现并发修改异常设置一个exception</p>
<pre><code>private int cursor; //后面元素的索引位置
private int expModCount = modCount;
private int lastRet = -1; // -1表示没有返回元素
</code></pre><p>  2.构造方法 两种一种带index 一种不带。默认就调用index = 0 就行了<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public Itr(int index) &#123;</div><div class="line">    cursor = index;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3.方法（<strong>注意看清楚操作的指针</strong>）<br>注意：先找软柿子捏</p>
<p>add:这个方法需要注意几个地方<br>1.添加了新的元素可以调用父类的add方法<br>2.修改了集合长度记得expModCount = modCount<br>调用父类的add modCount ++了为什么不是 expModCount ++？<br>考虑到了添加是集合的情况，直接赋值也是一样的结果<br>3.要把lastRet给质空 ，因为元素之间的关系已经改变不能在操作刚返回的元素了；<br>4.cursor++ ，cursor不++就会指向你刚添加的元素，这样连续添加时候并不会按照你添加顺序添加进入集合，而是反向。所以需要cursor++;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void add(String s) &#123;</div><div class="line">    checkConcurrentModification();</div><div class="line">    MyArrayList.this.add(cursor, s);</div><div class="line">    expModCount = modCount;</div><div class="line">    cursor++;       // caution</div><div class="line">    lastRet = -1;    // caution</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>//判断是否会出现并发修改异常<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">private void checkConcurrentModification() &#123;</div><div class="line">    if (expModCount != modCount) &#123;</div><div class="line">        throw new ConcurrentModificationException();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>软柿子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public boolean hasNext() &#123;</div><div class="line">    return cursor &lt; size;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public boolean hasPrevious() &#123;</div><div class="line">    return cursor &gt; 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>核心方法：<br>1.首先判断是否有下一个元素<br>2.lastRet = cursor<br>3.cursor++<br>4.return elements[lastRet]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public String next() &#123;</div><div class="line">    checkConcurrentModification();</div><div class="line">    if (!hasNext()) &#123;</div><div class="line">        throw new NoSuchElementException();</div><div class="line">    &#125;</div><div class="line">    lastRet = cursor;</div><div class="line">    return elements[cursor++];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>核心方法<br>这里注意cursor–;<br>此时cursor和lastRet指向的同一个元素哦<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public String previous() &#123;</div><div class="line">    checkConcurrentModification();</div><div class="line">    if (!hasPrevious()) &#123;</div><div class="line">        throw new NoSuchElementException();</div><div class="line">    &#125;</div><div class="line">    lastRet = cursor - 1;</div><div class="line">    /*String retValue = elements[cursor - 1];</div><div class="line">    cursor--;</div><div class="line">    return retValue;*/</div><div class="line">    return elements[--cursor];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>软柿子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public int nextIndex() &#123;</div><div class="line">    return cursor;</div><div class="line">&#125;</div><div class="line">@Override</div><div class="line">public int previousIndex() &#123;</div><div class="line">    return cursor - 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>remove最近返回的元素<br>注意事项：<br>1.这里判断lastRet是否存在不然抛出异常不该调用这个函数<br>2.expModCount = modCount 需要同步 增加和删除都需要<br>3.<strong>cursor = lastRet</strong>这个是为了不管正向遍历还是逆向遍历都能使得cursor位置不变；<br><em>首先看正向遍历：</em><br>|1|2|3|4|5|6|7|8|9|10|<br>假设正向遍历删除的是5  L表示last C 表示cursor<br>|1|2|3|4|5|6|7|8|9|10|</p>
<p>L在4和5之间，C在5和6之间。</p>
<p>把5删掉之后因为集合删除会自动向前移动并排满，5的位置被6取代以此类推。那么cursor就会指向值为7，所以正向遍历必须cursor-1;</p>
<p><em>看逆向遍历：</em><br>|1|2|3|4|5|6|7|8|9|10|<br>假设逆向遍历删除的是5  L表示last C 表示cursor<br>|1|2|3|4|5|6|7|8|9|10|<br>        C<br>        L</p>
<p>L,C都在4和5之间<br>此时cursor和lastRet是指向同一个的这种情况就不用-1<br>所以综合两种情况把cursor = lastRet就行</p>
<p>4.lastRet置空因为修改了元素不想能够在进行其他的修改操作</p>
<pre><code>@Override
public void remove() {
    checkConcurrentModification();
    if (lastRet == -1) {
        throw new IllegalStateException();
    }
    MyArrayList.this.remove(lastRet);
    expModCount = modCount;  //修改完就要同步count
    cursor = lastRet; // caution: 正向遍历和逆向遍历的结果一致
    lastRet = -1;
}
</code></pre><p>设置元素<br>这里需要注意的是：<br>lastRet也要置空只要元素有改变都应该置空</p>
<pre><code>@Override
public void set(String s) {
    // 判断迭代器是否有效
    checkConcurrentModification();
    if (lastRet == -1) {
        throw new IllegalStateException();
    }
    elements[lastRet] = s;
    lastRet = -1;
}
</code></pre><p>  }</p>
<h3 id="ArrayList总结"><a href="#ArrayList总结" class="headerlink" title="ArrayList总结"></a>ArrayList总结</h3><p>1.难点在于ArrayList的扩容的机智<br>2.内部类的对指针的移动和判断并发修改异常</p>
<h3 id="源码解析linkedList"><a href="#源码解析linkedList" class="headerlink" title="源码解析linkedList"></a>源码解析linkedList</h3><p>直接看源码：因为之前没看过，所以今天就来学习一下</p>
<h3 id="List接口-1"><a href="#List接口-1" class="headerlink" title="List接口"></a>List接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">只看核心方法</div></pre></td></tr></table></figure>
<h3 id="ListIterator接口-1"><a href="#ListIterator接口-1" class="headerlink" title="ListIterator接口"></a>ListIterator接口</h3><p>对于LinkedList来说应该没有什么难点，主要还是看迭代器里面的操作；因为是linkedList不需要考虑扩容的问题<br>先看看类名</p>
<pre><code>public class LinkedList&lt;E&gt;
extends AbstractSequentialList&lt;E&gt;
implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable
</code></pre><p>属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">transient int size = 0;</div><div class="line">transient Node&lt;E&gt; first;  //定义第一个结点可变</div><div class="line">transient Node&lt;E&gt; last;   //定义最后一个结点可变</div><div class="line">protected transient int modCount = 0; //AbstractList定义</div></pre></td></tr></table></figure></p>
<p>1这里出现了关键字transient。Java中transient关键字的作用，简单地说，就是让某些被修饰的成员属性变量不被序列化<br>2这里需要看看Node是什么:一个静态内部类；相当于外部类？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">private static class Node&lt;E&gt; &#123;</div><div class="line">    E item;</div><div class="line">    Node&lt;E&gt; next;</div><div class="line">    Node&lt;E&gt; prev;</div><div class="line"></div><div class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</div><div class="line">        this.item = element;</div><div class="line">        this.next = next;</div><div class="line">        this.prev = prev;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>构造方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public LinkedList() &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public LinkedList(Collection&lt;? extends E&gt; c) &#123;</div><div class="line">    this();</div><div class="line">    addAll(c);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Links e as first element.</div><div class="line"> */</div><div class="line">private void linkFirst(E e) &#123;</div><div class="line">    final Node&lt;E&gt; f = first;</div><div class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f);//这是头插法</div><div class="line">    first = newNode;</div><div class="line">    if (f == null)              // 说明里面一个结点都没有</div><div class="line">        last = newNode;</div><div class="line">    else</div><div class="line">        f.prev = newNode;       // first.prev = newNode;</div><div class="line">    size++;</div><div class="line">    modCount++;                 //在AbstractList定义</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在某个元素前面添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">void linkBefore(E e, Node&lt;E&gt; succ) &#123;</div><div class="line">    // assert succ != null;</div><div class="line">    final Node&lt;E&gt; pred = succ.prev;</div><div class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ);</div><div class="line">    succ.prev = newNode;</div><div class="line"></div><div class="line">    if (pred == null)</div><div class="line">        first = newNode;</div><div class="line">    else</div><div class="line">        pred.next = newNode;</div><div class="line"></div><div class="line">    size++;</div><div class="line">    modCount++;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>尾插法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Links e as last element.</div><div class="line"> */</div><div class="line">void linkLast(E e) &#123;</div><div class="line">    final Node&lt;E&gt; l = last;</div><div class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</div><div class="line">    last = newNode;</div><div class="line">    if (l == null)</div><div class="line">        first = newNode;</div><div class="line">    else</div><div class="line">        l.next = newNode;</div><div class="line">    size++;</div><div class="line">    modCount++;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>删除头结点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/</div><div class="line"> * Unlinks non-null first node f.</div><div class="line"> */</div><div class="line">private E unlinkFirst(Node&lt;E&gt; f) &#123;</div><div class="line">    // assert f == first &amp;&amp; f != null;</div><div class="line">    final E element = f.item;      //获取要删除的值</div><div class="line">    final Node&lt;E&gt; next = f.next;   //获取first的下一个结点（未知）</div><div class="line">    f.item = null;</div><div class="line">    f.next = null; // help GC</div><div class="line">    first = next;</div><div class="line">    //如果原本就只有一个结点，现在毛都没了</div><div class="line">    if (next == null)</div><div class="line">        last = null;</div><div class="line">    else</div><div class="line">        next.prev = null;    //next作为头结点把和之前first链接断开</div><div class="line">    size--;</div><div class="line">    modCount++;</div><div class="line">    return element;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>删除最后一个结点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">private E unlinkLast(Node&lt;E&gt; l) &#123;</div><div class="line">    // assert l == last &amp;&amp; l != null;</div><div class="line"></div><div class="line">    final E element = l.item;</div><div class="line">    final Node&lt;E&gt; prev = l.prev;</div><div class="line">    l.item = null;</div><div class="line">    l.prev = null; // help GC</div><div class="line">    last = prev;</div><div class="line"></div><div class="line">    if (prev == null)</div><div class="line">        first = null;</div><div class="line">    else</div><div class="line">        prev.next = null;</div><div class="line">    size--;</div><div class="line">    modCount++;</div><div class="line">    return element;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>删除任意一个结点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Unlinks non-null node x.</div><div class="line"> */</div><div class="line">E unlink(Node&lt;E&gt; x) &#123;</div><div class="line">    // assert x != null;</div><div class="line">    final E element = x.item;</div><div class="line">    final Node&lt;E&gt; next = x.next;</div><div class="line">    final Node&lt;E&gt; prev = x.prev;</div><div class="line"></div><div class="line">    if (prev == null) &#123;   //如果删除的是头结点</div><div class="line">        first = next;</div><div class="line">    &#125; else &#123;</div><div class="line">        prev.next = next;</div><div class="line">        x.prev = null;    //help GC</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (next == null) &#123;  //如果删除是最后一个结点</div><div class="line">        last = prev;</div><div class="line">    &#125; else &#123;</div><div class="line">        next.prev = prev;</div><div class="line">        x.next = null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    x.item = null;  //help GC</div><div class="line">    size--;</div><div class="line">    modCount++;</div><div class="line">    return element;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在index添加一个集合<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</div><div class="line">    checkPositionIndex(index);</div><div class="line"></div><div class="line">    Object[] a = c.toArray();</div><div class="line">    int numNew = a.length;</div><div class="line">    if (numNew == 0)</div><div class="line">        return false;</div><div class="line"></div><div class="line">    Node&lt;E&gt; pred, succ;</div><div class="line">    if (index == size) &#123;</div><div class="line">        succ = null;</div><div class="line">        pred = last;</div><div class="line">    &#125; else &#123;</div><div class="line">        succ = node(index);</div><div class="line">        pred = succ.prev;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for (Object o : a) &#123;</div><div class="line">        @SuppressWarnings(&quot;unchecked&quot;) E e = (E) o;</div><div class="line">        Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null);</div><div class="line">        if (pred == null)</div><div class="line">            first = newNode;</div><div class="line">        else</div><div class="line">            pred.next = newNode;</div><div class="line">        pred = newNode;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (succ == null) &#123;</div><div class="line">        last = pred;</div><div class="line">    &#125; else &#123;</div><div class="line">        //连接原版在index的元素</div><div class="line">        pred.next = succ;</div><div class="line">        succ.prev = pred;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    size += numNew;</div><div class="line">    modCount++;</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>indexOf和arrayList差不多<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public int indexOf(Object o) &#123;</div><div class="line">    int index = 0;</div><div class="line">    if (o == null) &#123;</div><div class="line">        for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;</div><div class="line">            if (x.item == null)</div><div class="line">                return index;</div><div class="line">            index++;</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;</div><div class="line">            if (o.equals(x.item))</div><div class="line">                return index;</div><div class="line">            index++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return -1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>寻找Node的index方法，就分半查找<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Node&lt;E&gt; node(int index) &#123;</div><div class="line">    // assert isElementIndex(index);</div><div class="line"></div><div class="line">    if (index &lt; (size &gt;&gt; 1)) &#123;</div><div class="line">        Node&lt;E&gt; x = first;</div><div class="line">        for (int i = 0; i &lt; index; i++)</div><div class="line">            x = x.next;</div><div class="line">        return x;</div><div class="line">    &#125; else &#123;</div><div class="line">        Node&lt;E&gt; x = last;</div><div class="line">        for (int i = size - 1; i &gt; index; i--)</div><div class="line">            x = x.prev;</div><div class="line">        return x;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来来看LinkedList的迭代器吧<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private class ListItr implements ListIterator&lt;E&gt; &#123;</div></pre></td></tr></table></figure></p>
<p>//属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">private Node&lt;E&gt; lastReturned;</div><div class="line">private Node&lt;E&gt; next;</div><div class="line">private int nextIndex;</div><div class="line">private int expectedModCount = modCount;</div></pre></td></tr></table></figure></p>
<p>//构造函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ListItr(int index) &#123;</div><div class="line">    // assert isPositionIndex(index);</div><div class="line">    next = (index == size) ? null : node(index);</div><div class="line">    nextIndex = index;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>//软柿子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public boolean hasNext() &#123;</div><div class="line">    return nextIndex &lt; size;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public E next() &#123;</div><div class="line">    checkForComodification();</div><div class="line">    if (!hasNext())</div><div class="line">        throw new NoSuchElementException();</div><div class="line"></div><div class="line">    lastReturned = next;</div><div class="line">    next = next.next;</div><div class="line">    nextIndex++;</div><div class="line">    return lastReturned.item;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public boolean hasPrevious() &#123;</div><div class="line">    return nextIndex &gt; 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public E previous() &#123;</div><div class="line">    checkForComodification();</div><div class="line">    if (!hasPrevious())</div><div class="line">        throw new NoSuchElementException();</div><div class="line"></div><div class="line">    //lastReturned = next = (next == null) ? last : next.prev;</div><div class="line">    next = (next == null) ? last : next.prev;</div><div class="line">    lastRetured = next;</div><div class="line"></div><div class="line">    nextIndex--;</div><div class="line">    return lastReturned.item;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public int nextIndex() &#123;</div><div class="line">    return nextIndex;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public int previousIndex() &#123;</div><div class="line">    return nextIndex - 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public void remove() &#123;</div><div class="line">    checkForComodification();</div><div class="line">    if (lastReturned == null)</div><div class="line">        throw new IllegalStateException();</div><div class="line"></div><div class="line">    Node&lt;E&gt; lastNext = lastReturned.next;</div><div class="line">    unlink(lastReturned);</div><div class="line"></div><div class="line">    if (next == lastReturned) //说明是逆序遍历的</div><div class="line">        next = lastNext;</div><div class="line">    else                      //正序遍历</div><div class="line">        nextIndex--;</div><div class="line">    lastReturned = null;</div><div class="line">    expectedModCount++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public void set(E e) &#123;</div><div class="line">    if (lastReturned == null)</div><div class="line">        throw new IllegalStateException();</div><div class="line">    checkForComodification();</div><div class="line">    lastReturned.item = e;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public void add(E e) &#123;</div><div class="line">    checkForComodification();</div><div class="line">    lastReturned = null;</div><div class="line">    if (next == null)</div><div class="line">        linkLast(e);</div><div class="line">    else</div><div class="line">        linkBefore(e, next);</div><div class="line">    nextIndex++;</div><div class="line">    expectedModCount++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public void forEachRemaining(Consumer&lt;? super E&gt; action) &#123;</div><div class="line">    Objects.requireNonNull(action);</div><div class="line">    while (modCount == expectedModCount &amp;&amp; nextIndex &lt; size) &#123;</div><div class="line">        action.accept(next.item);</div><div class="line">        lastReturned = next;</div><div class="line">        next = next.next;</div><div class="line">        nextIndex++;</div><div class="line">    &#125;</div><div class="line">    checkForComodification();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">    final void checkForComodification() &#123;</div><div class="line">        if (modCount != expectedModCount)</div><div class="line">            throw new ConcurrentModificationException();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/06/Java总结（二）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王邸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路要坚持">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/06/Java总结（二）/" itemprop="url">Java总结（二）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-06T22:10:02+08:00">
                2019-07-06
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/07/06/Java总结（二）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/07/06/Java总结（二）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>总结<br>时间：0701-0706</p>
<p>本周主要内容:<br>代码块介绍，对象继承，final（修饰类，方法，变量），对象的多态，抽象类，接口，打包指令，权限修饰符（public default…），内部类（成员内部类，静态内部类，局部内部类，匿名内部类），Object类（注意他的方法，所有类都可以重写），String类（注意byte数组可以构建String（流对象）），</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>这周主要把面向对象的内容讲完了。很多东西虽然很熟悉但是却很多细节的处理很重要。是打好基础的关键。但是万变不离其中，离不开三大特性：继承，封装，多态。现在也只能字面意思上去理解到底这些东西是什么。这些东西的规律是什么，但是他为什么这样实现的？最初的构想是什么？等等问题，这不是老师能教你的，你自己需要去学习。上个礼拜简单的讲了什么是封装，但是封装远远没有private那么简单。接下来将总结一下本周的学习内容：</p>
<h2 id="星期一"><a href="#星期一" class="headerlink" title="星期一"></a>星期一</h2><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>用{}括起来的代码<br>分类：<br>局部代码块<br>  位置：方法里面(局部位置)<br>  作用：限制局部变量的生命周期，及早释放，提高内存利用率</p>
<p>构造代码块(语法糖)：<br>  位置：类中方法外(成员位置)<br>  作用：多个构造方法方法中相同的代码存放到一起，每次调用构造都执行，并且在构造方法前执行<br>  相当于放在每个构造函数的首行</p>
<p>静态代码块：<br>  位置: 成员位置 需要用static标识；<br>  作用：对类进行初始化, 在类加载的时候执行, 并且只执行一次</p>
<p>  同步代码块(以后再讲)synchronized:是为了线程安全出现的</p>
<p>这里只需要搞清楚一个问题：这些代码块的执行顺序：<br>静态代码块 &gt;构造代码块(语法糖) &gt; 构造方法<br>先执行父类的,看下面例子：<br><strong>注意：先执行父类静态块，再执行子类静态块。</strong></p>
<pre><code>class Fu {
  static {
    System.out.println(&quot;静态代码块Fu&quot;);
  }

  {
    System.out.println(&quot;构造代码块Fu&quot;);
  }

  public Fu() {
    System.out.println(&quot;构造方法Fu&quot;);
  }
}

class Zi extends Fu {
  static {
    System.out.println(&quot;静态代码块Zi&quot;);
  }

  {
    System.out.println(&quot;构造代码块Zi&quot;);
  }

  public Zi() {
    System.out.println(&quot;构造方法Zi&quot;);
  }
}

class Test2 {
  public static void main(String[] args) {
    new Zi();
  }
}
输出结果：
    静态代码块Fu
    静态代码块Zi
    构造代码块fu
    构造方法fu
    构造代码块zi
    构造方法zi
</code></pre><p>先加载父类静态代码块然后加载子代静态代码块<br>Java中如果有继承关系，对象的初始化是分层初始化</p>
<ol>
<li>父类按照层次依次加载，然后再加载子类</li>
<li>成员变量是按照层次进行初始化的<br>先初始化父类中定义的数据，再初始化子类中定义的数据</li>
</ol>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>(1)把多个类中相同的成员给提取出来定义到一个独立的类中。然后让这多个类和该单独的类产生一个关系，使多个类中具备这个单独的类中定义的成员。<br>  这个关系叫继承。</p>
<p>(2)Java中如何表示继承呢?格式是什么呢?<br>  A:用关键字extends表示<br>  B:格式：class 子类名 extends 父类名 {}</p>
<p>(3)继承的好处：<br>  A: 提高了代码的复用性<br>  B: 提高了代码的维护性<br>  C: 让类与类产生了一个关系，是多态的前提</p>
<p>(4)继承的弊端：<br>  A:让类的耦合性增强。这样某个类的改变，就会影响其他和该类相关的类。<br>    设计原则：低耦合，高内聚。<br>    耦合：类与类的关系<br>    内聚：自己完成某件事情的能力（责任）<br>  B:打破了封装性</p>
<p>(5)Java中继承的特点<br>  A: Java只支持单继承，不支持多继承<br>  B: 但是支持多层继承   界门纲目科属种</p>
<p>(6)继承的注意事项：<br>  A:子类不能继承父类的私有成员（私有成员是被子类隐式继承的，其实私有成员被继承了，但是在子类中不能访问。反射）<br>  B:子类不能继承父类的构造方法，但是可以通过super去访问<br>  C:不要为了部分功能而去继承。如下例子</p>
<pre><code>class A {
  m1();
  m2();
  m3();
  m4();
}
我们现在需要一个类有以下功能：m1(), m2(), m3(), m5();
class B extends A{ (不推荐)
  m5();
}
</code></pre><p>说到功能那就一定要写成接口来实现就好;</p>
<p>(7)什么时候使用继承呢?<br>  A类和B类如果是: is a<br>  is a的关系：</p>
<ul>
<li>Person：<ul>
<li>Student</li>
<li>Teacher</li>
</ul>
</li>
</ul>
<p><strong>(8)Java继承中的成员关系</strong></p>
<p>  A:成员变量</p>
<pre><code>a:子类的成员变量名称和父类中的成员变量名称不一样。
b:子类的成员变量名称和父类中的成员变量名称一样，这个怎么访问呢?
  子类的方法访问变量的查找顺序(一层一层向外)：
  首先找子类的局部变量
  再找子类的成员变量
  再找父类的成员变量 ...
c.子类的成员变量隐藏了父类的成员变量？(就近原则)
  super关键字
    super是内存空间的标识
  super.name //父亲的名字
</code></pre><p>  B:静态成员:</p>
<pre><code>a.静态成员也会被继承
b.如果出现同名的静态变量，那么父类中定义的静态成员只能通过类名访问。
c.如果new一个对象,还是能super访问父类的静态成员的（我自己发现的）
</code></pre><p>  C:构造方法</p>
<pre><code>a:子类的构造方法默认会去访问父类的无参构造方法
  目的：将在父类中定义的成员变量初始化。
b:父类中如果没有无参构造方法，怎么办?
  1)子类通过super去明确调用父类带参构造
  2)子类通过this调用本身的其他构造，**但是一定会有一个去访问了父类的构造**
  3)让父类提供无参构造
  this(...), super(...)只能在构造方法的第一条语句。
</code></pre><p>  D:成员方法</p>
<p>  a:子类的成员方法和父类中的成员方法签名不一样。<br>    相当于两个不同的方法(我们来举个栗子);</p>
<pre><code>public class demo2 {
    public static void main(String[] args) {
        Son son = new Son();
        son.show(&quot;我传入了一个参数&quot;);
        son.show();
    }
}
class Father {
    public void show(String s){
        System.out.println(&quot;我是父类的show方法：&quot; + s);
    }
}
class Son extends  Father {
    public void show() {
        System.out.println(&quot;我是子类的show方法我没有参数&quot;);
    }
}

我是父类的show方法我传入了一个参数
我是子类的show方法我没有参数
</code></pre><p>b:子类的成员方法和父类中的成员方法签名一样，这个怎么访问呢?<br>  父类的方法被重写了，不能再访问父类的方法，此时方法被重写。<br>  通过子类对象访问一个方法的查找顺序：</p>
<pre><code>查找子类的成员方法
再查找父类的成员方法
</code></pre><p>c:重写的成员方法返回值类型（引用类型兼容即可）：<br>  基本数据类型必须一致<br>  <strong>引用数据类型：父类的类型必须兼容子类的类型</strong></p>
<p>d:其他注意事项：<br>  访问权限:子类的方法的访问权限必须大于等于父类的方法<br>  父类中的私有方法不能被重写</p>
<p>E:静态方法<br>  a.静态的方法也可以被继承<br>  b.静态方法可以被”重写”, 但是不能添加Override</p>
<p>(9)方法的重写：<br>  有子父类关系, 方法签名一样。<br>  返回值类型：<br>    基本类型：必须一致<br>    引用类型：父类兼容子类。<br>  访问权限：子类的访问权限必须大于等于父类的访问权限。<br>    Father f = new Son();<br>    f.show();  //多态性，编译看左边，运行看右边；</p>
<p>(10)两个面试题：<br>  A:Override和Overload的区别?<br>    override: 子类重写父类的同名方法。要求子类的返回值类型要被父类兼容，方法名一样，参数列表一样（方法签名一样）子类的访问权限不能比父类的小。<br>    overload：在同一个类中，方法名一样，但是参数列表不一样。与返回值类型无关<br>      如果在子类中定义了一个和父类同名的方法，但是参数列表不一样就表示是不同的方法；<br>      如果在子类中定义了一个和父类同名的方法，但是参数列表一样，但是返回值类型不兼容，会报错。<br>  B:this和super的区别和各自的作用?<br>    this<br>    this.成员变量 super.成员变量<br>    this(…)   super(…) //调用构造方法<br>    this.成员方法() super.成员方法()</p>
<p>(11)数据初始化的面试题<br>  <strong>A:回顾：对象初始化过程</strong><br>    加载Student.class文件进内存<br>    在栈内存为s开辟空间<br>    在堆内存为学生对象开辟空间<br>    对学生对象的成员变量进行默认初始化<br>    对学生对象的成员变量进行显示初始化<br>    通过构造方法对学生对象的成员变量赋值<br>    学生对象初始化完毕，把对象地址赋值给s变量</p>
<p>  B:子类对象的初始化过程（分层初始化：加载父类，然后加载子类）<br>  C:子父类的构造执行过程<br>    加载父类<br>    加载子类<br>    先对父类进行初始化: 父类显示初始化，父类的构造方法。<br>    对子类进行初始化：子类的显示初始化，子类的构造方法。<br>  看下面这个例子更好的理解对象初始化过程：</p>
<pre><code>public class test3 {
  public static void main(String[] args) {
    new Z(); //先进行父类的初始化！！！！！
  }
}

class X {
  Y b = new Y();   //第一步
  int a = 10;
  X() {
    System.out.print(&quot;X&quot;);  //然后初始化X
  }
}

class Y {
  Y() {
    System.out.print(&quot;Y&quot;);  //从X过来第一次打印Y   第二次过来从Z
  }
}

class Z extends X {
  Y y = new Y();   //第三步
  Z() {
    // super();
    System.out.print(&quot;Z&quot;); //最后一次打印
  }
}

运行结果：
Y X Y Z
</code></pre><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>  (1)是最终的意思，可以修饰类，方法，变量。<br>  (2)特点：<br>  A:修饰类，表示这个类不能被继承（绝育手术）<br>  B:修饰变量，表示该变量使常量，它的值不能被修改<br>  基本数据类型：里面的值不能被修改<br>  引用数据类型：它的地址值不能被修改，指向同一个对象，但是对象的内容可以修改<br>  注意事项：<br>    被final的变量只能被赋值一次，即使值相同。<br>    注意final的默认初始化是无效的，所以可以在初始化对象的时候，使用构造方法初始化他，这样写并不会报错：</p>
<pre><code>class Son {
  final int a;
  public Son() {
    a = 10;
  }
}
</code></pre><p>然而这样写，相当于赋值两次就会报错：</p>
<pre><code>class Son {
  final int a;
  a = 10;  //就会报错。
}
</code></pre><p>  C:修饰方法，表示该方法不能被子类重写</p>
<h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>(1)同一个对象在不同时刻体现出来的不同状态。</p>
<p>(2)多态的前提：<br>  A:有继承（实现）关系<br>  B:子类重写父类的方法<br>  C:父类的引用变量指向子类的对象<br>  多态的分类：<br>    a:具体类多态<br>      class Father{}<br>      class Son extends Father{}<br>      Father father = new Son();<br>    b:抽象类多态<br>      abstarct class Father{}<br>      class Son extends Father{}<br>      Father father = new Son();<br>    c:接口多态<br>      interface Father{}<br>      class Son implements Father{}<br>      Father father = new Son();</p>
<p>(3)多态中的成员访问特点<br>  A:成员变量<br>    编译看左边，运行看左边<br>  B:静态变量：<br>    编译看左边，运行看左边<br>  C:成员方法<br>    编译看左边，运行看右边<br>  D:静态方法<br>    编译看左边，运行看左边</p>
<p>(4)多态的好处：<br>  A:提高代码的维护性 (继承体现)<br>  B:提高代码的扩展性 (多态体现)</p>
<p>(5)多态的弊端：<br>  破坏了封装性（继承）<br>  无法访问子类特有的功能</p>
<p>(6)多态中的转型<br>  A:向上转型<br>    子类 –&gt; 父类（Java默认支持）<br>  B:向下转型<br>    父类 –&gt; 子类（可能会出现 ClassCastException）<br>看个例子：</p>
<pre><code>class A{
  public void show(){
    show2();
  }
  public void show2(){
    System.out.println(&quot;我&quot;);
  }
}
class B extends A {
  public void show2(){
    System.out.println(&quot;爱&quot;);
  }
}
class C extends B {
  public void show(){
    super.show();
  }
  public void show2(){
    System.out.println(&quot;你&quot;);
  }
}
public class Test1 {
  public static void main(String[] args) {
    A a = new B();
    a.show();   //爱  成员函数 编译看左边 运行看右边 最终执行b的show2()方法
    B b = new C();
    b.show();   //你  最终执行c的show2()方法
  }
}
</code></pre><p>还有一个例子：</p>
<pre><code>class Animal{}
class Dog extends Animal{}
class Cat extends Animal{}
public class Test3 {
  public static void main(String[] args) {
    Animal p0 = new Animal();
    Dog p1 = new Dog ();
    Cat p2 = new Cat ();
    Animal p3 = new Dog ();
    Animal p4 = new Cat ();
    p0 = p1;          //a  默认向上转型
    // p1 = p2;       //b  //编译报错 不兼容类型
    p1 = (Dog)p3;     //c
    p2 = (Cat)p4;     //d
    // p1 = (Dog)p4;  //e  异常：java.lang.ClassCastException: Cat cannot be cast to Dog
    // p2 = (Cat)p3;  //f  同理也是异常
  }
}
编译报错：
  b
运行报错：
  e f
</code></pre><p>这个例子告诉我们不要乱用转型，学会使用instanceOf先判断是否是该对象的类或者子类然后再转型。</p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>(1)概述：<br>  将类抽象    举例：动物<br>  将方法抽象 比如动物会怎么叫，你不知道，所以你不应该给一个具体的实现，而只要给一个声明就可以</p>
<p>(2)抽象类的特点<br>  A:抽象类和抽象方法必须用关键字abstract修饰<br>  B:抽象类中不一定有抽象方法,但是有抽象方法的类一定是抽象类(但是接口也定义了抽象法方法)<br>  C:抽象类不能实例化 （存在的用途就是被子类继承）<br>  D:抽象类的子类<br>    a:是一个抽象类。可以重写抽象方法，也可以不重写。<br>    b:是一个具体类。一定要重写所有的抽象方法<br>(3)抽象类的成员特点：<br>  A:成员变量<br>    可以是变量，也可以是常量<br>  B:构造方法<br>    有构造方法<br>  C:成员方法<br>    可以是抽象方法，也可以是普通方法<br>(4)抽象类的几个小问题<br>  A:抽象类有构造方法，不能实例化，那么构造方法有什么用?<br>    给子类访问，对在抽象类中定义的成员变量进行初始化<br>  B:一个类如果没有抽象方法,却定义为了抽象类，有什么用?<br>    该类不能被实例化<br>  C:abstract 不能和哪些关键字共存<br>    final: 冲突<br>    private：冲突<br>    static：无意义</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>(1)在Java中，接口一般是用来表示扩展功能的。<br>(2)接口的特点：<br>  A:接口用关键字interface修饰<br>    interface 接口名 {} //接口名一般大写<br>  B:类实现接口用implements修饰<br>    class 类名 implements 接口名 {}<br>  C:接口不能实例化<br>  D:接口的实现类<br>    a:是一个抽象类  可以重写抽象方法，也可以不重写。<br>    b:是一个具体类  一定要重写所有的抽象方法，可以写成匿名对象，如果只有一个方法可以写lambda表达式<br>  E:空的接口<br>    a:就是为了做标记的标记接口JAVA源码中经常看到<br>(3)接口的成员特点：<br>  A:成员变量<br>    只能是静态常量，默认用public static final修饰<br>  B:构造方法<br>    接口没有构造方法<br>  C:成员方法<br>    可以有抽象方法，默认用 public abstract修饰<br>    <strong><em>注意：JDK8以后可以有</em></strong></p>
<pre><code>默认方法：必修用default关键字修饰，默认用 public修饰
静态方法：必修用static修饰，默认用public 修饰
</code></pre><p>(4)类与类,类与接口,接口与接口<br>  A:类与类   单继承<br>  B:类与接口  多实现<br>  C:接口与接口 多继承</p>
<p>(5)抽象类和接口的区别<br>  A:成员区别<br>    抽象类：抽象方法，成员变量，静态成员等等<br>    接口：抽象方法，只能静态常量（static final）<br>  B:关系区别:<br>    类与类：  单继承<br>    类与接口：多实现<br>    接口与接口：多继承<br>  C:设计理念不同<br>    抽象类：和它的子类之间表现的是 is a的关系， 描述的是子类中共性<br>    接口：和它的子类之间表现的是 like a 的关系，描述的是扩展功能</p>
<h3 id="形式参数和返回值的问题"><a href="#形式参数和返回值的问题" class="headerlink" title="形式参数和返回值的问题"></a>形式参数和返回值的问题</h3><p>(1)形式参数：<br>  类名：需要该类或者该类子类的对象<br>  抽象类名：需要该类的子类对象<br>  接口名：需要该接口的实现类对象<br>(2)返回值类型：<br>  类名：返回的是该类或者该类子类的对象<br>  抽象类名：返回的是该类的子类对象<br>  接口名：返回的是该接口的实现类的对象<br>(3)链式编程<br>  对象.方法1().方法2()…….方法n();</p>
<h2 id="星期三-拉闸放假"><a href="#星期三-拉闸放假" class="headerlink" title="星期三(拉闸放假)"></a>星期三(拉闸放假)</h2><h2 id="星期四"><a href="#星期四" class="headerlink" title="星期四"></a>星期四</h2><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><pre><code>命令：javac -d . xxx.java
</code></pre><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><pre><code>命令：java com.cs.kaoyan.demo;
</code></pre><h3 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h3><p>(1)访问不同包的类<br>  a. 指定类的全限定名（例如java.util.Scanner）;<br>  b. 导包<br>(2)格式：<br>  import 包名.类名；<br>  静态导入：（导入静态方法，就好像导入的方法就定义在这个类中一样）<br>    import static 包名.类名.方法名<br>    要求该方法必须是静态的。<br>(3)面试题：package,import,class的在JAVA文件中的顺序<br>  package &gt; import &gt; class<br>  一个  多个  多个(建议一个文件里面只有一个class)</p>
<h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><p>(1)权限修饰符</p>
<table>
<thead>
<tr>
<th>类型</th>
<th style="text-align:center">本类</th>
<th style="text-align:center">同一个包下</th>
<th style="text-align:center">不同包下的子类</th>
<th style="text-align:right">不同包下的无关类</th>
</tr>
</thead>
<tbody>
<tr>
<td>private</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">N</td>
<td style="text-align:center">N</td>
<td style="text-align:right">N</td>
</tr>
<tr>
<td>默认</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">N</td>
<td style="text-align:right">N</td>
</tr>
<tr>
<td>protected</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y(注意)</td>
<td style="text-align:right">N</td>
</tr>
<tr>
<td>public</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:right">Y</td>
</tr>
</tbody>
</table>
<p>  (2)这四种权限修饰符在任意时刻只能出现一种。</p>
<h3 id="常见的修饰符"><a href="#常见的修饰符" class="headerlink" title="常见的修饰符"></a>常见的修饰符</h3><p>(1)分类：<br>  权限修饰符：private,默认,protected,public<br>  状态修饰符：static, final<br>  抽象修饰符：abstract<br>(2)常见的类及其组成的修饰<br>  普通类：默认  public  final abstract<br>  成员变量: private,  默认, protected,  public  static, final<br>  构造方法：private, 默认, protected,  public<br>  成员方法：private, 默认, protected,  public  static, final abstract</p>
<h3 id="内部类（难）"><a href="#内部类（难）" class="headerlink" title="内部类（难）"></a>内部类（难）</h3><p><strong>我这里一定要强调。内部类这里的知识点有点小乱，需要捋一捋才能搞清楚。常用四种内部类<br>分成两个类：成员位置（成员内部类，静态内部类）,局部位置（局部内部类，匿名内部类）。对应着有三种访问：内部类访问外部类，外部类访问内部类，其他类访问内部类</strong><br>(1)把类定义在另一个类的内部，该类就被称为内部类。<br>  举例：把类B定义在类A中，类B就被称为内部类。 A称为外围类</p>
<p>(2) 内部类的作用：<br>  a. 保护内部类<br>  b. 方便内部类和外部类的交互</p>
<p>(3) 内部类的访问规则<br>  A:内部类可以直接访问外部类的成员，包括私有（内部类秘密捕获了一个外部类对象）<br>  B:外部类要想访问内部类成员，必须创建内部类对象</p>
<p>(4) 内部类的分类<br>  A:成员位置（成员内部类，静态内部类）<br>  B:局部位置（局部内部类，匿名内部类）</p>
<p>(5)成员内部类(外部类对象所有)<br>  a. 内部类怎么访问外部类？<br>    直接访问，并且访问外部类的私有成员<br>  b. 外部类怎么访问内部类？<br>    创建对象，并且可以访问内部类私有成员<br>  c. 其他类怎么访问内部类？<br>    创建对象<br>    格式：Outer.Inner inner = new Outer().new Inner()；<br>    受访问权限修饰符的限制。<br>  注意事项：反编译之后，发现内部类秘密捕获了外部类对象。<br>  成员内部类例子如下：</p>
<pre><code>  // 成员内部类
class Outer1 {
  private int a = 10;
  public int b = 20;
  public void method() {
    Inner1 inner = new Inner1();  //访问内部对象需要创建对象
    System.out.println(inner.num1);
    System.out.println(inner.num2);
  }

  class Inner1 {
    // int a = 100;
    // int b = 200;
    private int num1 = 100;
    public int num2 = 200;
    public void show() {
      System.out.println(a); //直接访问外部
      System.out.println(b); //直接访问外部
      // System.out.println(Outer1.a);无法从静态上下文中引用非静态 变量 a
      // System.out.println(Outer1.b); 无法从静态上下文中引用非静态 变量 b
      // System.out.println(Outer1.this.a);
      // System.out.println(Outer1.this.b);
    }
  }
  public static void main(String[] args) {
    //成员内部类想访问外部类时要创建外部类对象
    Outer1 outer = new Outer1();
    Inner1 inner = outer.new Inner1();
    inner.show();
    outer.method();
  }
}
</code></pre><p>(6)静态内部类（外部类所有）<br>  a. 内部类怎么访问外部类？<br>    直接访问，只能访问静态的成员，可以访问外部类私有的（必须是静态的因为在静态上下文中）<br>  b. 外部类怎么访问内部类？<br>    创建对象，并且可以访问内部类私有成员<br>  c. 其他类怎么访问内部类？<br>    创建对象<br>    格式：Outer.Inner inner = new Outer.Inner()；<br>    受访问权限修饰符的限制。<br>    静态内部类的例子：</p>
<pre><code>class Outer2 {
  private int a = 10;
  public int b = 20;
  private static int c = 30;
  public static int d = 40;

  public void method() {
    //全部报错，无法获取静态上下文的成员
    // System.out.println(Inner2.c);
    // System.out.println(Inner2.c);
    // System.out.println(Inner2.num1);
    // System.out.println(Inner2.num2);
    // Inner2.show();
  }

  public static void method2() {
    //只有创建了对象才能在外部类使用
    Inner2 inner2 = new Inner2();

    System.out.println(inner2.c);
    System.out.println(inner2.c);
    System.out.println(inner2.num1);
    System.out.println(inner2.num2);
    inner2.show();
  }

  static class Inner2 {
    // int a;
    // int b;
    int c = 300;
    int d = 400;
    private int num1 = 1;
    public int num2 = 2;
    public void show() {
      // System.out.println(a);
      // System.out.println(b);
      System.out.println(c);
      System.out.println(d);
      // System.out.println(Outer2.this.c);
      // System.out.println(Outer2.this.d);
      System.out.println(Outer2.c);
      System.out.println(Outer2.d);
    }
  }

  public static void main(String[] args) {

    //以下两种创建静态内部类都可以
    System.out.println(&quot;创建内部类访问&quot;);

    Inner2 inner = new Inner2();
    inner.show();
    Outer2.Inner2 inner2 = new Outer2.Inner2();
    inner2.show();

    System.out.println(inner.num1);
    System.out.println(inner.num2);

    System.out.println(&quot;创建外部类访问&quot;);
    Outer2 outer2 = new Outer2();
    outer2.method2();
  }
}
</code></pre><p>写完例子我们就在想，静态内部类到底有什么用？<br>感觉用起来很蠢：</p>
<pre><code>首先外部类是非静态的，所以外部类如果不创建内部类对象是访问不了内部类的成员的。
然后我觉得既然可以直接创建内部类，那还要外部类包装干什么？
和普通的成员内部类区别？
</code></pre><p>  <a href="https://blog.csdn.net/nimeghbia/article/details/87871441" target="_blank" rel="external">内部静态类作用</a><br>  <strong>如果需要内部类需要创静态的成员，就要用到内部类。静态成员是类所有，但这是静态内部类的特性</strong></p>
<p>(7)局部内部类(局部变量)<br>  a. 内部类怎么访问外部类？<br>    直接访问，并且可以访问私有的。<br>    访问外部类的局部变量：要求该局部变量不能改变。（放在常量池中）（通过画图了解和反编译了解）<br>  b. 外部类怎么访问内部类？<br>    只能在该方法中访问。<br>    创建对象，并且可以访问内部类私有成员<br>  c. 其他类怎么访问内部类？<br>    不能！</p>
<p>  A:局部内部类访问局部变量必须是最终量或者是实际的最终量（final）也就是常量,为什么呢?<br>  因为局部变量使用完毕就消失，而堆内存的数据并不会立即消失。<br>  为了让该值还存在，就加final修饰。 –&gt; 常量池</p>
<pre><code>反编译的源码：
class Outer3$1Inner3
{
  final int val$num1;  //把这个值保存成了常量
  final Outer3 this$0;
  Outer3$1Inner3()
  {
    this$0 = final_outer3;
    val$num1 = I.this;
    super();
  }
}
</code></pre><p>下面举个例子来说明：</p>
<pre><code>interface Sing {
  void sing();
}
public class Outer4 {
  public Sing getSing() {
    int a = 10;
    class Inner4 implements Sing {
      @Override
      public void sing() {
        System.out.println(&quot;Inner4.sing()&quot; + a);
      }
    }
    return new Inner4();
  }
  public static void main(String[] args) {
    Outer4 outer = new Outer4();
    Sing sing = outer.getSing();
    sing.sing(); //还能访问a的值
  }
}
</code></pre><p>这个例子说明了当outer调用完getSing()创建一个sing对象之后，却还能访问a的值。就说明a不是定义在getSing()函数中。而是一个常量</p>
<h4 id="8-匿名内部类（必须掌握）"><a href="#8-匿名内部类（必须掌握）" class="headerlink" title="(8)匿名内部类（必须掌握）"></a>(8)匿名内部类（必须掌握）</h4><p>前提：<br>  存在一个类或者接口。<br>  类：可以是普通类, 也可以是抽象类, 但是不能最终类,因为最终类（final）不能有子类<br>    创建了该类的子类。<br>  接口：<br>    创建了该接口的子类</p>
<p>格式：<br>  new 类名或者接口名() {重写方法;}</p>
<p>本质：创建了一个继承了该类或者实现该接口的子类对象。匿名内部类可以实现的，局部内部类一定可以实现；</p>
<p>//定义一个接口</p>
<pre><code>interface Sing {
  void sing();
}
</code></pre><p>//定义一个最终类，不能继承的</p>
<pre><code>final class Dance {
  public void dance() {
  }
}
class Outer6 {
  //局部内部类写法
  public Sing getSing() {
    class Inner6 implements Sing {
      @Override
      public void sing() {
        System.out.println(&quot;sing, sing, sing...&quot;);
      }
    }
    return new Inner6();

  //匿名内部类写法
    return new Sing() {
      @Override
      public void sing() {
        System.out.println(&quot;sing, sing, sing...&quot;);
      }
    };//因为是语句所以要加分号
  }

  public Dance getDance() {
    return new Dance() {
      @Override
      public void dance() {
        System.out.println(&quot;dance,dance,dance...&quot;);
      }
    };
  }

  public static void main(String[] args) {
    Outer6 outer  = new Outer6();
    Sing sing = outer.getSing();
    sing.sing();
    Dance dance = outer.getDance(); //报错无法从final类继承
    dance.dance();
  }
}
</code></pre><p>我要创建一个Sing, 发现它是一个接口, 需要它的子类, 子类还没有定义。然后对这个子类进行定义。</p>
<p>再来看一个题目：</p>
<p>按照要求，补齐代码</p>
<pre><code>interface Inter { void show(); }
class Outer { //补齐代码 }
class OuterDemo {
  public static void main(String[] args) {
      Outer.method().show();
  }
}
</code></pre><p>要求在控制台输出”HelloWorld”</p>
<p>分析：<br>  Outer有个静态的method的方法</p>
<pre><code>Outer.method();
</code></pre><p>  这个方法的返回值是接口类型的对象,然后调用接口的show方法</p>
<pre><code>Outer.method().show();
</code></pre><p>interface Inter {<br>  void show();<br>}</p>
<pre><code>class Outer {
  /*补齐代码*/
  //静态方法属于类 不需要创建对象
  public static Inter method() {
    //局部内部类写法
    class Inner implements Inter {
      @Override
      public void show() {
        System.out.println(&quot;HelloWorld&quot;);
      }
    }
    return  new Inner();  //这里创建了一个局部内部类
    //匿名内部类写法
    return new Inter() {  //直接创建一个接口的子类
      @Override
      public void show() {
        System.out.println(&quot;HelloWorld&quot;);
      }
    };
  }
}
class Test3 {
  public static void main(String[] args) {
    Outer.method().show();
  }
}
</code></pre><h2 id="星期五"><a href="#星期五" class="headerlink" title="星期五"></a>星期五</h2><h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><p>  概述：类 Object 是类层次结构的根类。每个类都使用 Object 作为超类。所有对象（包括数组）都实现这个类的方法。</p>
<p>构造方法：<br>  Object()<br>  为什么子类会默认调用父类的无参构造方法。</p>
<p>  因为object类是所有类的父类，而Object类只有无参构造方法。所以一定会默认调用父类的无参构造方法</p>
<p>成员方法：<br>  protected  Object clone()<br>  boolean equals(Object obj)<br>  protected  void finalize()<br>  Class&lt;?&gt; getClass()<br>  int hashCode()<br>  String toString()</p>
<h3 id="public-final-Class-getClass"><a href="#public-final-Class-getClass" class="headerlink" title="public final Class getClass():"></a>public final Class getClass():</h3><p>  子类不能被重写, 任何一个对象它的 getClass() 行为是一致。<br>  返回此 Object 的运行时类型。</p>
<h3 id="Class-类类型"><a href="#Class-类类型" class="headerlink" title="Class: 类类型"></a>Class: 类类型</h3><p>  概述：Class 类的实例表示正在运行的 Java 应用程序中的类和接口。枚举是一种类，注解是一种接口。<br>  public String getName()：返回该对象的运行时类的全限定名。</p>
<h3 id="public-int-hashCode"><a href="#public-int-hashCode" class="headerlink" title="public int hashCode()"></a>public int hashCode()</h3><p>返回该对象的哈希码值。<br>默认实现：这一般是通过将该对象的内部地址转换成一个整数来实现的</p>
<p>hashcode()的常规协定：<br>1） 一致性. 如果一个对象进行比较的信息没有发生修改，那么在一次程序运行期间，它们的hash值要一致。<br>2) 相等性. 如果两个对象通过 equals 比较是相等的，那么它们的 hashcode 也要相等。<br>3) 哈希碰撞概率低. 如果两个对象不相等，那么它们的 hashcode 最好不相等，这个可以提高哈希表的性能。</p>
<p>哈希函数很像之前数据结构的哈希查找的相关的内容。所以理解起来并不是很困难。</p>
<pre><code>public class hashCode {
    public static void main(String[] args) {
        String s = &quot;我感觉很难受&quot;;
        int hash = hash(s);
    }
    //加法哈希
    public static int hash(String str) {
        int hash = str.length();
        for (int i = 0; i &lt; str.length(); i++) {
            hash += str.charAt(i);  //字符运算默认转换成int
        }
        return hash;
    }
    //位运算哈希
    public static int hash2(String str) {
        int hash = str.length();
        for (int i = 0; i &lt; str.length(); i++) {
            hash = (hash&lt;&lt;4)^(hash&gt;&gt;28)^str.charAt(i);
        }
        return hash;
    }
    //乘法哈希
    public static int hash3(String str) {
        int hash = str.length();
        for (int i = 0; i &lt; str.length(); i++) {
            hash = hash*31+str.charAt(i);
        }
        return hash;
    }
}
</code></pre><h3 id="public-String-toString-（简历）"><a href="#public-String-toString-（简历）" class="headerlink" title="public String toString(): （简历）"></a>public String toString(): （简历）</h3><p>  返回该对象的字符串表示。结果应是一个简明但易于读懂的信息表达式。建议所有子类都重写此方法。<br>  默认实现：return getClass().getName() + “@” + Integer.toHexString(hashCode());</p>
<p>注意事项：<br>  直接打印对象, 默认会调用该对象的 toString() 方法。</p>
<h3 id="public-boolean-equals-Object-obj"><a href="#public-boolean-equals-Object-obj" class="headerlink" title="public boolean equals(Object obj):"></a>public boolean equals(Object obj):</h3><p>  指示其他某个对象是否与此对象”相等”。<br>  默认实现： return (this == obj); 判断两个对象的地址值是否相等 (是否是同一个对象)</p>
<p>实体类：</p>
<pre><code>一个对象对应一个实体。没有必要重写 Object 中的 equals();
</code></pre><p>值类：</p>
<pre><code>String, Point, 重写 equals 方法。
Rectangle:
关键域：length, width
衍生域：area, perimeter
无关域：color
根据关键域进行比较
</code></pre><p>equals方法常规协定：<br>    equals 方法在非空对象引用上实现相等关系：</p>
<pre><code>自反性：对于任何非空引用值 x，x.equals(x) 都应返回true。
对称性：对于任何非空引用值 x 和 y，当且仅当 y.equals(x) 返回true时，x.equals(y)才应返回true。
传递性：对于任何非空引用值 x、y 和 z，如果x.equals(y)返回 true，并且y.equals(z)返回 true，那么 x.equals(z) 应返回 true。
一致性：对于任何非空引用值 x 和 y，多次调用 x.equals(y) 始终返回 true 或始终返回 false，前提是对象上 equals 比较中所用的信息没有被修改。
非空性：对于任何非空引用值 x，x.equals(null) 都应返回 false。
</code></pre><p><strong><em>注意事项：当此方法被重写时，通常有必要重写hashCode方法，在IDEA中使用alt+insert可以自动生成。通常改写是为了比较两个对象是否“相等”，这里的相等，并不是地址值相等。而是成员内容相等。或者用于判断深拷贝是否成功</em></strong></p>
<pre><code>public boolean equals(Object o) {
  if(o == this) return true; //包括了null
  if(o == null || o.getClass() != this.getClass()) return false;
  //比较成员变量
  return id == emp.id &amp;&amp;
            Double.compare(emp.salary, salary) == 0 &amp;&amp;
            Objects.equals(name, emp.name) &amp;&amp;
            Objects.equals(flag, emp.flag);
}
</code></pre><p>instanceof:是 Java 的保留关键字。它的作用是测试它左边的对象是否是它右边的类的实例，返回 boolean 的数据类型。<br>    null instanceof 类名: 返回fasle;<br>    obj instanceof Object: 返回true, 子类能够内父类接受</p>
<p>instanceof可以判断类和类的关系吗？或者对象和对象的？</p>
<pre><code>只能判断对象是否是右边的类的实例或者是子类的实例。
</code></pre><h3 id="protected-void-finalize-throws-Throwable"><a href="#protected-void-finalize-throws-Throwable" class="headerlink" title="protected void finalize() throws Throwable"></a>protected void finalize() throws Throwable</h3><p>概述：当垃圾回收器回收这个对象时，会自动调用此方法。子类重写 finalize 方法，以释放资源。<br>默认实现：什么都没做，空实现。</p>
<p>finalize:</p>
<ol>
<li>可以自动调用, 该对象没有被回收。</li>
<li>当垃圾回收器回收这个对象时，会自动调用此方法。</li>
<li>释放资源最好不要放在 finalize() 里面。为什么？</li>
</ol>
<p>原因是：垃圾回收线程是一个优先级低的线程，当一个对象变成垃圾后，并不会马上被回收，因此资源得不到立刻释放。<br>怎么释放资源呢？<br>    try … catch … finally(异常处理)语句释放资源</p>
<h3 id="protected-Object-clone-throws-CloneNotSupportedException"><a href="#protected-Object-clone-throws-CloneNotSupportedException" class="headerlink" title="protected Object clone() throws CloneNotSupportedException"></a>protected Object clone() throws CloneNotSupportedException</h3><pre><code>创建并返回此对象的一个&quot;副本&quot;.
</code></pre><p>异常：CloneNotSupportedException。<br>解决方案：实现 Cloneable 接口<br>Cloneable(空接口, 标记接口):<br>    此类实现了 Cloneable 接口，以指示 Object.clone() 方法可以合法地对该类实例进行按字段复制。<br>如果在没有实现 Cloneable 接口的实例上调用 Object 的 clone 方法，则会导致抛出CloneNotSupportedException异常。<br>一个接口没有定义任何内容，叫做空接口，在Java中往往起标记作用。</p>
<p>Java的默认实现是浅拷贝和深拷贝？<br>    浅拷贝<br>实现深拷贝的例子：</p>
<p>首先先调用父类的clone()方法获取一个浅拷贝的对象，然后对里面的非基本数据类型的引用数据类型类型成员再clone新的对象赋给外层的成员变量。当然这个操作应该在那个引用数据类型对应的类里面进行编写的</p>
<pre><code>/*
  和在一个文件里面写
  这里注意记得把初始化的数据要传过去
*/
import java.util.Objects;

//第一层
public class FirstLevel implements Cloneable{

    int i;
    int j;
    SecondLevel sec;

    public FirstLevel() {

    }
    public FirstLevel(int i, int j, SecondLevel sec) {
        this.i = i;
        this.j = j;
        this.sec = sec;
    }

    @Override
    protected FirstLevel clone() throws CloneNotSupportedException {
        FirstLevel fl = (FirstLevel)super.clone();

        //如果要克隆的对象本身没有sec
        if(sec == null) {
            fl.sec = null;

        } else {
            //记得传初始化的数值进去给他初始化！
            SecondLevel secondLevel = new SecondLevel(fl.sec.j ,fl.sec.third);

            SecondLevel clone = secondLevel.clone();


            fl.sec = clone;
        }
        return fl;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        FirstLevel that = (FirstLevel) o;
        return i == that.i &amp;&amp;
                j == that.j &amp;&amp;
                Objects.equals(sec, that.sec);
    }

    @Override
    public int hashCode() {
        return Objects.hash(i, j, sec);
    }

    public static void main(String[] args) throws CloneNotSupportedException {
        ThirdLevel tl = new ThirdLevel(10);
        SecondLevel sl = new SecondLevel(20,tl);
        FirstLevel fl = new FirstLevel(30,40,sl);

        FirstLevel fl2 = fl.clone();
        System.out.println(fl == fl2);
        System.out.println(fl.equals(fl2));
        System.out.println(&quot;深拷贝成功&quot;);
    }
}
//第二层
class SecondLevel implements Cloneable {
    double j;
    ThirdLevel third;
    //无参构造方法
    public SecondLevel() {}

    public SecondLevel(double j, ThirdLevel third) {
        this.j = j;
        this.third = third;
    }
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        SecondLevel that = (SecondLevel) o;
        return Double.compare(that.j, j) == 0 &amp;&amp;
                Objects.equals(third, that.third);
    }

    @Override
    public int hashCode() {
        return Objects.hash(j, third);
    }

    protected SecondLevel clone() throws CloneNotSupportedException {
        SecondLevel sl = (SecondLevel)super.clone();
        if(third == null) {
            sl.third = null;
        } else {
            //初始化third对象；
            ThirdLevel tl = new ThirdLevel(third.k);
            ThirdLevel clone = tl.clone();
            sl.third = clone;
        }
        return sl;
    }
}
//第三层
class ThirdLevel implements Cloneable{
    int k;
    //无参构造方法
    public ThirdLevel() {

    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        ThirdLevel that = (ThirdLevel) o;
        return k == that.k;
    }

    @Override
    public int hashCode() {
        return Objects.hash(k);
    }

    public ThirdLevel(int k) {
        this.k = k;
    }
    protected ThirdLevel clone() throws CloneNotSupportedException {
        ThirdLevel tl = (ThirdLevel)super.clone();
        return tl;
    }
}
</code></pre><h2 id="星期六"><a href="#星期六" class="headerlink" title="星期六"></a>星期六</h2><p>介绍了String的构造函数和一些常用的API</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>public String()<br>public String(byte[] bytes)<br>public String(byte[] bytes,int offset,int length)<br>public String(char[] value)<br>public String(char[] value,int offset,int count)<br>public String(String original)</p>
<h3 id="判断功能："><a href="#判断功能：" class="headerlink" title="判断功能："></a>判断功能：</h3><p>boolean equals(Object obj)<br>boolean equalsIgnoreCase(String str)<br>boolean contains(String str)<br>    判断一个字符串是否包含另一个字符串<br>boolean startsWith(String str)<br>    判断字符串是否以给定的字符串开头<br>boolean endsWith(String str)<br>    判断字符串是否以给定的字符串结束<br>boolean isEmpty()<br>    判断一个字符串是否是空串</p>
<h3 id="获取功能："><a href="#获取功能：" class="headerlink" title="获取功能："></a>获取功能：</h3><p>int length()<br>    获取字符的个数<br>char charAt(int index)<br>    获取指定索引的字符<br>int indexOf(int ch)<br>    判断字符在字符串中第一次出现的索引位置，如果该字符不存在返回负数。<br>int indexOf(String str)<br>    判断str在字符串中第一次出现的索引位置，如果该str不存在返回负数。<br>    返回的是第一个字符所在位置的索引<br>int indexOf(int ch,int fromIndex)<br>    从指定的索引位置开始，判断是否包含该字符<br>int indexOf(String str,int fromIndex)<br>    从指定的索引位置开始，判断是否包含该字符串str<br>int lastIndexOf(int ch)<br>int lastIndexOf(int ch, int fromIndex)<br>int lastIndexOf(String str)<br>int lastIndexOf(String str, int fromIndex)</p>
<p>String substring(int start)<br>    截取子串, 从start开始，截取到最后<br>String substring(int start,int end) (包左不包右，包括start，不包括end)<br>     截取子串, 从start开始，截取到end。</p>
<h3 id="转换功能："><a href="#转换功能：" class="headerlink" title="转换功能："></a>转换功能：</h3><p>  byte[] getBytes()<br>  char[] toCharArray()<br>  static String valueOf()<br>  String toLowerCase()<br>  String toUpperCase()<br>  String concat(String str)</p>
<p>byte[] –&gt; String<br>    new String(byte[])<br>String –&gt; byte[]<br>    getBytes()<br>char[] –&gt; String<br>    new String(char[])<br>String –&gt; char[]<br>    toCharArray();</p>
<p>任意类型 –&gt; String<br>    valueOf()</p>
<h3 id="替换功能"><a href="#替换功能" class="headerlink" title="替换功能"></a>替换功能</h3><p>String replace(char old,char new)<br>    将所有的字符old转化成new<br>String replace(String old,String new)<br>    将所有的字符串old转化成new<br>String trim()<br>    修建字符串两边的空白字符</p>
<h3 id="字符串分割："><a href="#字符串分割：" class="headerlink" title="字符串分割："></a>字符串分割：</h3><p>public String[] split(String regex)<br>    根据给定正则表达式的匹配拆分此字符串。</p>
<h3 id="比较功能："><a href="#比较功能：" class="headerlink" title="比较功能："></a>比较功能：</h3><p>Comparable:(可以进行比较，表示对象的一种能力)<br>    int compareTo(T o)<br>    比较此对象与指定对象的顺序。<br>    如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。</p>
<h3 id="markdown格式："><a href="#markdown格式：" class="headerlink" title="markdown格式："></a>markdown格式：</h3><p>表格使用竖杠| 分割，注意要上下都有空格才能显示正确；</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这周的内容比较乱。但是总体还是把类和对象讲完了。脑海也有一个整体的概念。就是内部类的细节和深拷贝有一点难度以外。其他东西都很基础，必须要掌握。对象成员的继承关系，以及子类的初始化过程等等。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">王邸</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王邸</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'Fn4BuvoixOxjJAhR79TvaD5M-gzGzoHsz',
        appKey: '1uspTrSwPqkmSBSUr948WqxE',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
