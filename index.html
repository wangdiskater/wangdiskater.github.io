<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="路要坚持">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="路要坚持">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="路要坚持">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>路要坚持</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">路要坚持</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/22/jdbcTemplate使用总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王邸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路要坚持">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/22/jdbcTemplate使用总结/" itemprop="url">jdbcTemplate使用总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-22T23:31:30+08:00">
                2019-09-22
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/09/22/jdbcTemplate使用总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/09/22/jdbcTemplate使用总结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2019/09/22/jdbcTemplate使用总结/" class="leancloud_visitors" data-flag-title="jdbcTemplate使用总结">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-查（Query）"><a href="#1-查（Query）" class="headerlink" title="1 查（Query）"></a>1 查（Query）</h3><p>1.1 基本类型</p>
<pre><code>@Test
public void queryTest(){
   String sql = &quot;select username from j12_user_t where password = ?&quot;;
   String lisi = jdbcTemplate.queryForObject(sql, String.class, &quot;lisi&quot;);
   System.out.println(&quot;username = &quot; + lisi);
}
</code></pre><p>—-output:<br>username = zhangsan</p>
<p>1.2 Javabean</p>
<pre><code>@Test
public void queryTest2(){
   String sql = &quot;select username,password,id from j12_user_t where id = ? &quot;;
   RowMapper&lt;User&gt; rowMapper = new BeanPropertyRowMapper&lt;User&gt;(User.class);
   User user = jdbcTemplate.queryForObject(sql, rowMapper,&quot;8&quot;);
   System.out.println(&quot;user = &quot; + user);
}
</code></pre><p>—-output:<br>user = User{id=’8’, username=’wangwu33’, password=’123456’}</p>
<p>1.3 Map</p>
<pre><code>@Test
public void queryTest3(){
   String sql = &quot;select username,password,id,age,gender from j12_user_t where id = ? &quot;;
   Map&lt;String, Object&gt; userMap = jdbcTemplate.queryForMap(sql, &quot;8&quot;);
   System.out.println(&quot;user = &quot; + userMap);
}
</code></pre><p>—-output:<br>user = {username=wangwu33, password=123456, id=8, age=15, gender=male}</p>
<p>1.4 List</p>
<pre><code>@Test
public void queryTest4(){
   String sql = &quot;select username,password,id from j12_user_t where id = ? or id = ?&quot;;
   RowMapper&lt;User&gt; rowMapper = new BeanPropertyRowMapper&lt;User&gt;(User.class);
   List&lt;User&gt; users = jdbcTemplate.query(sql, rowMapper,&quot;8&quot;,&quot;9&quot;);
   System.out.println(&quot;users = &quot; + users);
}
</code></pre><p>—-output:<br>users = [User{id=’8’, username=’wangwu33’, password=’123456’}, User{id=’9’, username=’zhangsan’, password=’lisi’}]</p>
<h3 id="2-增（Update）"><a href="#2-增（Update）" class="headerlink" title="2 增（Update）"></a>2 增（Update）</h3><pre><code>@Test
public void increaseTest1(){
   String sql = &quot;insert into j12_user_t (username,password,age,gender) value (?,?,?,?)&quot;;
   int update = jdbcTemplate.update(sql, &quot;lanzhao&quot;, &quot;123456&quot;, &quot;30&quot;, &quot;male&quot;);
   System.out.println(&quot;update = &quot; + update);
}
</code></pre><p>—-output:<br>update = 1</p>
<h3 id="3-删（Update）"><a href="#3-删（Update）" class="headerlink" title="3 删（Update）"></a>3 删（Update）</h3><pre><code>@Test
public void deleteTest2(){
   String sql = &quot;delete from j12_user_t where id = ?&quot;;
   int update = jdbcTemplate.update(sql, 1);
   System.out.println(&quot;delete = &quot; + update);
}
</code></pre><p>—-output:<br>delete = 1</p>
<h3 id="4-改（Update）"><a href="#4-改（Update）" class="headerlink" title="4 改（Update）"></a>4 改（Update）</h3><pre><code>@Test
public void updateTest3(){
   String sql = &quot;update j12_user_t set username = ? where id = ?&quot;;
   int update = jdbcTemplate.update(sql, &quot;zhaoge&quot;, 10);
   System.out.println(&quot;update = &quot; + update);
}
</code></pre><p>—-output:<br>update = 1</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/22/Java总结（十三）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王邸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路要坚持">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/22/Java总结（十三）/" itemprop="url">Java总结（十三）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-22T23:30:56+08:00">
                2019-09-22
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/09/22/Java总结（十三）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/09/22/Java总结（十三）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2019/09/22/Java总结（十三）/" class="leancloud_visitors" data-flag-title="Java总结（十三）">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>从这周开始，总结分为两类，一类是总结知识点，一类是每天遇到的问题。思考填坑等等</p>
<p><strong><em>总结部分</em></strong></p>
<h2 id="周日（9月15日）"><a href="#周日（9月15日）" class="headerlink" title="周日（9月15日）"></a>周日（9月15日）</h2><h2 id="星期日（0915）"><a href="#星期日（0915）" class="headerlink" title="星期日（0915）"></a>星期日（0915）</h2><h3 id="AOP-切面编程介绍"><a href="#AOP-切面编程介绍" class="headerlink" title="AOP 切面编程介绍"></a>AOP 切面编程介绍</h3><p>在软件业，面向切面编程，是指通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP（面向对象编程）的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容。<br>利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>
<h3 id="AOP的特点"><a href="#AOP的特点" class="headerlink" title="AOP的特点"></a>AOP的特点</h3><p>AOP采取<strong>横向抽取</strong>机制，取代了传统纵向继承体系重复性代码<br>Spring AOP使用纯Java实现，不需要专门的编译过程和类加载器，在运行期通过代理方式向目标类织入增强代码</p>
<h3 id="经典应用："><a href="#经典应用：" class="headerlink" title="经典应用："></a>经典应用：</h3><pre><code>事务管理、性能监视、安全检查、缓存 、日志等
</code></pre><p>这些系统服务通常被称为横切关注点<br>想象一下如果每个组件都单独去实现这些系统功能</p>
<pre><code>改变这些关注点的逻辑，修改各个模块当中的实现，方法的调用就会重复出现在各个模块中
组件会因为那些与自身核心业务无关的代码而变得混乱
</code></pre><h3 id="AOP编程术语"><a href="#AOP编程术语" class="headerlink" title="AOP编程术语"></a>AOP编程术语</h3><p><strong>Target</strong>：目标类，委托类，举例：房东<br><strong>Pointcut</strong>：切入点，通过切入点 指定要等增强：谁<br><strong>Advice</strong>：通知：在什么时机 做什么事情<br><strong>切面</strong>：切入点+通知。通知 谁 在什么时机 做什么事情</p>
<h3 id="aop底层将采用代理机制进行实现。"><a href="#aop底层将采用代理机制进行实现。" class="headerlink" title="aop底层将采用代理机制进行实现。"></a>aop底层将采用代理机制进行实现。</h3><p>动态代理的两种机制<br>A:jdk<br>接口 + 实现类 ：spring采用 jdk 的动态代理Proxy。<br>怎么做的？基于接口去实现。<br>缺点：如果目标类没有实现任何接口呢？jkd动态代理就无能为力。<br>B:cglib<br>实现类：spring 采用 cglib字节码增强。<br>怎么做的？基于继承。也可以实现动态代理。<br>建立切面</p>
<p><strong>SpringAOP的本质就是动态代理，那么Spring到底使用的是JDK代理，还是cglib代理呢？</strong></p>
<pre><code>答：混合使用。如果被代理对象实现了接口，就优先使用JDK代理，如果没有实现接口，就用用cglib代理。
</code></pre><h3 id="AOP实战"><a href="#AOP实战" class="headerlink" title="AOP实战"></a>AOP实战</h3><p>三种方式<br>1.手动方式(自己实现)</p>
<pre><code>JDK动态代理
CGLib动态代理
</code></pre><p>2.半自动方式(SpringAOP了解)<br><strong>3.自动方式（AspectJ掌握重点！）</strong></p>
<p>第一种方式之前我们就已经讲过了在上周的复习中就已经写了手动动态代理，</p>
<h3 id="手动方式"><a href="#手动方式" class="headerlink" title="手动方式"></a>手动方式</h3><p>jdk动态代理 Proxy.newProxyInstance</p>
<pre><code>@Test
public void mytest(){
  RentHouse houseOwner = new HouseOwner();
  //参数1 委托类类加载器
  //参数2 委托类的接口
  //参数3 响应处理器
  RentHouse houseProxy = (RentHouse) Proxy.newProxyInstance(houseOwner.getClass().getClassLoader(), houseOwner.getClass().getInterfaces(),
        new InvocationHandler() {
    //参数1：代理对象
    //参数2：代理对象正在执行的方法
    //参数3：代理对象正在执行的方法所对应的参数
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
      if (&quot;toString&quot;.equals(method.getName())){
        return null;
      }
      if (&quot;rentHouse&quot;.equals(method.getName())){
        args[0] = (int)args[0] - 500;
      }
      System.out.println(method.getName() + &quot;委托类执行方法前&quot;);
      //这一行代码相当于去执行委托类的方法
      //参数1：委托类的实例（而不是代理类的实例，不要写成proxy）
      //参数2：想要委托类去执行方法的参数（可以是对args处理后的参数）
      Object invoke = method.invoke(houseOwner, args);
      System.out.println(&quot;委托类执行方法后&quot;);
      return invoke;
    }
  });
</code></pre><p>cglib动态代理（需要引入Spring-context）Enhancer.create</p>
<pre><code>public class CglibTest {
  @Test
  public void mytest(){
    HouseOwner houseOwner = new HouseOwner();
    HouseOwner houseOwnerProxy = (HouseOwner) Enhancer.create(HouseOwner.class, new InvocationHandler() {
      @Override
      public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println(&quot;before &quot;);
        args[0] = args[0]-500;//当场拿走中介费
        Object invoke = method.invoke(houseOwner, args);
        System.out.println(&quot;after&quot;);
        return invoke;
      }
    });
    boolean b = houseOwnerProxy.rentHouse(2000);
  }
}
</code></pre><p>这里主要就讲解第二种和第三种。当然最重要的还是使用AspectJ来实现</p>
<h3 id="AOP实战——SpringAOP"><a href="#AOP实战——SpringAOP" class="headerlink" title="AOP实战——SpringAOP"></a>AOP实战——SpringAOP</h3><p>核心：就是userSerive通过 proxyFactory 和通知的实例去获取 userServiceProxy 对象，然后从容器中取出代理对象的实例，调用实例的方法。</p>
<p>关键点1： UserServiceImpl</p>
<pre><code>@Service(&quot;userService&quot;)
public class UserServiceImpl implements UserService {
  @Override
  public int register(String username, String password) {
    System.out.println(&quot;username = &quot; + username + &quot;|| password = &quot; + password);
    return 0;
  }
}
</code></pre><p>关键点二：一个 <strong>advice 对象</strong>，起通知的作用（ 其实也就是和动态代理很相似的部分 ）<br>Advice通知的实例（实现MethodInterceptor的接口，通过invoke方法通知在什么之间做什么事情）</p>
<pre><code>@Component(&quot;myadvice&quot;)
public class CustomAdvice implements MethodInterceptor {
  @Override
  public Object invoke(MethodInvocation methodInvocation) throws Throwable {
    System.out.println(&quot;before&quot;);
    //这一行执行的是委托类的方法，类似于动态代理中的method.invoke
    Object proceed = methodInvocation.proceed();
    System.out.println(&quot;after&quot;);
    return proceed;
  }
}
</code></pre><p>关键点三：获取代理的对象(<strong>ProxyFactoryBean</strong>)<br>UserServiceProxy代理对象的实例（通过<strong>目标对象</strong>和<strong>interceptorName</strong>→容器中通知）<br>在application.xml中编写下面代码：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;
        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
  &lt;!-- bean definitions here --&gt;
  &lt;context:component-scan base-package=&quot;com.cskaoyan&quot;/&gt;
  &lt;bean id=&quot; userServiceProxy &quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;
    &lt;!-- 目标对象 --&gt;
    &lt;property name=&quot;target&quot; ref=&quot;userService&quot;/&gt;
    &lt;!--容器中这个通知的名称（id）--&gt;
    &lt;property name=&quot;interceptorNames&quot; value=&quot;myadvice&quot;/&gt;
  &lt;/bean&gt;
&lt;/beans&gt;
</code></pre><p>最后再进行单元测试</p>
<pre><code>@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(&quot;classpath:application.xml&quot;)
public class AopTest {
  @Resource(name = &quot;userService&quot;)
  UserService userService;
  @Resource(name = &quot;userServiceProxy&quot;)
  UserService userServiceProxy;
  @Test
  public void mytest(){
    //不会调用通知的方法
    userService.register(&quot;songge&quot;,&quot;123456&quot;);
  }
  @Test
  public void mytest2(){
    userServiceProxy.register(&quot;songge&quot;,&quot;123456&quot;);
  }
}
</code></pre><p>特点：target的所有方法，全部带上了增强，这就和手动的区别不大，直接给所有方法增强</p>
<p>不足之处</p>
<pre><code>1.哪些方法被增强需要写代码判断
2.增强的代码有要求，必须实现一些接口
3.如果多个对象增强，那么就要多个ProxyFactoryBean来构建增强的对象
</code></pre><h3 id="AOP实战–AspectJ（先以aop-advisor为例）"><a href="#AOP实战–AspectJ（先以aop-advisor为例）" class="headerlink" title="AOP实战–AspectJ（先以aop:advisor为例）"></a>AOP实战–AspectJ（先以aop:advisor为例）</h3><h3 id="3-1-导包"><a href="#3-1-导包" class="headerlink" title="3.1 导包"></a>3.1 导包</h3><pre><code>&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
    &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
    &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;junit&lt;/groupId&gt;
    &lt;artifactId&gt;junit&lt;/artifactId&gt;
    &lt;version&gt;4.12&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
  &lt;/dependency&gt;
</code></pre><p><strong>导入织入包</strong>要使用切入点表达式，就要导入织入包</p>
<pre><code>  &lt;!--织入包--&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
    &lt;version&gt;1.6.12&lt;/version&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre><h3 id="配置文件配置（切入点表达式和通知）"><a href="#配置文件配置（切入点表达式和通知）" class="headerlink" title="配置文件配置（切入点表达式和通知）"></a>配置文件配置（切入点表达式和通知）</h3><pre><code>&lt;!-- bean definitions here --&gt;
&lt;context:component-scan base-package=&quot;com.cskaoyan&quot;/&gt;
&lt;!--使用aspectJ--&gt;
&lt;aop:config&gt;
  &lt;!--pointcut--&gt;
  &lt;!--切入点的表达式：指定的是方法→容器中组件的方法--&gt;
  &lt;aop:pointcut id=&quot;mypointcut&quot; expression=&quot;execution(com.cskaoyan.bean.User *.cs*..*(..))&quot;/&gt;
  &lt;!--advisor--&gt;
  &lt;aop:advisor advice-ref=&quot;myadvice&quot; pointcut-ref=&quot;mypointcut&quot; /&gt;
&lt;/aop:config&gt;
</code></pre><p><strong>注意事项</strong>这里用了expression = “execution()”这里用了切入表达式之后会介绍</p>
<h3 id="业务逻辑模块组件注册"><a href="#业务逻辑模块组件注册" class="headerlink" title="业务逻辑模块组件注册"></a>业务逻辑模块组件注册</h3><pre><code>@Service(&quot;userService&quot;)
public class UserServiceImpl implements UserService {
  @Override
  public User register(String username, String password) {
    System.out.println(&quot;username = &quot; + username + &quot;|| password = &quot; + password);
    return new User();
  }
}
</code></pre><h3 id="Advisor-需要实现-MethodInterceptor（方法拦截器）类"><a href="#Advisor-需要实现-MethodInterceptor（方法拦截器）类" class="headerlink" title="Advisor 需要实现 MethodInterceptor（方法拦截器）类"></a>Advisor 需要实现 MethodInterceptor（方法拦截器）类</h3><pre><code>@Component(&quot;myadvice&quot;)
public class CustomAdvice implements MethodInterceptor {
    @Override
    public Object invoke(MethodInvocation methodInvocation) throws Throwable {
        System.out.println(&quot;before&quot;);
        //这一行执行的是委托类的方法，类似于动态代理中的method。invoke
        Object proceed = methodInvocation.proceed();
        System.out.println(&quot;after&quot;);
        return proceed;
    }
}
</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><pre><code>@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(&quot;classpath:application.xml&quot;)
public class AspectjTest {
    @Autowired
    UserService userService;
    @Test
    public void myteste(){
        userService.register(&quot;zhangsong&quot;,&quot;123456&quot;);
    }
}
</code></pre><p><strong>使用切入点表达式之后，再也不用全部都加强了，哪里需要点哪里！</strong></p>
<h3 id="Aspect介绍用法（最重要的）"><a href="#Aspect介绍用法（最重要的）" class="headerlink" title="Aspect介绍用法（最重要的）"></a>Aspect介绍用法（最重要的）</h3><p>切面类：切入点 和 通知，两点分别讨论</p>
<h3 id="切入点pointcut"><a href="#切入点pointcut" class="headerlink" title="切入点pointcut"></a>切入点pointcut</h3><p>切入点最主要就是:切入点表达式<br>指定要被增强的方法</p>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p><strong>execution（修饰符 返回值 包名.类名.方法名（参数））</strong></p>
<h3 id="3-4-1-修饰符"><a href="#3-4-1-修饰符" class="headerlink" title="3.4.1 修饰符"></a>3.4.1 修饰符</h3><p>（public,provided,default,private,static,finnal…..）<br>不写 == 通配<br>通常我们也不写修饰符</p>
<h3 id="3-4-2-返回值"><a href="#3-4-2-返回值" class="headerlink" title="3.4.2 返回值"></a>3.4.2 返回值</h3><p>能不能省略？ 不能省略，省略还知道是哪个方法？<br>能不能通配？ 可以通配，使用*代表任意类型的返回值<br>特殊情况：返回值要写类的<strong>全类名</strong>。除了java.lang包下的类和基本类型可以直接写。</p>
<h3 id="3-4-3-包名-类名-方法名"><a href="#3-4-3-包名-类名-方法名" class="headerlink" title="3.4.3 包名+类名+方法名"></a>3.4.3 包名+类名+方法名</h3><p>能不能省略？ 可以省略（有条件），除了头和尾，使用<strong>..</strong>省略中间的部分,头尾不能省<br>能不能通配？ 可以通配，使用*通配，代表一个单词或者一个单词的一部分，最多通配一级目录。 头和尾都可以进行通配</p>
<h3 id="3-4-4-参数"><a href="#3-4-4-参数" class="headerlink" title="3.4.4 参数"></a>3.4.4 参数</h3><p>能不能省略？（）对应的是无参的方法<br>能不能写一个东西代表任意类型任意个数的参数呢？使用<strong>..</strong> method_name(..)。有点像可变参数，但是可变参数三个.<br>能不能通配？* 进行通配，一个*通配一个任意类型的参数，如果多个参数就多个*<br>特殊情况：特定的参数类型需要写类的全类名。除了java.lang包下的类和基本类型可以直接写</p>
<h3 id="通知（advisor）"><a href="#通知（advisor）" class="headerlink" title="通知（advisor）"></a>通知（advisor）</h3><p>我们在&lt;aop:config&gt;标签中看到里面可以写三个aop的标签：</p>
<pre><code>&lt;aop:pointcut id=&quot;mypointcut1&quot; expression=&quot;execution(* com..impl..*(..))&quot;/&gt;
&lt;aop:advisor advice-ref=&quot;myadvice&quot; pointcut-ref=&quot;mypointcut&quot; /&gt;
&lt;aop:aspect ref=&quot;customAspect&quot;&gt;
  &lt;!--通知类型before、after、around、afterThrowing、afterReturning--&gt;
  &lt;!--method写切面类中所包含的方法--&gt;
  &lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;mypointcut1&quot;/&gt;
  &lt;aop:before method=&quot;mybefore&quot; pointcut-ref=&quot;mypointcut1&quot;/&gt;
  &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;mypointcut1&quot;/&gt;
  &lt;aop:after-throwing method=&quot;myAfterThrowing&quot; pointcut-ref=&quot;mypointcut1&quot; throwing=&quot;myexception&quot;/&gt;
  &lt;aop:after-returning method=&quot;myAfterReturning&quot; pointcut-ref=&quot;mypointcut1&quot; returning=&quot;myreturnResult&quot;/&gt;
&lt;/aop:aspect&gt;
</code></pre><p>在之前的例子中已经说了前面两个怎么使用：<br>一个是切入点，expression写切入点表达式<br>还有一个是aop:advisor，这里需要两个东西：一个是切入点表达式，一个是通知的方法（也就是动态代理的方法）<br>这里介绍第三个：<strong>aop:aspect</strong>—–里面写的是通知类型<br>我们看到这里面也有很多通知的类型</p>
<h3 id="AspectJ通知类型"><a href="#AspectJ通知类型" class="headerlink" title="AspectJ通知类型"></a>AspectJ通知类型</h3><p>Before<br>    在切入点之前执行。 参数类型的校验。 前置通知。</p>
<p>AtterReturning<br>    周在切入点之后执行。。后置通知，可以对结果进行检查。增加log</p>
<p>Around<br>    环绕通知 在切入点之前和之后都会执行。增加事务。等等。</p>
<p>AfterThrowing<br>    抛出异常的时候执行通知。正常情况下走不到。只有发生异常的情况下才会去通知。记录一些日志。</p>
<p>After<br>    在finally语句里。不管切入点是否有异常发生都会执行。类似finally</p>
<p>我们可以看出around类型的通知类型，很像之前的aop:advisor，可以在之前之后搞事情。</p>
<p>接下来我们通过例子来使用这种AOP<br>service</p>
<pre><code>@Service(&quot;userService&quot;)
public class UserServiceImpl implements UserService {
  @Override
  public User register(String username, String password) {
      System.out.println(&quot;username = &quot; + username + &quot;|| password = &quot; + password);
      //int i = 1/0;
      return new User(username,password);
  }
  @Override
  public void myvoid() {
      System.out.println(&quot;myvoid&quot;);
  }
}
</code></pre><p>application.xml</p>
<pre><code>&lt;!-- spring注解扫描开关 --&gt;
&lt;context:component-scan base-package=&quot;com.cskaoyan&quot;/&gt;
&lt;aop:config&gt;
    &lt;aop:pointcut id=&quot;mypointcut1&quot; expression=&quot;execution(* com..impl..*(..))&quot;/&gt;
    &lt;aop:aspect ref=&quot;customAspect&quot;&gt;
      &lt;!--通知类型before、after、around、afterThrowing、afterReturning--&gt;
      &lt;!--method写切面类中所包含的方法--&gt;
      &lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;mypointcut1&quot;/&gt;
      &lt;aop:before method=&quot;mybefore&quot; pointcut-ref=&quot;mypointcut1&quot;/&gt;
      &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;mypointcut1&quot;/&gt;
      &lt;aop:after-throwing method=&quot;myAfterThrowing&quot; pointcut-ref=&quot;mypointcut1&quot; throwing=&quot;myexception&quot;/&gt;
      &lt;aop:after-returning method=&quot;myAfterReturning&quot; pointcut-ref=&quot;mypointcut1&quot; returning=&quot;myreturnResult&quot;/&gt;
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
</code></pre><p><strong>aop:aspect ref=”customAspect”</strong> customAspect,就是我们的通知的对象，作用类似于之前的:CustomAdvice</p>
<pre><code>//不需要实现接口，也不需要继承类
//如果注解组件注册时没有指定id，使用类名首字母小写的形式
//必须要注册（@Component），要不然application.xml找不到这个引用
@Component
public class CustomAspect {

  public void mybefore(JoinPoint joinPoint){
    Object[] args = joinPoint.getArgs();
    System.out.println(Arrays.toString(args));
    String methodName = joinPoint.getSignature().getName();
    System.out.println(&quot;method = &quot; + methodName);
    System.out.println(&quot;aspect的before&quot;);
  }
  public void after(JoinPoint joinPoint){
    System.out.println(&quot;aspect的after&quot;);
  }

  public Object around(ProceedingJoinPoint joinPoint) throws Throwable {
    System.out.println(&quot;around 的before&quot;);
    //这一行做的是执行目标类的方法
    Object proceed = joinPoint.proceed();
    System.out.println(&quot;around的after&quot;);
    return proceed;
  }
  public void myAfterThrowing(Throwable myexception){
    System.out.println(&quot;myexception =&quot; + myexception.getMessage());
  }

  public void myAfterReturning(Object myreturnResult){
    System.out.println(&quot;returning&quot; + myreturnResult);
  }
}
</code></pre><p>测试我们就略过了。我们看到这里面通知的类型的方法里面有一个joinPoint的参数</p>
<h3 id="JointPoint"><a href="#JointPoint" class="headerlink" title="JointPoint"></a>JointPoint</h3><p>作为通知方法的形参，可以通过joinPoint拿到代理对象、目标对象、方法、参数</p>
<h3 id="ProceedingJoinPoint"><a href="#ProceedingJoinPoint" class="headerlink" title="ProceedingJoinPoint"></a>ProceedingJoinPoint</h3><p>在public Object around(ProceedingJoinPoint joinPoint) throws Throwable {}<br>我们发现这里的返回值是一个Object,然后传入的参数并不是JointPoint类型的，而是ProceedingJoinPoint。</p>
<pre><code>public interface ProceedingJoinPoint extends JoinPoint {
  void set$AroundClosure(AroundClosure var1);
  Object proceed() throws Throwable;
  Object proceed(Object[] var1) throws Throwable;
}
</code></pre><p>就这点东西，继承了JoinPoint</p>
<pre><code>//这两个方法做的是执行目标类的方法
Object proceed() throws Throwable;
Object proceed(Object[] var1) throws Throwable;
</code></pre><p>然后我发现在<strong>spring-aop.java</strong>中实现了这两个方法：</p>
<pre><code>public Object proceed() throws Throwable {
      return this.methodInvocation.invocableClone().proceed();
  }
public Object proceed(Object[] arguments) throws Throwable {
  Assert.notNull(arguments, &quot;Argument array passed to proceed cannot be null&quot;);
  if (arguments.length != this.methodInvocation.getArguments().length) {
      throw new IllegalArgumentException(&quot;Expecting &quot; + this.methodInvocation.getArguments().length + &quot; arguments to proceed, but was passed &quot; + arguments.length + &quot; arguments&quot;);
  } else {
      this.methodInvocation.setArguments(arguments);
      return this.methodInvocation.invocableClone(arguments).proceed();
  }
}
</code></pre><h2 id="通过注解去实现切面-AspectJ-太重要了给一个二级标签"><a href="#通过注解去实现切面-AspectJ-太重要了给一个二级标签" class="headerlink" title="通过注解去实现切面 AspectJ (太重要了给一个二级标签)"></a>通过注解去实现切面 AspectJ (太重要了给一个二级标签)</h2><p>因为以后最常用的就是AspectJ的AOP。所以为了更方便，我们必须要选择使用注解代。<br>每次我们使用注解都要思考一个问题：<br><strong>我们使用注解的目的是什么？到底代替的是什么东西</strong><br>仔细看我们到底哪些文件用了AspectJ？</p>
<h3 id="application-xml"><a href="#application-xml" class="headerlink" title="application.xml"></a>application.xml</h3><pre><code>&lt;!--通过注解的形式 实现aspect--&gt;
&lt;!--打开aspectJ的注解开关--&gt;
&lt;aop:aspectj-autoproxy/&gt;
</code></pre><p>代替之前的：&lt;aop:config&gt;</p>
<pre><code>&lt;aop:config&gt;
  &lt;aop:pointcut id=&quot;mypointcut1&quot; expression=&quot;execution(* com..impl..*(..))&quot;/&gt;
  &lt;aop:aspect ref=&quot;customAspect&quot;&gt;
    &lt;!--通知类型before、after、around、afterThrowing、afterReturning--&gt;
    &lt;!--method写切面类中所包含的方法--&gt;
    &lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;mypointcut1&quot;/&gt;
    &lt;aop:before method=&quot;mybefore&quot; pointcut-ref=&quot;mypointcut1&quot;/&gt;
    &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;mypointcut1&quot;/&gt;
    &lt;aop:after-throwing method=&quot;myAfterThrowing&quot; pointcut-ref=&quot;mypointcut1&quot; throwing=&quot;myexception&quot;/&gt;
    &lt;aop:after-returning method=&quot;myAfterReturning&quot; pointcut-ref=&quot;mypointcut1&quot; returning=&quot;myreturnResult&quot;/&gt;
  &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
</code></pre><p>aop:pointcut和aop:aspect要怎么替换呢？直接去ref=”customAspect”里面去改就好了。</p>
<h3 id="CustomAspect-java"><a href="#CustomAspect-java" class="headerlink" title="CustomAspect.java"></a>CustomAspect.java</h3><p>修改后的文件：</p>
<pre><code>//不需要实现接口，也不需要继承类
//如果注解组件注册时没有指定id，使用类名首字母小写的形式
@Component
@Aspect//这是一个切面类的注解
public class CustomAspect {

    // 通过一个方法去写切入点表达式
    @Pointcut(&quot;execution(* com..impl..*(..))&quot;)
    public void mypointcut(){}

    @Before(&quot;mypointcut()&quot;)
    public void mybefore(JoinPoint joinPoint){
        Object[] args = joinPoint.getArgs();
        System.out.println(Arrays.toString(args));
        String methodName = joinPoint.getSignature().getName();
        System.out.println(&quot;method = &quot; + methodName);
        System.out.println(&quot;aspect的before&quot;);
    }
    @After(value = &quot;mypointcut()&quot;)
    public void after(){
        System.out.println(&quot;aspect的after&quot;);
    }

    @Around(&quot;mypointcut()&quot;)
    public Object around(ProceedingJoinPoint joinPoint) throws Throwable {
        System.out.println(&quot;around 的before&quot;);
        //这一行做的是执行目标类的方法
        Object proceed = joinPoint.proceed();
        System.out.println(&quot;around的after&quot;);
        return proceed;
    }
    @AfterThrowing(value = &quot;mypointcut()&quot;,throwing = &quot;myexception&quot;)
    public void myAfterThrowing(Throwable myexception){
        System.out.println(&quot;myexception =&quot; + myexception.getMessage());
    }

    @AfterReturning(value = &quot;mypointcut()&quot;,returning = &quot;myreturnResult&quot;)
    public void myAfterReturning(Object myreturnResult){
        System.out.println(&quot;returning&quot; + myreturnResult);
    }
}
</code></pre><p>有三个地方要修改：<br>1.首先要通过注解表示这是一个Aspect的对象</p>
<pre><code>@Aspect
</code></pre><p>2.要定义我们的<strong>切入点</strong>，注解写在一个方法上，方法名就是我们pointcut的名字，注解的内容就是切入点表达式</p>
<pre><code>// 通过一个方法去写切入点表达式
@Pointcut(&quot;execution(* com..impl..*(..))&quot;)
public void mypointcut(){}
</code></pre><p>3.需要在我们的通知类型的对应的方法上加上注解</p>
<pre><code>@Before(&quot;mypointcut()&quot;)
@After(value = &quot;mypointcut()&quot;)
@Around(&quot;mypointcut()&quot;)
</code></pre><p><strong>下面两个要加上returning 和throwing,value就是pointcut的名字</strong></p>
<pre><code>@AfterThrowing(value = &quot;mypointcut()&quot; ,throwing = &quot;myexception&quot;)
@AfterReturning(value = &quot;mypointcut()&quot;,returning = &quot;myreturnResult&quot;)
</code></pre><h3 id="通过自定义注解只给一个方法进行加强"><a href="#通过自定义注解只给一个方法进行加强" class="headerlink" title="通过自定义注解只给一个方法进行加强"></a>通过自定义注解只给一个方法进行加强</h3><h2 id="先对之前的AOP写一个小结"><a href="#先对之前的AOP写一个小结" class="headerlink" title="先对之前的AOP写一个小结"></a>先对之前的AOP写一个小结</h2><p>我们一开始是通过手动的动态代理，Spring-AOP给一个类的<strong>所有方法进行加强</strong><br>然后使用了Apectj，设置切面类（切点+通知）我们可以给<strong>任意类的任意一些方法进行加强</strong>，切点表达式切到哪个方法哪个方法就加强<br>现在我们使用自定义注解，给<strong>一个方法</strong>进行加强。</p>
<h3 id="如何操作自定义注解？"><a href="#如何操作自定义注解？" class="headerlink" title="如何操作自定义注解？"></a>如何操作自定义注解？</h3><p>application不变</p>
<h3 id="先创建一个自定义的注解"><a href="#先创建一个自定义的注解" class="headerlink" title="先创建一个自定义的注解"></a>先创建一个自定义的注解</h3><p>我们知道一个自定义的注解需要两个元注解:<strong>@Target,@Retention</strong></p>
<pre><code>@Target(ElementType.METHOD)         //这个注解写在方法上
@Retention(RetentionPolicy.RUNTIME) //这个注解需要在运行时使用一般自定义注解都是RUNTIME
public @interface CountingTime{}
</code></pre><h3 id="然后在Aspect对象中设置切入点和通知"><a href="#然后在Aspect对象中设置切入点和通知" class="headerlink" title="然后在Aspect对象中设置切入点和通知"></a>然后在Aspect对象中设置切入点和通知</h3><p>CustomAspect.java</p>
<pre><code>@Component
@Aspect
public class CustomAspect {
  //注解注册一个切入点
  @Pointcut(&quot;@annotation(com.cskaoyan.anno.CountingTime)&quot;)
  public void mypointcut(){}

  //通知类型的方法（也就是加强的方法）
  @Around(&quot;mypointcut()&quot;)
  public Object around(ProceedingJoinPoint joinPoint) throws Throwable{
    long start = System.currentTimeMillis();
    Object proceed = joinPoint.proceed();
    long end = System.currentTimeMillis();
    System.out.println(&quot;time cost: &quot; + (end - start));
    return proceed;
  }
}
</code></pre><p><strong>相当于把切入点表达式，换成一个单一的标记去标记一个方法</strong></p>
<h3 id="在我们的需要加强的方法上去加注解"><a href="#在我们的需要加强的方法上去加注解" class="headerlink" title="在我们的需要加强的方法上去加注解"></a>在我们的需要加强的方法上去加注解</h3><p>UserServiceImpl</p>
<pre><code>@Service(&quot;userService&quot;)
public class UserServiceImpl implements UserService {
  @CountingTime//这个方法需要加强
  @Override
  public User register(String username, String password) {
    System.out.println(&quot;username = &quot; + username + &quot;|| password = &quot; + password);
    //int i = 1/0;
    return new User(username,password);
  }
  @Override
  public void myvoid() {
    System.out.println(&quot;myvoid&quot;);
  }
}
</code></pre><h3 id="测试中使用"><a href="#测试中使用" class="headerlink" title="测试中使用"></a>测试中使用</h3><pre><code>@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(&quot;classpath:application.xml&quot;)
public class AnnotationTest {
  @Autowired
  UserService userService;
  @Test
  public void mytest(){
    userService.register(&quot;zhangsong&quot;,&quot;123456&quot;);
  }
}
</code></pre><h3 id="JdbcTemplate"><a href="#JdbcTemplate" class="headerlink" title="JdbcTemplate"></a>JdbcTemplate</h3><p><strong>实质就是se代码和配置文件相互转换</strong></p>
<h3 id="一个简单的jdbcTemplate的例子"><a href="#一个简单的jdbcTemplate的例子" class="headerlink" title="一个简单的jdbcTemplate的例子"></a>一个简单的jdbcTemplate的例子</h3><p><strong>导包</strong></p>
<pre><code>&lt;!--spring-jdbc--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
    &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>就直接在Test.java里面写的</p>
<pre><code>public class JdbcTest {
  @Test
  public void mytest(){
    DruidDataSource druidDataSource = new DruidDataSource();
    //driverClass
    druidDataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
    //jdbcUrl
    druidDataSource.setUrl(&quot;jdbc:mysql://localhost:3306/j16_db?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&quot;);
    //username
    druidDataSource.setUsername(&quot;root&quot;);
    //password
    druidDataSource.setPassword(&quot;123456&quot;);

    //获得jdbcTemplate的实例
    JdbcTemplate jdbcTemplate = new JdbcTemplate();
    jdbcTemplate.setDataSource(druidDataSource);

    //通过jdbcTemplate执行crud
    String sql = &quot;select username from j16_user_t where id = ?&quot;;
    String username = jdbcTemplate.queryForObject(sql, String.class, 1);

  }
}
</code></pre><p>首先知道 jdbcTemplate 是怎么用的：</p>
<p>1.需要设置一个DataSource<br>    配置Driver  （启动的驱动）<br>    配置Url     （设置url）<br>    配置UserName（数据库账号）<br>    配置PassWord（数据库密码）</p>
<p>2.需要给一个JdbcTemplate设置一个DataSource</p>
<p><strong>注意事项</strong>就是CRUD的操作，这些操作和dbUtil有一些不同，这里单独有一个文档，单独写一篇文章</p>
<h2 id="星期一（0916）"><a href="#星期一（0916）" class="headerlink" title="星期一（0916）"></a>星期一（0916）</h2><p>这里有好几个例子，必须要掌握的是使用注解使用jdbcTemplate 还有javaConfig，代替application.xml（@Configuration)</p>
<h3 id="JdbcTemplate-1"><a href="#JdbcTemplate-1" class="headerlink" title="JdbcTemplate"></a>JdbcTemplate</h3><p>上一次我们直接在单元测试里面直接跑了一次JdbcTemplate，回顾一下一个JdbcTemplate需要什么<br>1.需要设置一个DataSource</p>
<pre><code>配置Driver  （启动的驱动）
配置Url     （设置url）
配置UserName（数据库账号）
配置PassWord（数据库密码）
</code></pre><p>2.需要给一个JdbcTemplate设置一个DataSource</p>
<h3 id="实现一：一个简单的jdbcTemplate注册到Spring中"><a href="#实现一：一个简单的jdbcTemplate注册到Spring中" class="headerlink" title="实现一：一个简单的jdbcTemplate注册到Spring中"></a>实现一：一个简单的jdbcTemplate注册到Spring中</h3><p><strong>配置文件application.xml</strong></p>
<pre><code>&lt;context:component-scan base-package=&quot;com.cskaoyan&quot;/&gt;
&lt;!--        &amp;--&gt;
&lt;!--        &amp;nbsp;--&gt;
&lt;!--        &amp;gt; greater than--&gt;
&lt;!--        &amp;lt; less than--&gt;
&lt;!--datasource--&gt;
&lt;bean id=&quot;druidDatasource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
  &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
  &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/j16_db?useUnicode=true&amp;amp;characterEncoding=utf-8&quot;/&gt;
  &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
  &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;
 &lt;/bean&gt;

&lt;!--注册jdbcTemplate--&gt;
&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;druidDatasource&quot;/&gt;
&lt;/bean&gt;
</code></pre><p><strong>AccountDaoImpl.java</strong></p>
<pre><code>@Repository
public class AccountDaoImpl implements AccountDao {
  @Autowired
  JdbcTemplate jdbcTemplate;

  @Override
  public int queryMoneyById(int id) {
    String sql = &quot;select money from j16_account_t where id = ?&quot;;
    Integer money = jdbcTemplate.queryForObject(sql, Integer.class, id);
    return money;
  }

  @Override
  public int updateMoneyById(int id, int money) {
    String sql = &quot;update j16_account_t set money = ? where id = ?&quot;;
    int update = jdbcTemplate.update(sql, money, id);
    return update;
  }
}
</code></pre><p><strong>单元测试使用</strong></p>
<pre><code>@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(&quot;classpath:applicaiton.xml&quot;)
public class JdbcTemplateTest {
  @AutoWired
  AccountDao accountDao;

  @Test
  public void mytest(){
    int i = accountDao.queryMoneyById(1);
    System.out.println(i);
    accountDao.updateMoneyById(1,500);
  }
}
</code></pre><h3 id="实现二：不需要在-AccountDaoImpl-中创建成员-jdbcTemplate"><a href="#实现二：不需要在-AccountDaoImpl-中创建成员-jdbcTemplate" class="headerlink" title="实现二：不需要在 AccountDaoImpl 中创建成员 jdbcTemplate"></a>实现二：不需要在 AccountDaoImpl 中创建成员 jdbcTemplate</h3><p>我们需要在AccountDaoImpl 中 <strong>extends JdbcDaoSupport</strong><br>这样就能直接调用父类的jdbcTemplate，但是我们要帮父类实现获取dataSource（setDataSource()方法），在set的同时,<strong>父类还会帮我们初始化我们需要的用的JdbcTemplate对象</strong>，这样就不能使用注解来注册这个类，需要在application.xml中注册</p>
<p><strong>application.xml</strong></p>
<pre><code>&lt;context:component-scan base-package=&quot;com.cskaoyan&quot;/&gt;
&lt;bean id=&quot;druidDatasource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
  &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
  &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/j16_db?useUnicode=true&amp;amp;characterEncoding=utf-8&quot;/&gt;
  &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
  &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;
&lt;/bean&gt;

&lt;!--jdbcTemplate--&gt;
&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
  &lt;property name=&quot;dataSource&quot; ref=&quot;druidDatasource&quot;/&gt;
&lt;/bean&gt;

&lt;bean class=&quot;com.cskaoyan.dao.AccountDaoImpl&quot;&gt;
  &lt;!-- 为的是调用父类的setDataSource,就会初始化一个getJdbcTemplate，然后直接用父类定义好的jdbcTemplate进行操作 --&gt;
  &lt;property name=&quot;dataSource&quot; ref=&quot;druidDatasource&quot;/&gt;
&lt;/bean&gt;
</code></pre><p>AccountDaoImpl.java直接写：this.getJdbcTemplate()</p>
<pre><code>//@Repository不需要注解去注册，已经在application.xml中注册了
//继承JdbcDaoSupport
public class AccountDaoImpl extends JdbcDaoSupport implements AccountDao {
  @Override
  public int queryMoneyById(int id) {
    String sql = &quot;select money from j16_account_t where id = ?&quot;;
    Integer money = this.getJdbcTemplate().queryForObject(sql, Integer.class, id);
    return money;
  }

  @Override
  public int updateMoneyById(int id, int money) {
    String sql = &quot;update j16_account_t set money = ? where id = ?&quot;;
    int update = this.getJdbcTemplate().update(sql, money, id);
    return update;
  }
}
</code></pre><h3 id="实现三-AutoWired的新的用法"><a href="#实现三-AutoWired的新的用法" class="headerlink" title="实现三 AutoWired的新的用法"></a>实现三 AutoWired的新的用法</h3><p>通过这个例子我们知道AutoWired不仅仅可以写在类上<br>还可以写在方法上：</p>
<pre><code>//组件初始化的调用到这个方法
//从容器中给所有形参注入值
</code></pre><p>这样就不需要在application.xml中注册AccountDaoImpl,使用注解注册即可，就能设置一个 datasource</p>
<pre><code>@Repository
public class AccountDaoImpl extends JdbcDaoSupport implements AccountDao {

  //从容器中给方法的所有形参注入值
  //组件初始化的调用到这个方法
  @Autowired
  public void setDaoDatasource(@Qualifier(&quot;druidDatasource&quot;) DataSource datasource){
    //调用自己的setDataSource方法，也能得到一个jdbcTemplate
    this.setDataSource(datasource);
  }

  @Override
  public int queryMoneyById(int id) {
    String sql = &quot;select money from j16_account_t where id = ?&quot;;
    Integer money = this.getJdbcTemplate().queryForObject(sql, Integer.class, id);
    return money;
  }
  @Override
  public int updateMoneyById(int id, int money) {
    String sql = &quot;update j16_account_t set money = ? where id = ?&quot;;
    int update = this.getJdbcTemplate().update(sql, money, id);
    return update;
  }
}
</code></pre><p><strong>注意事项</strong><br>1.从容器中给方法的所有形参注入值,这个形参的对象默认情况在容器中注册只能有一个,不过可以通过对应的形参前面加：</p>
<pre><code>@Qualifier(&quot;id&quot;)
</code></pre><p>这样就能唯一指向。这样就可以指向不同的组件。不过一般就只有一个。</p>
<h3 id="实现方法四：写javaConfig代替application-xml"><a href="#实现方法四：写javaConfig代替application-xml" class="headerlink" title="实现方法四：写javaConfig代替application.xml"></a>实现方法四：写javaConfig代替application.xml</h3><p>我们之前在使用application时候里面有一些什么内容呢？<br>1.开启了一个Spring的扫描</p>
<pre><code>&lt;context:component-scan base-package=&quot;com.cskaoyan&quot;/&gt;
</code></pre><p>里面注册了一个 datasource 和 JdbcTemplate</p>
<pre><code>&lt;!--datasource--&gt;
&lt;bean id=&quot;druidDatasource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
    &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;

    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/j16_db?useUnicode=true&amp;amp;characterEncoding=utf-8&quot;/&gt;
    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;
 &lt;/bean&gt;
&lt;!--jdbcTemplate--&gt;
&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;druidDatasource&quot;/&gt;
&lt;/bean&gt;
</code></pre><p>那么我们可以写一个 javaConfig 来代表这个application.xml</p>
<pre><code>@Configuration                              //表示这是一个javaConfig
@ComponentScan(backPackages=&quot;com.cskaoyan&quot;) //开启Spring的扫描
public class SpringConfig {
  //注册一个datasource
  @Bean
  public DruidDataSource druidDataSource(){
    DruidDataSource druidDataSource = new DruidDataSource();
    //driverClass
    druidDataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
    //jdbcUrl
    druidDataSource.setUrl(&quot;jdbc:mysql://localhost:3306/j16_db?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&quot;);
    //username
    druidDataSource.setUsername(&quot;root&quot;);
    //password
    druidDataSource.setPassword(&quot;123456&quot;);
    return druidDataSource;
  }
  //注册一个 JdbcTemplate
  @Bean
  public JdbcTemplate jdbcTemplate(/*@Qualifier*/ DataSource dataSource){
    JdbcTemplate jdbcTemplate = new JdbcTemplate();
    jdbcTemplate.setDataSource(dataSource);
    return jdbcTemplate;
  }
}
</code></pre><p><strong>对于之前的的（Spring-AOP）例子我们也可以使用JavaConfig来写</strong><br>那时我们需要一个userServiceProxy</p>
<p>通知类CustomAdvice（不变）：</p>
<pre><code>@Component(&quot;myadvice&quot;)
public class CustomAdvice implements MethodInterceptor {
    @Override
    public Object invoke(MethodInvocation methodInvocation) throws Throwable {
      System.out.println(&quot;before&quot;);
      //这一行执行的是委托类的方法，类似于动态代理中的method。invoke
      Object proceed = methodInvocation.proceed();
      System.out.println(&quot;after&quot;);
      return proceed;
    }
}
</code></pre><p>Service</p>
<pre><code>@Service(&quot;userService&quot;)
public class UserServiceImpl implements UserService {
  @Override
  public int register(String username, String password) {
    System.out.println(&quot;username = &quot; + username + &quot;|| password = &quot; + password);
    return 0;
  }
}
</code></pre><p>之前的配置文件：</p>
<pre><code>&lt;!-- bean definitions here --&gt;
&lt;context:component-scan base-package=&quot;com.cskaoyan&quot;/&gt;
&lt;bean id=&quot;userServiceProxy&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;
  &lt;property name=&quot;target&quot; ref=&quot;userService&quot;/&gt;
  &lt;!--容器中这个通知的名称（id）--&gt;
  &lt;property name=&quot;interceptorNames&quot; value=&quot;myadvice&quot;/&gt;
&lt;/bean&gt;
</code></pre><p>同样我们可以写成JavaConfig<br>SpringConfig.java</p>
<pre><code>@Configuration
@ComponentScan(basePackages = &quot;com.cskaoyan&quot;)
&lt;!-- @EnableAspectJAutoProxy 需要使用ASPECT注解时使用--&gt;
public class SpringConfig {
  //Spring-Aop
  @Bean
  public ProxyFactoryBean proxyFactoryBean(UserService userService){
    ProxyFactoryBean proxyFactoryBean = new ProxyFactoryBean();
    proxyFactoryBean.setTarget(userService);
    proxyFactoryBean.setInterceptorNames(&quot;myadvice&quot;);
    return proxyFactoryBean;
  }
  public SpringConfig(){
    System.out.println(&quot;初始化&quot;);
  }
}
</code></pre><p><strong>注意事项</strong><br>1.@Bean注册组件的时候，其实就是还原了JAVASE的代码，然后返回一个对象。@Bean(“id”)可以设置一个id。如果不设置默认方法名就是id。<br>2.这个SpringConfig会在运行的时候，自动创建一个对象，然后初始化里面的方法注册好我们需要的组间，何以见得？看我们的测试代码<br><strong>单元测试：</strong></p>
<pre><code>@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes = SpringConfig.class) //加载我们的SpringConfig文件
public class ConfigTest {
  @Resource(name = &quot;proxyFactoryBean&quot;)
  UserService userService;

  @Test
  public void mytest(){
    int zhangsong = userService.register(&quot;zhangsong&quot;, &quot;123456&quot;);
  }

  @Autowired
  AccountService accountService;
  @Test
  public void mytest2(){
    accountService.transferMoney(1,2,100);
  }

}
</code></pre><p>这里测试有一个@ContextConfiguration，已经写的不是之前的</p>
<pre><code>@ContextConfiguration(&quot;classpath:application.xml&quot;)
</code></pre><p>而是：</p>
<pre><code>@ContextConfiguration(classes = SpringConfig.class)
</code></pre><h3 id="实现五（没有代码）"><a href="#实现五（没有代码）" class="headerlink" title="实现五（没有代码）"></a>实现五（没有代码）</h3><p>但是我们要说一下怎么加入事务</p>
<h3 id="Spring事务管理常用对象（山大对象）"><a href="#Spring事务管理常用对象（山大对象）" class="headerlink" title="Spring事务管理常用对象（山大对象）"></a>Spring事务管理常用对象（山大对象）</h3><pre><code>PlatformTransactionManager
TransactionDefinition
TransactionStatus
</code></pre><h3 id="PlatformTransactionManager-（事务的核心）"><a href="#PlatformTransactionManager-（事务的核心）" class="headerlink" title="PlatformTransactionManager （事务的核心）"></a>PlatformTransactionManager （事务的核心）</h3><pre><code>平台事务管理器，spring要管理事务，必须使用事务管理器
进行事务配置时，必须配置事务管理器。
有多种实现，通过实现此接口，Spring可以管理任何实现了这些接口的事务。开发人员可以使用统一的编程模型来控制管理事务。
</code></pre><p>常见的事务管理器的实现<br>DataSourceTransactionManager，jdbc开发时事务管理器，采用JdbcTemplate</p>
<h3 id="PlatformTransactionManager常用API"><a href="#PlatformTransactionManager常用API" class="headerlink" title="PlatformTransactionManager常用API"></a>PlatformTransactionManager常用API</h3><pre><code>TransactionStatus getTransaction(TransactionDefinition definition) ，
    事务管理器 通过“事务详情”，获得“事务状态”，从而管理事务。 获取事务状态后，Spring根据传播行为来决定如何开启事务；
void commit(TransactionStatus status)  根据状态提交
void rollback(TransactionStatus status) 根据状态回滚
</code></pre><h3 id="TransactionStatus"><a href="#TransactionStatus" class="headerlink" title="TransactionStatus"></a>TransactionStatus</h3><p>这个接口的作用就是获取事务的状态（回滚点、是否完成、是否新事物、是否回滚）属性<br>通常这个是对我们来说是透明，我们不需要去设置状态。而是通过定义属性的名称去控制</p>
<h3 id="TransactionDefinition"><a href="#TransactionDefinition" class="headerlink" title="TransactionDefinition"></a>TransactionDefinition</h3><p>这个接口的作用就是定义事务的名称、隔离级别、传播行为、超时时间长短、只读属性等。</p>
<pre><code>REQUIRED: 支持当前事务，如果当前没有事务，就新建一个事务。
SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行。
MANDATORY： 支持当前事务，如果当前没有事务，就抛出异常
REQUIRES_NEW：新建事务，如果当前存在事务，把当前事务挂起
NOT_SUPPORTED: 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起
NEVER: 以非事务方式执行，如果当前存在事务，则抛出异常
NESTED: 支持当前事务，如果当前事务存在，则执行一个嵌套事务，如果当前没有事务，就新建一个事务
</code></pre><p>怎么使用？看下面的例子</p>
<p><strong>注意事项</strong>我们不需要再导包了 Spring自动给我们导入了spring-tx</p>
<h3 id="实现六-加入事务实现JdbcTemplate"><a href="#实现六-加入事务实现JdbcTemplate" class="headerlink" title="实现六 加入事务实现JdbcTemplate"></a>实现六 加入事务实现JdbcTemplate</h3><p>继续以转账的例子为例：<br>在写例子之前，我们需要知道我们在哪里加上事务?<br>当然是给 service 加上事务，一个service会调用多个dao,在我们需要加事务的方法上加事务</p>
<p><strong>AccountDaoImpl（没有什么变化，也可以加上面的方法改写一些获取jdbcTemplate的方式）</strong></p>
<pre><code>@Repository
public class AccountDaoImpl implements AccountDao{
  @Autowired
  JdbcTemplate jdbcTemplate;
  @Override
  public int queryMoneyById(int id) {
    Integer money = jdbcTemplate.queryForObject(&quot;select money from j16_account_t where id = ?&quot;, Integer.class, id);
    return money;
  }
  @Override
  public int updateMoneyById(int id, int money) {
    int update = jdbcTemplate.update(&quot;update j16_account_t set money = ? where id = ?&quot;, money, id);
    return update;
  }
}
</code></pre><p><strong>JavaConfig中注册事务</strong></p>
<pre><code>@Configuration
@ComponentScan(basePackages = &quot;com.cskaoyan&quot;)
public class SpringConfig {
  @Bean
  public DataSource druidDatasource(){
    DruidDataSource druidDataSource = new DruidDataSource();
    druidDataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
    druidDataSource.setUrl(&quot;jdbc:mysql://localhost:3306/j16_db?useUnicode=true&amp;characterEncoding=utf-8&quot;);
    druidDataSource.setUsername(&quot;root&quot;);
    druidDataSource.setPassword(&quot;123456&quot;);
    return druidDataSource;
  }
  @Bean
  public JdbcTemplate jdbcTemplate(DataSource dataSource){
    JdbcTemplate jdbcTemplate = new JdbcTemplate();
    jdbcTemplate.setDataSource(dataSource);
    return jdbcTemplate;
  }

  /*TransactionTemplate  需要引入设置transactionManager*/
  @Bean
  public TransactionTemplate transactionTemplate(PlatformTransactionManager transactionManager){
    TransactionTemplate transactionTemplate = new TransactionTemplate();
    transactionTemplate.setTransactionManager(transactionManager);
    return transactionTemplate;
  }
  /*TransactionManager*/
  @Bean
  public DataSourceTransactionManager dataSourceTransactionManager(DataSource dataSource){
    DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager();
    dataSourceTransactionManager.setDataSource(dataSource);
    return dataSourceTransactionManager;
  }
}
</code></pre><p>上面两个组件的注册这里不再说了，这里主要说一下怎么用事务。这里我们需要注册两个组件；<br>1.transactionTemplate<br>2.dataSourceTransactionManager</p>
<p><strong>transactionTemplate</strong></p>
<pre><code>transactionTemplate需要一个transactionManager
</code></pre><p><strong>dataSourceTransactionManager</strong></p>
<pre><code>transactionManager 注册需要设置一个DataSource。因为我们需要使用DataSource拿到同一个Connection去控制事务
</code></pre><p><strong>接下来就在我们Serive里面使用—–需要注册transactionTemplate</strong><br>transactionTemplate.execute方法里面可以写两种匿名对象TransactionCallback，TransactionCallbackWithoutResult，通过名字我们知道一个是有返回值的事务，一个是没有返回值的事务。就对应着操作数据局的增删改（不需要返回值），查（需要返回值）</p>
<pre><code>@Service
public class AccountServiceImpl implements AccountService {
    @Autowired
    AccountDao accountDao;

    //这里就需要注册一下我们的transactionTemplate
    @Autowired
    TransactionTemplate transactionTemplate;
    @Override
    public void transfer(int fromId, int destId, int money) {
        int fromMoney = accountDao.queryMoneyById(fromId) - money;
        int destMoney = accountDao.queryMoneyById(destId) + money;
        //两种写法：一种可以有返回的结果，查询类的，一种没有返回值，更新类的
        /*String execute = transactionTemplate.execute(new TransactionCallback&lt;String&gt;() {
            @Override
            public String doInTransaction(TransactionStatus transactionStatus) {
                accountDao.updateMoneyById(fromId, fromMoney);
                //int i = 1/0;
                accountDao.updateMoneyById(destId, destMoney);
                return &quot;ok&quot;;
            }
        });*/
        transactionTemplate.execute(new TransactionCallbackWithoutResult() {
            @Override
            protected void doInTransactionWithoutResult(TransactionStatus transactionStatus) {
                accountDao.updateMoneyById(fromId, fromMoney);
               // int i = 1/0;
                accountDao.updateMoneyById(destId, destMoney);
            }
        });
    }
}
</code></pre><p><strong>最后进行测试</strong></p>
<pre><code>@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes = SpringConfig.class)
public class TxTest {
  @Autowired
  AccountService accountService;
  @Test
  public void mytest(){
      accountService.transfer(1,2,100);
  }
}
</code></pre><p>这是第一次使用transaction,和第一次使用jdbc一样，一定要知道我们需要注册什么组件<br>1.TransactionTemplate（需要一个TransactionManager）<br>2.TransactionManager(需要一个DataSource)</p>
<p><strong>注意</strong><br>我们发现一个很严重的问题， 每次使用事务，我们都要在每个service类里面都要创建一个TransactionTemplate的对象，进行execute方法。<br>这种写法就很像动态代理的写法。需要在我们原来的代码上进行修改，这感觉就不是很友好，所以一般不用。</p>
<h3 id="实现七使用动态代理（proxy）实现（Spring-aop实现）"><a href="#实现七使用动态代理（proxy）实现（Spring-aop实现）" class="headerlink" title="实现七使用动态代理（proxy）实现（Spring-aop实现）"></a>实现七使用动态代理（proxy）实现（Spring-aop实现）</h3><p>在上个例子中使用了transactionTemplate。这个例子将不再使用，而是使用动态代理，proxy作为代理对象。<br><strong>AccountDaoImpl没有变化</strong>，还是要使用JdbcTemplate去操作DAO</p>
<p><strong>而在service里面我们不需要再创建TransactionTemplate对象，从而把他抽离出来了</strong>使用代理对象<br>还原我们的service</p>
<pre><code>@Service
public class AccountServiceImpl implements AccountService {
  @Autowired
  AccountDao accountDao;
  @Override
  public void transfer(int fromId, int destId, int money) {
    int fromMoney = accountDao.queryMoneyById(fromId) - money;
    int destMoney = accountDao.queryMoneyById(destId) + money;
    accountDao.updateMoneyById(fromId, fromMoney);
    // int i = 1/0;
    accountDao.updateMoneyById(destId, destMoney);
  }
}
</code></pre><p><strong>关键点当然就是我们的 JavaConfig —-怎么去配置proxy</strong></p>
<pre><code>@Configuration
@ComponentScan(basePackages = &quot;com.cskaoyan&quot;)
public class SpringConfig {

    @Bean
    public DataSource druidDatasource(){
        DruidDataSource druidDataSource = new DruidDataSource();
        druidDataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
        druidDataSource.setUrl(&quot;jdbc:mysql://localhost:3306/j16_db?useUnicode=true&amp;characterEncoding=utf-8&quot;);
        druidDataSource.setUsername(&quot;root&quot;);
        druidDataSource.setPassword(&quot;123456&quot;);
        return druidDataSource;
    }
    @Bean
    public JdbcTemplate jdbcTemplate(DataSource dataSource){
        JdbcTemplate jdbcTemplate = new JdbcTemplate();
        jdbcTemplate.setDataSource(dataSource);
        return jdbcTemplate;
    }
    /*txManager*/
    @Bean
    public DataSourceTransactionManager dataSourceTransactionManager(DataSource dataSource){
        DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager();
        dataSourceTransactionManager.setDataSource(dataSource);
        return dataSourceTransactionManager;
    }
</code></pre><p>上面都是一样的，注意这里需要注册代理的对象（TransactionProxyFactoryBean）来代替了transactionTemplate。 这个代理对象需要两个参数一个是<strong>目标对象</strong>，一个是<strong>dataSourceTransactionManager</strong>传进去.而之前的transactionTemplate需要的是transactionManager，因为每个目标对象都要自己创建，相当于抽离出来了。<br>需要给这个代理的对象设置四个参数：<br>1）设置目标对象(传进去的)   —-  setTarget<br>2）设置目标对象的接口？（从这我们可以大胆猜测底层是<strong>jdk</strong>的动态代理）    —-  setProxyInterfaces<br>3）设置transactionManager(传进去的)    —-  setTransactionManager<br>4）设置事务的一些属性(需要写成properties的类型,key就是要代理的方法名)    —-  setTransactionAttributes</p>
<pre><code>    /*根据目标对象生成代理对象*/
    @Bean
    public TransactionProxyFactoryBean serviceProxy(AccountService accountService,
                                                    DataSourceTransactionManager dataSourceTransactionManager){
        TransactionProxyFactoryBean transactionProxyFactoryBean = new TransactionProxyFactoryBean();
        //需要设置四个东西：
        //1.target 目标对象
        transactionProxyFactoryBean.setTarget(accountService);

        //2.setProxyInterfaces
        transactionProxyFactoryBean.setProxyInterfaces(new Class[]{AccountService.class});
        //3.setTransactionManager
        transactionProxyFactoryBean.setTransactionManager(dataSourceTransactionManager);

        //设置transactionDefinition需要写成properties的方式，key就是目标对象的方法名
        Properties transactionAttributes = new Properties();
        transactionAttributes.setProperty(&quot;transfer&quot;,&quot;PROPAGATION_REQUIRED,ISOLATION_DEFAULT&quot;);

        //4.设置一些transactionDefinition的东西
        transactionProxyFactoryBean.setTransactionAttributes(transactionAttributes);
        return transactionProxyFactoryBean;
    }
}
</code></pre><p><strong>注意事项：</strong>这个也可以写成配置文件的形式，这里主要想说明TransactionProxyFactoryBean的标签应该怎么写</p>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       xsi:schemaLocation=&quot;
        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd
        http://www.springframework.org/schema/tx https://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:component-scan base-package=&quot;com.cskaoyan&quot;/&gt;

    &lt;bean id=&quot;serviceProxy&quot; class=&quot;org.springframework.transaction.interceptor.TransactionProxyFactoryBean&quot;&gt;
        &lt;property name=&quot;target&quot; ref=&quot;accountServiceImpl&quot;/&gt;
        &lt;property name=&quot;proxyInterfaces&quot; value=&quot;com.cskaoyan.service.AccountService&quot;/&gt;
        &lt;property name=&quot;transactionManager&quot; ref=&quot;txManager&quot;/&gt;
        &lt;property name=&quot;transactionAttributes&quot;&gt;
          &lt;props&gt;
            &lt;prop key=&quot;transfer&quot;&gt;PROPAGATION_REQUIRED,ISOLATION_DEFAULT&lt;/prop&gt;
          &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;datasource&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;datasource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/j16_db?useUnicode=true&amp;amp;characterEncoding=utf-8&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;datasource&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre><p>最后是测试：拿出的是代理的对象</p>
<pre><code>@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes = SpringConfig.class)
public class ProxyTest {
    @Resource(name = &quot;serviceProxy&quot;)
    AccountService accountService;
    @Test
    public void mytest(){
        accountService.transfer(1,2,100);
    }
}
</code></pre><h3 id="实现八：使用ASPECT实现-记得导入weaver包"><a href="#实现八：使用ASPECT实现-记得导入weaver包" class="headerlink" title="实现八：使用ASPECT实现(记得导入weaver包)"></a>实现八：使用ASPECT实现(记得导入weaver包)</h3><p>使用application来导入aspect，注意这里记得导入<strong>tx的schema</strong><br>需要在application中配置tx:advice给到aop:advsor，通知就应该由tx来控制。tx:advice ，需要设置一个<br>dataSourceTransactionManager</p>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
     xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
     xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
     xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
     xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
     xsi:schemaLocation=&quot;
      http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
      http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd
      http://www.springframework.org/schema/tx https://www.springframework.org/schema/tx/spring-tx.xsd
      http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:component-scan base-package=&quot;com.cskaoyan&quot;/&gt;
    &lt;!--同时使用xml配置文件和javaConfig、配置类要在扫描包范围内--&gt;
    &lt;aop:config&gt;
        &lt;aop:pointcut id=&quot;txpointcut&quot; expression=&quot;execution(* com.cskaoyan.service..*(..))&quot;/&gt;
        &lt;aop:advisor advice-ref=&quot;txAdvisor&quot; pointcut-ref=&quot;txpointcut&quot;/&gt;
    &lt;/aop:config&gt;
    &lt;!-- transaction给我们提供了一个advice来给aspect用 --&gt;
    &lt;tx:advice id=&quot;txAdvisor&quot; transaction-manager=&quot;dataSourceTransactionManager&quot;&gt;
        &lt;tx:attributes&gt;
            &lt;!--增加事务的方法--&gt;
            &lt;tx:method name=&quot;transfer&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;
&lt;/beans&gt;
</code></pre><p>虽然我们写了application。但是<strong>我们写的springConfig也需要注册到spring中</strong>，application.xml会自动来注册这个SpringConfig 从构造函数初始化可以知道。这里也印证我们之前说的application.xml应该和Annotation一起使用才是效率最高的。</p>
<pre><code>@Configuration
//@ComponentScan(basePackages = &quot;com.cskaoyan&quot;)不需要在这里写
public class SpringConfig {

  @Bean
  public DataSource druidDatasource(){
      DruidDataSource druidDataSource = new DruidDataSource();
      druidDataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
      druidDataSource.setUrl(&quot;jdbc:mysql://localhost:3306/j16_db?useUnicode=true&amp;characterEncoding=utf-8&quot;);
      druidDataSource.setUsername(&quot;root&quot;);
      druidDataSource.setPassword(&quot;123456&quot;);
      return druidDataSource;
  }

  @Bean
  public JdbcTemplate jdbcTemplate(DataSource dataSource){
      JdbcTemplate jdbcTemplate = new JdbcTemplate();
      jdbcTemplate.setDataSource(dataSource);
      return jdbcTemplate;
  }

  /*txManager*/
  @Bean
  public DataSourceTransactionManager dataSourceTransactionManager(DataSource dataSource){
      DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager();
      dataSourceTransactionManager.setDataSource(dataSource);
      return dataSourceTransactionManager;
  }

  //检测有没有注册
  public SpringConfig() {
      System.out.println(&quot;springconfig init&quot;);
  }
}
</code></pre><p>测试和service，dao代码省略了。都一样的</p>
<h3 id="注解-声明式-实现事务（重点中的重点）"><a href="#注解-声明式-实现事务（重点中的重点）" class="headerlink" title="注解(声明式)实现事务（重点中的重点）"></a>注解(声明式)实现事务（重点中的重点）</h3><p>还是那个问题：我们使用注解到底代替了哪些东西？<br>1.application.xml，在springConfig中我们也没有注册新的组件但是我们加了一个新的注解：</p>
<pre><code>@EnableTransactionManagement 开启事务的开关
</code></pre><p>这是声明式的事务可以写成application.xml的形式，或者在application.xml添加：<br>（<strong>以下两种配置方法二选一即可，建议直接写javaConfig的注解</strong>）</p>
<pre><code>&amp;lt;!&amp;ndash;开启一个声明事务的开关&amp;ndash;&amp;gt;
&lt;tx:annotation-driven transaction-manager=&quot;dataSourceTransactionManager&quot;/&gt;--&gt;
</code></pre><p>SpringConfig.java</p>
<pre><code>@Configuration
@ComponentScan(basePackages = &quot;com.cskaoyan&quot;)
@EnableTransactionManagement
public class SpringConfig {
  @Bean
  public DataSource druidDatasource(){
      DruidDataSource druidDataSource = new DruidDataSource();
      druidDataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
      druidDataSource.setUrl(&quot;jdbc:mysql://localhost:3306/j16_db?useUnicode=true&amp;characterEncoding=utf-8&quot;);
      druidDataSource.setUsername(&quot;root&quot;);
      druidDataSource.setPassword(&quot;123456&quot;);
      return druidDataSource;
  }

  @Bean
  public JdbcTemplate jdbcTemplate(DataSource dataSource){
      JdbcTemplate jdbcTemplate = new JdbcTemplate();
      jdbcTemplate.setDataSource(dataSource);
      return jdbcTemplate;
  }

  /*txManager*/
  @Bean
  public DataSourceTransactionManager dataSourceTransactionManager(DataSource dataSource){
      DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager();
      dataSourceTransactionManager.setDataSource(dataSource);
      return dataSourceTransactionManager;
  }

  public SpringConfig() {
      System.out.println(&quot;springconfig init&quot;);
  }
}
</code></pre><p>2.service 层的修改<br>我们需要在哪个方法添加事务，就在哪个方法上添加注解(@Transactional)，他自动给我们做好了。不需要我们自己去动态代理等等。</p>
<pre><code>@Service
public class AccountServiceImpl implements AccountService {
    @Autowired
    AccountDao accountDao;
    @Transactional(propagation = Propagation.REQUIRED,isolation = Isolation.DEFAULT)
    @Override
    public void transfer(int fromId, int destId, int money) {
        int fromMoney = accountDao.queryMoneyById(fromId) - money;
        int destMoney = accountDao.queryMoneyById(destId) + money;
        accountDao.updateMoneyById(fromId, fromMoney);
        //int i = 1/0;
        accountDao.updateMoneyById(destId, destMoney);
    }
}
</code></pre><p>@Transactional<br>可以通过这个注解实现一些definition的东西，当然我们看到不写也有一个默认值。</p>
<pre><code>@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
public @interface Transactional {
    @AliasFor(&quot;transactionManager&quot;)
    String value() default &quot;&quot;;
    @AliasFor(&quot;value&quot;)
    String transactionManager() default &quot;&quot;;
    Propagation propagation() default Propagation.REQUIRED;
    Isolation isolation() default Isolation.DEFAULT;
    int timeout() default -1;
    boolean readOnly() default false;
    Class&lt;? extends Throwable&gt;[] rollbackFor() default {};
    String[] rollbackForClassName() default {};
    Class&lt;? extends Throwable&gt;[] noRollbackFor() default {};
    String[] noRollbackForClassName() default {};
}
</code></pre><h3 id="AliasFor"><a href="#AliasFor" class="headerlink" title="@AliasFor"></a>@AliasFor</h3><p>单独写这个注解，因为这个注解很多地方都遇到</p>
<pre><code>@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD})
@Documented
public @interface AliasFor {
    @AliasFor(&quot;attribute&quot;)
    String value() default &quot;&quot;;

    @AliasFor(&quot;value&quot;)
    String attribute() default &quot;&quot;;
    Class&lt;? extends Annotation&gt; annotation() default Annotation.class;
}
</code></pre><p>这个注解老牛皮了：字面意思就是表示为别名</p>
<pre><code>* @AliasFor 用法：&lt;br&gt;
* &lt;li&gt;用到注解 属性上，表示两个属性互相为别名，互相为别名的属性值必须相同，若设置成不同，则会报错&lt;/li&gt;
* &lt;li&gt;注解是可以继承的，但是注解是不能继承父注解的属性的,也就是说,我在类扫描的时候,拿到的注解的属性值,依然是父注解的属性值,而不是你定义的注解的属性值&lt;br&gt;
* 所以此时可以在子注解对应的属性上加上@AliasFor&lt;br&gt;
</code></pre><p>用法：<br>1、同个注解中的两个属性互为别名<br>2、继承父注解的属性，使其拥有更强大的功能</p>
<p><a href="https://www.cnblogs.com/sandyflower/p/10877291.html" target="_blank" rel="external">https://www.cnblogs.com/sandyflower/p/10877291.html</a><br><a href="https://blog.csdn.net/wolfcode_cn/article/details/80654730" target="_blank" rel="external">https://blog.csdn.net/wolfcode_cn/article/details/80654730</a></p>
<h2 id="周二（9月17日）"><a href="#周二（9月17日）" class="headerlink" title="周二（9月17日）"></a>周二（9月17日）</h2><h2 id="星期二（0917）"><a href="#星期二（0917）" class="headerlink" title="星期二（0917）"></a>星期二（0917）</h2><h2 id="今天上课对之前的知识点进行回顾"><a href="#今天上课对之前的知识点进行回顾" class="headerlink" title="今天上课对之前的知识点进行回顾"></a>今天上课对之前的知识点进行回顾</h2><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>1.jdk<br>2.cglib</p>
<h3 id="Ioc-Di"><a href="#Ioc-Di" class="headerlink" title="Ioc/Di"></a>Ioc/Di</h3><p>组件注册<br>依赖注入<br>生命周期（10个部分）</p>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>切入点表达 execution （）<br>修饰符<br>返回值<br>包名+类名+方法名<br>参数</p>
<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><pre><code>&lt;bean id=&quot;&quot; class=&quot;&quot; factory-bean factory-method scope init-method destroy-method/&gt;
&lt;constructor-arg  name value
&lt;property name value/ref&gt;
&lt;array&gt;
&lt;bean&gt;
&lt;value&gt;
&lt;ref&gt;
&lt;list&gt;
&lt;set&gt;
&lt;map&gt;
&lt;props&gt;

扫描包(注解)功能
&lt;context:component-scan base-package=””/&gt;
&lt;aop:aspectj-autoproxy/&gt; → 织入包
&lt;tx:annotation-driver transaction-manager=/&gt;

Aop
&lt;aop:Config&gt;
&lt;aop:pointcut id expression/&gt;
&lt;aop:advisor advice-ref pointcut(-ref)/&gt; 类实现MethodInterceptor
&lt;aop:aspect ref/&gt;
&lt;aop:before method pointccut(-ref)
&lt;aop:after method pointccut(-ref)
&lt;aop:around method pointccut(-ref)
&lt;aop:after-returning method pointccut(-ref) returning
&lt;aop:after-throwing method pointccut(-ref) throwing

Tx：
&lt;tx:advice id transaction-manager/&gt;
&lt;tx:attributes&gt;
&lt;tx:method name definition的属性
</code></pre><h3 id="5-注解"><a href="#5-注解" class="headerlink" title="5 注解"></a>5 注解</h3><p>5.1 组件注册：<br>类上的：</p>
<pre><code>@Component（）
@Service @Repository @Controller
@Configuration
@ContextConfiguration(特殊的)
@Aspect
方法上：@Bean @Qualifier
</code></pre><p>5.2 注入<br>成员变量：</p>
<pre><code>@Autowired
@Autowired + @Qualifier
@Resource（name）
@Value
</code></pre><p>执行方法：</p>
<pre><code>@Autowired （+@Qualifier）
</code></pre><p>5.3 生命周期<br>被@PostConstruct修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器执行一次。PostConstruct在构造函数之后执行，init（）方法之前执行。<br>PreDestroy（）方法在destroy（）方法执行之后执行<br>Constructor &gt;&gt; @Autowired &gt;&gt; @PostConstruct<br>如果想在生成对象时完成某些初始化操作，而偏偏这些初始化操作又依赖于依赖注入，那么久无法在构造函数中实现。为此，可以使用@PostConstruct注解一个方法来完成初始化，@PostConstruct注解的方法将会在依赖注入完成后被自动调用。</p>
<pre><code>@PostConstruct
@PreDestroy
</code></pre><p>5.4 Scope<br>5.5 开关类</p>
<pre><code>@ComponentScan（basePackages ={}）
@EnableAspectJAutoProxy
@EnableTransactionManagement
</code></pre><p>5.6 单元测试</p>
<pre><code>@Runwith（SpringJUnit4ClassRunner.class）
@ContextConfiguration(“”) classes
</code></pre><p>5.7 Aop</p>
<pre><code>@Aspect
@Pointcut
@Before
@After
@Around
@AfterThrowing
@AfterReturning
</code></pre><h2 id="今天学习的内容—SpringMVC"><a href="#今天学习的内容—SpringMVC" class="headerlink" title="今天学习的内容—SpringMVC"></a>今天学习的内容—SpringMVC</h2><p>它是Spring框架的一部分，负责表示层，这里有一张图比较直观的表示出每一个部分的功能<br><img src="https://s2.ax1x.com/2019/09/18/noL8sI.png" alt="noL8sI.png"></p>
<h3 id="使用SpringMVC"><a href="#使用SpringMVC" class="headerlink" title="使用SpringMVC"></a>使用SpringMVC</h3><p>不管那么多，先用起来，入门案例一，</p>
<h3 id="第一步导包"><a href="#第一步导包" class="headerlink" title="第一步导包"></a>第一步导包</h3><p>在pom.xml</p>
<pre><code>&lt;packaging&gt;war&lt;/packaging&gt;
&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
    &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
    &lt;version&gt;3.0-alpha-1&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre><p>这里注意，只需要导入spring-webmvc，就可以了。就导入了5+2+1,5+1就是之前的导入spring-context的五个。剩下两个是<br>spring-web和spring-mvc</p>
<h3 id="第二步-web-xml配置前端控制器"><a href="#第二步-web-xml配置前端控制器" class="headerlink" title="第二步 web.xml配置前端控制器"></a>第二步 web.xml配置前端控制器</h3><p>配置一个dispatchServlet去接收所有的请求，然后在分发</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:application.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</code></pre><h3 id="第三步-springmvc-xml配置springmvc依赖的bean"><a href="#第三步-springmvc-xml配置springmvc依赖的bean" class="headerlink" title="第三步 springmvc.xml配置springmvc依赖的bean"></a>第三步 springmvc.xml配置springmvc依赖的bean</h3><p>配置处理器映射器 handlerMapping<br>配置处理器适配器 HandlerAdapter<br>注册bean</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;
        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd
        http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;!--映射器--&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt;
    &lt;!--适配器--&gt;
    &lt;!--适配一个实现Controller接口的Handler--&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt;
    &lt;!-- 注册controller组件 id就是url --&gt;
    &lt;bean id=&quot;/hello&quot; class=&quot;com.cskaoyan.controller.HelloController&quot;/&gt;
&lt;/beans&gt;
</code></pre><h3 id="第四步-实现请求处理类并配置访问url"><a href="#第四步-实现请求处理类并配置访问url" class="headerlink" title="第四步 实现请求处理类并配置访问url"></a>第四步 实现请求处理类并配置访问url</h3><p>modelAndView是数据和view，model返回给jsp的数据，而view是设置viewName获取视图的路径。</p>
<pre><code>public class HelloController implements Controller {
    @Override
    public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception {
        ModelAndView modelAndView = new ModelAndView();
        //model和数据相关
        modelAndView.addObject(&quot;content&quot;,&quot; springmvc&quot; );
        //相对于webroot(webapp)下的路径
        modelAndView.setViewName(&quot;/WEB-INF/hello.jsp&quot;);
        return modelAndView;
    }
}
</code></pre><h3 id="第五步-实现结果视图"><a href="#第五步-实现结果视图" class="headerlink" title="第五步 实现结果视图"></a>第五步 实现结果视图</h3><pre><code>&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    hello ${content}
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h3 id="入门案例二（使用注解，我们要用的形式）"><a href="#入门案例二（使用注解，我们要用的形式）" class="headerlink" title="入门案例二（使用注解，我们要用的形式）"></a>入门案例二（使用注解，我们要用的形式）</h3><p>前面都要配置。从第三步开始使用注解</p>
<h3 id="第三步配置application-xml"><a href="#第三步配置application-xml" class="headerlink" title="第三步配置application.xml"></a>第三步配置application.xml</h3><p>schema引入：</p>
<pre><code>xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd

&lt;!-- 开起spring的扫描标签 --&gt;
&lt;context:component-scan base-package=&quot;com.cskaoyan&quot;/&gt;

&lt;!-- 开启mvc的注解 --&gt;
&lt;mvc:annotation-driven/&gt;
</code></pre><h3 id="第四步-controller类–加入-Controller标签，不需要再实现Controller类了"><a href="#第四步-controller类–加入-Controller标签，不需要再实现Controller类了" class="headerlink" title="第四步 controller类–加入@Controller标签，不需要再实现Controller类了"></a>第四步 controller类–加入@Controller标签，不需要再实现Controller类了</h3><pre><code>@Controller
public class Hello2Controller {
    @RequestMapping(&quot;/hello2&quot;)
    public ModelAndView hello2z(){
        ModelAndView modelAndView = new ModelAndView();
        //model和数据相关
        modelAndView.addObject(&quot;content&quot;,&quot; springmvc hello2&quot; );
        //相对于webroot(webapp)下的路径
        modelAndView.setViewName(&quot;/WEB-INF/hello.jsp&quot;);
        return modelAndView;
    }
}
</code></pre><h3 id="第五步-显示-一样的"><a href="#第五步-显示-一样的" class="headerlink" title="第五步 显示 一样的"></a>第五步 显示 一样的</h3><p>这里有三个是新的东西：</p>
<pre><code>application.xml
&lt;mvc:annotation-driven/&gt;  //开启mcv的注解扫描标签

controller.java
@RequestMapping()    //设置请求的url以及参数的限制，请求的限制等等（比较重要）
@Controller          //表示这是一个controller类
</code></pre><h3 id="RequestMapping用法"><a href="#RequestMapping用法" class="headerlink" title="@RequestMapping用法"></a>@RequestMapping用法</h3><p><strong>URL路径映射</strong><br>我们上面例子用的就是这种情况，在方法名上写：</p>
<pre><code>@RequestMapping(&quot;/hello2&quot;)
public ModelAndView hello2z()
</code></pre><p><strong>窄化请求映射</strong><br>我们有三个请求：</p>
<pre><code>User/query
User/insert
User/delete
</code></pre><p>难道我们要在每个方法上面都写这些url吗？<br>答案是可以把相同的部分提取出来：<br>通过在类上增加 @RequestMapping 的注解进行请求的窄化</p>
<pre><code>@Controller(&quot;user&quot;)
@RequestMapping(&quot;user&quot;)
public class UserController
</code></pre><p><strong>注意事项</strong><br>这里我故意在@Controller上也加了一个user，注意@Controller是告诉Spring我这里是一个组件，这个组件的id叫做user，而要请求窄化：设置的是@RequestMapping(“user”)（后来总结时候，发现我真的写错了= =）</p>
<p><strong>请求方法限定（405错误）</strong></p>
<p>通过@RequestMapping中的method属性进行请求方法的限定，上面写URL路径映射，其实也就是value属性，因为我们之前讲过<strong>注解的value属性名在只写一个属性的时候可以省略，有多个就不能省略</strong></p>
<pre><code>/*请求方法的限定*/
@RequestMapping(value = &quot;method/limit&quot;, method = RequestMethod.POST)
public ModelAndView methodLimit(){
    ModelAndView modelAndView = new ModelAndView();
    modelAndView.setViewName(&quot;/WEB-INF/view/limit.jsp&quot;);
    return modelAndView;
}
/*请求方法的限定 or*/
/*method:多个method之间的关系是or*/
@RequestMapping(value = &quot;method/limit/multi&quot;, method = {RequestMethod.POST,RequestMethod.GET})
public ModelAndView methodLimitMulti(){
    ModelAndView modelAndView = new ModelAndView();
    modelAndView.setViewName(&quot;/WEB-INF/view/limit.jsp&quot;);
    return modelAndView;
}
</code></pre><p><strong><em>注意：</em></strong>请求方法也可以通过注解@PostMapping 和 @GetMapping</p>
<p><strong>请求参数的限定（400）params— 最常见的报错</strong><br><strong>回来总结时候就是这个错误最常见！，其次就是500。就发生在今天文件上传上，忘记配置MultipartResolver就一直500</strong><br>Params属性</p>
<pre><code>/*参数中要包含*/
/*多个参数之间的关系是and,传过来的请求参数可以多，但是不能少*/
@RequestMapping(value = &quot;param/limit&quot;,params = {&quot;username!=songge&quot;,&quot;password&quot;})
public ModelAndView paramLimit(String username ,String password){
    ModelAndView modelAndView = new ModelAndView();
    modelAndView.setViewName(&quot;/WEB-INF/view/limit.jsp&quot;);
    modelAndView.addObject(&quot;value&quot;, &quot;param limit&quot;);
    return modelAndView;
}
</code></pre><p><strong>请求的Content-type的限定（415）consumes</strong><br>不匹配时出现的异常</p>
<pre><code>@RequestMapping(value = &quot;consume/limit&quot;,consumes = &quot;application/json&quot;)
public ModelAndView cusumeLimit(){
    ModelAndView modelAndView = new ModelAndView();
    modelAndView.setViewName(&quot;/WEB-INF/view/limit.jsp&quot;);
    modelAndView.addObject(&quot;value&quot;, &quot;consume limit&quot;);
    return modelAndView;
}
</code></pre><p><strong>请求Accept的限定（406）produces</strong></p>
<pre><code>@RequestMapping(value = &quot;produces/limit&quot;,produces = &quot;application/json&quot;)
public ModelAndView producesLimit(){
    ModelAndView modelAndView = new ModelAndView();
    modelAndView.setViewName(&quot;/WEB-INF/view/limit.jsp&quot;);
    modelAndView.addObject(&quot;value&quot;, &quot;produces limit&quot;);
    return modelAndView;
}
</code></pre><h3 id="Controller方法返回值-处理ModelAndView的时候"><a href="#Controller方法返回值-处理ModelAndView的时候" class="headerlink" title="Controller方法返回值(处理ModelAndView的时候)"></a>Controller方法返回值(处理ModelAndView的时候)</h3><p>在我们没有引入json前，目前返回就这三种</p>
<pre><code>返回ModelAndView
返回void
返回字符串
</code></pre><h3 id="返回ModelAndView"><a href="#返回ModelAndView" class="headerlink" title="返回ModelAndView"></a>返回ModelAndView</h3><p>也就是之前我们的情况。ModelAndView就是Model和view，控制数据和控制viewName，<br>通过addObject，和setViewName来控制。</p>
<h3 id="返回void"><a href="#返回void" class="headerlink" title="返回void"></a>返回void</h3><p>这种就相当于直接去操作之前的servlet，不推荐，而且有点蠢，毕竟有了Spring还要去自己操作servlet</p>
<pre><code>@RequestMapping(&quot;return/void&quot;)
public void returnVoid(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    request.getRequestDispatcher(&quot;/WEB-INF/view/void.jsp&quot;).forward(request, response);
}
</code></pre><h3 id="返回字符串（String）"><a href="#返回字符串（String）" class="headerlink" title="返回字符串（String）"></a>返回字符串（String）</h3><p>基础用法：返回一个viewName</p>
<pre><code>@RequestMapping(&quot;return/string&quot;)
public String returnString(Model model){
    //返回值变为ModelAndView中的ViewName
    model.addAttribute(&quot;value&quot;,&quot;string&quot;);
    //viewName开头包含/的时候对应的是相对webroot（webapp）下的文件
    return &quot;/WEB-INF/view/string.jsp&quot;;
}
</code></pre><p><strong>注意</strong>为了控制model这里引入了一个model对象，这个对象有一个addAttribute来添加数据。和ModelAndView略微有点差别。<br>物理视图，逻辑视图这些不会用到不讲了，但是后面会讲到jsp的解析器什么的。后面再说</p>
<h3 id="通过String返回值请求跳转"><a href="#通过String返回值请求跳转" class="headerlink" title="通过String返回值请求跳转"></a>通过String返回值请求跳转</h3><pre><code>Forward redirect
对应的是请求之间的转发和重定向，也就是RequestMapping所对应方法之间的跳转

@Controller
public class RequestStringController {
    @RequestMapping(&quot;request/forward&quot;)
    public String requestForward(){
        System.out.println(&quot;forward&quot;);
        return &quot;forward:/receive&quot;;
    }
    @RequestMapping(&quot;request/redirect&quot;)
    public String requestRedirect(){
        System.out.println(&quot;redirect&quot;);
        return &quot;redirect:/receive&quot;;
    }
    @RequestMapping(&quot;receive&quot;)
    public String receive(){
        System.out.println(&quot;receive&quot;);
        return &quot;receive&quot;;
    }
}
</code></pre><h3 id="请求参数的封装"><a href="#请求参数的封装" class="headerlink" title="请求参数的封装"></a>请求参数的封装</h3><p>也就是简单介绍一下，过两天使用到json才是重头戏，反正就是可以用bean来接收参数，他会自动把json转成Bean就不需要用什么工具啦。</p>
<pre><code>@RequestMapping(&quot;parameter/javabean&quot;)
public String getBeanParameter(User user, Model model){
    System.out.println(user);
    return &quot;/WEB-INF/view/request.jsp&quot;;
}
</code></pre><h2 id="周三（9月18日）"><a href="#周三（9月18日）" class="headerlink" title="周三（9月18日）"></a>周三（9月18日）</h2><h2 id="星期三（0918）"><a href="#星期三（0918）" class="headerlink" title="星期三（0918）"></a>星期三（0918）</h2><h3 id="数据接收"><a href="#数据接收" class="headerlink" title="数据接收"></a>数据接收</h3><p>昨天说到了数据的接收，可以用bean来接收。其实也可以用数组接收，<strong>但是不能直接用list</strong>想了好几种方法都不行，虽然可以接收，但是list接收到的都是空的。不知要name应该怎么写，最终的用法是使用bean中的list接收。</p>
<p><strong>数组接收：可以单独接收，也可以通过bean接收</strong></p>
<pre><code>@RequestMapping(&quot;parameter/array&quot;)
public String getArrayParameter(String[] hobbys, Model model){
    for (String hobby : hobbys) {
        System.out.println(hobby);
    }
    return &quot;/WEB-INF/view/request.jsp&quot;;
}

表单提交，是相同的name
 &lt;form action=&quot;/parameter/array&quot; method=&quot;post&quot;&gt;
    爱好的数组&lt;br&gt;
    &lt;input type=&quot;checkbox&quot; name=&quot;hobbys&quot; value=&quot;sing&quot;&gt;唱&lt;br&gt;
    &lt;input type=&quot;checkbox&quot; name=&quot;hobbys&quot; value=&quot;jump&quot;&gt;跳&lt;br&gt;
    &lt;input type=&quot;checkbox&quot; name=&quot;hobbys&quot; value=&quot;rap&quot;&gt;rap&lt;br&gt;
    &lt;input type=&quot;checkbox&quot; name=&quot;hobbys&quot; value=&quot;basketball&quot;&gt;篮球&lt;br&gt;
    &lt;input type=&quot;submit&quot;&gt;
 &lt;/form&gt;
</code></pre><p><strong>bean接收list，只能通过bean接收</strong></p>
<pre><code>@RequestMapping(&quot;/parameter/javabean/list&quot;)
public String getListInBeanParameter(User userz){
    return &quot;/WEB-INF/view/request.jsp&quot;;
}
&lt;form action=&quot;/parameter/javabean/list&quot; method=&quot;post&quot;&gt;
    username:&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;
    password:&lt;input type=&quot;text&quot; name=&quot;password&quot;&gt;&lt;br&gt;
    age:&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;&lt;br&gt;
    married:&lt;input type=&quot;text&quot; name=&quot;married&quot;&gt;&lt;br&gt;
    value:&lt;input type=&quot;text&quot; name=&quot;value&quot;&gt;&lt;br&gt;
    userdetail.email&lt;input type=&quot;text&quot; name=&quot;userDetail.email&quot;&gt;&lt;br&gt;
爱好&lt;br&gt;
    &lt;input type=&quot;checkbox&quot; name=&quot;hobbys&quot; value=&quot;sing&quot;&gt;唱&lt;br&gt;
    &lt;input type=&quot;checkbox&quot; name=&quot;hobbys&quot; value=&quot;jump&quot;&gt;跳&lt;br&gt;
    &lt;input type=&quot;checkbox&quot; name=&quot;hobbys&quot; value=&quot;rap&quot;&gt;rap&lt;br&gt;
    &lt;input type=&quot;checkbox&quot; name=&quot;hobbys&quot; value=&quot;basketball&quot;&gt;篮球&lt;br&gt;
    car&lt;br&gt;
    &lt;!-- 使用bean中的carList接收 --&gt;
    汽车1&lt;br&gt;
    &lt;input type=&quot;text&quot; name=&quot;carList[0].name&quot;&gt;
    &lt;input type=&quot;text&quot; name=&quot;carList[0].price&quot;&gt;
    汽车2&lt;br&gt;
    &lt;input type=&quot;text&quot; name=&quot;carList[1].name&quot;&gt;
    &lt;input type=&quot;text&quot; name=&quot;carList[1].price&quot;&gt;
    &lt;input type=&quot;submit&quot;&gt;
&lt;/form&gt;
</code></pre><h3 id="中文乱码问题，编解码不一致问题"><a href="#中文乱码问题，编解码不一致问题" class="headerlink" title="中文乱码问题，编解码不一致问题"></a>中文乱码问题，编解码不一致问题</h3><p>需要在web.xml中配置一个filter</p>
<pre><code>&lt;filter&gt;
    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;param-value&gt;utf-8&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre><h3 id="转换器（converter）"><a href="#转换器（converter）" class="headerlink" title="转换器（converter）"></a>转换器（converter）</h3><p>从前端默认传过来的就是一个字符串的数据。如果我们想用Date对象来接收，Spring默认没有给我们实现，我们需要自己的去实现这个功能，就要使用一个叫转换器的东西。</p>
<pre><code>&lt;h1&gt;接收日期&lt;/h1&gt;
&lt;form action=&quot;/parameter/date&quot; method=&quot;post&quot;&gt;
  &lt;input type=&quot;text&quot; name=&quot;date&quot;&gt;
  &lt;input type=&quot;submit&quot;&gt;
&lt;/form&gt;

@RequestMapping(&quot;parameter/date&quot;)
public String getDateParameter(Date date){
  return &quot;/WEB-INF/view/request.jsp&quot;;
}
</code></pre><p>默认是不能直接转换的，需要我们去spring中配置一个转换器，然后我们手动去实现这个转换。<br>1.在application.xml中需要配置：转换器是一个set的集合，不能重复。</p>
<pre><code>&lt;!-- 不写转换器会报400错误 --&gt;
&lt;mvc:annotation-driven conversion-service=&quot;customConversionService&quot;/&gt;

&lt;!-- 设置转换器 --&gt;
&lt;bean id=&quot;customConversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt;
    &lt;property name=&quot;converters&quot;&gt;
      &lt;set&gt;
        &lt;!-- 可以写多个转换器 --&gt;
        &lt;bean class=&quot;com.cskaoyan.converter.String2DateConverter&quot;/&gt;
        &lt;ref bean=&quot;String2DateConverter2&quot;&gt;
      &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;
&lt;bean id=&quot;String2DateConverter2&quot; class=&quot;com.cskaoyan.converter.String2DateConverter2&quot;/&gt;
</code></pre><p>2.写一个转换器的组间String2DateConverter</p>
<pre><code>public class String2DateConverter implements Converter&lt;String, Date&gt; {
  @Override
  public Date convert(String s) {
    //转换成date类型的业务逻辑1931-09-18
    SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
    try {
        Date parse = simpleDateFormat.parse(s);
        //返回一个日期对象
        return parse;
    } catch (ParseException e) {
        e.printStackTrace();
    }
    return null;
  }
}
</code></pre><p><strong>其实我们可以想到，之前的直接转成bean，数组，或者bean里面的bean，这些都是通过反射Spring的转换器给我们转好了。</strong></p>
<h3 id="文件上传（重点）"><a href="#文件上传（重点）" class="headerlink" title="文件上传（重点）"></a>文件上传（重点）</h3><p>同样我们需要导包（pom.xml）</p>
<pre><code>&lt;!--文件上传的支持--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;commons-io&lt;/groupId&gt;
    &lt;artifactId&gt;commons-io&lt;/artifactId&gt;
    &lt;version&gt;2.6&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;
    &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;
    &lt;version&gt;1.3.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>在application中配置组间，注意<strong>id是固定</strong>的</p>
<pre><code>&lt;!--id一定要写multipartResolver，可以写一些文件设置--&gt;
&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;
    &lt;property name=&quot;maxUploadSize&quot; value=&quot;5242880&quot;/&gt;
&lt;/bean&gt;
</code></pre><p>html/jsp中</p>
<pre><code>&lt;!-- 注意事项：一定要post请求（足够大上传文件），一个是enctype=&quot;multipart/form-data&quot; --&gt;
&lt;form action=&quot;${pageContext.request.contextPath}/file/upload&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt;
    &lt;input type=&quot;file&quot; name=&quot;myfile&quot;&gt;&lt;input type=&quot;submit&quot;&gt;
&lt;/form&gt;
</code></pre><p>最后controller，MultipartFile myfile接收，这个参数名，要和上传的文件的name相同</p>
<pre><code>@Controller
public class FileUploadController {
    @RequestMapping(&quot;file/upload&quot;)
    public String fileUpload(MultipartFile myfile, User user) throws IOException {
//        myfile.getOriginalFilename()
        File file = new File(&quot;d://myfile.jpg&quot;);
        myfile.transferTo(file);
        return &quot;/WEB-INF/view/success.jsp&quot;;
    }
}
</code></pre><h2 id="周四（9月19日）"><a href="#周四（9月19日）" class="headerlink" title="周四（9月19日）"></a>周四（9月19日）</h2><h2 id="星期四（0919）"><a href="#星期四（0919）" class="headerlink" title="星期四（0919）"></a>星期四（0919）</h2><h3 id="1-REST"><a href="#1-REST" class="headerlink" title="1 REST"></a>1 REST</h3><p>1.1 获得请求url中的参数<strong>@PathVariable</strong><br>controller.java</p>
<pre><code>@RequestMapping(&quot;user/{method}/id/{idz}&quot;)
public String queryUserById(@PathVariable(&quot;idz&quot;) int id,
                            @PathVariable(&quot;method&quot;)String method,
                            Model model){
  User user = userService.queryUserById(id);
  System.out.println(&quot;method=&quot; + method);
  model.addAttribute(&quot;user&quot;,user);
  return &quot;/WEB-INF/user.jsp&quot;;
}
</code></pre><p>1.2 获得请求头（RequestHeaders）中的值<strong>@RequestHeader</strong></p>
<pre><code>@RequestMapping(&quot;hello&quot;)
public String getRequestHeader(@RequestHeader(&quot;Accept-Language&quot;)String[] language,
                               @RequestHeader(&quot;student&quot;)String student,
                               Model model){
    System.out.println(&quot;language = &quot; + language);
    model.addAttribute(&quot;language&quot;,language);
    System.out.println(&quot;student = &quot; + student);
    return &quot;/WEB-INF/show.jsp&quot;;
}
</code></pre><p>1.3 限定请求参数<strong>@RequestParam</strong></p>
<pre><code>//通过@RequestParam设置
//@RequestMapping(&quot;parameter/limit&quot;)
//public String parameterLimit(@RequestParam(&quot;username&quot;) String username,String password,Model model){

//通过@RequestMapping限制
@RequestMapping(value = &quot;parameter/limit&quot;, params = {&quot;username&quot;})
public String parameterLimit(String username,String password,Model model){
    model.addAttribute(&quot;username&quot;,username);
    return &quot;/WEB-INF/limit.jsp&quot;;
}
</code></pre><h3 id="2-静态资源的处理"><a href="#2-静态资源的处理" class="headerlink" title="2 静态资源的处理"></a>2 静态资源的处理</h3><p>2.1 Default-servlet<br>在web.xml中添加：</p>
<pre><code>&lt;servlet-mapping&gt;
  &lt;servlet-name&gt;default&lt;/servlet-name&gt;
  &lt;url-pattern&gt;*.html&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
&lt;servlet-mapping&gt;
  &lt;servlet-name&gt;default&lt;/servlet-name&gt;
  &lt;url-pattern&gt;*.gif&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
&lt;servlet-mapping&gt;
  &lt;servlet-name&gt;default&lt;/servlet-name&gt;
  &lt;url-pattern&gt;*.js&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
&lt;servlet-mapping&gt;
  &lt;servlet-name&gt;default&lt;/servlet-name&gt;
  &lt;url-pattern&gt;*.css&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre><p>2.2 Default servlet handler<br>Springmvc 提供了一种方式让默认的servlet去处理静态资源</p>
<pre><code>&lt;mvc:default-servlet-handler/&gt;
</code></pre><p>2.3 Springmvc的静态资源处理</p>
<pre><code>&lt;!--mapping对应的是请求url--&gt;
&lt;!--location：静态资源存放的路径--&gt;
&lt;!--pic1/abc.jpg pic1/abc/abc.jpg--&gt;
&lt;mvc:resources mapping=&quot;/pic1/**&quot; location=&quot;classpath:/pic1/&quot;/&gt;&lt;!--classpath--&gt;
&lt;mvc:resources mapping=&quot;/pic2/**&quot; location=&quot;/WEB-INF/jpg/&quot;/&gt;&lt;!--web根目录、没有前缀--&gt;
&lt;mvc:resources mapping=&quot;/pic3/**&quot; location=&quot;file:D:/spring/file/pic3/&quot;/&gt;&lt;!--文件路径 file：的前缀--&gt;
</code></pre><p>注意这里 mapping 映射里的</p>
<pre><code>mapping = &quot;/pic3/**&quot;
</code></pre><p>就是/pic3/下的任意路径。<br>1.配置classpath在maven就是在resource的目录会和src合并到classes文件夹中<br>2.配置/ 就是在webroot下面<br>3.配置文件系统，这个应该是最常用的 file:/.. /</p>
<p><strong>注意事项:</strong>这里每个location后面一定要加”/“”</p>
<h3 id="3-Interceptor"><a href="#3-Interceptor" class="headerlink" title="3 Interceptor"></a>3 Interceptor</h3><p>SpringMVC 的处理器拦截器类似于 Servlet 开发中的过滤器Filter，用于对处理器进行预处理和后处理</p>
<h3 id="常见使用场景"><a href="#常见使用场景" class="headerlink" title="常见使用场景"></a>常见使用场景</h3><pre><code>1、日志记录：记录请求信息的日志，以便进行信息监控、信息统计、计算PV（Page View）等。
2、权限检查：如登录检测，进入处理器检测检测是否登录，如果没有直接返回到登录页面；
3、性能监控：有时候系统在某段时间莫名其妙的慢，可以通过拦截器在进入处理器之前记录开始时间，在处理完后记录结束时间，从而得到该请求的处理时间 ；
4、通用行为：读取cookie得到用户信息并将用户对象放入请求，从而方便后续流程使用，还有如提取Locale、Theme信息等，只要是多个处理器都需要的即可使用拦截器实现。
5、OpenSessionInView：如Hibernate，在进入处理器打开Session，在完成后关闭Session。
</code></pre><h3 id="能不能用，用起来再说"><a href="#能不能用，用起来再说" class="headerlink" title="能不能用，用起来再说"></a>能不能用，用起来再说</h3><p>（简单案例，对所有的访问controller都进行拦截）</p>
<p>第一步：需要写一个类继承 HandlerInterceptor（需要重写三个方法）<br><strong><em>3.1.1 preHandle</em></strong><br>返回值是boolean，当为true可以执行到Handler（RequestMapping所对应的的方法），如果为false则执行不到handler。<br><strong>注意当前类的prehandle返回值为true，一定可以执行到它所对应的afterCompletion</strong></p>
<p><strong><em>3.1.2 PostHandle</em></strong><br>执行是在Handler返回ModelAndView给dispatcherServlet之间执行<br>形参中包含一个ModelAndView，来源于@RequestMapping所对应的的Handler，并且可以对ModelAndView做进一步的处理</p>
<p><strong><em>3.1.3 afterCompletion</em></strong><br>在dispatcherServlet处理完ModelAndView之后执行，通常做一些流的关闭</p>
<pre><code>public class CustomInterceptor implements HandlerInterceptor {
  @Override
  public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
    System.out.println(&quot;preHandle&quot;);
    return true;
  }
  @Override
  public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
    System.out.println(&quot;postHandle&quot;);
  }
  @Override
  public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
    System.out.println(&quot;afterCompletion&quot;);
  }
}
</code></pre><p>第二步：在application中配置</p>
<pre><code>&lt;mvc:interceptors&gt;
  &lt;bean class=&quot;com.cskaoyan.interceptor.CustomInterceptor&quot;/&gt;
&lt;mvc:interceptors&gt;
</code></pre><p>然后访问到controller里面有的请求，就会触发拦截器，这也是写作业才发现的<br>当然问题就来了：<br><strong>怎么拦截controller中没有的请求？</strong></p>
<h3 id="3-4-多个interceptor的执行关系"><a href="#3-4-多个interceptor的执行关系" class="headerlink" title="3.4 多个interceptor的执行关系"></a>3.4 多个interceptor的执行关系</h3><p>这里多个请求，就好像汉堡一样一层包着一层，先注册的是外层，后注册的是内层。<br>1.正常走完prehandle全是true<br>2.多个interceptor，当第一个preHandle返回false，下面所有的流程都走不到<br>3.多个interceptor第一个为true，第二个为false，后面都走不到，但可以走到第一个的afterCompletion</p>
<p>结论：<br>当prehandle返回值为true，嵌套结构这部分可以继续往下走，<br>并且当prehandle返回值为true，一定可以指定到其对应的afterCompletion</p>
<h3 id="Interceptor的作用范围"><a href="#Interceptor的作用范围" class="headerlink" title="Interceptor的作用范围"></a>Interceptor的作用范围</h3><p>可以设置成拦截固定的url，<br>在application中设置</p>
<pre><code>&lt;mvc:interceptors&gt;
  &lt;bean class=&quot;com.cskaoyan.interceptor.CustomInterceptor&quot;/&gt;
  &lt;ref bean=&quot;customInterceptor2&quot;/&gt;
  &lt;mvc:interceptor&gt;
    &lt;mvc:mapping path=&quot;/user/**&quot;/&gt;
    &lt;bean class=&quot;com.cskaoyan.interceptor.UserInterceptor&quot;/&gt;
  &lt;/mvc:interceptor&gt;
&lt;/mvc:interceptors&gt;
</code></pre><h3 id="4-异常处理器"><a href="#4-异常处理器" class="headerlink" title="4 异常处理器"></a>4 异常处理器</h3><h3 id="第一步自定义的异常的实现"><a href="#第一步自定义的异常的实现" class="headerlink" title="第一步自定义的异常的实现"></a>第一步自定义的异常的实现</h3><p>通过继承异常类实现自定义的异常</p>
<pre><code>public class CustomException extends Exception {
    //可以自定义参数
    String customParam;
    public String getCustomParam() {
        return customParam;
    }
    public void setCustomParam(String customParam) {
        this.customParam = customParam;
    }
    public CustomException(String message, String customParam) {
        super(message);
        this.customParam = customParam;
    }
}
</code></pre><h3 id="第二步编写-exceptionHandler"><a href="#第二步编写-exceptionHandler" class="headerlink" title="第二步编写 exceptionHandler"></a>第二步编写 exceptionHandler</h3><p>我们的异常向上抛出，抛出到dispatcherServlet就可以通过我们的handlerException来接收，然后再进行不同的业务逻辑</p>
<pre><code>@Component//注册到spring
public class CustomExceptionHandler implements HandlerExceptionResolver {
  @Override
  public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) {
    ModelAndView modelAndView = new ModelAndView();
    if (e instanceof CustomException){
      modelAndView.addObject(&quot;message&quot;,e.getMessage());
      modelAndView.setViewName(&quot;/WEB-INF/view/exception.jsp&quot;);
    }else if (e instanceof ParamException){
      modelAndView.addObject(&quot;message&quot;,e.getMessage());
      ParamException paramException = (ParamException) e;
      modelAndView.addObject(&quot;paramz&quot;,paramException.getParam());
      modelAndView.setViewName(&quot;/WEB-INF/view/param.jsp&quot;);
    }
    return modelAndView;
  }
}
</code></pre><p><strong>注意事项</strong>这里其实我们也发现了，这种做法很蠢，写成if else 和之前的没学SpringMVC之前一个servlet，接收多个请求的一样，有问题。后面会说怎么解决</p>
<h3 id="5-Json"><a href="#5-Json" class="headerlink" title="5 Json"></a>5 Json</h3><p>主要解决两个问题：<br>接收前端发送的json数据<br>返回json数据给到前端<br>5.1 导包<br>一拖三<br>Jackson core databind annotation</p>
<pre><code>&lt;!--jackson--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
    &lt;version&gt;2.9.9&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>@ResponseBody 以json数据的形式返回值（<strong>位置：写在方法名上</strong>）<br>@RequestBody 接收json数据（<strong>位置：写在方法的形参前面</strong>）<br>@RestController = @Controller + @ResponseBody 当前类下全部方法都返回json数据（位置写在类名上）</p>
<pre><code>@RequestMapping(value = &quot;user/insert&quot;,method = RequestMethod.POST)
//@ResponseBody
public BaseResultVo queryUser(@RequestBody User user){
    //使用bean封装返回结果
    BaseResultVo&lt;User&gt; baseResultVo = new BaseResultVo&lt;&gt;();

    baseResultVo.setData(user);
    return baseResultVo;
}
</code></pre><p>这里使用了一个结果包装类</p>
<p>5.4.1 同一个url映射到不同的方法<br>通过不同的请求方法，或者请求头等等，但是很蠢</p>
<pre><code>@RequestMapping(value = &quot;user/insert&quot;,method = RequestMethod.POST)
//@ResponseBody
public BaseResultVo queryUser(@RequestBody User user){
    //使用bean封装返回结果
    BaseResultVo&lt;User&gt; baseResultVo = new BaseResultVo&lt;&gt;();
    baseResultVo.setData(user);
    return baseResultVo;
}

@RequestMapping(value = &quot;user/insert&quot;,method = RequestMethod.GET)
public BaseResultVo queryUser2(){
    return new BaseResultVo();
}
</code></pre><p>5.4.2 多个url映射到同一个方法上</p>
<pre><code>@RequestMapping(value = {&quot;hello1&quot;,&quot;hello2&quot;})
public String helloMulti(){
    return &quot;hello Multi&quot;;
}
@RequestMapping(value = {&quot;hello3*&quot;})
public String helloMulti2(){
    return &quot;hello Multi2&quot;;
}
</code></pre><h2 id="周五（9月20日）"><a href="#周五（9月20日）" class="headerlink" title="周五（9月20日）"></a>周五（9月20日）</h2><h2 id="星期五（0920）"><a href="#星期五（0920）" class="headerlink" title="星期五（0920）"></a>星期五（0920）</h2><h3 id="exception的真正用法"><a href="#exception的真正用法" class="headerlink" title="exception的真正用法"></a>exception的真正用法</h3><p>一般exception配合json传送给前端，也不需要导包</p>
<p>先写一个异常：</p>
<pre><code>public class CustomException extends Exception {
  public CustomException(String message) {
      super(message);
  }
}
</code></pre><p>写业务逻辑<br>在 controller.java</p>
<pre><code>@RestController
public class ExceptionController {
  @RequestMapping(&quot;hello&quot;)
  public String hello() throws CustomException {
    if (true) {
      throw new CustomException(&quot;你发生异常了&quot;);
    }
    return &quot;hello exception&quot;;
  }
}
</code></pre><p>再写一个异常控制器，不需要继承什么类，只要写三个注解</p>
<pre><code>@ControllerAdvice   //里面有@Component
public class JsonExceptionHandler {
  @ExceptionHandler(CustomException.class)
  @ResponseBody//发送一个json数据
  public BaseResultVo resolveCustomException(CustomException e){
    BaseResultVo baseResultVo = new BaseResultVo();
    baseResultVo.setErrorMsg(e.getMessage());
    return baseResultVo;
  }
}
</code></pre><p>@ControllerAdvice 里面有@Component注册成组件，然后这是一个通知，我们可以大胆猜测这个excepti<br>@ExceptionHandler 表示要handler哪个Exception.class<br>@ResponseBody  之前讲过</p>
<p>再来是转给前端的bean</p>
<pre><code>public class BaseResultVo&lt;T&gt; {
  int errorNo;
  String errorMsg;
  T data;
}
</code></pre><h3 id="Freemarker"><a href="#Freemarker" class="headerlink" title="Freemarker"></a>Freemarker</h3><p>两种用法：一种是后端自己渲染一些模板，一种是后端渲染好网页给前端显示。</p>
<p>自从前后端分离之后，可能用来渲染一些其他的东西。前端也有自己的模板引擎。<br>而且控制更加方便。</p>
<p>首先老规矩：导包</p>
<pre><code>&lt;packaging&gt;war&lt;/packaging&gt;
&lt;dependencies&gt;
  &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;4.12&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
    &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
    &lt;version&gt;3.0-alpha-1&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
  &lt;/dependency&gt;
  &lt;!--整合freemarker--&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.freemarker&lt;/groupId&gt;
    &lt;artifactId&gt;freemarker&lt;/artifactId&gt;
    &lt;version&gt;2.3.28&lt;/version&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;
    &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre><h3 id="后端自己渲染一些模板"><a href="#后端自己渲染一些模板" class="headerlink" title="后端自己渲染一些模板"></a>后端自己渲染一些模板</h3><p>就在测试类里面写</p>
<pre><code>第一步：创建一个Configuration对象，直接new一个对象。构造方法的参数就是freemarker的版本号。
第二步：设置模板文件所在的路径。
第三步：设置模板文件使用的字符集。一般就是utf-8.
第四步：加载一个模板，创建一个模板对象。
第五步：创建一个模板使用的数据集，Map对象。
第六步：创建一个Writer对象，一般创建一FileWriter对象，指定生成的文件名。
第七步：调用模板对象的process方法输出文件。
第八步：关闭流。
</code></pre><p>测试：</p>
<pre><code>public class MainTest {
  @Test
  public void mytest() throws IOException, TemplateException {
    //第一步：创建一个Configuration对象，直接new一个对象。构造方法的参数就是freemarker的版本号。
    Configuration configuration = new Configuration(Configuration.getVersion());
    //第二步：设置模板文件所在的路径。
    File templatePath = new File(&quot;src/main/resources/template&quot;);
    configuration.setDirectoryForTemplateLoading(templatePath);
    //第三步：设置模板文件使用的字符集。一般就是utf-8.
    configuration.setDefaultEncoding(&quot;utf-8&quot;);
    //第四步：加载一个模板，创建一个模板对象。
    Template template = configuration.getTemplate(&quot;hello.ftl&quot;);
    //第五步：创建一个模板使用的数据集，Map对象。
    Map&lt;String,Object&gt; dataMap = new HashMap&lt;&gt;();
    dataMap.put(&quot;content&quot;,&quot;freemarker&quot;);
    //第六步：创建一个Writer对象，一般创建一FileWriter对象，指定生成的文件名。
    File destFile = new File(&quot;src/main/resources/hello.html&quot;);
    FileWriter fileWriter = new FileWriter(destFile);
    //第七步：调用模板对象的process方法输出文件。
    template.process(dataMap,fileWriter);
    //第八步：关闭流。
    fileWriter.close();
  }
}
</code></pre><p>模板文件.ftl,看起来很像网页</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    hello ${content}
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h3 id="传给前端显示页面-SpringMVC中使用"><a href="#传给前端显示页面-SpringMVC中使用" class="headerlink" title="传给前端显示页面(SpringMVC中使用)"></a>传给前端显示页面(SpringMVC中使用)</h3><p>导包：除了需要一个freeMarker还需要spring-context-support<br>controller写法给前端很像jsp,为了使得两个不打架我们需要把用jsp渲染和用freeMarker渲染分开<br>可以通过<br>1）顺序，使得先让freemarker渲染，再让jsp渲染。因为jsp渲染不了会强制渲染。很难受<br>2）通过分发，设置viewNames这样就能分开了；<br>看下面的例子：<br>配置application:</p>
<pre><code>&lt;!--jsp视图解析器配置--&gt;
&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/view/&quot;/&gt;
    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;
    &lt;!--&lt;property name=&quot;order&quot; value=&quot;2&quot;/&gt;--&gt;
    &lt;property name=&quot;viewNames&quot; value=&quot;*jsp&quot;/&gt;
&lt;/bean&gt;
&lt;!--配置--&gt;
&lt;bean class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer&quot;&gt;
    &lt;!--相对于webroot(webapp)的路径--&gt;
    &lt;property name=&quot;templateLoaderPath&quot; value=&quot;/WEB-INF/template&quot;/&gt;
    &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot;/&gt;
&lt;/bean&gt;
&lt;!--freeMarker视图解析器--&gt;
&lt;bean class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver&quot;&gt;
    &lt;property name=&quot;suffix&quot; value=&quot;.ftl&quot;/&gt;
    &lt;property name=&quot;contentType&quot; value=&quot;text/html;charset=utf-8&quot;/&gt;
    &lt;!--&lt;property name=&quot;order&quot; value=&quot;1&quot;/&gt;--&gt;
    &lt;property name=&quot;viewNames&quot; value=&quot;*fm&quot;/&gt;
&lt;/bean&gt;
</code></pre><p>Controller中测试<br><strong>使用freeMarker时候。model对象，就是dataMap来用</strong></p>
<pre><code>@Controller
public class HelloController {
  @RequestMapping(&quot;hello_fm&quot;)
  public String hello(Model model){
      model.addAttribute(&quot;content&quot;,&quot; freemarker&quot;);
      /*对应的viewName：模板的加载路径+返回值+suffix*/
      return &quot;hellofm&quot;;
  }
  @RequestMapping(&quot;hello_jsp&quot;)
  public String hello2(Model model){
      /*对应的viewName：模板的加载路径+返回值+suffix*/
      return &quot;hellojsp&quot;;
  }
}
</code></pre><p>注意模板加载路径即可；</p>
<h3 id="freemark渲染的语法"><a href="#freemark渲染的语法" class="headerlink" title="freemark渲染的语法"></a>freemark渲染的语法</h3><p>说了半天没说渲染的语法，这里就简单介绍一下一些渲染，判断之类都放在Java中判断吧<br>para.ftl</p>
<pre><code>&lt;h1&gt;使用map中的key&lt;/h1&gt;
hello ${content}
&lt;h1&gt;使用pojo中的属性&lt;/h1&gt;
用户名：${user.username}
密码：${user.password}
邮箱：${user.userDetail.email}
&lt;h1&gt;集合中的数据&lt;/h1&gt;
&lt;#list userList as userz&gt;
    &lt;h3&gt;下标：${userz_index+1} ||用户名：${userz.username}|| 密码： ${userz.password}&lt;/h3&gt;
&lt;/#list&gt;
&lt;h1&gt;特殊值&lt;/h1&gt;
${abc! &quot;&quot;}
日期：${date?string(&quot;MM月dd日&quot;)}
文件引入
&lt;#include &quot;inner.ftl&quot;&gt;
</code></pre><p><strong>1.${content}</strong>,对应的在dataMap中   dataMap.put(“content”,”freemarker”);</p>
<p><strong>2.显示bean</strong><br>    ${user.username}<br>    ${user.password}<br>    ${user.userDetail.email}</p>
<p>在java中</p>
<pre><code>/*放入pojo类型的数据*/
UserDetail userDetail = new UserDetail(&quot;cskaoyan123@qq.com&quot;);
User user = new User(&quot;zhangsong&quot;, &quot;123456&quot;,userDetail);
dataMap.put(&quot;user&quot;,user);
</code></pre><p><strong>3.遍历</strong></p>
<pre><code>&lt;#list userList as userz&gt;
    &lt;h3&gt;下标：${userz_index+1} ||用户名：${userz.username}|| 密码： ${userz.password}&lt;/h3&gt;
&lt;/#list&gt;
</code></pre><p><strong>4.设置默认值</strong><br>因为出现异常模板默认是直接渲染到你生成文件上就很丑，所以必须要给一个默认值，这样就不会让用户看到一大堆异常信息</p>
<pre><code>${abc! &quot;&quot;}
</code></pre><p><strong>5.日期</strong>：${date?string(“MM月dd日”)}</p>
<p><strong>6.文件引入</strong></p>
<pre><code>&lt;#include &quot;inner.ftl&quot;&gt;
</code></pre><h3 id="JavaConfig代替web-xml和application-xml（重要！？）"><a href="#JavaConfig代替web-xml和application-xml（重要！？）" class="headerlink" title="JavaConfig代替web.xml和application.xml（重要！？）"></a>JavaConfig代替web.xml和application.xml（重要！？）</h3><p>导包是一定要导包的。需要知道我们的目的是什么:就是不写web.xml和application.xml<br>我们先配置好，之后再加上不同的组间的功能</p>
<p>第一步：配置启动项<br>我们导完包就之后就是创建webapp的文件夹，然后再创建web.xml，那么我们肯定是先配置web.xml<br>需要写一个类继承AACDSI<br>这三个方法必须配置，就是配置Spring的配置文件，SpringMVC的配置文件，和dispatcherServlet的url-pattern</p>
<pre><code>public class WebApplicationInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {
  /*Spring容器的配置类*/
  @Override
  protected Class&lt;?&gt;[] getRootConfigClasses() {
    return new Class[]{SpringConfig.class};
  }

  /*Springmvc的配置*/
  @Override
  protected Class&lt;?&gt;[] getServletConfigClasses() {
    return new Class[]{MvcConfig.class};
  }

  /*dispatcherServlet对应的urlpattern*/
  @Override
  protected String[] getServletMappings() {
    return new String[]{&quot;/&quot;};
  }
}
</code></pre><p>写Spring的配置文件</p>
<pre><code>@Configuration
@ComponentScan(basePackages = &quot;com.cskaoyan&quot;,
  excludeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION,value = {Controller.class, EnableWebMvc.class}))
public class SpringConfig {
}
</code></pre><p><strong>注意：</strong>因为我们知道SpringMVC继承Spring所以配置的组间写在SpringMVC这样更好的使用。</p>
<p>SpringMVC的配置文件，需要实现一个接口WebMvcConfigurer</p>
<pre><code>@EnableWebMvc
@ComponentScan(basePackages = &quot;com.cskaoyan.controller&quot;)
public class MvcConfig implements WebMvcConfigurer {
}
</code></pre><p>如何告诉Spring我需要用哪个configuration去扫描呢。SpringMVC只需要去扫描controller的包下的文件。而Spring如何设置使得controller包下的文件不会扫两次。这里就需要：</p>
<pre><code>excludeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION,value = {Controller.class, EnableWebMvc.class}))
</code></pre><p>表示带着这个@Controller注解，@EnableWebMvc注解的类不会扫描到。</p>
<p>这样我们就完全替代了web.xml和application.xml<br>我觉得： Spring 的做法肯定是读取这两个xml然后转成我们写的形式罢了。</p>
<h3 id="为我们的javaConfig添加新东西"><a href="#为我们的javaConfig添加新东西" class="headerlink" title="为我们的javaConfig添加新东西"></a>为我们的javaConfig添加新东西</h3><h3 id="全局编码格式"><a href="#全局编码格式" class="headerlink" title="全局编码格式"></a>全局编码格式</h3><p>我们之前是写在web.xml中的，所以我们要写 javaConfig 形式就要写在WebApplicationInitializer</p>
<pre><code>//默认设置全局的编码格式
@Override
protected Filter[] getServletFilters() {
    CharacterEncodingFilter characterEncodingFilter = new CharacterEncodingFilter();
    characterEncodingFilter.setEncoding(&quot;utf-8&quot;);
    return new Filter[]{characterEncodingFilter};
}
</code></pre><h3 id="设置其他的组件，写在mvcConfig中"><a href="#设置其他的组件，写在mvcConfig中" class="headerlink" title="设置其他的组件，写在mvcConfig中"></a>设置其他的组件，写在mvcConfig中</h3><pre><code>@EnableWebMvc
@ComponentScan(basePackages = &quot;com.cskaoyan.controller&quot;)
public class MvcConfig implements WebMvcConfigurer {
</code></pre><p><strong>配置转换器</strong>：需要在原先的转换器上加一个我们自定义的转换器</p>
<pre><code>/**
 * 配置converter
 * 1、从容器中取出conversionService
 * 2、添加自定义的converter
 * 3、重新注册回容器中
 */

@Autowired
ConfigurableConversionService conversionService;

@PostConstruct
public void addConverter(){
    String2DateConverter string2DateConverter = new String2DateConverter();
    conversionService.addConverter(string2DateConverter);
}

//重新注册回去
@Bean
@Primary //唯一性
public ConfigurableConversionService configurableConversionService(){
    return conversionService;
}
</code></pre><p><strong>JSP视图解析器</strong></p>
<pre><code>/**
 * 创建jsp视图解析器
 */
@Bean
public InternalResourceViewResolver internalResourceViewResolver(){
    InternalResourceViewResolver internalResourceViewResolver = new InternalResourceViewResolver();
    internalResourceViewResolver.setPrefix(&quot;/WEB-INF/view/&quot;);
    internalResourceViewResolver.setSuffix(&quot;.jsp&quot;);
    internalResourceViewResolver.setViewNames(&quot;*.jsp&quot;);
    return internalResourceViewResolver;
}
</code></pre><p><strong>拦截器</strong>也是在默认的拦截器中添加我们自定义的拦截器<br>用法：拦截器拦截OPTIONS请求</p>
<pre><code>/**
 * 添加拦截器
 * @param registry
 */
@Override
public void addInterceptors(InterceptorRegistry registry) {
    registry.addInterceptor(new CustomInterceptor());
}
</code></pre><p><strong>文件上传</strong></p>
<pre><code>/**
 * 创建文件上传组件
 * id必须固定multipartResolver
 */
@Bean
public CommonsMultipartResolver multipartResolver(){
    CommonsMultipartResolver multipartResolver = new CommonsMultipartResolver();
    //中间可以设置一些参数
    return multipartResolver;
}
</code></pre><p><strong>访问静态资源</strong>：在原先的配置中添加</p>
<pre><code>/**
 * 添加静态文件访问
 * @param registry
 */
@Override
public void addResourceHandlers(ResourceHandlerRegistry registry) {
    registry.addResourceHandler(&quot;/pic/**&quot;).addResourceLocations(&quot;/&quot;);
}
</code></pre><p><strong>异常</strong></p>
<pre><code>/**
 * 异常不需要写在config里面，昨天的写法，
 * 需要继承的HandlerExceptionResolver估计要写
 *
 */
</code></pre><p><strong>freeMarker配置</strong></p>
<pre><code>    /**
     * freeMark注册
     */
    @Bean
    public FreeMarkerConfigurer freeMarkerConfigurer(){
        FreeMarkerConfigurer freeMarkerConfigurer = new FreeMarkerConfigurer();
        freeMarkerConfigurer.setTemplateLoaderPath(&quot;/WEB-INF/template&quot;);
        freeMarkerConfigurer.setDefaultEncoding(&quot;utf-8&quot;);
        return freeMarkerConfigurer;
    }

    /**
     * freeMark的视图解析器
     */
    @Bean
    public FreeMarkerViewResolver freeMarkerViewResolver(){
        FreeMarkerViewResolver freeMarkerViewResolver = new FreeMarkerViewResolver();
        freeMarkerViewResolver.setSuffix(&quot;.ftl&quot;);
        freeMarkerViewResolver.setContentType(&quot;text/html;charset=utf-8&quot;);
        freeMarkerViewResolver.setViewNames(&quot;*fm&quot;);
        return freeMarkerViewResolver;
    }
}
</code></pre><p><strong>注意事项</strong><br>1.这里我们发现如果我们要用的是springMVC初始化好的东西，我们就是去重写方法，例如converter，intercepter,filtere,addResourceHandlers<br>2.如果我们用到组件是SpringMVC中没有的，我们就必须写@Bean标签去注册在SpringMVC的容器中<br>3.转换器，拦截器。controller的请求的代码，之前都写过了。这里就不写了。关键是javaConfig应该怎么写</p>
<h2 id="周六（9月21日）"><a href="#周六（9月21日）" class="headerlink" title="周六（9月21日）"></a>周六（9月21日）</h2><h2 id="星期六"><a href="#星期六" class="headerlink" title="星期六"></a>星期六</h2><h2 id="Mybatis（dao层）"><a href="#Mybatis（dao层）" class="headerlink" title="Mybatis（dao层）"></a>Mybatis（dao层）</h2><p>Orm 对象关系映射<br>特点：</p>
<pre><code>自定义Sql
灵活（相对于Hibernate）
动态sql：
高级的输入映射：javabean、其他类型的参数 作为sql语句的参数
</code></pre><p>输出映射：</p>
<pre><code>查询结果封装成javabean或其他类型，做的是封装查询结果
</code></pre><h3 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h3><h3 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h3><p>Mybatis<br>Mysql-connector-java</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
    &lt;version&gt;3.4.6&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;version&gt;5.1.47&lt;/version&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre><h3 id="配置文件-mybatis-xml"><a href="#配置文件-mybatis-xml" class="headerlink" title="配置文件 mybatis.xml"></a>配置文件 mybatis.xml</h3><p>Mappers：mybatis存放sql语句的映射文件，文件名通常都叫XXXMapper.xml<br>需要的配置项：<br>1.Datasource：4大核心配置<br>2.映射文件</p>
<pre><code>&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;environments default=&quot;development&quot;&gt;
        &lt;environment id=&quot;development&quot;&gt;
            &lt;transactionManager type=&quot;JDBC&quot;/&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/j16_db?useUnicode=true&amp;amp;characterEncoding=utf-8&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
    &lt;!--mybatis的映射文件 sql和代码进行分离--&gt;
    &lt;mappers&gt;
        &lt;mapper resource=&quot;com/UserMapper.xml&quot;/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre><h3 id="映射文件"><a href="#映射文件" class="headerlink" title="映射文件"></a>映射文件</h3><p>放sql语句的—为了解耦<br>com/UserMapper.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;

&lt;mapper namespace=&quot;mynamespace&quot;&gt;
    &lt;select id=&quot;selectUserById&quot; resultType=&quot;com.cskaoyan.bean.User&quot;&gt;
        select id,username,password,age from user where id = #{renYi}
    &lt;/select&gt;

    &lt;select id=&quot;selectAllUser&quot; resultType=&quot;com.cskaoyan.bean.User&quot;&gt;
        select id,username,password,age from user
    &lt;/select&gt;

    &lt;select id=&quot;selectAllUserName&quot; resultType=&quot;string&quot;&gt;
        select username from user
    &lt;/select&gt;

    &lt;insert id=&quot;insertUser&quot;&gt;
        insert into user (username,password,age) values (#{username},#{password},#{age})
    &lt;/insert&gt;

    &lt;update id=&quot;updateUser&quot;&gt;
        update user set username = #{username}, password = #{password}, age = #{age} where id = #{id}
    &lt;/update&gt;

    &lt;delete id=&quot;deleteUser&quot;&gt;
        delete from user where id = #{shabi}
    &lt;/delete&gt;
&lt;/mapper&gt;
</code></pre><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><p>sqlSession←SqlSessionFactory←SqlSessionFactoryBuilder<br>（inputstream←Resources.getResourceAsStream）<br><strong>注意事项</strong> 进行数据库查询语句的第一个参数都是字符串形式的： namespace.id（sql语句）</p>
<pre><code>@Test
public void mytest() throws IOException {
    //SqlSessionFactoryBuider
    SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();
    //SqlSessionFactory
    InputStream resourceAsStream = Resources.getResourceAsStream(&quot;mybatis.xml&quot;);
    SqlSessionFactory sqlSessionFactory = builder.build(resourceAsStream);
    //SqlSession
    SqlSession sqlSession = sqlSessionFactory.openSession();

    //通过sql调用sql语句执行查询
    User user = sqlSession.selectOne(&quot;mynamespace.selectUserById&quot;, 1);
    System.out.println(user);
}
</code></pre><p>映射文件.xml</p>
<pre><code>&lt;select id=&quot;selectUserById&quot; resultType=&quot;com.cskaoyan.bean.User&quot;&gt;
    select id,username,password,age from user where id = #{renYi}
&lt;/select&gt;
</code></pre><h3 id="Before"><a href="#Before" class="headerlink" title="@Before"></a>@Before</h3><pre><code>/**
 * 配置一些初始化测试的参数
 */
SqlSession sqlSession;
SqlSessionFactory sqlSessionFactory;
@Before
public void init() throws IOException {
  SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();
  //配置sqlSessionFactory
  InputStream resourceAsStream = Resources.getResourceAsStream(&quot;mybatis.xml&quot;);
  sqlSessionFactory = builder.build(resourceAsStream);
}
</code></pre><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><pre><code>/**
 * 查询bean
 */
@Test
public void mybatisTest(){
    SqlSession sqlSession = sqlSessionFactory.openSession();
    User user = sqlSession.selectOne(&quot;mynamespace.selectUserById&quot;, 1);
    System.out.println(user);
}

/**
 * 查询List&lt;User&gt;
 */
@Test
public void test2(){
    sqlSession = sqlSessionFactory.openSession();
    List&lt;User&gt; list = sqlSession.selectList(&quot;mynamespace.selectAllUser&quot;);
    for (User user : list) {
        System.out.println(user);
    }
}

/**
 * 查询List&lt;String&gt;
 */
@Test
public void test3(){
    sqlSession = sqlSessionFactory.openSession();
    List&lt;String&gt; list = sqlSession.selectList(&quot;mynamespace.selectAllUserName&quot;);
    for (String s : list) {
        System.out.println(s);
    }
}
</code></pre><h3 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h3><pre><code>/**
 * 插入一个bean
 */
@Test
public void test_insert(){
    sqlSession = sqlSessionFactory.openSession();
    User user = new User(&quot;ersha&quot;, &quot;shazi&quot;, 24);
    int insert = sqlSession.insert(&quot;mynamespace.insertUser&quot;, user);
    System.out.println(insert);
    //不能这样执行test2，会直接开启另一个事务，所以之前插入的数据就没有真正插入。
    //test2();
}

&lt;insert id=&quot;insertUser&quot;&gt;
    insert into user (username,password,age) values (#{username},#{password},#{age})
&lt;/insert&gt;
</code></pre><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><pre><code>@Test
public void test_update(){
    sqlSession = sqlSessionFactory.openSession();
    User user = new User(&quot;阿飞&quot;, &quot;铁剑&quot;, 17);
    user.setId(5);
    int update = sqlSession.update(&quot;mynamespace.updateUser&quot;, user);
}

&lt;update id=&quot;updateUser&quot;&gt;
    update user set username = #{username}, password = #{password}, age = #{age} where id = #{id}
&lt;/update&gt;
</code></pre><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><pre><code>@Test
public void test_delete(){
    sqlSession = sqlSessionFactory.openSession();
    int delete = sqlSession.delete(&quot;mynamespace.deleteUser&quot;, 5);
}

&lt;delete id=&quot;deleteUser&quot;&gt;
    delete from user where id = #{shabi}
&lt;/delete&gt;
</code></pre><h3 id="After—测试（一定要提交事务）"><a href="#After—测试（一定要提交事务）" class="headerlink" title="@After—测试（一定要提交事务）"></a>@After—测试（一定要提交事务）</h3><pre><code>@After
public void destroy(){

    if(sqlSession!=null) {
        sqlSession.commit(); //这句话放外面会出现空指针异常吧？
        sqlSession.close();
    }
}
</code></pre><h3 id="技术总结"><a href="#技术总结" class="headerlink" title="技术总结"></a>技术总结</h3><p>sqlSession→ selectOne selectList（select标签）、insert（insert标签）、update（update）、delete（delete标签）</p>
<p>共同点：<br>• 都可以传入两个参数：<br>参数1（String）：</p>
<pre><code>对应的命名空间+id
</code></pre><p>参数2（Object）：</p>
<pre><code>基本类型→#{任意写}
Javabean→#{javabean的成员变量名}
</code></pre><p>• parameterType可以不写<br>Insert、delete、update：没有resultType、提交sqlSession</p>
<p>不同点：使用的标签不同<br>    查询的resultType是必须写的</p>
<p><strong>注意事项</strong>——-必须要提交事务</p>
<h2 id="周日（9月22）"><a href="#周日（9月22）" class="headerlink" title="周日（9月22）"></a>周日（9月22）</h2><p>1.今天突然想把交作业实现了。需要后端像服务器发送请求。那么我们本地开两个服务器来测试一下服务器提交给服务器。<br>需要用到HttpClient，这讲的很详细</p>
<p><a href="https://blog.csdn.net/justry_deng/article/details/81042379" target="_blank" rel="external">使用HttpClient</a><br>需要做的就是HttpClient 发送multipart/form-data的请求，网上一大堆。<br>那么我们开始吧：</p>
<h3 id="第一步-两个服务器先跑通"><a href="#第一步-两个服务器先跑通" class="headerlink" title="第一步:两个服务器先跑通"></a>第一步:两个服务器先跑通</h3><h3 id="第二步：文件上传跑通"><a href="#第二步：文件上传跑通" class="headerlink" title="第二步：文件上传跑通"></a>第二步：文件上传跑通</h3><p>问题一：</p>
<p>发现出现了错误：浏览器返回的是<strong>400</strong>错误</p>
<pre><code>Unable to process parts as no multi-part configuration has been provided
</code></pre><p>因为文件上传组件没有配置（MutipartResolver），但是居然不是先报（500）的错误- -<br>在我一步一步的排查下，终于爆了500错误- -从而知道是自己服务器配置出现了问题。<br>而且要注意：文件上传的那个name，一定要和后端接受的MutipartFile的名字相同。</p>
<p>问题二：</p>
<p>这里上传文件中文是？。因为中文名字一定是要的，所以必须要解决这个问题。<br>教程在是文件名使用Unicode.encode转码再发送的，我觉得老师后端肯定没有解码的。</p>
<p>看了很多解决方案都不行<br><a href="https://blog.csdn.net/xinjianwuhen1991/article/details/49949089" target="_blank" rel="external">https://blog.csdn.net/xinjianwuhen1991/article/details/49949089</a></p>
<p>更多的人家问题是：</p>
<p>  SpringCloud 上传文件，经过Zuul，中文文件名乱码解决办法</p>
<p>我都没用到SpringCloud- -</p>
<p>后来脑水一转直接搜索：</p>
<pre><code>httpClient上传文件乱码
</code></pre><p>就直接收到解决办法。还是自己太蠢了，问题都不知是什么问题就乱搜索。明明是httpClient的问题。却去搜索文件上传名字乱码问题<br>创建multipartEntityBuilder时候设置下面两个属性值:</p>
<pre><code>multipartEntityBuilder.setCharset(Charset.forName(&quot;utf-8&quot;));
multipartEntityBuilder.setMode(HttpMultipartMode.BROWSER_COMPATIBLE)
</code></pre><p>完美解决<br>来自：第一是怎么解决，第二个是原理<br><a href="https://blog.csdn.net/u012685794/article/details/51755799" target="_blank" rel="external">https://blog.csdn.net/u012685794/article/details/51755799</a><br><a href="https://blog.csdn.net/youshounianhua123/article/details/81100778" target="_blank" rel="external">https://blog.csdn.net/youshounianhua123/article/details/81100778</a></p>
<h3 id="第三步：文件能自动打包成压缩包"><a href="#第三步：文件能自动打包成压缩包" class="headerlink" title="第三步：文件能自动打包成压缩包"></a>第三步：文件能自动打包成压缩包</h3><p>因为不会，所以感觉有点难<br>找到一篇文章看看：<br><a href="https://www.cnblogs.com/zeng1994/p/7862288.html" target="_blank" rel="external">https://www.cnblogs.com/zeng1994/p/7862288.html</a><br>写的挺详细的<br>直接拿了人家的工具来用。很感谢</p>
<h3 id="第四步：全部结合起来"><a href="#第四步：全部结合起来" class="headerlink" title="第四步：全部结合起来"></a>第四步：全部结合起来</h3><p>删除文件夹中的target<br>忘记了：<br>delete() 删除此抽象路径名表示的文件或目录，如果文件夹中有文件存在，则该文件夹不能被删除。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>代码我会放在github上，感觉还是要多用才记得住啊！</p>
<p><strong><em>填坑部分</em></strong></p>
<h2 id="周日（9月15日）-1"><a href="#周日（9月15日）-1" class="headerlink" title="周日（9月15日）"></a>周日（9月15日）</h2><p>1.application.xml中这些通知的类型写的顺序是执行的顺序吗？</p>
<pre><code>&lt;aop:aspect ref=&quot;customAspect&quot;&gt;
  &lt;!--通知类型before、after、around、afterThrowing、afterReturning--&gt;
  &lt;!--method写切面类中所包含的方法--&gt;
  &lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;mypointcut1&quot;/&gt;
  &lt;aop:before method=&quot;mybefore&quot; pointcut-ref=&quot;mypointcut1&quot;/&gt;
  &lt;aop:after-throwing method=&quot;myAfterThrowing&quot; pointcut-ref=&quot;mypointcut1&quot; throwing=&quot;myexception&quot;/&gt;
  &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;mypointcut1&quot;/&gt;
  &lt;aop:after-returning method=&quot;myAfterReturning&quot; pointcut-ref=&quot;mypointcut1&quot; returning=&quot;myreturnResult&quot;/&gt;
&lt;/aop:aspect&gt;
</code></pre><p>答：不是，只是显示的顺序，最终的执行的顺序就和我们上课的图相同，after就是类似于finally在最后才执行。</p>
<p>2.以下两个是否相同？</p>
<pre><code>&lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;mypointcut1&quot;/&gt;
&lt;aop:advisor advice-ref=&quot;myadvice&quot; pointcut-ref=&quot;mypointcut&quot; /&gt;
</code></pre><p>第二种更灵活一点，但是后面用jdbc的时候使用是第一种。事务的使用也是第一种，可能都不太常用</p>
<p>3.复制项目的问题<br>复制了一个小项目一直运行不了显示<br>java.lang.SecurityException: Prohibited package name: java.servlet<br>发现复制的时候复制错了。把java文件夹也复制过来了。导致java文件夹下还有java文件夹，一定要小心！</p>
<p>4.切入点总是抓不住方法的问题<br>我直接在java下面就写<br>dao service servlet文件夹，然后在application里面的</p>
<pre><code>&lt;context:component-scan base-package=&quot;service&quot;/&gt;
&lt;aop:aspectj-autoproxy/&gt;
</code></pre><p>这就拉闸了，因为aspect根本没有扫到，需要把你的aspect的@Component扫到。<strong>一定要写包名！不写包名就扫描不到</strong></p>
<pre><code>@Component
@Aspect
public class CustomAspect {
    public void myPointCut(){}*/
    @Pointcut(&quot;execution(* com.cskaoyan.service.TransformServiceImpl..*(..))&quot;)
    public void mypointcut(){}
    @Around(&quot;mypointcut()&quot;)
    public Object around(ProceedingJoinPoint joinPoint) throws Throwable {
        System.out.println(&quot;around 的before&quot;);
        //这一行做的是执行目标类的方法
        Object proceed = joinPoint.proceed();
        System.out.println(&quot;around的after&quot;);
        return proceed;
    }
}
</code></pre><p>5.注解的原理<br>曾经我们写过注解，先来回顾一下之前学习注解的过程；</p>
<p>注意事项：</p>
<pre><code>a. @必不可少
b. 自定义注解继承了Annotation这个接口，由编译期完成细节
c. 不能继承任何接口
</code></pre><p>说明：</p>
<pre><code>方法的名称就是参数的名称，返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum, 以及它们的数组类型）。
方法不用写具体实现
一个方法表示一个配置
当只需要给 value 配置的时候，可以省略名称
方法之后可以使用 default 默认值
</code></pre><p>简单例子1：</p>
<pre><code>public @interface MyAnnotation  {
    int value() default 18;
    String method() default &quot;Henson_z&quot;;
    //...
}

@MyAnnotation()     // 创建了注解对象
public class AnnotationTest {
}
</code></pre><p>例子2：通过反射来拿到student注解上的参数</p>
<pre><code>public class Student {
    @NameConstraint(minLength = 2, maxLength = 10)
    private String name;

    @AgeConstraint(minAge = 6, maxAge = 1000)
    private int age;
}
</code></pre><p>test：通过成员属性对象，拿到属性对象上面的注解对象</p>
<pre><code>Class&lt;Student&gt; cl = Student.class;
int minLength = 0;
int maxLength = Integer.MAX_VALUE;
int minAge = 0;
int maxAge = Integer.MAX_VALUE;
try {
    //拿到成员属性对象
    Field nameField = cl.getDeclaredField(&quot;name&quot;);
    Field ageField = cl.getDeclaredField(&quot;age&quot;);
    //拿到注解对象
    NameConstraint nameAnnotation = nameField.getAnnotation(NameConstraint.class);
    AgeConstraint ageAnnotation = ageField.getAnnotation(AgeConstraint.class);

    minLength = nameAnnotation.minLength();
    maxLength = nameAnnotation.maxLength();
    minAge = ageAnnotation.minAge();
    maxAge = ageAnnotation.maxAge();
} catch (Exception e) {
    e.printStackTrace();
}
</code></pre><p><strong>注</strong>注解本身就为了定义一些东西，不影响代码运行。当我们使用xml文件配置的时候，是把代码解耦了。但是项目太大之后，就很难维护所以就使用注解。使得代码又耦合起来。就像Spring 有application的形式，也有注解的形式，定义说明。</p>
<h2 id="周一（9月16日）"><a href="#周一（9月16日）" class="headerlink" title="周一（9月16日）"></a>周一（9月16日）</h2><p>1.实现三为什么application.xml要</p>
<pre><code>&lt;aop:aspectj-autoproxy/&gt;
</code></pre><p>老师写错了- -</p>
<p>那么问题来了</p>
<pre><code>&lt;aop:aspectj-autoproxy/&gt;
</code></pre><p>怎么写javaConfig的注解？</p>
<pre><code>@EnableAspectJAutoProxy
</code></pre><h2 id="周二（9月17日）-1"><a href="#周二（9月17日）-1" class="headerlink" title="周二（9月17日）"></a>周二（9月17日）</h2><p>1.今天发现new String不能构造了，发现导错包了，这里有个包：</p>
<pre><code>import com.sun.org.apache.xpath.internal.operations.String;
</code></pre><p>当我复制new String进来的时候，会默认导入这个包，总结时候我TM自己去创建String对象的时候也会导这个包好奇怪。<br>导致String的构造方法用不了,当发现印象当中的方法用不了时候，一定要注意看导的包是否正常</p>
<p>2.@RequestMapping的源码</p>
<pre><code>@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Mapping
public @interface RequestMapping {
    String name() default &quot;&quot;;
    @AliasFor(&quot;path&quot;)
    String[] value() default {};
    @AliasFor(&quot;value&quot;)
    String[] path() default {};
    RequestMethod[] method() default {};
    String[] params() default {};
    String[] headers() default {};
    String[] consumes() default {};
    String[] produces() default {};
}
</code></pre><p>直接去找实现<br>去到RequestMappingHandlerMapping.class<br>找到：createRequestMappingInfo</p>
<pre><code>@Nullable
protected RequestMappingInfo getMappingForMethod(Method method, Class&lt;?&gt; handlerType) {
    RequestMappingInfo info = this.createRequestMappingInfo(method);
    if (info != null) {
        RequestMappingInfo typeInfo = this.createRequestMappingInfo(handlerType);
        if (typeInfo != null) {
            info = typeInfo.combine(info);
        }

        String prefix = this.getPathPrefix(handlerType);
        if (prefix != null) {
            info = RequestMappingInfo.paths(new String[]{prefix}).build().combine(info);
        }
    }

    return info;
}
</code></pre><p>应该是这里反射创建了RequestMapping对象，然后拿到@RequestMapping里面的值</p>
<pre><code>@Nullable
private RequestMappingInfo createRequestMappingInfo(AnnotatedElement element) {
    RequestMapping requestMapping = (RequestMapping)AnnotatedElementUtils.findMergedAnnotation(element, RequestMapping.class);
    RequestCondition&lt;?&gt; condition = element instanceof Class ? this.getCustomTypeCondition((Class)element) : this.getCustomMethodCondition((Method)element);
    return requestMapping != null ? this.createRequestMappingInfo(requestMapping, condition) : null;
}
</code></pre><p><strong>this.createRequestMappingInfo(requestMapping, condition)</strong></p>
<pre><code>protected RequestMappingInfo createRequestMappingInfo(RequestMapping requestMapping, @Nullable RequestCondition&lt;?&gt; customCondition) {
    Builder builder = RequestMappingInfo.paths(this.resolveEmbeddedValuesInPatterns(requestMapping.path())).methods(requestMapping.method()).params(requestMapping.params()).headers(requestMapping.headers()).consumes(requestMapping.consumes()).produces(requestMapping.produces()).mappingName(requestMapping.name());
    if (customCondition != null) {
        builder.customCondition(customCondition);
    }

    return builder.options(this.config).build();
}
</code></pre><p><strong>创建了一个builder，然后注解就能生效了</strong></p>
<p>3.设计模式总结完<br>（拉闸–下礼拜尽量写完）</p>
<h2 id="周三（9月18日）-1"><a href="#周三（9月18日）-1" class="headerlink" title="周三（9月18日）"></a>周三（9月18日）</h2><p>1.文件上传接收多个参数<br>可以通过接收多个参数就能接收，他已经给我们切好了</p>
<p>2.文件上传的相对路径<br>以后通过文件系统进行管理</p>
<p>3.前端传过来的参数都是以字符串的参数传过来的吗？而且传过来都是key=value&amp;key=value?<br>就算前端设置input type=date也是吗？</p>
<pre><code>&lt;input type=&quot;date&quot;&gt;
</code></pre><p>经过验证后端传过来的就是string 格式是1992-02-02</p>
<p>4.list能不能直接通过转换器在后端接收？—-<strong>根本走不到converter里面</strong><br>用List接收报错：</p>
<pre><code>Cannot generate variable name for non-typed Collection parameter type
</code></pre><p>然后使用ArrayList linkedList 接收拿到的都是空值，经过百般折腾，根本不可行，以后也不会用。那么就这样吧。</p>
<p>FormattingConversionServiceFactoryBean</p>
<pre><code>&lt;mvc:annotation-driven conversion-service=&quot;customConversionService&quot;/&gt;
&lt;!--    配置转换器--&gt;
    &lt;bean id=&quot;customConversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt;
        &lt;property name=&quot;converters&quot;&gt;
            &lt;set&gt;
                &lt;!-- 可以写多个转换器 --&gt;
                &lt;bean class=&quot;com.cskaoyan.converter.String2List&quot;/&gt;
                &lt;bean class=&quot;com.cskaoyan.converter.String2DateConverter&quot;/&gt;
            &lt;/set&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
</code></pre><p>网上查看了一些资料，确实没有发现转换list的例子</p>
<p>5.关于静态资源<br>因为设置了dispatcherServlet的url-pattern是/所以所有的静态资源都访问不到。这里有一个问题<br><a href="https://blog.csdn.net/crazylai1996/article/details/75142818" target="_blank" rel="external">静态资源访问困难问题</a><br>解决这个问题。<br>明天老师讲的方法更加牛皮</p>
<h2 id="周四（9月19日）-1"><a href="#周四（9月19日）-1" class="headerlink" title="周四（9月19日）"></a>周四（9月19日）</h2><p>1.rest风格的大致理解<br><a href="https://www.jianshu.com/p/c5c83872dad2" target="_blank" rel="external">https://www.jianshu.com/p/c5c83872dad2</a></p>
<p>2.interceptor的三个问题<br>a.三个方法中的handler对象是什么？<br>handler对象就是我们controller里面的@RequestMapping里面的那个方法，也就是说拦截器是知道要调用的是哪个方法的</p>
<p>b.拦截器是拦截所有还是可以设置拦截个别请求。<br>拦截所有请求，可以设置拦截特定请求，但是没有注解的形式写，可以通过javaConfig形式编写拦截器</p>
<p>c.通过流程发现，走完postHandler会走回到dispatchServlet那我们是否需要再控制dispatchServlet？<br>老师说不需要。</p>
<p>3.下午问题（拿到代码再说）<br>1.对于我们数据的bean，例如一些User是否需要使用Spring去注册？<br>仔细想想到底哪些bean需要我们去注册。当然是功能性的工具类，为了复用所以可以写成组件的形式。<br>而那些从数据库拿到的数据之类的，这些不是功能，而是数据。我们自己写的工具类，或者controller，service，repository之类的，需要复用，经常需要一个service里面需要用到好几个DAO的实例去调用方法，这时候还需要我们去复用自定义组件的功能。</p>
<p>2.对于自定义的异常处理器，我们能否可以像servlet一样，处理不同的自定义异常时候，不写成if。。。else的形式吗？写在不同的方法上面。<br>现在是这样的：</p>
<pre><code>@Component
public class CustomExceptionHandler implements HandlerExceptionResolver {
  @Override
  public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) {
    ModelAndView modelAndView = new ModelAndView();
    if (e instanceof CustomException){
        modelAndView.addObject(&quot;message&quot;,e.getMessage());
        modelAndView.setViewName(&quot;/WEB-INF/view/exception.jsp&quot;);
    }else if (e instanceof ParamException){
        modelAndView.addObject(&quot;message&quot;,e.getMessage());
        ParamException paramException = (ParamException) e;
        modelAndView.addObject(&quot;paramz&quot;,paramException.getParam());
        modelAndView.setViewName(&quot;/WEB-INF/view/param.jsp&quot;);
    }
    return modelAndView;
  }
}
</code></pre><p>答案是可以的，明天讲到。</p>
<p>3.原始前后端数据的传输格式是什么？<br>就是String类型的name = value 的形式，不是json 也不是xml</p>
<p>4.一个url对应多个不同的请求，是通过请求培新的不同来区分的，（POST,GET请求）那么能否通过其他的@RequestMapping来控制不同的参数呢？<br>可以通过不同的请求头可以，但是想通过传送不同的数据来确定进入不同的方法，这是不现实的。因为用户的数据不可靠，而且这是会变的。而请求的方法，请求头，请求接收类型，浏览器接收的类型，这些都是固定的，所以可以用来区分不同的请求。但是<strong>通过不同的数据来区分，不可能</strong></p>
<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><p>1.在WEB-INF下面创建目录，一定要在maven把target全删了，然后在再进行重新启动</p>
<p>2.配置静态文件时候，如果mapping写一样，只对第一个有效，并不是第二个覆盖第一个。不像map key相同会覆盖之前的值，这个就不是。就是写前面的才起作用，</p>
<pre><code>&lt;!--第二种，放在web根目录或者WEB-INF下  两个相同的mapping第一个有效，第二个无效--&gt;
&lt;mvc:resources mapping=&quot;/pic2/**&quot; location=&quot;/WEB-INF/jpg/&quot;/&gt;
&lt;mvc:resources mapping=&quot;/pic2/**&quot; location=&quot;/&quot;/&gt;
</code></pre><p>3.return “forward:/page/success.html”;<br>提交表单是post请求，跳转的时候是post请求，是不能直接去跳转页面的，<strong>错误代码405</strong>所以肯定会报错。请求页面（静态资源文件）就是get请求，<br>如果要成功必须return “redirect:/page/success.html”;从定向是GET，请求</p>
<h2 id="周五（9月20日）-1"><a href="#周五（9月20日）-1" class="headerlink" title="周五（9月20日）"></a>周五（9月20日）</h2><p>今天不够认真- -</p>
<h2 id="周六（9月21日）-1"><a href="#周六（9月21日）-1" class="headerlink" title="周六（9月21日）"></a>周六（9月21日）</h2><p>1.org.springframework.web.servlet.DispatcherServlet.noHandlerFound No mapping for OPTIONS<br>老师说的话真的应验了，我TM真的写成了：</p>
<p>@RestController(“/api/admin/“)<br>实际是：才能窄化请求<br>@RequestMapping(“/api/admin/“)<br>@RestController</p>
<p>2.解决跨域问题。<br>最主要的原因：之前项目需要用到Cookie，所以加了</p>
<pre><code>response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);
</code></pre><p>注解没有配置，不行</p>
<p>尝试一：加注解<br>//解决跨域失败<br>//在类上加：<br>@CrossOrigin(origins = “<a href="http://localhost:8080" target="_blank" rel="external">http://localhost:8080</a>“)</p>
<p>尝试二：直接在全局拦截器上加</p>
<pre><code>@Override
public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,
                            Exception ex) throws Exception {
    System.out.println(&quot;afterCompletion&quot;);
    //这三个头与跨域访问有关，如果不设置，则访问不成功
    //配置文件获取origin
    InputStream resourceAsStream = CustomInterceptor.class.getClassLoader().getResourceAsStream(&quot;main.properties&quot;);
    Properties properties = new Properties();
    properties.load(resourceAsStream);
    String origin = properties.getProperty(&quot;origin&quot;);

    response.addHeader(&quot;Access-Control-Allow-Origin&quot;, origin);
    response.addHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST,GET,OPTIONS,PUT,DELETE&quot;);
    response.addHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;x-requested-with,Authorization,Content-Type&quot;);
    response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);
}
</code></pre><p>都不行，报错：</p>
<pre><code>Response to preflight request doesn&apos;t pass access control check: It does not have HTTP ok status.
</code></pre><p>可能是因为之前的项目要加cookie，现在一直请求不到。<br>实际上的原因是：<strong>要给Option请求返回一个statusOk.他才会发一个get请求过来。</strong></p>
<p>尝试三：使用filter 因为之前使用的是filter，而不是拦截器。所以设置filter来试一下</p>
<pre><code>@Override
public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
    System.out.println(&quot;filter success&quot;);
    //这样就出问题了，我后面会说
    filterChain.doFilter(servletRequest, servletResponse);

    HttpServletResponse response = (HttpServletResponse) servletResponse;
    //这三个头与跨域访问有关，如果不设置，则访问不成功
    //配置文件获取origin
    InputStream resourceAsStream = CORSFilter.class.getClassLoader().getResourceAsStream(&quot;main.properties&quot;);
    Properties properties = new Properties();
    properties.load(resourceAsStream);
    String origin = properties.getProperty(&quot;origin&quot;);

    response.addHeader(&quot;Access-Control-Allow-Origin&quot;, origin);
    response.addHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST,GET,OPTIONS,PUT,DELETE&quot;);
    response.addHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;x-requested-with,Authorization,Content-Type&quot;);
    response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);
}
</code></pre><p>发现还是不行。报错还是：</p>
<pre><code>Response to preflight request doesn&apos;t pass access control check: It does not have HTTP ok status.
</code></pre><p>最终百度发现答案：</p>
<pre><code>https://majing.io/posts/10000010111185
</code></pre><p>需要再自己手动处理Options，dispatcherServlet不会帮你处理。所以你要自己处理。</p>
<p>两种：<br>1.自己再写拦截器</p>
<pre><code>public class CrosDomainAllowInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response,
                             Object handler) throws Exception {
        if(request.getMethod().equals(RequestMethod.OPTIONS.name())) {
            response.setStatus(HttpStatus.OK.value());
            return false;
        }
        return true;
    }
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response,
                           Object handler, ModelAndView modelAndView) throws Exception {
    }
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response,
                                Object handler, Exception ex) throws Exception {
    }
}
</code></pre><p>或者写一个handler专门处理option</p>
<pre><code>@RequestMapping(value = &quot;/*&quot;,method = RequestMethod.OPTIONS)
public ResponseEntity handleOptions(){
    return ResponseEntity.noContent();
}
</code></pre><p>数据是走通了，但是还是有问题：就算数据正确传给前端，数据格式也是前端可以接受的。也显示不了，显示这个</p>
<pre><code>No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource.
</code></pre><p>我很明确在filter里面我已经设置相应头了。但是没反应，<strong>我以为是Options请求没走到这个doFilter，在拦截Options后面我加了设置请求头，之后报错是重复设置了请求头。<br>打断点发现还是走到了</strong>就在快要崩溃的时候：<br><strong>我突然想起来网上写的是设置相应头要放在doFilter前面</strong>要写成这个样子。先设置相应头，再执行doFilter，居然奇迹般的可以了！</p>
<pre><code>response.addHeader(&quot;Access-Control-Allow-Origin&quot;, origin);
response.addHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST,GET,OPTIONS,PUT,DELETE&quot;);
response.addHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;x-requested-with,Authorization,Content-Type&quot;);
response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);
//再执行doFilter
filterChain.doFilter(servletRequest, servletResponse);
</code></pre><p>原因可能就在请求要带cookie上。他会发送两个Options请求，一个是为了发送Post请求的，一个是为了请求带Cookie的，肯定是有一个请求执行完servlet里面的方法后，就没有执行dofilter。所以就没设置好响应头。把设置相应头放前面就没问题了。</p>
<p><strong>搞完了发现一篇文章</strong>说注解解决跨域的配置的<br><a href="https://www.cnblogs.com/mmzs/p/9167743.html" target="_blank" rel="external">https://www.cnblogs.com/mmzs/p/9167743.html</a></p>
<p>3.mybatis 里面的sql语句不能有name 有name 取不出来</p>
<p>我用*取出全部代替了。<br>但是name设置值却可以设置，有点奇怪。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/14/Java总结（十二）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王邸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路要坚持">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/14/Java总结（十二）/" itemprop="url">Java总结（十二）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-14T21:56:43+08:00">
                2019-09-14
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/09/14/Java总结（十二）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/09/14/Java总结（十二）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2019/09/14/Java总结（十二）/" class="leancloud_visitors" data-flag-title="Java总结（十二）">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这周开始讲Spring了，讲Spring都是很多没有见过的东西，很多东西都是配置的，目前还不需要懂底层的实现，需要的是知道如何操作，特别是maven。当然Spring也很重要，需要多思考。今天是2019年9月13日星期五，中秋节，在武汉，去了一趟光谷，浏览了一圈武大。现在的年轻人都不行呀，烈日下骑单车就要中暑了。早早地回来，就确定把这周总结写了，虽然只有四天的东西，但是感觉学了好久了，因为东西很多，就好像刚开始学JavaEE一样，必须要总结，牢记于心！上个礼拜六上午开了一个头，这里一起总结</p>
<h2 id="星期一（0909）"><a href="#星期一（0909）" class="headerlink" title="星期一（0909）"></a>星期一（0909）</h2><h3 id="maven-（-‘meɪvn-）"><a href="#maven-（-‘meɪvn-）" class="headerlink" title="maven （[‘meɪvn]）"></a>maven （[‘meɪvn]）</h3><p>Maven是Apache下的一个纯java开发的开源项目，它是一个项目管理构建工具，使用maven对java项目进行构建、依赖管理。当前使用Maven的项目在持续增长。<br>Maven主要有两个功能（必须要知道）：</p>
<pre><code>1、项目构建
2、依赖管理(重点)
</code></pre><h3 id="web项目的基础"><a href="#web项目的基础" class="headerlink" title="web项目的基础"></a>web项目的基础</h3><p>这里介绍一些web项目的基础内容，以idea为做项目的编辑器，说一些web项目的内容<br>1.idea 可以给文件夹设置这五种文件夹的类型：</p>
<pre><code>Sources          (存放编写的Java源文件)
Tests           （存放测试的文件）
Resources        (存放一些静态文件)
Test Resources  （存放一些测试的源文件）
Excluded        （项目输出的文件类型）
</code></pre><p>这里有两个注意的点：<br>a.如何设置,一般来说idea在创建项目会自动给你设置，但是你可以自己设置：<br>    1）在左边树形文件夹中右键点击一个文件夹，在菜单中有“Mark Directory as”可以选择不同的文件夹<br>    2）在module文件夹按F4，或者右键菜单选择open module setting,也可设置</p>
<p>b.项目文件夹的名称，可以不和这些名称一样，比如Sources在idea里面是src，Exculded在maven项目中是target文件夹，在webapp项目中是out文件夹，这些都是在创建项目的时候idea已经设置好了，记住他们层级关系，以及每个文件夹意义就好。</p>
<p>2.project Structure<br>在module文件夹按F4，或者右键菜单选择open module setting,打开的菜单栏：<br>Project setting</p>
<pre><code>Project(项目的一些配置SDK，项目名字等等)
Modules（模块的一些配置，文件夹类型，依赖导入，输出路径等等）
Libraries（一些已经引用的库文件（依赖）会显示在这里）
Facets（表示这个module有什么特征，比如 Web，Spring和Hibernate等）
Artifacts（可以直接运行的web应用，生成的东西）
</code></pre><p>Platform Settings</p>
<pre><code>SDKs
Global Libraries
</code></pre><p>项目这些配置先知道怎么使用，之后在去思考他们所表示的东西。</p>
<p>3.src 和 resource目录下的文件编译完成后都会放在classes文件夹的目录下，如果他们的文件名相同，编译完将放在同一个文件夹下。</p>
<h3 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h3><p>项目构建是一个项目从编写源代码到编译、测试、打包、部署、运行的过程<br><strong>传统的构建过程如下：</strong></p>
<pre><code>1）在IDE 中创建一个java web工程
2）在工程中编写源代码及配置文件等(配置环境 导包)
3）对源代码进行编译，java文件编译成class文件
4）执行Junit单元测试
5）将工程打成war包部署至tomcat运行
</code></pre><p><strong>maven项目构建过程</strong><br>maven将项目构建的过程进行标准化，每个阶段使用一个命令完成，下图展示了构建过程的一些阶段，后面章节详细介绍每个阶段，这里先大概了解下：<br>target：</p>
<pre><code>清理-&gt;编译-&gt;测试-&gt;报告-&gt;打包-&gt;部署
</code></pre><p>上图中部分阶段对应命令如下：</p>
<pre><code>清理阶段对应maven的命令是clean，清理输出的class文件
编译阶段对应maven的命令是compile，将java代码编译成class文件。
打包阶段对应maven的命令是package，java工程可以打成jar包，web包可以打成war包
</code></pre><p>maven工程构建的优点：</p>
<pre><code>1、一个命令完成构建、运行，方便快捷。
2、maven对每个构建阶段进行规范，非常有利于大型团队协作开发。
</code></pre><h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p>什么是依赖？一个java项目可能要使用一些第三方的jar包才可以运行，那么我们说这个java项目依赖了这些第三方的jar包。<br>什么是依赖管理？就是对项目所有依赖的jar包进行规范化管理。<br><strong>传统项目的依赖管理</strong><br>传统的项目工程要管理所依赖的jar包完全靠人工进行，程序员从网上下载jar包添加到项目工程中，程序员手工将Hibernate、struts2、spring的jar添加到工程中的WEB-INF/lib目录下。<br>手工拷贝jar包添加到工程中的问题是：</p>
<pre><code>1、没有对jar包的版本统一管理，容易导致版本冲突（版本需一致）。
2、从网上找jar包非常不方便，有些jar找不到。
3、jar包添加到工程中导致工程过大。
</code></pre><p><strong>maven项目的依赖管理</strong><br>maven项目管理所依赖的jar包不需要手动向工程添加jar包，只需要在pom.xml（maven工程的配置文件）添加jar包的坐标，自动从maven仓库中下载jar包、运行<br>使用maven依赖管理添加jar的好处：</p>
<pre><code>1、通过pom.xml文件对jar包的版本进行统一管理，可避免版本冲突。
2、maven团队维护了一个非常全的maven仓库，里边包括了当前使用的jar包，maven工程可以自动从maven仓库下载jar包，非常方便。
</code></pre><p>吹了半天，现在开始使用maven吧！</p>
<h3 id="开始使用maven！"><a href="#开始使用maven！" class="headerlink" title="开始使用maven！"></a>开始使用maven！</h3><p><strong>下载</strong><br>从该网站 <a href="http://maven.apache.org/download.cgi" target="_blank" rel="external">官方地址</a> 下载，目前使用3.6.1。因为最新版的使用idea会有问题。</p>
<p><strong>解压</strong><br>将maven解压到一个不含有中文和空格的目录中。<br>目录简介</p>
<pre><code>bin目录 mvn.bat （以run方式运行项目）、 mvnDebug.bat（以debug方式运行项目 ）
boot目录 maven运行需要类加载器
conf目录 settings.xml 整个maven工具核心配置文件
lib目录 maven运行依赖jar包
</code></pre><p><strong>环境变量配置</strong><br>MAVEN_HOME:包含bin文件夹的目录<br>Path：%MAVEN_HOME%/bin<br>输入mvn –v的时候出现版本号，意味着安装完成</p>
<p><strong>配置maven</strong><br>在maven的配置文件中修改一些内容，路径：apache-maven-3.6.1\conf\settings.xml<br>1.添加本地仓库<br>在settings标签下添加如下标签，表示本地仓库地址。</p>
<pre><code>&lt;localRepository&gt;H:\maven\repository&lt;/localRepository&gt;
</code></pre><p>如果不设置默认的地址为：</p>
<pre><code>C:\Users\lenovo\.m2\repository
</code></pre><p>2.添加远程仓库<br>在mirrors标签下添加标签：</p>
<pre><code>&lt;mirror&gt;
  &lt;id&gt;nexus-aliyun&lt;/id&gt;
  &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;
  &lt;name&gt;Nexus aliyun&lt;/name&gt;
  &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;
&lt;/mirror&gt;
</code></pre><p>一般设置阿里的远程仓库，如果阿里没有，就会去中国区的官方仓库下载，为了安全官方仓库下载很慢就对了。</p>
<p>3.解决jdk1.5问题<br>在 profiles 标签下面添加：</p>
<pre><code>&lt;profile&gt;
  &lt;id&gt;jdk-1.8&lt;/id&gt;
  &lt;activation&gt;
    &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;
    &lt;jdk&gt;1.8&lt;/jdk&gt;
  &lt;/activation&gt;
  &lt;properties&gt;
    &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
    &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
    &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt;
  &lt;/properties&gt;
&lt;/profile&gt;
</code></pre><h3 id="Maven的工程结构"><a href="#Maven的工程结构" class="headerlink" title="Maven的工程结构"></a>Maven的工程结构</h3><p>Project（必须掌握）</p>
<pre><code>|-src
|   |-main
|   |  |-java        —— 存放项目的.java文件
|   |  |-resources   —— 存放项目资源文件，如spring, hibernate配置文件
|   |  |-webapp   —— web项目的webroot文件夹，存放网页资源 如jsp等
|   |-test
|   |    |-java        ——存放所有测试.java文件，如JUnit测试类
|   |    |-resources   —— 测试资源文件
|-target             —— 目标文件输出位置例如.class、.jar、.war文件(会生成)
|-pom.xml           ——maven项目核心配置文件
</code></pre><p>我们就发现了一个有趣的现象，这个project的文件是不是和之前我说设置文件夹类型是很类似的sources,resources,test 等等</p>
<h3 id="Maven的工程创建"><a href="#Maven的工程创建" class="headerlink" title="Maven的工程创建"></a>Maven的工程创建</h3><p>一般手动创建maven工程很少，都是idea给我们创建好的，就说一下配置pom.xml文件</p>
<pre><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  &lt;!-- 版本：4.0.0 --&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;!-- 组织名称：暂时使用 组织名称+项目名称 作为组织名称 --&gt;
  &lt;!-- 组织名称：实际名称 按照访问路径规范设置，通常以功能作为名称：eg: junit spring --&gt;
  &lt;groupId&gt;com.cskaoyan.maven&lt;/groupId&gt;
  &lt;!-- 项目名称 --&gt;
  &lt;artifactId&gt;HelloWorld&lt;/artifactId&gt;
  &lt;!-- 当前项目版本号：同一个项目开发过程中可以发布多个版本，此处标示0.0.1版 --&gt;
  &lt;!-- 当前项目版本号：每个工程发布后可以发布多个版本，依赖时调取不同的版本，使用不同的版本号 --&gt;
  &lt;version&gt;0.0.1&lt;/version&gt;
  &lt;!-- 名称：可省略，如果省略，artifactId就是name--&gt;
  &lt;name&gt;Hello&lt;/name&gt;

  &lt;!-- 可以写一些配置，一般配置的是版本号 --&gt;
  &lt;properties&gt;
      &lt;spring.versionw&gt;5.1.9.RELEASE&lt;/spring.versionw&gt;
  &lt;/properties&gt;
  &lt;!-- 依赖关系 --&gt;
  &lt;dependencies&gt;
    &lt;!-- 依赖设置 --&gt;
    &lt;dependency&gt;
      &lt;!-- 依赖组织名称 --&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;!-- 依赖项目名称 --&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;!-- 依赖版本名称 --&gt;
      &lt;version&gt;4.9&lt;/version&gt;
      &lt;!-- 依赖范围：test包下依赖该设置 --&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;!--通过context去导入5+1--&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
      &lt;version&gt;${spring.versionw}&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre><p><strong>注意事项</strong><br>1.Properties标签，引入其他参数 供其他值使用 表达式为${key}</p>
<h3 id="Maven命令-重点"><a href="#Maven命令-重点" class="headerlink" title="Maven命令(重点)"></a>Maven命令(重点)</h3><p>必须要知道每个指令都进行了哪些操作<br><strong>Clean：target文件夹</strong><br>执行 mvn clean命令<br>执行完毕后，会将target目录删除。</p>
<p><strong>compile：java和resources文件夹</strong><br>执行 mvn compile命令，完成编译操作<br>（默认编译src/main/java，同时会把src/resources下的资源放在编译的输出目录target/classes）<br>执行完毕后，会生成target目录，该目录中存放了编译后的字节码文件。</p>
<p><strong>test：</strong><br>执行 mvn test命令，完成单元测试操作，src\test\java所有包含@Test注解的方法，如果单元测试执行失败不会执行后续的操作，执行失败原因：类名，包含Test<br>执行完毕后，会在target目录中生成两个文件夹： surefire-reports（测试报告）、test-classes（测试的字节码文件，包括test/resources的资源文件）</p>
<p><strong>package：jar war pom</strong><br>执行 mvn package命令，完成打包操作（在打包之前会执行mvn test）执行完毕后，会在target目录中生成一个文件，该文件可能是jar、war、pom</p>
<pre><code>默认是：jar包
war包：是我们web项目的包，配置文件修改打包类型&lt;packaging&gt;war&lt;/packaging&gt;,idea会自动把我们module加入到Facts里面
pom包：出现在父子工程中，接下来会简单介绍
</code></pre><p><strong>install</strong><br>mvn install<br>将我们的项目安装到本地仓库</p>
<p><strong>注意事项</strong><br>1.执行：mvn clean 不会执行其他的命令，但其他几个compile,test,package,install。执行后一个指令会先执行前一个指令。例如：<br>如果我们执行的是：mvn install:<br>他会先执行:<br>mvn compile<br>mvn test<br>mvn package<br>之后再执行：<br>mav install;<br>2.关于打包，如果打包的是war包，必须在webapp里面新建WEB-INF,并有web.xml配置文件，才能打包成功。否则将会报错</p>
<h3 id="关于依赖的作用范围："><a href="#关于依赖的作用范围：" class="headerlink" title="关于依赖的作用范围："></a>关于依赖的作用范围：</h3><p>在我们在pom.xml编写依赖的时候，有时候需要加入依赖的作用范围scope例如：</p>
<pre><code>&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;junit&lt;/groupId&gt;
    &lt;artifactId&gt;junit&lt;/artifactId&gt;
    &lt;version&gt;4.12&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
  &lt;/dependency&gt;
&lt;dependencies&gt;
</code></pre><p><strong>compile</strong><br>：编译范围，指A在编译时依赖B，此范围为<strong>默认依赖范围</strong>。编译范围的依赖会用在编译、测试、运行，由于运行时需要所以编译范围的依赖会被打包。</p>
<p><strong>provided</strong><br>：provided依赖在编译和测试时需要，在<strong>运行时不需要</strong>，比如：<strong>servlet api</strong>被tomcat容器提供。provided依赖只有在当JDK或者一个容器已提供该依赖之后才能使用（否则会报错），</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
    &lt;version&gt;3.1.0&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;&lt;!--表示依赖范围，运行不需要--&gt;
&lt;/dependency&gt;
</code></pre><p><strong>runtime</strong><br>：runtime依赖在运行和测试系统的时候需要，但在编译的时候不需要。比如：jdbc的驱动包。由于运行时需要所以runtime范围的依赖会被打包。</p>
<p><strong>test</strong><br>：test范围依赖 在编译和运行时都不需要，它们只有在测试编译和测试运行阶段可用，比如：junit。由于运行时不需要所以test范围依赖不会被打包。就是一开始的情况</p>
<h3 id="IDEA使用maven"><a href="#IDEA使用maven" class="headerlink" title="IDEA使用maven"></a>IDEA使用maven</h3><p>idea默认会给我们配置一个maven，不过强烈建议使用自己的maven，然后在idea里面配置，这里需要配置两个地方:<br>1.进入settings -&gt; build,execution,deployment -&gt; build tools -&gt; maven中配置：<br>    maven home directory<br>    user settings file<br>    Local repository<br>名字已经表示意思，一定要自己配！不然idea就会找到默认的地方去下载，这样C盘就会爆炸哦<br>2.点击左上角的工具栏： file -&gt; other settings -&gt; other settings for new project:<br>修改的内容和1一样，把这两个地方都修改成自己下载的maven即可。再次强调：<strong>不要用idea给你配的maven</strong></p>
<h3 id="Maven聚合工程（父子工程-并不推荐使用）"><a href="#Maven聚合工程（父子工程-并不推荐使用）" class="headerlink" title="Maven聚合工程（父子工程,并不推荐使用）"></a>Maven聚合工程（父子工程,并不推荐使用）</h3><p>1.建立一个父module<br>2.鼠标点击一下父module使他选中，然后新建一个module就会新建一个module，上面会多出两行</p>
<pre><code>Add as module to
Parent
</code></pre><p>3.可以看到子项目的pom文件，有parent节点。<br>4.同时父项目的module里 有新增 module节点</p>
<h3 id="聚合工程的作用"><a href="#聚合工程的作用" class="headerlink" title="聚合工程的作用"></a>聚合工程的作用</h3><p>不希望在父工程里编码。具体的代码应该拆分到子工程。父工程的主要职责是把不同的子工程聚合起来，合为一个工程。<br>父工程里集中配置多个子模块里通用的jar包。<br>在父工程的pom.xml中抽取一些重复的配置的，比如：锁定jar包的版本、设置编译版本等。父工程定义的jar包子工程可以引用。</p>
<h3 id="关于maven常见问题："><a href="#关于maven常见问题：" class="headerlink" title="关于maven常见问题："></a>关于maven常见问题：</h3><p><strong>网络问题</strong><br>一定要在网络良好的情况下使用：如果maven的依赖未下载成功，去删除掉对应的依赖，（会产生lastupdated文件）重新下载。</p>
<p><strong>寻找依赖问题</strong><br>如何去找对应的依赖？通过groupId和artifactId，百度进入maven repository去寻找，里面会有给maven的标签直接复制</p>
<p><strong>项目导入问题</strong><br>当你导入别人的maven项目的时候，一定要注意maven的配置是不是自己的配置文件，查看上面idea配置maven。因为别人的maven配置文件可能不同，导入别人的maven项目可能会加载别人的配置文件，当idea找不到对应的maven的时候，会默认启用idea自己的maven,然后他就会去官方仓库下载包到本地仓库，这样C盘就爆炸了。导入别人项目之前，一定要检查配置文件哦。</p>
<p><strong>pom.xml图标问题</strong><br>如果pom.xml的图标不是显示的是maven项目的图标，每个不同主题图标不一样，默认的maven项目的图标是一个M，这时候需要设置一下<br>右键点击pom.xml  -&gt; Add as Maven Project<br>网上找到另一个方法：<br>1.右键点击我的项目，点击Add Framework Support，<br>2.弹出以下页面，若没有maven，一直下拉，若还没有，检查你的项目中是否已有pom.xml文件，勾选Maven，点击Ok<br>3.pom.xml成功创建(已转变成maven项目)，可以添加你的依赖了</p>
<h2 id="星期二（0910）"><a href="#星期二（0910）" class="headerlink" title="星期二（0910）"></a>星期二（0910）</h2><p>为了更好的理解Spring，今天讲了几种设计模式，最后讲了下动态代理，动态代理有两种一种是jdk实现的，一种是spring实现的。我打算这里先讲一次，到后面讲到Spring再讲一次，再两者进行比较。言归正传，在说设计模式之前，我觉得要先提一下<strong>设计模式的五个原则</strong></p>
<h3 id="设计模式的五个原则（solid）"><a href="#设计模式的五个原则（solid）" class="headerlink" title="设计模式的五个原则（solid）"></a>设计模式的五个原则（solid）</h3><p>S - 单一职责原则：<br>O - 开放封闭原则：<br>L - Liskov原则：<br>I - 接口隔离原则：<br>D – 依赖倒置原则：</p>
<p><strong>单一职责原则</strong>：<br>一个模块负责一个功能<br>一个类负责一个业务<br>一个API去实现一个功能<br>不同的功能分隔开。一个类如果需要变化，最好只能有一个维度的原因。</p>
<p><strong>开放封闭原则</strong>：<br>对什么开放：对扩展开放</p>
<p>扩展：新功能—》可以（提倡）去增加代码（增加一个类）<br>项目不断迭代（增加新的需求）</p>
<p>对什么封闭：对<strong>修改封闭</strong><br>不建议去修改代码 （尤其是一些底层的API）<br>牵一发而动全身。<br>Deprecate （不建议使用了，废弃掉了）</p>
<p><strong> L - Liskov原则</strong><br>李氏替换原则：任何一个基类可以出现的地方，子类一定可以出现，类似于多态性<br>//写法1</p>
<pre><code>UserDao dao = new UserDaoImpl2();
dao.findUserByid();
dao.findUserByName();
</code></pre><p>//写法2</p>
<pre><code>UserDaoImpl2 dao = new UserDaoImpl2 ();
dao.findUserByid();
dao.findUserByName();
</code></pre><p><strong>I - 接口隔离原则</strong>：</p>
<p>接口：interface （功能）<br>隔离：分开<br>不同功能的接口，最好放在不同的interface里。<br>一个接口里最好不要集成太多的功能，<br>否则用户去实现该接口会比较麻烦。</p>
<p><strong> D – 依赖倒置原则：（Spring  DI  IOC APSPECTJ）</strong><br>依赖，具体依赖于抽象，而非抽象依赖于具体。<br>先去设计抽象的DAO  （接口）</p>
<h3 id="常见的设计模式"><a href="#常见的设计模式" class="headerlink" title="常见的设计模式"></a>常见的设计模式</h3><h3 id="单例模式（Singleton-Pattern）"><a href="#单例模式（Singleton-Pattern）" class="headerlink" title="单例模式（Singleton Pattern）"></a>单例模式（Singleton Pattern）</h3><p><strong>概念</strong><br>何为单例？单一实例。全局只有一个。<br>哪些场合需要用到单例？<br>Servlet<br>ServletContext</p>
<p><strong>特点（必备！）</strong><br>1、单例类只能有一个实例。（自己创建对象）<br>2、单例类必须自己创建自己的唯一实例。（构造方法私有固定）<br>3、单例类必须给所有其他对象提供这一实例。</p>
<h3 id="单例的种类（六种，先介绍四种，之后介绍设计模式时候再全部进行罗列）"><a href="#单例的种类（六种，先介绍四种，之后介绍设计模式时候再全部进行罗列）" class="headerlink" title="单例的种类（六种，先介绍四种，之后介绍设计模式时候再全部进行罗列）"></a>单例的种类（六种，先介绍四种，之后介绍设计模式时候再全部进行罗列）</h3><p>懒加载（懒汉模式）<br>立即加载（饿汉模式）</p>
<p><strong>//线程不安全的懒加载 （懒汉模式）</strong></p>
<pre><code>public class Singleton1 {
  //1、单例类只能有一个实例。
  static Singleton1 singleton1;
  //2、单例类必须自己创建自己的唯一实例。→构造方法私有
  private Singleton1(){}
  //3、单例类必须给所有其他对象提供这一实例。
  public static Singleton1 getSingleton(){
    if (singleton1 == null) {
        singleton1 = new Singleton1();
    }
    return singleton1;
  }
}
</code></pre><p>线程不安全，所以很可能会出现同时进入<br>if(singleton1 == null) {<br>然后创建多个实例，而不是单例模式。</p>
<p><strong>//线程安全的懒加载</strong></p>
<pre><code>public class Singleton2 {
  //1、单例类只能有一个实例。
  static Singleton2 singleton2;
  //2、单例类必须自己创建自己的唯一实例。→构造方法私有
  private Singleton2(){}
  //3、单例类必须给所有其他对象提供这一实例。
  public synchronized static Singleton2 getSingleton(){
    if (singleton2 == null) {
        singleton2 = new Singleton2();
    }
    return singleton2;
  }
}
</code></pre><p>优点：多线程下依然是单例<br>缺点：加锁会影响执行效率。</p>
<p><strong>//线程安全的立即加载（恶汉模式）</strong></p>
<pre><code>public class Singleton3 {
  //1、单例类只能有一个实例。
  static Singleton3 singleton3 = new Singleton3();
  /*static {
      singleton3 = new Singleton3();
  }*/
  //2、单例类必须自己创建自己的唯一实例。→构造方法私有
  private Singleton3(){}
  //3、单例类必须给所有其他对象提供这一实例。
  public static Singleton3 getSingleton(){
    return singleton3;
  }
}
</code></pre><p>不使用锁，让类在加载的时候，通过隐式初始化，或者静态代码块自行实例化。</p>
<p><strong>//线程安全的懒加载（内部类，实现懒加载）</strong></p>
<pre><code>public class Singleton4 {
  //2、单例类必须自己创建自己的唯一实例。→构造方法私有
  private Singleton4(){}
  //3、单例类必须给所有其他对象提供这一实例。
  public static Singleton4 getSingleton(){
    System.out.println(&quot;outer getSingleton&quot;);
    return Inner.getInstance();
  }
  //静态内部类
  static class Inner{
    //1、单例类只能有一个实例。
    static Singleton4 singleton4 = new Singleton4();
    /*static {
      singleton4 = new Singleton4();
      System.out.println(&quot;inner static&quot;);
    }*/
    public static Singleton4 getInstance() {
      System.out.println(&quot;inner getInstance&quot;);
      return singleton4;
    }
  }
}
</code></pre><h3 id="工厂模式（Factory-Pattern）"><a href="#工厂模式（Factory-Pattern）" class="headerlink" title="工厂模式（Factory Pattern）"></a>工厂模式（Factory Pattern）</h3><p>生成产品的工厂，生产对象<br>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口（方法）来指向新创建的对象</p>
<h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h3><p>通过给定的参数的不同，返回不同的实例。<br>举例：我们想生成不同的动物，写一个动物类，让其他具体的动物来继承</p>
<pre><code>public class Animal {}
//继承动物类
public class Cat extends Animal {}
public class Dog extends Animal {}
//简单工厂
public class AnimalFactory {
  public Animal createAnimal(String animalName){
    Animal animal = null;
    /*if (&quot;dog&quot;.equals(animalName)){
        animal =  new Dog();
    }else (&quot;cat&quot;.equals(animalName)){
        animal = new Cat();
    }*/
    switch (animalName){
      case &quot;dog&quot; :
          animal = new Dog();
          break;
    }
    return animal;
  }
}
</code></pre><p>当我们去新增新的实例的时候，需要修改代码，要么添加if，要么添加switch（和开闭原则有些许出入）这里，让我想起了之前做第一个项目的时候，servlet也是这样，写了好多好多个接口用一个servlet来接收，感觉好像不太友好。</p>
<h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p>工厂方法模式，创建一个<strong>工厂接口</strong>和创建<strong>多个工厂实现类</strong>完全遵从开闭原则，不对任何已有代码进行修改，直接新增一个类，去实现工厂的接口。<br>举例：继续以小动物为例子：<br>动物类：</p>
<pre><code>Animal.java
public class Animal {}
</code></pre><p>继承动物类：</p>
<pre><code>Cat.java
public class Cat extends Animal {}
Dog.java
public class Dog extends Animal {}
</code></pre><p>这时我们要写一个工厂的接口：</p>
<pre><code>AnimalFactory.java
public interface AnimalFactory{
  Animal create();
}
</code></pre><p>然后为每个动物建一个工厂：（这样建工厂的开销有点大）</p>
<pre><code>CatFactory.java
public CatFactory implements AnimalFactory{
  @Override
  public Animal create(){
    return new Cat();
  }
}
DogFactory.java
public DogFactory implements AnimalFactory{
  @Override
  public Animal create(){
    return new Dog();
  }
}
</code></pre><p>这样满足了开闭原则，同时带来的一个缺点就是，每个实现类，需要一个建造的工厂，感觉开销有点大。虽然说目前遇到的很多别人写的依赖，还有jdk源码里面，感觉大都是用的这种设计模式，可能还是我见识比较少罢了。</p>
<h3 id="建造者Builder模式"><a href="#建造者Builder模式" class="headerlink" title="建造者Builder模式"></a>建造者Builder模式</h3><p>侧重点：参数的设置。<br>以建造一个人为例，当我们new了一个human对象的时候，我们的head对象，body对象，arm对象，foot对象，都已经创建好了。我们需要做的就是去set这些对象的参数：比如head的IQ,EQ多少，body的各个功能，arm的宽度，foot的脚长等等，<br>代码说明：</p>
<pre><code>public class Human {
  //我们创好human的时候，就已经把各个部分创好了
  Head head = new Head();
  Arm arm = new Arm();
  Leg leg = new Leg();
  int height;

  //对各部件的操作
  public Head getHead() {return head;}
  public void setHead(Head head) {this.head = head;}
  public Arm getArm() {return arm;}
  public void setArm(Arm arm) {this.arm = arm;}
  public Leg getLeg() {return leg;}
  public void setLeg(Leg leg) {this.leg = leg;}
  public int getHeight() {return height;}
  public void setHeight(int height) {this.height = height;}
}
各部件的对象：
public class Arm {
  int length;
  public int getLength() {return length;}
  public void setLength(int length) {this.length = length;}
}
public class Head {
  int iq;
  int eq;
  public int getIq() {return iq;}
  public void setIq(int iq) {this.iq = iq;}
  public int getEq() {return eq;}
  public void setEq(int eq) {this.eq = eq;}
}
。。。。等等
</code></pre><p>最后引入我们的builder类：</p>
<pre><code>public class HumanBuilder {

  //创建一个人
  Human human = new Human();

  //建造者对这些参数进行操作！
  public void setHeight(){human.setHeight(180);}
  public void setHeadIq(int iq){human.getHead().setIq(iq);}
  public void setHeadEq(int eq){ human.getHead().setEq(eq); }
  public void setArmLength(int length){human.getArm().setLength(length);}
  public void setLegLength(int length){human.getLeg().setLength(length);}
  //暴露方法调用
  public Human build(){ return human; }
}
</code></pre><h3 id="代理（重点！！！）"><a href="#代理（重点！！！）" class="headerlink" title="代理（重点！！！）"></a>代理（重点！！！）</h3><p><strong>代理（重点！！！）</strong><br><strong>代理（重点！！！）</strong><br><strong>代理（重点！！！）</strong><br>先要搞清楚：什么是<strong>代理对象</strong>，什么是<strong>委托类对象</strong><br>以租房为例子：<br>代理对象：中介<br>代理类 负责为委托类预处理消息，过滤消息并转发消息，以及进行消息被委托类执行后的后续处理。<br>被代理对象（委托类对象）：业主。<br>可以理解为：<strong>代理类不仅可以和委托类做相同的事情，而且对委托类的事情可以得到增强</strong></p>
<p>包装对象 和 被包装对象 能不能看成是一种代理？ 可以<br>代理对象：包装对象<br>被代理对象：被包装对象。</p>
<p><strong>静态代理</strong><br>生成一个中间类（继承）实现委托类的功能<br>举例：租房问题<br>房东直租：</p>
<pre><code>public class HouseOwner {
  public boolean rentHouse(int money){
    System.out.println(&quot;房东收到的钱为：&quot; + money);
    if (money &gt;= 2000){
        return true;
    }
    return false;
  }
}
</code></pre><p>中介继承了房东，去租房，</p>
<pre><code>public class HouseProxy extends HouseOwner{
    //HouseOwner houseOwner = new HouseOwner();
    @Override
    public boolean rentHouse(int money){
        System.out.println(&quot;中介收到的钱为：&quot; + money);
</code></pre><p>//调用父类房东的方法时，中间可以自己拿走500块！</p>
<pre><code>        boolean b = super.rentHouse(money - 500);
        System.out.println(&quot;房东决定租房子吗：&quot; + b);
        return b;
    }
}
</code></pre><p>单元测试测试两种情况，无中介和有中介</p>
<pre><code>public class MainTest {
    @Test
    public void mytest(){
        HouseOwner houseOwner = new HouseOwner();
        boolean b = houseOwner.rentHouse(2000);
    }
    @Test
    public void mytest2(){
        HouseProxy houseProxy = new HouseProxy();
        boolean b = houseProxy.rentHouse(2000);
        System.out.println(b);
    }
}
</code></pre><p><strong>动态代理</strong><br>动态代理它可以直接给某一个目标对象生成一个<strong>代理对象</strong>，而不需要<strong>代理类</strong>存在。<br>Java动态代理<br>Java 动态代理机制的出现，使得 Java 开发人员不用手工编写代理类，只要简单地指定一组接口及委托类对象，便能动态地获得代理类。</p>
<h3 id="动态代理的实现"><a href="#动态代理的实现" class="headerlink" title="动态代理的实现"></a>动态代理的实现</h3><p>1.jdk提供一个Proxy类可以 实现<strong>接口类</strong>的对象直接生成代理对象。（被代理类要有一个接口的实现）<br>2.cglib  (spring里再学习)</p>
<h3 id="动态代理的作用"><a href="#动态代理的作用" class="headerlink" title="动态代理的作用"></a>动态代理的作用</h3><p>可以不生成代理类，直接就可以通过委托类不仅实现委托类的方法，而且可以在实现委托类之前和之后都可以做一些其他的操作。例如：事务<br>两个动态代理的区别是jdk动态代理需要实现的是使用接口，而cglib不需要，这里后面会讲到。</p>
<h3 id="jdk代理实现"><a href="#jdk代理实现" class="headerlink" title="jdk代理实现"></a>jdk代理实现</h3><p>因为使用的是接口，所以委托类自身也要需要接口来实现<br>租房的接口：</p>
<pre><code>public interface RentHouse {
  public boolean rentHouse(int money);
  public boolean rentHouse2(int money);
}
</code></pre><p>委托类的实现：</p>
<pre><code>public class HouseOwner implements RentHouse{
  public boolean rentHouse(int money){
    System.out.println(&quot;房东收到的钱为：&quot; + money);
    if (money &gt;= 2000){
      return true;
    }
    return false;
  }
  public boolean rentHouse2(int money){
    System.out.println(&quot;房东收到的钱为：&quot; + money);
    if (money &gt;= 2000){
      return true;
    }
    return false;
  }
}
</code></pre><p>//代理对象生成：（使用到jdk自带的Proxy类）我们在单元测试中使用</p>
<pre><code>@Test
public void mytest(){
  RentHouse houseOwner = new HouseOwner();
  //参数1 委托类类加载器
  //参数2 委托类的接口
  //参数3 响应处理器
  RentHouse houseProxy = (RentHouse) Proxy.newProxyInstance(houseOwner.getClass().getClassLoader(), houseOwner.getClass().getInterfaces(),
        new InvocationHandler() {
    //参数1：代理对象
    //参数2：代理对象正在执行的方法
    //参数3：代理对象正在执行的方法所对应的参数
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
      if (&quot;toString&quot;.equals(method.getName())){
          return null;
      }
      if (&quot;rentHouse&quot;.equals(method.getName())){
          args[0] = (int)args[0] - 500;
      }
      System.out.println(method.getName() + &quot;委托类执行方法前&quot;);
      //这一行代码相当于去执行委托类的方法
      //参数1：委托类的实例（而不是代理类的实例，不要写成proxy）
      //参数2：想要委托类去执行方法的参数（可以是对args处理后的参数）
      Object invoke = method.invoke(houseOwner, args);
      System.out.println(&quot;委托类执行方法后&quot;);
      return invoke;
    }
  });

  //通过代理对象去调用方法
  boolean b = houseProxy.rentHouse(2000);
  System.out.println(b);
  boolean b2 = houseProxy.rentHouse2(2500);
  System.out.println(b2);
}
</code></pre><p><strong>注意事项</strong><br>1.在Porxy中的InnovationHandler的匿名内部类中，反射调用方法时：</p>
<pre><code>Object invoke = method.invoke(houseOwner, args);
</code></pre><p>里面的参数是<strong>houseOwner</strong>，是委托类对象，而不是代理对象。注意，如果写成代理对象houseProxy，老师说，就会无限调用这个方法，我来打断点看看，发现根本就用不了houseProxy作为参数invoke 直接就报错了。拿出来就会报空指针异常。<br>java.lang.NullPointerException</p>
<p>2.idea debug，这个我们知道，因为debug是会调用toString的方法，所以在debug模式下在反射的方法中把toString方法给过滤掉</p>
<pre><code>if (&quot;toString&quot;.equals(method.getName())){
  return null;
}
</code></pre><h2 id="星期三（0911）"><a href="#星期三（0911）" class="headerlink" title="星期三（0911）"></a>星期三（0911）</h2><p>只有半天，而且讲的东西很少，就简单介绍了一下Spring，核心就是：</p>
<pre><code>IOC/DI（控制反转/依赖注入）
AOP   （切面编程）
</code></pre><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>控制反转的意义<br>控制什么？</p>
<pre><code>之前是程序自己控制
之后是通过spring控制
</code></pre><p>其实之前就是我们自己去new一个对象，之后是通过Spring使用反射去创建对象。学了那么久我们知道一般都有两种方法：<br>1）通过配置文件（pom.xml）去注册实例对象<br>2）通过注解去注册实例对象<br><strong>注</strong>：之前的servlet不就是这样？可以写注解，也可以写web.xml的标签。jsp也是。。。。</p>
<h3 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h3><p>Dependency Injection<br>依赖注入<br>谁依赖谁，为什么需要依赖，谁注入谁，注入了什么（这是理解依赖注入的关键）</p>
<p>谁依赖了谁：应用程序依赖于IoC容器（Spring）<br>为什么要依赖：应用程序需要IoC容器来提供对象需要的外部资源<br>谁注入谁：IoC容器注入应用程序某个对象，应用程序依赖的对象<br>注入了什么：注入某个对象所需要的外部资源（包括对象、资源、常量数据）</p>
<p>话不多说，直接开始我们是Spring的例子：一个简单的service + dao的例子<br>dao层：</p>
<pre><code>UserDao.java
public interface UserDao {
  void addUser(String username,String password);
}
UserDaoImpl.java
public class UserDaoImpl implements UserDao {
  @Override
  public void addUser(String username, String password) {
    System.out.println(&quot;注册用户：&quot; + username + &quot;---&quot; + password);
  }
}
</code></pre><p>Service层：</p>
<pre><code>UserService.java
public interface UserService {
  void register(String username,String password);
}
UserServiceImpl.java
public class UserServiceImpl implements UserService {
  UserDao userDao;//并没有给Dao实例化
  String abc;
  public String getAbc() {return abc;}
  public void setAbc(String abc) {this.abc = abc;}
  public UserDao getUserDao() {return userDao;}
  public void setUserDaoaaa(UserDao userDao) {this.userDao = userDao;}
}
</code></pre><p>这里我们发现我们并没有给Dao实例化，而是通过Spring(实际上是反射)实例化Service，Dao然后把两者关联起来，<br><strong>我们如何使用Spring呢？</strong><br>1.首先我们需要使用maven来管理我们的项目，所以我们的Spring要放在maven当中.。当然第一步就是创建一个maven的项目。然后在pom.xml中写入我们需要的依赖。</p>
<pre><code>&lt;properties&gt;
  &lt;spring.versionz&gt;5.1.9.RELEASE&lt;/spring.versionz&gt;
&lt;/properties&gt;
&lt;dependencies&gt;
  &lt;!--通过context去导入5+1--&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
    &lt;version&gt;${spring.versionz}&lt;/version&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;junit&lt;/groupId&gt;
    &lt;artifactId&gt;junit&lt;/artifactId&gt;
    &lt;version&gt;4.12&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre><p>我们的maven配置只需要导入spring-context和junit，idea会给我们导入5+1：<br>spring-context<br>spring-expression<br>spring-core  —-&gt; spring-jcl(+的1)<br>spring-aop<br>spring-beans</p>
<p>2.如何使用？我们需要配置一下我们的Spring的配置文件，在resources下创建：<strong>application.xml</strong></p>
<pre><code>application.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;
        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
  &lt;bean id=&quot;userService&quot; class=&quot;com.cskaoyan.service.UserServiceImpl&quot;&gt;
    &lt;property name=&quot;userDao&quot; ref=&quot;userDao1&quot;/&gt;
    &lt;property name=&quot;abc&quot; value=&quot;123456&quot;/&gt;
  &lt;/bean&gt;
  &lt;bean id=&quot;userDao1&quot; class=&quot;com.cskaoyan.dao.UserDaoImpl&quot;/&gt;
&lt;/beans&gt;
</code></pre><p>配置文件有很多内容，之后会介绍。这里我们只需要关注<strong>bean</strong>标签和property标签<br>bean 这里有两个属性： id 和 class</p>
<pre><code>id:表示的是用一个唯一标识去标识这个注册的bean
class:表示的是全限定名。就是getClass()的名字运行时类。
</code></pre><p>property标签：</p>
<pre><code>name：这里表示的是userService 类中有setXXX中的XXX
ref:表示它的值是一个引用对象类型
value:表示是一个值的类型
</code></pre><p>3.在单元测试中测试</p>
<pre><code>public class MainTest {
  @Test
  public void mytest1(){
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;application.xml&quot;);
    //通过Spring获取到了对象
    UserService userService = applicationContext.getBean(UserServiceImpl.class);
    userService.register(&quot;zhaoge&quot;,&quot;123456&quot;);
  }

  @Test
  public void mytest2(){
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;application.xml&quot;);
    UserServiceImpl userService = applicationContext.getBean(UserServiceImpl.class);
    //这个是从service中取出的
    UserDao userDaoFromService = userService.getUserDao();
    UserDao userDaoFromIoc = applicationContext.getBean(UserDao.class);
    //两个取出的实例是相同，证明在我们导入application时候，实例其实已经建好了。
    Assert.assertEquals(userDaoFromIoc,userDaoFromService); true
  }

  //多个class实现了同一个接口，接下来通过类型从spring容器中取出实例。报错。
  @Test
  public void mytest3(){
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;application.xml&quot;);
    UserServiceImpl bean = applicationContext.getBean(UserServiceImpl.class);
    //肯定会报错
    UserService bean1 = applicationContext.getBean(UserService.class);
  }

  @Test
  public void mytest4(){
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;application.xml&quot;);
    ApplicationContext applicationContext2 =
            new FileSystemXmlApplicationContext(&quot;D:\\Coding Workspace\\j16_workspace\\codes\\ioc\\demo1_ioc\\src\\main\\resources\\application.xml&quot;);
    UserServiceImpl bean = applicationContext.getBean(UserServiceImpl.class);
    UserService bean1 = applicationContext.getBean(UserService.class);
  }
}
</code></pre><p><strong>注意事项</strong><br>1.getBean()里面写class一定要写实现类的class,如果写接口的class，当接口的实现类不止一个的时候，会报错。所以建议写实现类的运行时类。<br>2.通过new了一个ClassPathXmlApplicationContext对象来获取到当前上下文的对象。再通过getBean()来获取对象<br>3.ClassPathXmlApplicationContext和ClassPathXmlApplicationContext的效果一样，但是路径不一样。前者是文件的具体位置，后者是<strong>classpath</strong>的位置</p>
<h3 id="学习了-IOC-和-DI-最大的感触是什么？"><a href="#学习了-IOC-和-DI-最大的感触是什么？" class="headerlink" title="学习了 IOC 和 DI 最大的感触是什么？"></a>学习了 IOC 和 DI 最大的感触是什么？</h3><p>控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法<br>依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。</p>
<h2 id="星期四（0912）"><a href="#星期四（0912）" class="headerlink" title="星期四（0912）"></a>星期四（0912）</h2><p>正式开始学习Spring的知识</p>
<h3 id="bean的实例化的方式"><a href="#bean的实例化的方式" class="headerlink" title="bean的实例化的方式"></a>bean的实例化的方式</h3><p><strong>构造方法</strong></p>
<h3 id="无参构造（默认）"><a href="#无参构造（默认）" class="headerlink" title="无参构造（默认）"></a>无参构造（默认）</h3><p>bean</p>
<pre><code>public class User {
  String username;
  String password;
  int age;
  /**
   * 使用无参构造获取bean
   */
  public User() {}
  public String getUsername() {
      return username;
  }

  public void setUsername(String username) { System.out.println(&quot;set方法&quot;); this.username = username;}
  public void setPassword(String password) {this.password = password;}
  public void setAge(int age) {this.age = age;}
}
</code></pre><p>application.xml</p>
<pre><code>&lt;!--无参构造(默认就是这种获取实例)--&gt;
&lt;bean id=&quot;userNoConstructor&quot; class=&quot;com.cskaoyan.bean.User&quot;&gt;
  &lt;property name=&quot;username&quot; value=&quot;wangdi&quot;/&gt;
  &lt;property name=&quot;age&quot; value=&quot;24&quot;/&gt;
  &lt;property name=&quot;password&quot; value=&quot;admin&quot;/&gt;
&lt;/bean&gt;
</code></pre><p>text.java单元测试</p>
<pre><code>@Before
public void init() {
  applicationContext= new ClassPathXmlApplicationContext(&quot;application.xml&quot;);
}
@Test
public void test1(){
  User userNoConstructor = (User) applicationContext.getBean(&quot;userNoConstructor&quot;);
  System.out.println(userNoConstructor);
}
</code></pre><h3 id="有参构造"><a href="#有参构造" class="headerlink" title="有参构造"></a>有参构造</h3><pre><code>public class User {
  String username;
  String password;
  int age;
  /**
   * 有参构造
   * @param username
   * @param password
   * @param age
   */
   public User(String username, String password, int age) {
     this.username = username;
     this.password = password;
     this.age = age;
   }
  public void setUsername(String username) { System.out.println(&quot;set方法&quot;); this.username = username;}
  public void setPassword(String password) {this.password = password;}
  public void setAge(int age) {this.age = age;}
}
</code></pre><p>application.xml</p>
<pre><code>&lt;!--有参构造，这需要自己写好构造函数--&gt;
&lt;bean id=&quot;createUserByConstructor&quot; class=&quot;com.cskaoyan.bean.User&quot;&gt;
  &lt;constructor-arg name=&quot;username&quot; value=&quot;wangdi&quot;/&gt;
  &lt;constructor-arg name=&quot;age&quot; value=&quot;24&quot;/&gt;
  &lt;constructor-arg name=&quot;password&quot; value=&quot;admin2&quot;/&gt;
&lt;/bean&gt;
</code></pre><p>text.java</p>
<pre><code>@Test
public void test2(){
  User createUserByConstructor = (User) applicationContext.getBean(&quot;createUserByConstructor&quot;);
  System.out.println(createUserByConstructor);
}
</code></pre><p><strong>注意事项</strong><br>这里的constructor-arg顾名思义，就是构造方法的参数</p>
<pre><code>&lt;constructor-arg name=&quot;age&quot; value=&quot;24&quot;/&gt;
</code></pre><p>所以这里的name表示的就是构造方法里面参数的名字，而不是property中name表示的是setXXX中的XXX。这里要注意。</p>
<p><strong>静态工厂</strong><br>常用于Spring整合其他框架（或者工具类）<br>为了使用spring重构之前的代码，用Spring来进行解耦，我们之前的类里可能是用静态工厂来提供javabean的，现在加入spring之后就可以用spring的静态工厂去构造。<br>用于生产实例对象的方法都必须是<strong>静态方法</strong>注意这里只需要注册实现car的bean<br>bean</p>
<pre><code>public class StaticFactory {
    public static Car create(){
        return new Car();
    }
}
</code></pre><p>application.xml</p>
<pre><code>&lt;bean id=&quot;carFromStatic&quot; class=&quot;com.cskaoyan.factory.StaticFactory&quot; factory-method=&quot;create&quot;/&gt;
</code></pre><p>text</p>
<pre><code>@Test
public void mytest(){
  ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;application.xml&quot;);
  Car carFromStatic = (Car) applicationContext.getBean(&quot;carFromStatic&quot;);
  Car carFromStatic2 = (Car) applicationContext.getBean(&quot;carFromStatic&quot;);
  //创建的两个汽车是相同的
  Assert.assertEquals(carFromStatic,carFromStatic2);
}
</code></pre><p><strong>实例工厂</strong><br>必须先实例化工厂，通过工厂实例来产生bean。提供的方法是非静态的。这就必须Car和工厂都注册<br>Bean</p>
<pre><code>public class InstanceFactory {
    public Car create(){
        return new Car();
    }
}
</code></pre><p>application.xml</p>
<pre><code>&lt;!--实例工厂--&gt;
&lt;bean id=&quot;instanceFactory&quot; class=&quot;com.cskaoyan.factory.InstanceFactory&quot;/&gt;
&lt;bean id=&quot;carFromInstance&quot; factory-bean=&quot;instanceFactory&quot; factory-method=&quot;create&quot;/&gt;
</code></pre><p>test</p>
<pre><code>@Test
public void mytest2(){
  ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;application.xml&quot;);
  Object carFromStatic = applicationContext.getBean(&quot;carFromInstance&quot;);
  System.out.println(carFromStatic);
}
</code></pre><p><strong>注意事项</strong><br>1.通过比较发现静态工厂和实力工厂除了bean的create方法一个是static一个是非静态方法外，唯一的区别就是applicaiton.xml</p>
<pre><code>&lt;!--静态工厂--&gt;
&lt;bean id=&quot;carFromStatic&quot; class=&quot;com.cskaoyan.factory.StaticFactory&quot; factory-method=&quot;create&quot;/&gt;
&lt;!--实例工厂--&gt;
&lt;bean id=&quot;instanceFactory&quot; class=&quot;com.cskaoyan.factory.InstanceFactory&quot;/&gt;
&lt;bean id=&quot;carFromInstance&quot; factory-bean=&quot;instanceFactory&quot; factory-method=&quot;create&quot;/&gt;
</code></pre><p>这里有个特别的地方，老师讲过，当我们使用bean标签的时候，百分之99的情况都要写class属性来表示这个bean是哪个运行时类的。但是这里我们发现，实例工厂的factory的bean有class，而要造的东西却没有class。这就是百分之一的情况。bean没有写class属性。</p>
<p><strong>2.这里有个疑问，如果使用注解，如何使用静态工厂和实例工厂？</strong></p>
<h3 id="bean作用域"><a href="#bean作用域" class="headerlink" title="bean作用域"></a>bean作用域</h3><p>老师作用域只讲了两个<br>一个singleton : 表示在Spring ioc 容器中仅存在一个Bean的实例，Bean以单例的方式存在。是默认值<br>一个prototype 每次从容器中调用bean的时候，都返回一个新的实例。既每次调用getBean()时，相当于执行了new Bean();</p>
<h3 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h3><table>
<thead>
<tr>
<th style="text-align:right">Spring容器中的bean的生命周期</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">1、Bean的建立</td>
<td style="text-align:left">由BeanFactory读取Bean定义文件，并生成各个实例。</td>
</tr>
<tr>
<td style="text-align:right">2、Setter注入</td>
<td style="text-align:left">执行Bean的属性依赖注入。</td>
</tr>
<tr>
<td style="text-align:right">3、BeanNameAware的setBeanName()</td>
<td style="text-align:left">如果Bean类实现了org.springframework.beans.factory.BeanNameAware接口，则执行其setBeanName()方法。 没有name情况id =  name</td>
</tr>
<tr>
<td style="text-align:right">4、BeanFactoryAware的setBeanFactory()</td>
<td style="text-align:left">如果Bean类实现了org.springframework.beans.factory.BeanFactoryAware接口，则执行其setBeanFactory()方法。</td>
</tr>
<tr>
<td style="text-align:right">5、BeanPostProcessor的processBeforeInitialization()</td>
<td style="text-align:left">容器中如果有实现org.springframework.beans.factory.BeanPostProcessor接口的实例，则任何Bean在初始化之前都会执行这个实例的processBeforeInitialization()方法。</td>
</tr>
<tr>
<td style="text-align:right">6、InitializingBean的afterPropertiesSet()</td>
<td style="text-align:left">如果Bean类实现了org.springframework.beans.factory.InitializingBean接口，则执行其afterPropertiesSet()方法。</td>
</tr>
<tr>
<td style="text-align:right">7、Bean定义文件中定义init-method</td>
<td style="text-align:left">在Bean定义文件中使用“init-method”属性设定方法名称，这时会执行initMethod()方法，注意，这个方法是不带参数的。</td>
</tr>
<tr>
<td style="text-align:right">8、BeanPostProcessor的processAfterInitialization()</td>
<td style="text-align:left">容器中如果有实现org.springframework.beans.factory.BeanPostProcessors接口的实例，则任何Bean在初始化之前都会执行这个实例的processAfterInitialization()方法。</td>
</tr>
<tr>
<td style="text-align:right">9、DisposableBean的destroy()</td>
<td style="text-align:left">在容器关闭时，如果Bean类实现了org.springframework.beans.factory.DisposableBean接口，则执行它的destroy()方法。</td>
</tr>
<tr>
<td style="text-align:right">10、Bean定义文件中定义destroy-method</td>
<td style="text-align:left">在容器关闭时，可以在Bean定义文件中使用“destory-method”定义的方法 context.close();</td>
</tr>
</tbody>
</table>
<p><strong>注意事项</strong><br>大多是都是直接Bean继承接口即可，但是有例外。BeanPostProcessor，他说的是：</p>
<pre><code>容器中如果有实现org.springframework.beans.factory.BeanPostProcessor接口的实例，则任何Bean在初始化之前都会执行这个实例的processBeforeInitialization()方法。
</code></pre><p>注意是有一个实现的实例，其他的所有实例都会调用这个方法。也就是相当于一个给其他所有实例初始化的一个实例，这个就是<strong>后置处理器</strong></p>
<h3 id="上代码"><a href="#上代码" class="headerlink" title="上代码"></a>上代码</h3><p>在上代码之前，我们之前学习前端的时候也有VUE的生命周期，其实这些生命周期的方法，就像钩子函数一样，我们通过在这个地方调用这个钩子方法，达到我们想要的效果罢了。例子将会依次打印：</p>
<pre><code>* 1.bean建立
* 2.setter的注入
* 3.BeanNameAware的setBeanName()
* 4.BeanFactoryAware的setBeanFactory()
* 5.BeanPostProcessor的processBeforeInitialization()
* 6.InitializingBean 的 afterPropertiesSet()
* 7.Bean定义文件中定义init-method
* 8.BeanPostProcessor的processAfterInitialization()
* 9.DisposableBean 的destroy()
* 10.Bean定义文件中定义destroy-method
</code></pre><p>先写后置处理器，因为他很特别（继承BeanPostProcessor），</p>
<h3 id="这里有个很特别的地方一定要说："><a href="#这里有个很特别的地方一定要说：" class="headerlink" title="这里有个很特别的地方一定要说："></a>这里有个很特别的地方一定要说：</h3><p>就是当我们 implements BeanPostProcessor的时候，发现IDEA并没有提示要求我们一定要实现这个接口的方法，这就很奇怪了。他不是一个接口吗？为什么不用实现这个接口的方法？当我们点进这个接口的源码中我们发现：</p>
<pre><code>public interface BeanPostProcessor {
  @Nullable
  default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
      return bean;
  }
  @Nullable
  default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
      return bean;
  }
}
</code></pre><p>发现他里面的两个方法都有一个注解：@Nullable，百度了一下发现：</p>
<pre><code>@NonNull可以标注在方法、字段、参数之上，表示对应的值不可以为空
@Nullable注解可以标注在方法、字段、参数之上，表示对应的值可以为空
</code></pre><p>以上两个注解在程序运行的过程中不会起任何作用，只会在IDE、编译器、FindBugs检查、生成文档的时候有做提示；</p>
<p>好像和我们的问题没有什么关系。仔细看了一下这个接口的两个方法，是用<strong>default</strong>修饰的，表示只能是该接口的实现才能使用。那么不能为null的意思应该是传进来的bean不能为null。而这个接口已经实现好了一个备份的方法。我们实现这个接口就可以直接用。或者再重写他的方法。这里的这个接口应该是类没有区别。<br><strong>到底这么做是为什么呢？</strong>希望有一天我会懂</p>
<p>CustomBeanPostProcessor.java重写了postProcessBeforeInitialization，postProcessAfterInitialization方法。</p>
<pre><code>public class CustomBeanPostProcessor implements BeanPostProcessor {
  @Override
  public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
    System.out.println(&quot;5、BeanPostProcessor的before方法:&quot; + bean.getClass().getName());
    return bean;
  }
  @Override
  public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
    System.out.println(&quot;8、BeanPostProcessor的after方法:&quot; + bean.getClass().getName());
    return bean;
  }
}
</code></pre><p>LifeCycleBean.java</p>
<pre><code>public class LifeCycleBean implements BeanNameAware , BeanFactoryAware , InitializingBean, DisposableBean {
    String parameter;

    public LifeCycleBean(){
      System.out.println(&quot;1.bean建立&quot;);
    }

    public void setParameter(String parameter){
      System.out.println(&quot;2.setter的注入&quot;);
      this.parameter = parameter;
    }

    @Override
    public void setBeanName(String s) {
      //s是你在spring的配置文件中定义的name ,没有name 默认就是id
      System.out.println(&quot;3、beanNameAware的setBeanName方法：&quot; + s);
    }

    /**
     * 注意我们没有写工厂函数默认也会有一个工厂函数
     * @param beanFactory
     * @throws BeansException
     */
    @Override
    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
      System.out.println(&quot;4、beanFactory的setBeanFactory方法：&quot; + beanFactory );
    }

    @Override
    public void afterPropertiesSet() throws Exception {
      System.out.println(&quot;6、afterPropertiesSet（）&quot;);
    }

    public void myinit(){
      System.out.println(&quot;7、my init method&quot;);
    }

    @Override
    public void destroy() throws Exception {
      System.out.println(&quot;9、DisposableBean&quot;);
    }

    public void mydestroy(){
      System.out.println(&quot;10、mydestroy&quot;);
    }
}
</code></pre><p>application.xml</p>
<pre><code>&lt;bean id=&quot;lifeCycleBeanz&quot; class=&quot;com.cskaoyan.LifeCycleBean&quot; init-method=&quot;myinit&quot; destroy-method=&quot;mydestroy&quot;&gt;
    &lt;property name=&quot;parameter&quot; value=&quot;myparameter&quot;/&gt;
&lt;/bean&gt;
&lt;!-- 初始化用的bean --&gt;
&lt;bean class=&quot;com.cskaoyan.CustomBeanPostProcessor&quot;/&gt;
</code></pre><p>text.java</p>
<pre><code>public class LifeCycleTest {
  @Test
  public void mytest(){
    ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;application.xml&quot;);
    applicationContext.close();
  }
}
</code></pre><h3 id="属性的注入（-property-）"><a href="#属性的注入（-property-）" class="headerlink" title="属性的注入（ property ）"></a>属性的注入（ property ）</h3><p>属性注入一般可以分为</p>
<pre><code>手动装配
自动装配
</code></pre><p>一般情况下我们进行配置信息都是属于手动装配,基于xml的注入：</p>
<pre><code>一类叫做构造方法，
一类叫做set方法
</code></pre><p>之前已经演示过了这里就不演示了</p>
<h3 id="集合bean"><a href="#集合bean" class="headerlink" title="集合bean"></a>集合bean</h3><p>直接上代码吧<br>bean.java</p>
<pre><code>public class CollectionBean {
  List&lt;String&gt; stringList;
  List&lt;User&gt; userList;
  String[] array;
  Set&lt;String&gt; setData;
  Map&lt;String,String&gt; mapData;
  Properties properties;
  public void setUserList(List&lt;User&gt; userList) {this.userList = userList;}
  public void setStringList(List&lt;String&gt; stringList) {this.stringList = stringList;}
  public void setArray(String[] array) { this.array = array; }
  public void setSetData(Set&lt;String&gt; setData) {this.setData = setData;}
  public void setMapData(Map&lt;String, String&gt; mapData) {this.mapData = mapData;}
  public void setProperties(Properties properties) {this.properties = properties;}
}
</code></pre><p>只要记住标签就好主要是application.xml</p>
<pre><code>&lt;bean id=&quot;collectionBean&quot; class=&quot;com.cskaoyan.bean.CollectionBean&quot;&gt;
</code></pre><p>这是StringList注册的标签：里面有一层list标签，再套一层value</p>
<pre><code>&lt;property name=&quot;stringList&quot; &gt;
  &lt;list&gt;
    &lt;value&gt;list1&lt;/value&gt;
    &lt;value&gt;list2&lt;/value&gt;
    &lt;value&gt;list3&lt;/value&gt;
  &lt;/list&gt;
&lt;/property&gt;
</code></pre><p>List里面是bean的时候，（说引用类型并不合适，因为String就不符合这种情况）就是下面这种情况。有两种写法：<br>1.直接在里面写bean标签，和之前的一样。<br>2.里面写的是ref标签。bean属性指的是对应bean的id值。</p>
<pre><code>&lt;property name=&quot;userList&quot;&gt;
  &lt;list&gt;
    &lt;bean class=&quot;com.cskaoyan.bean.User&quot; &gt;
      &lt;property name=&quot;username&quot; value=&quot;admin&quot;/&gt;
      &lt;property name=&quot;password&quot; value=&quot;admin&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean class=&quot;com.cskaoyan.bean.User&quot; &gt;
      &lt;property name=&quot;username&quot; value=&quot;admin2&quot;/&gt;
      &lt;property name=&quot;password&quot; value=&quot;admin2&quot;/&gt;
    &lt;/bean&gt;
    &lt;ref bean=&quot;user2&quot;/&gt;
  &lt;/list&gt;
&lt;/property&gt;

//ref标签使用的bean，不应该写在这里，为了好看才写这里的注意！！！！
&lt;bean id=&quot;user2&quot; class=&quot;com.cskaoyan.bean.User&quot;&gt;
  &lt;property name=&quot;username&quot; value=&quot;user2&quot;/&gt;
  &lt;property name=&quot;password&quot; value=&quot;password2&quot;/&gt;
&lt;/bean&gt;
</code></pre><p>当实例是一个数组的时候：里面是array标签</p>
<pre><code>&lt;property name=&quot;array&quot;&gt;
  &lt;array&gt;
    &lt;value&gt;arr1&lt;/value&gt;
    &lt;value&gt;arr2&lt;/value&gt;
    &lt;value&gt;arr3&lt;/value&gt;
  &lt;/array&gt;
&lt;/property&gt;
</code></pre><p>当然如果是一个对象数组的时候。array里面也是bean标签啦</p>
<p>当实例是一个set集合（不能有重复值）当然这里写出了一个问题：反射生成的set是什么set？已经给出答案</p>
<pre><code>&lt;property name=&quot;setData&quot;&gt;
    &lt;set&gt;
      &lt;!--看看可以存重复的值吗？--&gt;
      &lt;!-- 生成的hashSet 还是treeSet --&gt;
      &lt;!--答案是linkHashSet,而且不存储重复值--&gt;
      &lt;value&gt;set1&lt;/value&gt;
      &lt;value&gt;set1&lt;/value&gt;//测试是否可以存重复值
      &lt;value&gt;set3&lt;/value&gt;
    &lt;/set&gt;
&lt;/property&gt;
</code></pre><p>实例是一个map，里面是map标签，每个字标签是entry,使用属性值表示key value</p>
<pre><code>&lt;property name=&quot;mapData&quot;&gt;
  &lt;map&gt;
    &lt;!--生成的是hashMap 还是 treeMap--&gt;
    &lt;!--答案是linkHashMap--&gt;
    &lt;entry key=&quot;key1&quot; value=&quot;value1&quot;/&gt;
    &lt;entry key=&quot;key2&quot; value=&quot;value2&quot;/&gt;
    &lt;entry key=&quot;key3&quot; value=&quot;value3&quot;/&gt;
  &lt;/map&gt;
&lt;/property&gt;
</code></pre><p>实例是一个properties,里面是props标签，虽然是特殊的map但是写法和map不同。props里的prop只有key属性，value写成里面的文本结点</p>
<pre><code>    &lt;property name=&quot;properties&quot;&gt;
      &lt;props&gt;
        &lt;prop key=&quot;propKey1&quot;&gt;value1&lt;/prop&gt;
        &lt;prop key=&quot;propKey2&quot;&gt;value2&lt;/prop&gt;
        &lt;prop key=&quot;propKey3&quot;&gt;value3&lt;/prop&gt;
      &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><h3 id="注解使用Spring-重点"><a href="#注解使用Spring-重点" class="headerlink" title="注解使用Spring(重点)"></a>注解使用Spring(重点)</h3><p>这里我要说一句，上面说的都是实际不会用的，这里开始才是我们真正需要掌握的东西。上面的写法虽然没用，但是注解却是以上面的知识点为基础的。从现在开始不用写bean标签了，需要加一个扫描标签：</p>
<pre><code>&lt;!--打开注解的扫描开关--&gt;
&lt;!--aop tx mvc transaction--&gt;
&lt;!--这个包以及这个包下的所有的目录--&gt;
&lt;context:component-scan base-package=&quot;com.cskaoyan&quot;/&gt;
</code></pre><h3 id="Setter方法注入属性"><a href="#Setter方法注入属性" class="headerlink" title="Setter方法注入属性"></a>Setter方法注入属性</h3><pre><code>@Component取代&lt;bean class=&quot;&quot;&gt;
@Component(&quot;id&quot;) 取代 &lt;bean id=&quot;&quot; class=&quot;&quot;&gt;
</code></pre><p>.web开发，提供3个@Component注解衍生注解（功能一样）取代 &lt;bean class=””&gt;</p>
<pre><code>@Repository ：dao层
@Service：service层
@Controller：web层
</code></pre><h3 id="属性的依赖注入。"><a href="#属性的依赖注入。" class="headerlink" title="属性的依赖注入。"></a>属性的依赖注入。</h3><p>给私有字段设置，也可以给setter方法设置<br>普通值：@Value(“”)<br>bean：</p>
<pre><code>@Autowired   单独使用，根据类型***。class(使用最多的，如果有两个实现类就会报错)
@Autowired    @Qualifier(&quot;名称&quot;) 两个连用
@Resource(name = &quot;名称&quot;)一个注解表示上面两个注解
</code></pre><p><strong> 不再需要set方法了！ </strong><br>举例<br>AutowiredBean.java</p>
<pre><code>@Component
public class AutowiredBean {
  @Autowired
  UserDao userDao;
}
</code></pre><p>userDaoImpl.java</p>
<pre><code>@Repository(&quot;userDao2&quot;)
public class UserDaoImpl implements UserDao {
    @Value(&quot;ADMIN&quot;)
    String name;
}
</code></pre><p>test.java</p>
<pre><code>@Test
public void test2(){
    ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;application.xml&quot;);
    AutowiredBean bean = applicationContext.getBean(AutowiredBean.class);
    UserDao userDao2 = (UserDao) applicationContext.getBean(&quot;userDao2&quot;);
    Assert.assertEquals(bean.userDao,userDao2); //相同的userDao
}
</code></pre><p>当userDao有两个实现类时，只写@Autowired会报错<br>需要配合@Qualifier(“id”)</p>
<pre><code>@Component
public class AutowiredBean {
    @Autowired
            @Qualifier(&quot;userDao2&quot;)
    UserDao userDao;
}
</code></pre><p>两条注解也可以换成@Resource（name = “id”）</p>
<pre><code>@Component
public class AutowiredBean {
//    @Autowired
//            @Qualifier(&quot;userDao2&quot;)
    @Resource(name = &quot;userDao2&quot;)
    UserDao userDao;
}
</code></pre><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>初始化：@PostConstruct<br>销毁：  @PreDestroy</p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>@Scope(“singleton”) 单例（默认）</p>
<p>@Scope(“prototype”) 多例<br>举例：</p>
<pre><code>@Component(&quot;user2&quot;)
@Scope(&quot;prototype&quot;)
public class User2 {
}
</code></pre><h3 id="更简便的Test"><a href="#更简便的Test" class="headerlink" title="更简便的Test"></a>更简便的Test</h3><p>也不过是节约写了applicationContext而已，需要引入一个spring的test的依赖<br>pom.xml(建议和spring的版本号是一样的!)</p>
<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.springframework&lt;/groupId&gt;
  &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
  &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre><p>test.java</p>
<pre><code>@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(&quot;classpath:application.xml&quot;)
public class AnnotationTest2 {
  @Autowired
  AutowiredBean bean;

  @Resource(name = &quot;userDao2&quot;)
  UserDao userDao2;

  @Test
  public  void test3(){
    Assert.assertEquals(bean.userDao,userDao2);//true
  }
}
</code></pre><p>这其实也没有什么用，只是直接可以获得实例罢了，把上面的单元测试改写了一下就是下面这个了。</p>
<h3 id="动态代理之cglib"><a href="#动态代理之cglib" class="headerlink" title="动态代理之cglib"></a>动态代理之cglib</h3><p>Spring自己自带的动态代理，这就不需要再写接口来进行代理了，继续是之前的转账的例子：<br>HouseOwner.java</p>
<pre><code>public class HouseOwner {
  public boolean rentHouse(int money){
    System.out.println(&quot;rentHOuse :&quot; + money);
    if (money &gt;= 2000){
        return true;
    }
    return false;
  }
}
</code></pre><p>Test.java</p>
<pre><code>public class CglibTest {
  @Test
  public void mytest(){
    HouseOwner houseOwner = new HouseOwner();
    HouseOwner houseOwnerProxy = (HouseOwner) Enhancer.create(HouseOwner.class, new InvocationHandler() {
      @Override
      public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println(&quot;before &quot;);
        args[0] = args[0]-500;//当场拿走中介费
        Object invoke = method.invoke(houseOwner, args);
        System.out.println(&quot;after&quot;);
        return invoke;
      }
    });
    boolean b = houseOwnerProxy.rentHouse(2000);
  }
}
</code></pre><h3 id="这有什么用？"><a href="#这有什么用？" class="headerlink" title="这有什么用？"></a>这有什么用？</h3><p>只需要通过Spring的Enhancer.create来创建动态代理的对象。你想问我代理对象有什么用？这其实就是我们可以添加事务的方式。在每一个需要启动的事务的对象，给他加一层代理，代理就是一个汉堡包的上下层，给他加上开启事务，然后提交事务。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这周好像没有什么问题啊，感觉很菜啊，慌得一批，其实问题还是有的，就是需要自己去找答案罢了<br>1.为什么反射形成集合的对象都是 linkHashSet linkHashMap ,数值型是double等等<br>2.为什么那个后置控制器的接口是已经实现好的default的方法，而不需要自己去实现？我以为之前的HttpServlet的doGet和doPost方法也是这种情况，后来发现这两个是他实现好的类。并不是接口。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/08/正则表达式初学/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王邸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路要坚持">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/08/正则表达式初学/" itemprop="url">正则表达式初学</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-08T18:16:03+08:00">
                2019-09-08
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/09/08/正则表达式初学/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/09/08/正则表达式初学/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2019/09/08/正则表达式初学/" class="leancloud_visitors" data-flag-title="正则表达式初学">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h2><p>一共有四个部分，语法，元字符，匹配优先级，匹配规则组成。<br>最重要当然是语法</p>
<h3 id="正则表达式-语法"><a href="#正则表达式-语法" class="headerlink" title="正则表达式 - 语法"></a>正则表达式 - 语法</h3><p>正则表达式(regular expression)描述了一种字符串匹配的模式，可以用来检查一个串是否含有某种子串、将匹配的子串做替换或者从某个串中取出符合某个条件的子串等。</p>
<p>构造正则表达式的方法和创建数学表达式的方法一样。也就是用多种元字符与运算符可以将小的表达式结合在一起来创建更大的表达式。正则表达式的组件可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。</p>
<p>正则表达式是由<strong>普通字符</strong>（例如字符 a 到 z）以及<strong>特殊字符</strong>（称为”元字符”）组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。</p>
<p><strong>普通字符</strong><br>普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。 这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。</p>
<p><strong>非打印字符</strong><br>非打印字符也可以是正则表达式的组成部分。就是一些空格制表符等等。。。下表列出了表示非打印字符的转义序列：</p>
<table>
<thead>
<tr>
<th style="text-align:right">字符</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">\cx</td>
<td style="text-align:left">匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’   字符。</td>
</tr>
<tr>
<td style="text-align:right">\f</td>
<td style="text-align:left">匹配一个换页符。等价于 \x0c 和 \cL。</td>
</tr>
<tr>
<td style="text-align:right">\n</td>
<td style="text-align:left">匹配一个换行符。等价于 \x0a 和 \cJ。</td>
</tr>
<tr>
<td style="text-align:right">\r</td>
<td style="text-align:left">匹配一个回车符。等价于 \x0d 和 \cM。</td>
</tr>
<tr>
<td style="text-align:right">\s</td>
<td style="text-align:left">匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。</td>
</tr>
<tr>
<td style="text-align:right">\S</td>
<td style="text-align:left">匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td>
</tr>
<tr>
<td style="text-align:right">\t</td>
<td style="text-align:left">匹配一个制表符。等价于 \x09 和 \cI。</td>
</tr>
<tr>
<td style="text-align:right">\v</td>
<td style="text-align:left">匹配一个垂直制表符。等价于 \x0b 和 \cK。</td>
</tr>
</tbody>
</table>
<p><strong>特殊字符</strong><br>所谓特殊字符，就是一些有特殊含义的字符，如上面说的”*.txt”中的*，简单的说就是表示任何字符串的意思。如果要查找文件名中有*的文件，则需要对*进行转义，即在其前加一个\。ls \*.txt。</p>
<p>许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符”转义”，即，将反斜杠字符 ( ‘\’ ) 放在它们前面。下表列出了正则表达式中的特殊字符：</p>
<table>
<thead>
<tr>
<th style="text-align:right">特别字符</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">$</td>
<td style="text-align:left">匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\n’ 或 ‘\r’。要匹配 $ 字符本身，请使用 \$。</td>
</tr>
<tr>
<td style="text-align:right">( )</td>
<td style="text-align:left">标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。</td>
</tr>
<tr>
<td style="text-align:right">*</td>
<td style="text-align:left">匹配前面的子表达式零次或多次。要匹配 <em> 字符，请使用 \</em>。</td>
</tr>
<tr>
<td style="text-align:right">+</td>
<td style="text-align:left">匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。</td>
</tr>
<tr>
<td style="text-align:right">.</td>
<td style="text-align:left">匹配除换行符 \n之外的任何单字符。要匹配 .，请使用 .。</td>
</tr>
<tr>
<td style="text-align:right">[</td>
<td style="text-align:left">标记一个中括号表达式的开始。要匹配 [，请使用 [。</td>
</tr>
<tr>
<td style="text-align:right">?</td>
<td style="text-align:left">匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \?。</td>
</tr>
<tr>
<td style="text-align:right">\</td>
<td style="text-align:left">将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。序列 ‘\‘ 匹配 “\”，而 ‘(‘ 则匹配 “(“。</td>
</tr>
<tr>
<td style="text-align:right">^</td>
<td style="text-align:left">匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 \^。</td>
</tr>
<tr>
<td style="text-align:right">{</td>
<td style="text-align:left">标记限定符表达式的开始。要匹配 {，请使用 {。</td>
</tr>
<tr>
<td style="text-align:right">&#124;</td>
<td style="text-align:left">指明两项之间的一个选择。要匹配 &#124;，请使用 \&#124;。</td>
</tr>
</tbody>
</table>
<p><strong>限定符</strong><br>限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有*或+或?或{n}或{n,}或{n,m}共6种。</p>
<table>
<thead>
<tr>
<th style="text-align:right">字符</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">*</td>
<td style="text-align:left">匹配前面的子表达式零次或多次。例如，zo<em> 能匹配 “z” 以及 “zoo”。</em> 等价于{0,}。</td>
</tr>
<tr>
<td style="text-align:right">+</td>
<td style="text-align:left">匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td>
</tr>
<tr>
<td style="text-align:right">?</td>
<td style="text-align:left">匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。</td>
</tr>
<tr>
<td style="text-align:right">{n}</td>
<td style="text-align:left">n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td>
</tr>
<tr>
<td style="text-align:right">{n,}</td>
<td style="text-align:left">n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*‘。</td>
</tr>
<tr>
<td style="text-align:right">{n,m}</td>
<td style="text-align:left">m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td>
</tr>
</tbody>
</table>
<p><strong>定位符</strong><br>定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。<br>定位符用来描述字符串或单词的边界，^和$分别指字符串的开始与结束，\b描述单词的前或后边界，\B表示非单词边界。<br>正则表达式的限定符有：</p>
<table>
<thead>
<tr>
<th style="text-align:right">字符</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">^</td>
<td style="text-align:left">匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。</td>
</tr>
<tr>
<td style="text-align:right">$</td>
<td style="text-align:left">匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。</td>
</tr>
<tr>
<td style="text-align:right">\b</td>
<td style="text-align:left">匹配一个字边界，即字与空格间的位置。</td>
</tr>
<tr>
<td style="text-align:right">\B</td>
<td style="text-align:left">非字边界匹配。</td>
</tr>
</tbody>
</table>
<p><strong>注意</strong>：</p>
<pre><code>不能将限定符与定位点一起使用。由于在紧靠换行或者字边界的前面或后面不能有一个以上位置，因此不允许诸如 ^* 之类的表达式。
若要匹配一行文本开始处的文本，请在正则表达式的开始使用 ^ 字符。不要将 ^ 的这种用法与中括号表达式内的用法混淆。
若要匹配一行文本的结束处的文本，请在正则表达式的结束处使用 $ 字符。
</code></pre><p>若要在搜索章节标题时使用定位点，下面的正则表达式匹配一个章节标题，该标题只包含两个尾随数字，并且出现在行首：</p>
<pre><code>/^Chapter [1-9][0-9]{0,1}/
</code></pre><p>真正的章节标题不仅出现行的开始处，而且它还是该行中仅有的文本。它即出现在行首又出现在同一行的结尾。下面的表达式能确保指定的匹配只匹配章节而不匹配交叉引用。通过创建只匹配一行文本的开始和结尾的正则表达式，就可做到这一点。</p>
<pre><code>/^Chapter [1-9][0-9]{0,1}$/
</code></pre><p>匹配字边界稍有不同，但向正则表达式添加了很重要的能力。字边界是单词和空格之间的位置。非字边界是任何其他位置。下面的表达式匹配单词 Chapter 的开头三个字符，因为这三个字符出现字边界后面：</p>
<pre><code>/\bCha/
</code></pre><p>\b 字符的位置是非常重要的。如果它位于要匹配的字符串的开始，它在单词的开始处查找匹配项。如果它位于字符串的结尾，它在单词的结尾处查找匹配项。例如，下面的表达式匹配单词 Chapter 中的字符串 ter，因为它出现在字边界的前面：</p>
<pre><code>/ter\b/
</code></pre><p>下面的表达式匹配 Chapter 中的字符串 apt，但不匹配 aptitude 中的字符串 apt：</p>
<pre><code>/\Bapt/ 字符串 apt 出现在单词 Chapter 中的非字边界处，但出现在单词 aptitude 中的字边界处。
</code></pre><p>对于 \B 非字边界运算符，位置并不重要，因为匹配不关心究竟是单词的开头还是结尾。</p>
<p><strong>选择</strong><br>用圆括号将所有选择项括起来，相邻的选择项之间用|分隔。但用圆括号会有一个副作用，是相关的匹配会被缓存，此时可用?:放在第一个选项前来消除这种副作用。<br>其中?:是非捕获元之一，还有两个非捕获元是?=和?!，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。</p>
<p><strong>反向引用</strong><br>对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 ‘\n’ 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。<br>可以使用非捕获元字符 ‘?:’、’?=’ 或 ‘?!’ 来重写捕获，忽略对相关匹配的保存。<br>反向引用的最简单的、最有用的应用之一，是提供查找文本中两个相同的相邻单词的匹配项的能力。以下面的句子为例：</p>
<pre><code>Is is the cost of of gasoline going up up?
</code></pre><p>上面的句子很显然有多个重复的单词。如果能设计一种方法定位该句子，而不必查找每个单词的重复出现，那该有多好。下面的正则表达式使用单个子表达式来实现这一点：</p>
<pre><code>/\b([a-z]+) \1\b/gi
</code></pre><p>捕获的表达式，正如 [a-z]+ 指定的，包括一个或多个字母。正则表达式的第二部分是对以前捕获的子匹配项的引用，即，单词的第二个匹配项正好由括号表达式匹配。\1 指定第一个子匹配项。字边界元字符确保只检测整个单词。否则，诸如”is issued”或”this is”之类的词组将不能正确地被此表达式识别。正则表达式后面的全局标记 (g) 指示，将该表达式应用到输入字符串中能够查找到的尽可能多的匹配。表达式的结尾处的不区分大小写 (i) 标记指定不区分大小写。多行标记指定换行符的两边可能出现潜在的匹配。</p>
<p>语法当中比较难的点在于：<br>1.. 表示是任意的字符，<br>2.：（冒号）并不是元字符<br>3.*、+和?限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。<br>4.反向应用很重要</p>
<h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><p>语法介绍完了，接下来的元字符才是最常用的：</p>
<table>
<thead>
<tr>
<th style="text-align:right">字符</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">\</td>
<td style="text-align:left">将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\n’ 匹配一个换行符。序列 ‘\‘ 匹配 “\” 而 “(“ 则匹配 “(“。</td>
</tr>
<tr>
<td style="text-align:right">^</td>
<td style="text-align:left">匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。</td>
</tr>
<tr>
<td style="text-align:right">$</td>
<td style="text-align:left">匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。</td>
</tr>
<tr>
<td style="text-align:right">*</td>
<td style="text-align:left">匹配前面的子表达式零次或多次。例如，zo<em> 能匹配 “z” 以及 “zoo”。</em> 等价于{0,}。</td>
</tr>
<tr>
<td style="text-align:right">+</td>
<td style="text-align:left">匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td>
</tr>
<tr>
<td style="text-align:right">?</td>
<td style="text-align:left">匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 中的”do” 。? 等价于 {0,1}。</td>
</tr>
<tr>
<td style="text-align:right">{n}</td>
<td style="text-align:left">n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td>
</tr>
<tr>
<td style="text-align:right">{n,}</td>
<td style="text-align:left">n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*‘。</td>
</tr>
<tr>
<td style="text-align:right">{n,m}</td>
<td style="text-align:left">m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td>
</tr>
<tr>
<td style="text-align:right">?</td>
<td style="text-align:left">当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。</td>
</tr>
<tr>
<td style="text-align:right">.</td>
<td style="text-align:left">匹配除 “\n” 之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用象 ‘[.\n]’ 的模式。</td>
</tr>
<tr>
<td style="text-align:right">(pattern)</td>
<td style="text-align:left">匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘(‘ 或 ‘)‘。</td>
</tr>
<tr>
<td style="text-align:right">(?:pattern)</td>
<td style="text-align:left">匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (&#124;) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y&#124;ies) 就是一个比 ‘industry&#124;industries’ 更简略的表达式。</td>
</tr>
<tr>
<td style="text-align:right">(?=pattern)</td>
<td style="text-align:left">正向预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，’Windows (?=95&#124;98&#124;NT&#124;2000)’ 能匹配 “Windows 2000” 中的 “Windows” ，但不能匹配 “Windows 3.1” 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td>
</tr>
<tr>
<td style="text-align:right">(?!pattern)</td>
<td style="text-align:left">负向预查，在任何不匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如’Windows (?!95&#124;98&#124;NT&#124;2000)’ 能匹配 “Windows 3.1” 中的 “Windows”，但不能匹配 “Windows 2000” 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td>
</tr>
<tr>
<td style="text-align:right">x&#124;y</td>
<td style="text-align:left">匹配 x 或 y。例如，’z&#124;food’ 能匹配 “z” 或 “food”。’(z&#124;f)ood’ 则匹配 “zood” 或 “food”。</td>
</tr>
<tr>
<td style="text-align:right">[xyz]</td>
<td style="text-align:left">字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。</td>
</tr>
<tr>
<td style="text-align:right">[^xyz]</td>
<td style="text-align:left">负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’。</td>
</tr>
<tr>
<td style="text-align:right">[a-z]</td>
<td style="text-align:left">字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。</td>
</tr>
<tr>
<td style="text-align:right">[^a-z]</td>
<td style="text-align:left">负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。</td>
</tr>
<tr>
<td style="text-align:right">\b</td>
<td style="text-align:left">匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</td>
</tr>
<tr>
<td style="text-align:right">\B</td>
<td style="text-align:left">匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。</td>
</tr>
<tr>
<td style="text-align:right">\cx</td>
<td style="text-align:left">匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td>
</tr>
<tr>
<td style="text-align:right">\d</td>
<td style="text-align:left">匹配一个数字字符。等价于 [0-9]。</td>
</tr>
<tr>
<td style="text-align:right">\D</td>
<td style="text-align:left">匹配一个非数字字符。等价于 [^0-9]。</td>
</tr>
<tr>
<td style="text-align:right">\f</td>
<td style="text-align:left">匹配一个换页符。等价于 \x0c 和 \cL。</td>
</tr>
<tr>
<td style="text-align:right">\n</td>
<td style="text-align:left">匹配一个换行符。等价于 \x0a 和 \cJ。</td>
</tr>
<tr>
<td style="text-align:right">\r</td>
<td style="text-align:left">匹配一个回车符。等价于 \x0d 和 \cM。</td>
</tr>
<tr>
<td style="text-align:right">\s</td>
<td style="text-align:left">匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。</td>
</tr>
<tr>
<td style="text-align:right">\S</td>
<td style="text-align:left">匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td>
</tr>
<tr>
<td style="text-align:right">\t</td>
<td style="text-align:left">匹配一个制表符。等价于 \x09 和 \cI。</td>
</tr>
<tr>
<td style="text-align:right">\v</td>
<td style="text-align:left">匹配一个垂直制表符。等价于 \x0b 和 \cK。</td>
</tr>
<tr>
<td style="text-align:right">\w</td>
<td style="text-align:left">匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9_]’。</td>
</tr>
<tr>
<td style="text-align:right">\W</td>
<td style="text-align:left">匹配任何非单词字符。等价于 ‘[^A-Za-z0-9_]’。</td>
</tr>
<tr>
<td style="text-align:right">\xn</td>
<td style="text-align:left">匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，’\x41’ 匹配 “A”。’\x041’ 则等价于 ‘\x04’ &amp; “1”。正则表达式中可以使用 ASCII 编码。</td>
</tr>
<tr>
<td style="text-align:right">\num</td>
<td style="text-align:left">匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，’(.)\1’ 匹配两个连续的相同字符。</td>
</tr>
<tr>
<td style="text-align:right">\n</td>
<td style="text-align:left">标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。</td>
</tr>
<tr>
<td style="text-align:right">\nm</td>
<td style="text-align:left">标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。</td>
</tr>
<tr>
<td style="text-align:right">\nml</td>
<td style="text-align:left">如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。</td>
</tr>
<tr>
<td style="text-align:right">\un</td>
<td style="text-align:left">匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。</td>
</tr>
</tbody>
</table>
<h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><table>
<thead>
<tr>
<th style="text-align:right">运算符</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">\</td>
<td style="text-align:left">转义符</td>
</tr>
<tr>
<td style="text-align:right">(), (?:), (?=), []</td>
<td style="text-align:left">圆括号和方括号</td>
</tr>
<tr>
<td style="text-align:right">*, +, ?, {n}, {n,}, {n,m}</td>
<td style="text-align:left">限定符</td>
</tr>
<tr>
<td style="text-align:right">^, $, \任何元字符、任何字符</td>
<td style="text-align:left">定位点和序列（即：位置和顺序）</td>
</tr>
<tr>
<td style="text-align:right">&#124;</td>
<td style="text-align:left">替换，”或”操作</td>
</tr>
</tbody>
</table>
<p>字符具有高于替换运算符的优先级，使得”m&#124;food”匹配”m”或”food”。若要匹配”mood”或”food”，请使用括号创建子表达式，从而产生”(m&#124;f)ood”。</p>
<h3 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h3><p><strong>基本模式匹配</strong><br>一切从最基本的开始。模式，是正规表达式最基本的元素，它们是一组描述字符串特征的字符。模式可以很简单，由普通的字符串组成，也可以非常复杂，往往用特殊的字符表示一个范围内的字符、重复出现，或表示上下文。例如：</p>
<pre><code>^once
</code></pre><p>这个模式包含一个特殊的字符^，表示该模式只匹配那些以once开头的字符串。例如该模式与字符串”once upon a time”匹配，与”There once was a man from NewYork”不匹配。正如如^符号表示开头一样，$符号用来匹配那些以给定模式结尾的字符串。</p>
<pre><code>bucket$
</code></pre><p>这个模式与”Who kept all of this cash in a bucket”匹配，与”buckets”不匹配。字符^和$同时使用时，表示精确匹配（字符串与模式一样）。例如：</p>
<p>  ^bucket$<br>只匹配字符串”bucket”。如果一个模式不包括^和$，那么它与任何包含该模式的字符串匹配。例如：模式</p>
<pre><code>once
</code></pre><p>与字符串</p>
<pre><code>There once was a man from NewYork
Who kept all of his cash in a bucket.
Who kept all (o)f his cash i(n) a bu(c)k(e)t.
</code></pre><p>是匹配的。</p>
<p>在该模式中的字母(o-n-c-e)是字面的字符，也就是说，他们表示该字母本身，数字也是一样的。其他一些稍微复杂的字符，如标点符号和白字符（空格、制表符等），要用到转义序列。所有的转义序列都用反斜杠()打头。制表符的转义序列是：\t。所以如果我们要检测一个字符串是否以制表符开头，可以用这个模式：</p>
<pre><code>^\t
</code></pre><p>类似的，用\n表示”新行”，\r表示回车。其他的特殊符号，可以用在前面加上反斜杠，如反斜杠本身用\表示，句号.用.表示，以此类推。</p>
<p><strong>字符簇</strong><br>在INTERNET的程序中，正规表达式通常用来验证用户的输入。当用户提交一个FORM以后，要判断输入的电话号码、地址、EMAIL地址、信用卡号码等是否有效，用普通的基于字面的字符是不够的。<br>所以要用一种更自由的描述我们要的模式的办法，它就是字符簇。要建立一个表示所有元音字符的字符簇，就把所有的元音字符放在一个方括号里：</p>
<pre><code>[AaEeIiOoUu]
</code></pre><p>这个模式与任何元音字符匹配，但只能表示<strong>一个字符</strong>。用连字号可以表示一个字符的范围，如：</p>
<pre><code>[a-z] //匹配所有的小写字母
[A-Z] //匹配所有的大写字母
[a-zA-Z] //匹配所有的字母
[0-9] //匹配所有的数字
[0-9\.\-] //匹配所有的数字，句号和减号
[ \f\r\t\n] //匹配所有的白字符
</code></pre><p>同样的，这些也只表示<strong>一个字符</strong>，这是一个非常重要的。如果要匹配一个由一个小写字母和一位数字组成的字符串，比如”z2”、”t6”或”g7”，但不是”ab2”、”r2d3” 或”b52”的话，用这个模式：</p>
<pre><code>^[a-z][0-9]$
</code></pre><p>尽管[a-z]代表26个字母的范围，但在这里它只能与第一个字符是小写字母的字符串匹配。</p>
<p>前面曾经提到^表示字符串的开头，但它还有另外一个含义。当在一组方括号里使用^是，它表示”非”或”排除”的意思，常常用来剔除某个字符。还用前面的例子，我们要求第一个字符不能是数字：</p>
<pre><code>^[^0-9][0-9]$
</code></pre><p>这个模式与”&amp;5”、”g7”及”-2”是匹配的，但与”12”、”66”是不匹配的。下面是几个排除特定字符的例子：</p>
<pre><code>[^a-z] //除了小写字母以外的所有字符
[^\\\/\^] //除了(\)(/)(^)之外的所有字符
[^\&quot;\&apos;] //除了双引号(&quot;)和单引号(&apos;)之外的所有字符
</code></pre><p>特殊字符”.” (点，句号)在正规表达式中用来表示除了”新行”之外的所有字符。所以模式”^.5$”与任何两个字符的、以数字5结尾和以其他非”新行”字符开头的字符串匹配。模式”.”可以匹配任何字符串，除了空串和只包括一个”新行”的字符串。</p>
<p><strong>确定重复出现</strong><br>到现在为止，你已经知道如何去匹配一个字母或数字，但更多的情况下，可能要匹配一个单词或一组数字。一个单词有若干个字母组成，一组数字有若干个单数组成。跟在字符或字符簇后面的花括号({})用来确定前面的内容的重复出现的次数。</p>
<table>
<thead>
<tr>
<th style="text-align:right">字符簇</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">^[a-zA-Z_]$</td>
<td style="text-align:left">所有的字母和下划线</td>
</tr>
<tr>
<td style="text-align:right">^[[:alpha:]]{3}$</td>
<td style="text-align:left">所有的3个字母的单词</td>
</tr>
<tr>
<td style="text-align:right">^a$</td>
<td style="text-align:left">字母a</td>
</tr>
<tr>
<td style="text-align:right">^a{4}$</td>
<td style="text-align:left">aaaa</td>
</tr>
<tr>
<td style="text-align:right">^a{2,4}$</td>
<td style="text-align:left">aa,aaa或aaaa</td>
</tr>
<tr>
<td style="text-align:right">^a{1,3}$</td>
<td style="text-align:left">a,aa或aaa</td>
</tr>
<tr>
<td style="text-align:right">^a{2,}$</td>
<td style="text-align:left">包含多于两个a的字符串</td>
</tr>
<tr>
<td style="text-align:right">^a{2,}</td>
<td style="text-align:left">如：aardvark和aaab，但apple不行</td>
</tr>
<tr>
<td style="text-align:right">a{2,}</td>
<td style="text-align:left">如：baad和aaa，但Nantucket不行</td>
</tr>
<tr>
<td style="text-align:right">\t{2}</td>
<td style="text-align:left">两个制表符</td>
</tr>
<tr>
<td style="text-align:right">.{2}</td>
<td style="text-align:left">所有的两个字符</td>
</tr>
</tbody>
</table>
<p>这些例子描述了花括号的三种不同的用法。一个数字，{x}的意思是”前面的字符或字符簇只出现x次”；一个数字加逗号，{x,}的意思是”前面的内容出现x或更多的次数”；两个用逗号分隔的数字，{x,y}表示”前面的内容至少出现x次，但不超过y次”。我们可以把模式扩展到更多的单词或数字：</p>
<pre><code>^[a-zA-Z0-9_]{1,}$ //所有包含一个以上的字母、数字或下划线的字符串
^[0-9]{1,}$ //所有的正数
^\-{0,1}[0-9]{1,}$ //所有的整数
^\-{0,1}[0-9]{0,}\.{0,1}[0-9]{0,}$ //所有的小数
</code></pre><p>最后一个例子不太好理解，是吗？这么看吧：与所有以一个可选的负号(-{0,1})开头(^)、跟着0个或更多的数字([0-9]{0,})、和一个可选的小数点(.{0,1})再跟上0个或多个数字([0-9]{0,})，并且没有其他任何东西($)。下面你将知道能够使用的更为简单的方法。</p>
<p>特殊字符”?”与{0,1}是相等的，它们都代表着：”0个或1个前面的内容”或”前面的内容是可选的”。所以刚才的例子可以简化为：</p>
<pre><code>^\-?[0-9]{0,}\.?[0-9]{0,}$
</code></pre><p>特殊字符”*“与{0,}是相等的，它们都代表着”0个或多个前面的内容”。最后，字符”+”与 {1,}是相等的，表示”1个或多个前面的内容”，所以上面的4个例子可以写成：</p>
<pre><code>^[a-zA-Z0-9_]+$ //所有包含一个以上的字母、数字或下划线的字符串
^[0-9]+$ //所有的正数
^\-?[0-9]+$ //所有的整数
^\-?[0-9]*\.?[0-9]*$ //所有的小数
</code></pre><p>当然这并不能从技术上降低正规表达式的复杂性，但可以使它们更容易阅读。</p>
<h2 id="出处来自w3cschool还是挺好的"><a href="#出处来自w3cschool还是挺好的" class="headerlink" title="出处来自w3cschool还是挺好的"></a>出处来自w3cschool还是挺好的</h2><p><a href="https://www.w3cschool.cn/zhengzebiaodashi/" target="_blank" rel="external">https://www.w3cschool.cn/zhengzebiaodashi/</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/08/Java总结（十一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王邸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路要坚持">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/08/Java总结（十一）/" itemprop="url">Java总结（十一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-08T18:14:57+08:00">
                2019-09-08
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/09/08/Java总结（十一）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/09/08/Java总结（十一）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2019/09/08/Java总结（十一）/" class="leancloud_visitors" data-flag-title="Java总结（十一）">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从上周开始做项目，火烧火燎的做了项目。这是后端第一个项目，虽然没有用什么框架，手写的servlet，以及MVC的架构。总的来说这个是一个小项目。虽然 bug 不多，但是发现很多问题。这些问题，越早发现越好。而且这些问题我希望自己下次不再犯了。言归正传，这次总结，结合周总结进行总结。分为两个部分，一个部分是每天学习的知识，一个部分是项目开发的过程。</p>
<h2 id="学习知识部分："><a href="#学习知识部分：" class="headerlink" title="学习知识部分："></a>学习知识部分：</h2><h3 id="星期一（0902）"><a href="#星期一（0902）" class="headerlink" title="星期一（0902）"></a>星期一（0902）</h3><p>主要讲了两个知识点：跨域，模糊查询</p>
<h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p>这是属于前端的技术范畴，之前我也知道，前端常用有AJAX 等等方法，主要是解决不同域名+端口号的请求。为了安全考虑默认是不允许这样做的。但是在前后端分离的环境下，这个问题是无法避免。因为前后端肯定不是同一台电脑开发的，而且还要链接公司的内网，少不了就是跨域的问题。老师给了一个比较暴力的方法来解决这个问题：写了一个全局的filter 默认接收所有来源的请求，这样做当然不好。所有请求都放行肯定要拉闸的。所以一般设置一个配置文件放可以访问的域名。</p>
<pre><code>public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException {
    HttpServletRequest request = (HttpServletRequest) req;
    HttpServletResponse response = (HttpServletResponse) resp;
    request.setCharacterEncoding(&quot;utf-8&quot;);
    response.setContentType(&quot;application/json;charset=UTF-8&quot;);
    chain.doFilter(request, response);
    //这三个头与跨域访问有关，如果不设置，则访问不成功
    response.addHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);
    response.addHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST,GET,OPTIONS,PUT,DELETE&quot;);
    response.addHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;x-requested-with,Authorization,Content-Type&quot;);
}
</code></pre><h3 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h3><p>模糊查询的核心就是sql语句的拼接，其实我发现，这种做法不仅仅是模糊查询，而是最大程度上的复用了一个DAO的方法，只需要一个要求，就是这个方法的返回值是相同的，那么我传给他一个sql语句，一个语句的参数，我就能拿到我要的返回值，DAO就单纯的负责去给我CURD，岂不是美滋滋。话不多说直接上代码：<br>核心代码就是这样：sql语句拼接 + 存放参数的list<br>service:查询一个有pid的商品，模糊查询like 里面有一个价格范围内的商品。</p>
<pre><code>String sql = &quot;select * from product where 1 = 1 &quot;;
List&lt;Object&gt; list = new ArrayList&lt;&gt;();
if(!StringUtils.isEmpty(pid)){
  sql = sql + &quot; and pid = ? &quot;;
  list.add(Integer.parseInt(pid));
}
if(!StringUtils.isEmpty(pname)){
  //最好不要直接拼参数，防止sql注入
  sql += &quot; and pname like ?&quot;;
  list.add(&quot;%&quot;+ pname+ &quot;%&quot;);
}
if(!StringUtils.isEmpty(minprice)){
  sql += &quot; and estoreprice &gt; ? &quot;;
  list.add(Double.parseDouble(minprice));
}
if(!StringUtils.isEmpty(maxprice)){
  sql += &quot; and estoreprice &lt; ?&quot;;
  list.add(Double.parseDouble(maxprice));
}
return productDao.getSearchProducts(sql,list);
</code></pre><p>DAO:</p>
<pre><code>public List&lt;Product&gt; getSearchProducts(String sql, List&lt;Object&gt; list) throws SQLException {
  QueryRunner runner = new QueryRunner(DruidUtils.getDataSource());
  List&lt;Product&gt; products = runner.query(sql, new BeanListHandler&lt;Product&gt;(Product.class), list.toArray());
  return products;
}
</code></pre><p>这里还有一个点需要注意runner.query 和runner.update 是可以传可变参数的。而可变参数是什么？就是一个数组，所以才可以用list.toArray()去作为参数进行查找</p>
<h3 id="星期二（0903）"><a href="#星期二（0903）" class="headerlink" title="星期二（0903）"></a>星期二（0903）</h3><h3 id="权限控制filter"><a href="#权限控制filter" class="headerlink" title="权限控制filter"></a>权限控制filter</h3><p>后台接口的权限控制：<br>目前系统仅仅是前台页面有登录校验，但是如果直接访问接口，那么可以直接访问到所有的数据。接口系统中增加权限控制，session，登录时添加session，注销时清除session。但是因为我们是跨域的项目。默认情况是不允许带cookie，cookie只允许在安全的情况下才给用户带上。跨域就是一种不安全的操作，但是现在必须这样做，就没得办法了。需要在前，后端设置一些参数，<br><strong>注意事项：</strong>这个设置很容易使得前端向后端请求失败，因为经常忘记改这改那，要么可能发不出POST和GET请求，要么可能找不到服务器，等等。这里filter的设置一定要懂得filter的运行逻辑，老师上课演示写的不是很标准，并不能直接拿来用。<strong>总之要调好这个filter需要花一些时间，如果原理懂了就会快一些</strong></p>
<p><strong>前端配置</strong><br>在前端的axios的配置文件需要设置：<br>axios.js</p>
<pre><code>axios.defaults.withCredentials = true;
</code></pre><p><strong>后端配置</strong><br>filter的配置这里要注意几点：<br>1.options的请求必须要放行，只有options放行了浏览器才会发送对应的get，post的请求<br>2.发送请求的时候我们拦截，让这个请求不执行chain.doFilter(request, response);但是我们还是要让这个请求<strong>带上那些服务器的响应头</strong>的，这样浏览器才能正常的接收到服务器的响应，要不然浏览器接收时候会爆异常，并不能正确显示服务器传回给浏览器的信息。<br>3.filter的名字不能改，这个问题是我发现一个比较诡异的问题，修改里面的内容可以，但是不要refactor，是我太菜了，还不知道原因。如果要改，就必须在注解的地方不要写filterName,就只写那个url-pattern,例如：</p>
<pre><code>@WebFilter(filterName = &quot;GlobalFilter&quot;,urlPatterns = &quot;/api/admin/*&quot;)
</code></pre><p>写成：</p>
<pre><code>@WebFilter(urlPatterns = &quot;/api/admin/*&quot;)
</code></pre><p>就好了<br>4.设置完filter 服务器必须要重启一下，如果有问题建议把out目录下的文件全删了，给idea重新再导出一遍。<br>上代码：<br>//filter 注解</p>
<pre><code>@WebFilter(filterName = &quot;GlobalFilter&quot;,urlPatterns = &quot;/api/admin/*&quot;)
</code></pre><p> 实现Filter接口</p>
<pre><code>public class GlobalFilter implements Filter {
    public void destroy() {
    }

    //解决cookie问题
    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException {
        //跨域解决
        HttpServletRequest request = (HttpServletRequest) req;
        HttpServletResponse response = (HttpServletResponse) resp;
        request.setCharacterEncoding(&quot;utf-8&quot;);
        response.setContentType(&quot;application/json;charset=UTF-8&quot;);

        //给跨域带上cookie能使用会话
        if(&quot;GET&quot;.equals(request.getMethod()) || &quot;POST&quot;.equals(request.getMethod()) ){
            //获取一个会话，之后查看session scope里面是否有username
            HttpSession session = request.getSession();
            String requestURI = request.getRequestURI();
            //这一步用来替换掉前面的/api/admin
            requestURI = requestURI.replace(&quot;/api/admin/&quot;,&quot;&quot;);
</code></pre><p>//把需要直接放过的请求放在list中</p>
<pre><code>List&lt;String&gt; list = new ArrayList&lt;&gt;();
list.add(&quot;adminLogin&quot;);
list.add(&quot;goods/getType&quot;);
list.add(&quot;goods/imgUpload&quot;);

if(!list.contains(requestURI)){
    String username = (String) session.getAttribute(&quot;username&quot;);
    System.out.println(&quot;username &quot; + username);
    if(username == null){
        String message = &quot;你无权查看网页！&quot;;
        HttpUtils.resultError(message,response);
</code></pre><p>//注意！，就算是不放过，这里还是要设置响应头的，而不是直接return</p>
<pre><code>                    setResponseHeader(response);
                    return;
                }
            }
        }
        chain.doFilter(request, response);
        setResponseHeader(response);
    }

    void setResponseHeader(HttpServletResponse response) throws IOException {
        //这三个头与跨域访问有关，如果不设置，则访问不成功
        //配置文件获取origin
        InputStream resourceAsStream = GlobalFilter.class.getClassLoader().getResourceAsStream(&quot;main.properties&quot;);
        Properties properties = new Properties();
        properties.load(resourceAsStream);
        String origin = properties.getProperty(&quot;origin&quot;);
        response.addHeader(&quot;Access-Control-Allow-Origin&quot;, origin);
        response.addHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST,GET,OPTIONS,PUT,DELETE&quot;);
        response.addHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;x-requested-with,Authorization,Content-Type&quot;);
        response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);
    }
    public void init(FilterConfig config) throws ServletException {
    }
}
</code></pre><p>我觉得这样写，才能使得不管过没过滤都能给浏览器一个交代，过滤的请求直接return就会拉闸，浏览器啥也没有</p>
<h3 id="星期三（0904）"><a href="#星期三（0904）" class="headerlink" title="星期三（0904）"></a>星期三（0904）</h3><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>主要是学会看懂就行（我会单独写一篇文章来总结）<br><a href="https://www.w3cschool.cn/zhengzebiaodashi/" target="_blank" rel="external">https://www.w3cschool.cn/zhengzebiaodashi/</a></p>
<h3 id="星期四（0905）"><a href="#星期四（0905）" class="headerlink" title="星期四（0905）"></a>星期四（0905）</h3><h3 id="添加事务（-transation-）"><a href="#添加事务（-transation-）" class="headerlink" title="添加事务（ transation ）"></a>添加事务（ transation ）</h3><p>一个简单的例子：<br>在用户下订单的时候，如果出现网络不好情况，用户下单和商品的减少中间如果出现连接数据库异常，是不是就应该回滚到交易之前的状态。那么我们就应该引入事务的机制：要么都成功，要么都失败。一条船上的蚂蚱。<br><strong>引入事务的难点</strong>：要引入事务，我们使用连接池，就遇到一个难题，如何保证我们每次从连接池拿出来的connection都是同一个connection。<br>这里引入一个很重要的概念，听说之后spring也会用到：<strong> ThreadLocal </strong></p>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>简单理解就是一个thread里面的一个ThreadLocal对象，这个参数就只能在这个线程内使用，进入别的线程使用的就是别的线程的ThreadLocal对象。在主线程中创建的对象，就只能在主线程中使用，当你创建一个新的线程就不能使用。我的理解就是一个类似<strong>线程域</strong>的东西。</p>
<h3 id="使用ThreadLocal"><a href="#使用ThreadLocal" class="headerlink" title="使用ThreadLocal"></a>使用ThreadLocal</h3><p>就两个方法get()  set()方法。</p>
<pre><code>public static void main(String[] args) {
  ThreadLocal&lt;String&gt; threadlocal = new ThreadLocal&lt;&gt;();
  threadLocal.set(&quot;zhangshan&quot;);
  System.out.println(threadLocal.get()); //zhangshan
}
</code></pre><p>我们去看看源码：<br>ThreadLocal.java</p>
<pre><code>/**
 * Returns the value in the current thread&apos;s copy of this
 * thread-local variable.  If the variable has no value for the
 * current thread, it is first initialized to the value returned
 * by an invocation of the {@link #initialValue} method.
 *
 * 返回一个目前线程的一个变量的值，如果没有值就通过initialValue方法初始化一个值
 * @return the current thread&apos;s value of this thread-local
 */
public T get() {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            @SuppressWarnings(&quot;unchecked&quot;)
            T result = (T)e.value;
            return result;
        }
    }
    return setInitialValue();
}
</code></pre><p>首先获取一个ThreadLocalMap，去里面通过this 这个key 去找value值。<br>再看看set方法：</p>
<pre><code>public void set(T value) {
  Thread t = Thread.currentThread();
  ThreadLocalMap map = getMap(t);
  if (map != null)
      map.set(this, value);
  else
      createMap(t, value);
}
ThreadLocalMap getMap(Thread t) {
    return t.threadLocals;
}
/* ThreadLocal values 存在 to this thread. This map is maintained
 * by the ThreadLocal class. */
ThreadLocal.ThreadLocalMap threadLocals = null;
</code></pre><p>和get方法类似，我们可以先获取到一个threadLocalMap对象，然后设置key,value。 this就是key，value就是我们要存的值。<br>这里都使用了Thread的一个静态方法：</p>
<pre><code>Thread t = Thread.currentThread();
</code></pre><p>我们并不陌生，之前要找当前线程的时候，经常用这个方法去找当前的线程。每一个线程有自己的threadLocalMap ,里面放了你这个线程你创建的threadLocal 对象，里面保存了值。当然一个线程可以创建多个threadLocal。</p>
<h3 id="加入到我们的项目"><a href="#加入到我们的项目" class="headerlink" title="加入到我们的项目"></a>加入到我们的项目</h3><p>在druidUtil中加入ThreadLocal存放connection</p>
<pre><code>public class DruidUtils {
    private static DataSource dataSource;
    private static ThreadLocal&lt;Connection&gt; threadLocal = new ThreadLocal&lt;&gt;();
    static {
        //dataSource = new DruidDataSource();
        InputStream resourceAsStream = DruidUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);
        Properties properties = new Properties();
        try {
            properties.load(resourceAsStream);
            dataSource = new DruidDataSourceFactory().createDataSource(properties);
        } catch (IOException e) {
            e.printStackTrace();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    public static Connection getConnection() throws SQLException {
        return dataSource.getConnection();
    }
</code></pre><p>当我们需要开启事务使用同一个connection的时候flag给true：</p>
<pre><code>/**
 * flag表示是否开启事务，true表示开启事务
 * @param flag
 * @return
 */
public static Connection getConnection(boolean flag) throws SQLException {
    if(flag){
        Connection connection = threadLocal.get();
        //如果是null，表示第一次，那么要放入ThreadLocal中
        if(connection == null){
            connection = getConnection();
            threadLocal.set(connection);
        }
        return connection;
    }
    return getConnection();
}

public static DataSource getDataSource(){
    return dataSource;
}
</code></pre><p>我们发现这里多了这个方法，这个方法也是我们加上的，还记得如果我们自己手动写的connection在调用runner.query 和 runner.update的时候不会帮我们关connection吗？所以我们需要自己关connection.<strong>但是</strong>这里又有新的问题：我们关掉之前用的connection,第二次用的时候怎么办？第二次再取出来已经关闭的connectin，根本用不了。所以我们要采取措施：<br><strong>每次用完把threadLocal.set(null)</strong>这样就把threadLocal里的connection置为null,下次事务使用connection时又和第一次一样。这就好像前端canvas每次使用完画布需要把画布清空一样。不影响下次的使用。</p>
<pre><code>    public static void setThreadLocalIsNull(){
        threadLocal.set(null);
    }
}
</code></pre><h3 id="一个关于事务的坑"><a href="#一个关于事务的坑" class="headerlink" title="一个关于事务的坑"></a>一个关于事务的坑</h3><p>这里有一个事务的坑，一开始我以为是我逻辑错了，打断点之后发现取数据的时候出现了问题。这个问题之前没有遇过，还是一个很幼稚的问题，还是我太年轻了。不够努力学习：这个坑就是取数据的问题。因为我需要获得刚刚插入数据的id值，在存另一张表时候，需要把这个值也放在另一张表中。后来我发现<strong>另一张表存的并不是这个刚插入数据的id。而是上一条的id</strong>。之后debug发现，开启事务之后，数据并不会马上插入到数据库中，需要等事务提交才会放到数据库中。所以取出来的数据就有问题。那么就想解决办法：<br><strong>方法一</strong>：在取出来的id+1。这个方法看起来很方便，但是这里有一个问题，如果前一条数据被删了，你获取的id就是上上条数据的id 然后再+1，就是上一条数据的id.那么这个肯定是错的，因为那个id表示的是你之前删除的数据的id。另一张表存的是删除数据的id,明显不行。<br><strong>方法二</strong>：把插入第一张表的操作放在事务开始之前，然后到最后，如果需要事务的回滚，再把这条数据从数据库中删掉。这个方法我最后采用的方法，感觉还是有点蠢，但是不会依赖其他的数据。</p>
<h3 id="星期五（0906）"><a href="#星期五（0906）" class="headerlink" title="星期五（0906）"></a>星期五（0906）</h3><p>拉闸,出去玩了一天，没有写代码的一天，感觉手生。</p>
<h3 id="星期六（0907）"><a href="#星期六（0907）" class="headerlink" title="星期六（0907）"></a>星期六（0907）</h3><p>今天讲的就是一些MAVEN的东西<br>maven 的核心就是：</p>
<p>1、项目构建<br>2、依赖管理(重点)</p>
<p>最核心的思想其实就是<strong>解耦</strong>其他都没什么好说的，学到再说。今天讲的知识，没有代码很难讲的生动</p>
<h2 id="实战部分："><a href="#实战部分：" class="headerlink" title="实战部分："></a>实战部分：</h2><h3 id="星期日（0901）"><a href="#星期日（0901）" class="headerlink" title="星期日（0901）"></a>星期日（0901）</h3><p>内容：<br>完成商品管理，留言功能（完成）</p>
<p>总结：<br>1.请求处理乱码问题<br>那个处理请求的工具有问题设置：vmoption:-Dfile.encoding=UTF-8</p>
<p>2.servlet报错问题：<br> org.apache.catalina.core.ContainerBase.addChildInternal ContainerBase.addChild: start:<br> org.apache.catalina.LifecycleException: Failed to start component [StandardEngine[Catalina].StandardHost[localhost].StandardContext[]]<br> 设置了两个相同的url-pattern 所以会报错</p>
<p>3.mysql 注意关键字一定要加: `` ，规范是每个字段的名字都要加``</p>
<pre><code>String sql = &quot;update addGoods set name = ?, typeId = ?, img = ?, `desc` = ? where id = ?&quot;;
</code></pre><p>4 ResultSetHandler的总结</p>
<p><a href="https://blog.csdn.net/qq_37796017/article/details/78032605" target="_blank" rel="external">出处</a><br><strong>1.BeanListHandler:返回值  List<t></t></strong><br>       (适合取多条数据)把查询到的每一条结果封装成实体类，再最终把每一个实体类放到list集合中<br><strong>2.BeanHanlder:返回值  T</strong><br>    (适合取单条数据) 把查询到的一条结果封装成实体类。</p>
<p><strong>3.ArrayHandler: 返回值：  Object[]</strong><br>   (适合取单条数据) 把查询的一条结果值依次封装到一个对象数组中。object[]<br><strong>4.ArrayListHandler:返回值：  List<object[]></object[]></strong><br>(适合取多条数据) 把查询的一条结果值依次封装到一个对象数组中。再最终把对象数组依次放入到list集合中。</p>
<p><strong>5.MapHandler:   返回值：  Map<string,object></string,object></strong><br>     (适合取单条数据)把查询到的结果以键值对的形式进行封装，封装的时候列名是map的键，值就是map的值<br><strong>6.MapListHandler: 返回值：  List<map<string,object>&gt;</map<string,object></strong><br>   (适合取多条数据)把查询到的结果以键值对的形式进行封装，封装的时候列名是map的键，值就是map的值,<br>最终把每一条数据封装到list中</p>
<p><strong>7.ColumnListHandler: 返回值：List<object></object></strong><br>取出某一列的数据存储到list集合<br>三种取法：根据结果集的形式来决定sql语句如何写：<br>第一种：推荐</p>
<pre><code>ColumnListHandler()   : sql：select 具体的列名 from 表名
</code></pre><p>第二种：</p>
<pre><code>ColumnListHandler(列的位置int)   sql：   select * from 表名
</code></pre><p>第三种：</p>
<pre><code>ColumnListHandler(列的名称)       sql：   select * from 表名
</code></pre><p><strong>8.ScalarHandler:适合于取单行单列的数据</strong></p>
<p><strong>9.KeyedHandler:返回值是Map<object,map<string,object></object,map<string,object></strong><br>把每一条查到的结果封装，把这条数据对应的列名当作map的键存入，把这条数据对应的列的值当作map的value存储，在把每一条的数据再次存入到map中，把该条数据的唯一表示id当作键存储，这条数据的map当作外层map的value存入<br>最后一个说起来有点绕，还是上代码吧：</p>
<pre><code>@Test
public void KeyedHandler() throws SQLException {
  QueryRunner queryRunner = new QueryRunner(C3P0Utils.getDataSource());
  String sql=&quot;select * from user&quot;;
  //查询结果： 把每一条查到的结果封装，把这条数据对应的列名当作map的键存入，把这条数据对应的列的值当作map的value存储，
 //          在把每一条的数据再次存入到map中，把该条数据的唯一表示id当作键存储，这条数据的map当作外层map的value存入
  Map&lt;Object, Map&lt;String, Object&gt;&gt;   map = queryRunner.query(sql, new KeyedHandler());
   for (Map.Entry&lt;Object, Map&lt;String, Object&gt;&gt; m : map.entrySet()) {
     Object object  = m.getKey();
     System.out.println(&quot;===&quot;+object); //每一条数据的id
     Map&lt;String, Object&gt; m1 = m.getValue();
     for (Map.Entry&lt;String, Object&gt; m2 : m1.entrySet()) {
         //key:列名  value:列的值
         System.out.println(&quot;=qqqqqq=&quot;+m2.getKey()+&quot;==&quot;+m2.getValue());
      }
    }
}
</code></pre><p><strong>必须掌握： BeanHandler  ,BeanListHandler ,ColumnListHandler,  ScalarHandler</strong></p>
<h3 id="星期一（0902）-1"><a href="#星期一（0902）-1" class="headerlink" title="星期一（0902）"></a>星期一（0902）</h3><p><strong>内容：</strong><br>1.把img的域名写成配置文件（完成）<br>2.添加商品，保存最低价，和总的库存（完成）<br>3.修改商品显示之前的图片<br>4.完成订单管理（完成）<br>5.修改商品添加规格有bug</p>
<p><strong>问题</strong><br>1.double转int出错<br>java.lang.ClassCastException: java.lang.Double cannot be cast to java.lang.Integer<br>从map拿到前端传过来的json,用gson接收转成map，id是double类型，而且这个double不能转型还会报错。<br>原来还想   Value.of(id.toString);后来发现还是不行，<br>不管强转什么类型都会报错。</p>
<p>原因：通过打断点发现：Gson 转换过来的map,他默认会把类型转成最大范围的类型,数字就是double,map获取double 然后先强转double 再强转成int例如：</p>
<pre><code>int state = (int)(double) map.get(&quot;state&quot;); //  订单状态全部订单-1
</code></pre><h3 id="星期二（0903）-1"><a href="#星期二（0903）-1" class="headerlink" title="星期二（0903）"></a>星期二（0903）</h3><p>昨天问题：<br>3.修改商品显示之前的图片 （完成）<br>5.修改商品添加规格有bug (完成)</p>
<p>今天任务：<br>1.代码大改（把数据处理从dao层抽离到sevice层）<br>2.解决前后端跨域带cookie问题<br>但是出现新的问题，图片上传也被拦截，尝试直接把图片放行，最后解决由老师修改代码使用axios上传图片<br>3.评估前台功能需要的接口</p>
<pre><code>1.用户模块
2.购物车模块
3.订单模块
4.商品详情模块
5.filter
</code></pre><p>总结：<br>1.报错<br> Cannot create com.cskaoyan.model.SpecList: com.cskaoyan.model.SpecList Query: select * from specList where gid = ?<br>这是由于我之前突然写了一个带参数的构造函数，但是没有设置默认构造函数造成的。所以出现这个问题由于没有给bean设置默认构造函数的问题。记得自己必须提供一个不带参数的构造方法</p>
<p>2.跨域可以让请求带cookie<br>1.在vue的配置文件中加：<br>axios.defaults.withCredentials = true;</p>
<p>2.在自己的filter上加：<br>//配置文件中取出能通过的IP</p>
<pre><code>InputStream resourceAsStream = GlobalFilter.class.getClassLoader().getResourceAsStream(&quot;main.properties&quot;);
Properties properties = new Properties();
properties.load(resourceAsStream);
String origin = properties.getProperty(&quot;origin&quot;);

response.addHeader(&quot;Access-Control-Allow-Origin&quot;, origin);
response.addHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST,GET,OPTIONS,PUT,DELETE&quot;);
response.addHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;x-requested-with,Authorization,Content-Type&quot;);
response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);
</code></pre><p><strong>注意事项</strong>当你发现有时候只有OPTION没有GET POST 大概率是这里的问题，看看是没有加axios还是后端的问题</p>
<p>3.需要查哪个表的数据，就调用对应的DAO，而不要使用别的service去走自己的DAO取数据。而用对应的DAO去找数据。这样在不同的service还能复用我们的dao的方法。这里我建议每个表都写两个方法:</p>
<pre><code>一个是:getXXXById(int id) 通过id获取你的数据
一个是:getXXX(String sql, list&lt;Object&gt; parameter)通过你自己写的sql去获取数据
</code></pre><p>当然不是最好的，只是我觉得这复用比较多。</p>
<h3 id="星期三（0904）-1"><a href="#星期三（0904）-1" class="headerlink" title="星期三（0904）"></a>星期三（0904）</h3><p>1.servlet的改名问题，<br>会出现前端找不到servlet的情况，把servlet的name去掉就好了。应该是没有更新新的name问题，写成这样就好了</p>
<pre><code>@WebServlet(urlPatterns = &quot;/api/user/user/*&quot;)
</code></pre><p>2.有问题 goodsDetailId 是 specList 的Id 还有东西要大改（MMP）</p>
<p>3.应该把传回给前端的 bean 和 数据库接收的 bean 分开！！！快做完的时候，我自己总结发现的。这样后端自己get给前端拼，美滋滋。</p>
<p>4.java.sql.SQLException: Cannot set goods: incompatible types. Query: select * from userOrder where 1 = 1  AND userId = ?  Parameters: [1]<br>注意自己new beanListHandler接收的类是否都全部正确 可能一个是string 一个是object</p>
<h3 id="星期四（0905）-1"><a href="#星期四（0905）-1" class="headerlink" title="星期四（0905）"></a>星期四（0905）</h3><p>1.问题<br>对于filter直接return的问题，不能是直接判断完filter不给进就return 这样后面设置跨域的也没有执行，那么response信息就没有拿到，直接就vue catch报错了，所以不要轻易在跨域设置之前return<br>2.IDEA如何查看哪里调用这个函数：鼠标右键 Find Usage 。或者使用快捷键 Alt + f7;<br>3.VUE 自适应显示img的问题，vue显示如何使得图片不管是长比宽大还是宽比长大都能自定义显示。</p>
<h3 id="星期五（0906）-1"><a href="#星期五（0906）-1" class="headerlink" title="星期五（0906）"></a>星期五（0906）</h3><p>1.在数据库选择字段之前，要确定好表之间的关系</p>
<p>2.display实现过渡效果<br><a href="https://blog.csdn.net/longyin0528/article/details/81212137" target="_blank" rel="external">https://blog.csdn.net/longyin0528/article/details/81212137</a></p>
<p>3.首页轮播图默认做法是直接修改透明度的方法，但是我要加上跳转，一开始发现不管换那张照片显示都是最后一张照片的链接。这很难受，我就吧opacity改成了display的属性来控制，后来我发现，display的效果又不能有过渡效果了，正在焦头烂额之际我想到了一个方法，使用z-index 和 opacity连用 效果极佳！</p>
<pre><code>&lt;div class=&quot;swiperItem&quot; v-for=&quot;(item,index) in len&quot; :style=&quot;{opacity:curIndex===index?1:0, zIndex:curIndex===index?1:0}&quot;&gt;
  &lt;slot :name=&quot;&apos;item&apos;+(index+1)&quot;&gt;&lt;/slot&gt;
&lt;/div&gt;
</code></pre><p>但是这时候要注意，其他的部分按钮可能会被盖到图片下面，所以要设置其他按钮的z-index要比图片高，而且注意有些属性会使得z-index失效。切记。</p>
<p>4.添加功能<br>商品管理在添加商品时，默认选择点击对应类目的商品<br>在跳转的URL后面添加参数：</p>
<pre><code>&lt;div class=&quot;addGoods&quot; @click=&quot;navTo(&apos;/backstage/goods/new?typeId=&apos; + curTypeId)&quot;&gt;
</code></pre><p>在页面使用路由获取<br>在跳转页面mounted中设置初始化一下</p>
<pre><code>mounted(){
   this.getTypes();
   this.initTypeId = this.$route.query.typeId;
   //初始化的type给到当前type
   this.temTypeId = this.initTypeId;
</code></pre><p>this.$route还是有挺多参数的，要设置URL可以试试</p>
<h3 id="星期六（0907）-1"><a href="#星期六（0907）-1" class="headerlink" title="星期六（0907）"></a>星期六（0907）</h3><p>1 优化图片显示<br>图片使用了绝对定位，发现container并不能装得下图片。所以要给container的div一个position:relative;这样img就相对于你设置的container布局了。默认会找到第一个position不是static的父类去布局。</p>
<p>2.关于事务的问题，这里有一个问题，我的业务逻辑需要获取最近的数据的时候，我发现我总是获取不到。因为我开了事务，所以实际上数据还没有存到数据中，拿到的是上一次的存放的最后一条数据。所以这里就使得数据不能同步而报错。也不能把拿到的id默认加一就是插入的数据。因为中间如果有删除数据，也会发现拿错数据的情况。我的解决办法就是把要插入的数据放事务外面。如果出现回滚，在回滚之前，把插入的数据删了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="总结的心得"><a href="#总结的心得" class="headerlink" title="总结的心得"></a>总结的心得</h3><p>总之，这个礼拜一直都在做项目，而且睡的时间也少。主要运动少了，缺少了一点该有的生气。而且做得也焦虑，不断的发现问题，不断的大改。到达一定阶段就发现再改也来不及了。但是这算吸取了经验。<br>1）<strong>准备</strong>。做项目之前一定要想清楚应该怎么写，而不是上去就开始干controller,service,dom。没想清楚怎么写，到最后花更多的时间去重构，例如：之前说的不要把所有要处理的逻辑都写在dao层，这样dao层的东西还不能复用。又例如应该把要传给前端的bean和从数据库取出数据的bean分开，这样更高效的去传输数据，不管字段是什么，就算前后端不同，也能够传递。还有就是数据库的字段问题，为了方便设计了多张表，但是多张表出现了重复的字段，这就不够优雅了，不符合数据库的三大范式。因为项目经验不足，而且时间紧迫，所以出现了很多感觉不该出现的问题，下次写项目之前一定要好好想清楚。</p>
<p>2）<strong>计划</strong>做项目一定要清楚自己的任务，每天一定要有计划，而不是慢慢悠悠的写。这样到最后肯定拉闸，时间不够用。虽然我在规定时间完成了但事实上我感觉虽然没有什么东西，却已经花了太多的时间在写逻辑上。</p>
<p>3）<strong>思考</strong>做项目时要多思考，多发现问题，我发现很容易就陷入一个误区，认为所有的业务代码写法都一样。也许时间不够，忽略了每个接口之间的不同，虽然说功能的实现可能没有问题。但是代码显得更加臃肿，我们前端讲究的就是代码的优雅，当然现在做了后端，代码风格也需要更加优雅才行。</p>
<h3 id="总结的技术"><a href="#总结的技术" class="headerlink" title="总结的技术"></a>总结的技术</h3><p>技术来说，这个项目太太太简单了。并没有什么技术上的难点，后端就是CRUD，前端就是展示一些数据，一些交互。算是初步了解了一个JavaEE的项目应该要实现哪些功能，以及如何实现的问题。接下来我将分几个部分进行总结：</p>
<h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p>前端使用的是VUE，虽然马上进入4.0，但是两年前从2.0刚出来开始我就开始玩了，那时候VUE还没有那么火，也只是自学的阶段公司当时使用的还是微信的框架，还有jquery之类的东西。自学就发现VUE还是非常非常好用的。两年过去了虽然基础语法没怎么改变，但是现在的VUE，感觉更加方便，更加快速的去构建项目（虽然以前也挺快的）。没得说，VUE配合element-ui可以更快速的构建一个我们需要的项目。而axios能够更方便的负责前端像后端传输数据，而bus和vuex也能够让前端的数据的共享，上升到一个新的层次。当然这些都是之前学过的，通过项目重新在复习一遍，美滋滋。</p>
<h3 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h3><h3 id="CREATE"><a href="#CREATE" class="headerlink" title="CREATE"></a>CREATE</h3><p>创建当然是最关键的部分，一个数据库表的设计就决定了存取是否高效。当然最基础的就是要满足三大范式。我TM就知道你三大范式已经忘了，还好我还记得放在了哪里：</p>
<h3 id="数据库三大范式"><a href="#数据库三大范式" class="headerlink" title="数据库三大范式"></a>数据库三大范式</h3><h3 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h3><p>每列应当保证原子性。即不可以再进行分割。<br>比如收货地址这列，就不是原子性的，如果需要经常统计到省份或者城市信息，则该列的设计就不符合第一范式的要求，仍然可以进一步拆分为省份，城市。。。。</p>
<h3 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h3><p>表：学号、课程号、姓名、学分;<br>学分依赖课程，姓名依赖学号</p>
<p>这个时候，如果删除一条学分数据，会导致相应的课程数据也会被删除。同时这张表还存在数据冗余的情况。<br>如果数据存在部分依赖的情形，需要将字段进行拆分，拆成多个表。这样删除一个数据时，就不会把其他的需要的数据项删除，<br><strong>注意</strong> 这里说的删数据是删一条数据，而不是删除一列，列是一个字段，字段一般不能删除。最好把依赖的字段分成两个表<br>需要重新拆分表：<br>学生表：学号、姓名<br>课程表：课程号<br>选课表：课程号、学号、学分</p>
<h3 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h3><p>不要存在冗余数据，虽然说可能有潜在的关系，但是最好使用外链关系起来，而不是放在一起<br>只有一张表: 学号, 姓名, 年龄, 学院名称, 学院电话，虽然说学院电话和学生有那么一点关系，但是放一起就冗余了。</p>
<p>学生表：学号、姓名、年龄、学院号<br>学院表：学院名称、学院电话、学院号<br>每一张表在设计的时候，都应该遵循着，只关注最小的一块功能，如统计学生信息，就仅停留在学生信息中，不要过多去延伸。分工而治的思想</p>
<p>在来说回创建，如果满足了这三个范式我觉得应该没什么问题了</p>
<h3 id="READ"><a href="#READ" class="headerlink" title="READ"></a>READ</h3><p>读数据就按上面 resultSetHandler 的那几个类去取数据就好了，拿出来然后再做处理。</p>
<h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p>如果要问CRUD最难的是哪部分，现阶段我觉得最难的还是删除，为什么？因为我把他放在了Update的前面，自然说明很重要。因为表和表之前不可能是独立的，表和表之前肯定有一定的关系关联起来的，要么是外键，要么是有相同的字段。举一个例子，就拿我们的项目说，如果我要删除一个物品，那么我不仅需要删除这个商品，而且还要删除这个商品的规格，这个商品的订单，商品的评分，商品下的问答。那么删除表就显得尤为的困难了，因为删除表，必须要对整个数据库有完整的了解，知道那些该删除，哪些不该删除。</p>
<h3 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h3><p>同样的更新数据库，就是对数据库里的一条数据进行修改，那么是否会影响其他的数据？这是肯定的，但是相比较删除来说，这个更容易去实现一些，因为不一定所有的有关系的数据都要修改。就举个例子，就好像一个图，就以无相图为例，我要删除一个结点，那么我必须要把所有和这个结点联通的结点都要删除。这样才不会有脏数据产生。但是要update一个数据，不一定所有联通的结点都要update。</p>
<h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>这个项目我打算是学完spring框架之后，再来重构这个项目，所以我打算再把前端完善一下，实现一些功能，之后配合后端使用spring。代码一定要多写，写多了就会了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/03/jsp初探/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王邸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路要坚持">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/03/jsp初探/" itemprop="url">jsp初探</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-03T08:45:57+08:00">
                2019-09-03
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/09/03/jsp初探/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/09/03/jsp初探/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2019/09/03/jsp初探/" class="leancloud_visitors" data-flag-title="jsp初探">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>这里先对JSP的最基本的语法做概述，基础当然重中之重，所以必须要掌握清楚。不然真的看不懂JSP。</p>
<h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><p>脚本程序可以包含任意量的Java语句、变量、方法或表达式，只要它们在脚本语言中是有效的。脚本程序的语法格式：</p>
<pre><code>&lt;% 代码片段 %&gt;
</code></pre><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>一个JSP表达式中包含的脚本语言表达式，先被转化成String，然后插入到表达式出现的地方。<br>由于表达式的值会被转化成String，所以您可以在一个文本行中使用表达式而不用去管它是否是HTML标签。<br>表达式元素中可以包含任何符合Java语言规范的表达式，但是不能使用<strong>分号</strong>来结束表达式。<br>JSP表达式的语法格式：</p>
<pre><code>&lt;%= 表达式 %&gt;
</code></pre><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>一个声明语句可以声明一个或多个变量、方法，供后面的Java代码使用。在JSP文件中，您必须先声明这些变量和方法然后才能使用它们。<br>JSP声明的语法格式：</p>
<pre><code>&lt;%! declaration; [ declaration; ]+ ... %&gt;
</code></pre><h3 id="JSP注释"><a href="#JSP注释" class="headerlink" title="JSP注释"></a>JSP注释</h3><table>
<thead>
<tr>
<th style="text-align:right">语法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">&lt;%-- 注释 --%&gt;</td>
<td style="text-align:left">JSP注释，注释内容不会被发送至浏览器甚至不会被编译</td>
</tr>
<tr>
<td style="text-align:right">&lt;!-- 注释 --&gt;</td>
<td style="text-align:left">HTML注释，通过浏览器查看网页源代码时可以看见注释内容</td>
</tr>
<tr>
<td style="text-align:right">&lt;\%</td>
<td style="text-align:left">代表静态 &lt;%常量</td>
</tr>
<tr>
<td style="text-align:right">%></td>
<td style="text-align:left">代表静态 %&gt; 常量</td>
</tr>
<tr>
<td style="text-align:right">\’</td>
<td style="text-align:left">在属性中使用的单引号</td>
</tr>
<tr>
<td style="text-align:right">\”</td>
<td style="text-align:left">在属性中使用的双引号</td>
</tr>
</tbody>
</table>
<h3 id="JSP指令"><a href="#JSP指令" class="headerlink" title="JSP指令"></a>JSP指令</h3><p>JSP指令用来设置与整个JSP页面相关的属性。<br>JSP指令语法格式：</p>
<pre><code>&lt;%@ directive attribute=&quot;value&quot; %&gt;
</code></pre><p>这里有三种指令标签：</p>
<table>
<thead>
<tr>
<th style="text-align:right">指令</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">&lt;%@ page … %&gt;</td>
<td style="text-align:left">定义页面的依赖属性，比如脚本语言、error页面、缓存需求等等</td>
</tr>
<tr>
<td style="text-align:right">&lt;%@ include … %&gt;</td>
<td style="text-align:left">包含其他文件</td>
</tr>
<tr>
<td style="text-align:right">&lt;%@ taglib … %&gt;</td>
<td style="text-align:left">引入标签库的定义，可以是自定义标签</td>
</tr>
</tbody>
</table>
<h3 id="JSP行为（动作元素）"><a href="#JSP行为（动作元素）" class="headerlink" title="JSP行为（动作元素）"></a>JSP行为（动作元素）</h3><p>JSP行为标签使用XML语法结构来控制servlet引擎。它能够动态插入一个文件，重用JavaBean组件，引导用户去另一个页面，为Java插件产生相关的HTML等等。<br>行为标签只有一种语法格式，它严格遵守XML标准：</p>
<pre><code>&lt;jsp:action_name attribute=&quot;value&quot; /&gt;
</code></pre><p>行为标签基本上是一些预先就定义好的函数，下表罗列出了一些可用的JSP行为标签：：</p>
<table>
<thead>
<tr>
<th style="text-align:right">语法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">jsp:include</td>
<td style="text-align:left">用于在当前页面中包含静态或动态资源</td>
</tr>
<tr>
<td style="text-align:right">jsp:useBean</td>
<td style="text-align:left">寻找和初始化一个JavaBean组件</td>
</tr>
<tr>
<td style="text-align:right">jsp:setProperty</td>
<td style="text-align:left">设置 JavaBean组件的值</td>
</tr>
<tr>
<td style="text-align:right">jsp:getProperty</td>
<td style="text-align:left">将 JavaBean组件的值插入到 output中</td>
</tr>
<tr>
<td style="text-align:right">jsp:forward</td>
<td style="text-align:left">从一个JSP文件向另一个文件传递一个包含用户请求的request对象</td>
</tr>
<tr>
<td style="text-align:right">jsp:plugin</td>
<td style="text-align:left">用于在生成的HTML页面中包含Applet和JavaBean对象</td>
</tr>
<tr>
<td style="text-align:right">jsp:element</td>
<td style="text-align:left">动态创建一个XML元素</td>
</tr>
<tr>
<td style="text-align:right">jsp:attribute</td>
<td style="text-align:left">定义动态创建的XML元素的属性</td>
</tr>
<tr>
<td style="text-align:right">jsp:body</td>
<td style="text-align:left">定义动态创建的XML元素的主体</td>
</tr>
<tr>
<td style="text-align:right">jsp:text</td>
<td style="text-align:left">用于封装模板数据</td>
</tr>
</tbody>
</table>
<h3 id="JSP隐含对象"><a href="#JSP隐含对象" class="headerlink" title="JSP隐含对象"></a>JSP隐含对象</h3><p>JSP支持九个自动定义的变量，江湖人称隐含对象。这九个隐含对象的简介见下表：</p>
<table>
<thead>
<tr>
<th style="text-align:right">对象</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">request</td>
<td style="text-align:left">HttpServletRequest类的实例</td>
</tr>
<tr>
<td style="text-align:right">response</td>
<td style="text-align:left">HttpServletResponse类的实例</td>
</tr>
<tr>
<td style="text-align:right">out</td>
<td style="text-align:left">PrintWriter类的实例，用于把结果输出至网页上</td>
</tr>
<tr>
<td style="text-align:right">session</td>
<td style="text-align:left">HttpSession类的实例</td>
</tr>
<tr>
<td style="text-align:right">application</td>
<td style="text-align:left">ServletContext类的实例，与应用上下文有关</td>
</tr>
<tr>
<td style="text-align:right">config</td>
<td style="text-align:left">ServletConfig类的实例</td>
</tr>
<tr>
<td style="text-align:right">pageContext</td>
<td style="text-align:left">PageContext类的实例，提供对JSP页面所有对象以及命名空间的访问</td>
</tr>
<tr>
<td style="text-align:right">page</td>
<td style="text-align:left">类似于Java类中的this关键字</td>
</tr>
<tr>
<td style="text-align:right">Exception</td>
<td style="text-align:left">Exception类的对象，代表发生错误的JSP页面中对应的异常对象</td>
</tr>
</tbody>
</table>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>指令可以有很多个属性，它们以键值对的形式存在，并用逗号隔开（明明就是空格隔开的）。</p>
<h3 id="Page指令"><a href="#Page指令" class="headerlink" title="Page指令"></a>Page指令</h3><p>Page指令为容器提供当前页面的使用说明。一个JSP页面可以包含多个page指令。<br>Page指令的语法格式：</p>
<pre><code>&lt;%@ page attribute=&quot;value&quot; %&gt;
</code></pre><p>等价的XML格式：</p>
<pre><code>&lt;jsp:directive.page attribute=&quot;value&quot; /&gt;
</code></pre><p>例子：</p>
<pre><code>&lt;%@page autoFlush=&quot;false&quot; buffer=&quot;none&quot; info=&quot;asd&quot; %&gt;
</code></pre><h3 id="Include指令"><a href="#Include指令" class="headerlink" title="Include指令"></a>Include指令</h3><p>JSP可以通过include指令来包含其他文件。被包含的文件可以是JSP文件、HTML文件或文本文件。包含的文件就好像是该JSP文件的一部分，会被同时编译执行。</p>
<pre><code>&lt;%@ include file=&quot;relative url&quot; %&gt;
</code></pre><h3 id="Taglib指令"><a href="#Taglib指令" class="headerlink" title="Taglib指令"></a>Taglib指令</h3><p>JSP API允许用户自定义标签，一个自定义标签库就是自定义标签的集合。<br>Taglib指令引入一个自定义标签集合的定义，包括库路径、自定义标签。<br>Taglib指令的语法：</p>
<pre><code>&lt;%@ taglib uri=&quot;uri&quot; prefix=&quot;prefixOfTag&quot; %&gt;
</code></pre><p>uri属性确定标签库的位置，prefix属性指定标签库的前缀。</p>
<h2 id="注"><a href="#注" class="headerlink" title="注"></a>注</h2><p>我发现JSP的教程很多都是servlet内容，不管是过滤器还是处理请求和相应。因为jsp本质就是servlet。他会先转成一个servlet的java文件，然后再编译，再去执行。所以很多东西都和servlet是类似的。接下来才是真东西，学习一些JSP的高级的用法</p>
<h3 id="JSP-标准标签库（JSTL）"><a href="#JSP-标准标签库（JSTL）" class="headerlink" title="JSP 标准标签库（JSTL）"></a>JSP 标准标签库（JSTL）</h3><p>JSP标准标签库（JSTL）是一个JSP标签集合，它封装了JSP应用的通用核心功能。<br>JSTL支持通用的、结构化的任务，比如迭代，条件判断，XML文档操作，国际化标签，SQL标签。 除了这些，它还提供了一个框架来使用集成JSTL的自定义标签。<br>根据JSTL标签所提供的功能，可以将其分为5个类别。</p>
<pre><code>核心标签&lt;c:xxx&gt;&lt;/c:xxx&gt;
格式化标签&lt;fmt:xxx/&gt;
SQL 标签  &lt;sql:xxx/&gt;
XML 标签  &lt;x:xxx/&gt;
JSTL 函数 &lt;fn:xxx/&gt;
</code></pre><p>其实就是JAVA的官方的jar包，可以方便我们使用的东西罢了。</p>
<h3 id="JSP-连接数据库"><a href="#JSP-连接数据库" class="headerlink" title="JSP 连接数据库"></a>JSP 连接数据库</h3><p>通过使用标准标签库可以操作数据库的CRUD<br>一个从数据库取数据的简单的例子</p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;%@ page import=&quot;java.io.*,java.util.*,java.sql.*&quot;%&gt;
&lt;%@ page import=&quot;javax.servlet.http.*,javax.servlet.*&quot; %&gt;
&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;
&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/sql&quot; prefix=&quot;sql&quot;%&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;SELECT 操作&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;sql:setDataSource var=&quot;snapshot&quot; driver=&quot;com.mysql.jdbc.Driver&quot;
       url=&quot;jdbc:mysql://localhost/TEST&quot;
       user=&quot;root&quot;  password=&quot;pass123&quot;/&gt;
  &lt;sql:query dataSource=&quot;${snapshot}&quot; var=&quot;result&quot;&gt;
  SELECT * from Employees;
  &lt;/sql:query&gt;
  &lt;table border=&quot;1&quot; width=&quot;100%&quot;&gt;
  &lt;tr&gt;
     &lt;th&gt;Emp ID&lt;/th&gt;
     &lt;th&gt;First Name&lt;/th&gt;
     &lt;th&gt;Last Name&lt;/th&gt;
     &lt;th&gt;Age&lt;/th&gt;
  &lt;/tr&gt;
  &lt;c:forEach var=&quot;row&quot; items=&quot;${result.rows}&quot;&gt;
  &lt;tr&gt;
     &lt;td&gt;&lt;c:out value=&quot;${row.id}&quot;/&gt;&lt;/td&gt;
     &lt;td&gt;&lt;c:out value=&quot;${row.first}&quot;/&gt;&lt;/td&gt;
     &lt;td&gt;&lt;c:out value=&quot;${row.last}&quot;/&gt;&lt;/td&gt;
     &lt;td&gt;&lt;c:out value=&quot;${row.age}&quot;/&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;/c:forEach&gt;
  &lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h3 id="JSP-XML-数据处理"><a href="#JSP-XML-数据处理" class="headerlink" title="JSP XML 数据处理"></a>JSP XML 数据处理</h3><p>当通过HTTP发送XML数据时，就有必要使用JSP来处理传入和流出的XML文档了，比如RSS文档。作为一个XML文档，它仅仅只是一堆文本而已，使用JSP创建XML文档并不比创建一个HTML文档难。<br><strong>例子：使用JSP发送XML</strong><br>使用JSP发送XML内容就和发送HTML内容一样。唯一的不同就是您需要把页面的context属性设置为text/xml。要设置context属性，使用&lt;%@page % &gt;命令，就像这样：</p>
<pre><code>&lt;%@ page contentType=&quot;text/xml&quot; %&gt;
</code></pre><p>接下来这个例子向浏览器发送XML内容：</p>
<pre><code>&lt;%@ page contentType=&quot;text/xml&quot; %&gt;
&lt;books&gt;
   &lt;book&gt;
      &lt;name&gt;Padam History&lt;/name&gt;
      &lt;author&gt;ZARA&lt;/author&gt;
      &lt;price&gt;100&lt;/price&gt;
   &lt;/book&gt;
&lt;/books&gt;
</code></pre><h3 id="JSP-JavaBean"><a href="#JSP-JavaBean" class="headerlink" title="JSP JavaBean"></a>JSP JavaBean</h3><p>先来回顾一下什么是JavaBean<br>JavaBean是特殊的Java类，是用Java语言写成的可重用组件，并且遵守JavaBeans API规范。<br>接下来给出的是JavaBean与其它Java类相比而言独一无二的特征：</p>
<pre><code>提供一个默认的无参构造函数。
需要被序列化并且实现了Serializable接口。
可能有一系列可读写属性。
可能有一系列的&quot;getter&quot;或&quot;setter&quot;方法。
</code></pre><h3 id="访问JavaBeans"><a href="#访问JavaBeans" class="headerlink" title="访问JavaBeans"></a>访问JavaBeans</h3><p>&lt;jsp:useBean&gt;标签可以在JSP中声明一个JavaBean，然后使用。声明后，JavaBean对象就成了脚本变量，可以通过脚本元素或其他自定义标签来访问。&lt;jsp:useBean&gt;标签的语法格式如下：</p>
<pre><code>&lt;jsp:useBean id=&quot;bean&apos;s name&quot; scope=&quot;bean&apos;s scope&quot; typeSpec/&gt;;
</code></pre><p>其中，根据具体情况，scope的值可以是page，request，session或application。id值可任意只要不和同一JSP文件中其它&lt;jsp:useBean&gt;中id值一样就行了。</p>
<pre><code>&lt;html&gt;
  &lt;head&gt;
  &lt;title&gt;useBean Example&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;jsp:useBean id=&quot;date&quot; class=&quot;java.util.Date&quot; /&gt;
    &lt;p&gt;The date/time is &lt;%= date %&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><h3 id="访问JavaBeans对象的属性"><a href="#访问JavaBeans对象的属性" class="headerlink" title="访问JavaBeans对象的属性"></a>访问JavaBeans对象的属性</h3><p>在 &lt;jsp:useBean&gt; 标签主体中使用 &lt;jsp:getProperty/&gt; 标签来调用getter方法，使用 &lt;jsp:setProperty/&gt;标签来调用setter方法，语法格式如下：</p>
<pre><code>&lt;jsp:useBean id=&quot;id&quot; class=&quot;bean&apos;s class&quot; scope=&quot;bean&apos;s scope&quot;&gt;
   &lt;jsp:setProperty name=&quot;bean&apos;s id&quot; property=&quot;property name&quot; value=&quot;value&quot;/&gt;
   &lt;jsp:getProperty name=&quot;bean&apos;s id&quot; property=&quot;property name&quot;/&gt;
   ...........
&lt;/jsp:useBean&gt;
</code></pre><p>  name属性指的是Bean的id属性。property属性指的是想要调用的getter或setter方法的名字。</p>
<p>  接下来给出使用以上语法进行属性访问的一个简单例子：</p>
<pre><code>&lt;html&gt;
  &lt;head&gt;
  &lt;title&gt;get and set properties Example&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;jsp:useBean id=&quot;students&quot; class=&quot;com.tutorialspoint.StudentsBean&quot;&gt;
       &lt;jsp:setProperty name=&quot;students&quot; property=&quot;firstName&quot; value=&quot;Zara&quot;/&gt;
       &lt;jsp:setProperty name=&quot;students&quot; property=&quot;lastName&quot; value=&quot;Ali&quot;/&gt;
       &lt;jsp:setProperty name=&quot;students&quot; property=&quot;age&quot; value=&quot;10&quot;/&gt;
    &lt;/jsp:useBean&gt;
    //不在主体中也能调用？
    &lt;p&gt;Student First Name:
       &lt;jsp:getProperty name=&quot;students&quot; property=&quot;firstName&quot;/&gt;
    &lt;/p&gt;
    &lt;p&gt;Student Last Name:
       &lt;jsp:getProperty name=&quot;students&quot; property=&quot;lastName&quot;/&gt;
    &lt;/p&gt;
    &lt;p&gt;Student Age:
       &lt;jsp:getProperty name=&quot;students&quot; property=&quot;age&quot;/&gt;
    &lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><h3 id="JSP-自定义标签"><a href="#JSP-自定义标签" class="headerlink" title="JSP 自定义标签"></a>JSP 自定义标签</h3><p>为了能够更容易理解jsp标签是如何运作的：</p>
<p>自定义标签是用户定义的JSP语言元素。当JSP页面包含一个自定义标签时将被转化为servlet，标签转化为对被 称为tag handler的对象的操作，即当servlet执行时Web container调用那些操作。<br>JSP标签扩展可以让你创建新的标签并且可以直接插入到一个JSP页面。 JSP 2.0规范中引入Simple Tag Handlers来编写这些自定义标记。<br>你可以继承SimpleTagSupport类并重写的doTag()方法来开发一个最简单的自定义标签。</p>
<h3 id="创建”Hello”标签"><a href="#创建”Hello”标签" class="headerlink" title="创建”Hello”标签"></a>创建”Hello”标签</h3><p>第一步：</p>
<pre><code>接下来，我们想创建一个自定义标签叫作&lt;ex:Hello&gt;，标签格式为：
&lt;ex:Hello /&gt;
</code></pre><p>第二步：<br>要创建自定义的JSP标签，你首先必须创建处理标签的Java类。所以，让我们创建一个HelloTag类，如下所示：</p>
<pre><code>package com.tutorialspoint;
import javax.servlet.jsp.tagext.*;
import javax.servlet.jsp.*;
import java.io.*;
public class HelloTag extends SimpleTagSupport {
  public void doTag() throws JspException, IOException {
    JspWriter out = getJspContext().getOut();
    out.println(&quot;Hello Custom Tag!&quot;);
  }
}
</code></pre><p>以上代码重写了doTag()方法，方法中使用了getJspContext()方法来获取当前的JspContext对象，并将”Hello Custom Tag!”传递给JspWriter对象。</p>
<p>第三步：<br>编译以上类，并将其复制到环境变量CLASSPATH目录中。最后创建如下标签库：<tomcat安装目录>webapps\ROOT\WEB-INF\custom.tld。</tomcat安装目录></p>
<pre><code>&lt;taglib&gt;
  &lt;tlib-version&gt;1.0&lt;/tlib-version&gt;
  &lt;jsp-version&gt;2.0&lt;/jsp-version&gt;
  &lt;short-name&gt;Example TLD&lt;/short-name&gt;
  &lt;tag&gt;
    &lt;name&gt;Hello&lt;/name&gt;
    &lt;tag-class&gt;com.tutorialspoint.HelloTag&lt;/tag-class&gt;
    &lt;body-content&gt;empty&lt;/body-content&gt;
  &lt;/tag&gt;
&lt;/taglib&gt;
</code></pre><p>第四步<br>接下来，我们就可以在JSP文件中使用Hello标签：（注意格式）</p>
<pre><code>&lt;%@ taglib prefix=&quot;ex&quot; uri=&quot;WEB-INF/custom.tld&quot;%&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;A sample custom tag&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;ex:Hello/&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><h3 id="JSP-表达式语言"><a href="#JSP-表达式语言" class="headerlink" title="JSP 表达式语言"></a>JSP 表达式语言</h3><p>JSP表达式语言（EL）使得访问存储在JavaBean中的数据变得非常简单。JSP EL既可以用来创建算术表达式也可以用来创建逻辑表达式。在JSP EL表达式内可以使用整型数，浮点数，字符串，常量true、false，还有null。<br>JSP EL允许您指定一个表达式来表示属性值。一个简单的表达式语法如下：</p>
<pre><code>${expr}
</code></pre><p>其中，expr指的是表达式。在JSP EL中通用的操作符是”.”和”[]”。这两个操作符允许您通过内嵌的JSP对象访问各种各样的JavaBean属性</p>
<pre><code>&lt;jsp:setProperty name=&quot;box&quot; property=&quot;perimeter&quot; value=&quot;${2*box.width+2*box.height}&quot;/&gt;
</code></pre><p>当JSP编译器在属性中见到”${}”格式后，它会产生代码来计算这个表达式，并且产生一个替代品来代替表达式的值。</p>
<p><strong>JSP EL中的函数</strong><br>JSP EL允许您在表达式中使用函数。这些函数必须被定义在自定义标签库中。函数的使用语法如下：</p>
<pre><code>${ns:func(param1, param2, ...)}
</code></pre><p>ns指的是命名空间（namespace），func指的是函数的名称，param1指的是第一个参数，param2指的是第二个参数，以此类推。比如，有函数fn:length，在JSTL库中定义，可以像下面这样来获取一个字符串的长度：</p>
<pre><code>${fn:length(&quot;Get my length&quot;)}
</code></pre><p><strong>注意事项：</strong>要使用任何标签库中的函数，您需要将这些库安装在服务器中，然后使用&lt;taglib&gt;标签在JSP文件中包含这些库</p>
<p><strong>JSP EL隐含对象</strong><br>JSP EL支持下表列出的隐含对象：</p>
<table>
<thead>
<tr>
<th style="text-align:right">隐含对象</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">pageScope</td>
<td style="text-align:left">page 作用域</td>
</tr>
<tr>
<td style="text-align:right">requestScope</td>
<td style="text-align:left">request 作用域</td>
</tr>
<tr>
<td style="text-align:right">sessionScope</td>
<td style="text-align:left">session 作用域</td>
</tr>
<tr>
<td style="text-align:right">applicationScope</td>
<td style="text-align:left">application 作用域</td>
</tr>
<tr>
<td style="text-align:right">param</td>
<td style="text-align:left">Request 对象的参数，字符串</td>
</tr>
<tr>
<td style="text-align:right">paramValues</td>
<td style="text-align:left">Request对象的参数，字符串集合</td>
</tr>
<tr>
<td style="text-align:right">header</td>
<td style="text-align:left">HTTP 信息头，字符串</td>
</tr>
<tr>
<td style="text-align:right">headerValues</td>
<td style="text-align:left">HTTP 信息头，字符串集合</td>
</tr>
<tr>
<td style="text-align:right">initParam</td>
<td style="text-align:left">上下文初始化参数</td>
</tr>
<tr>
<td style="text-align:right">cookie</td>
<td style="text-align:left">Cookie值</td>
</tr>
<tr>
<td style="text-align:right">pageContext</td>
<td style="text-align:left">当前页面的pageContext</td>
</tr>
</tbody>
</table>
<h3 id="JSP-异常处理"><a href="#JSP-异常处理" class="headerlink" title="JSP 异常处理"></a>JSP 异常处理</h3><h3 id="JSP-调试"><a href="#JSP-调试" class="headerlink" title="JSP 调试"></a>JSP 调试</h3><h3 id="JSP-国际化"><a href="#JSP-国际化" class="headerlink" title="JSP 国际化"></a>JSP 国际化</h3><h3 id="注：全篇内容出自w3cschool"><a href="#注：全篇内容出自w3cschool" class="headerlink" title="注：全篇内容出自w3cschool"></a>注：全篇内容出自w3cschool</h3><p><a href="https://www.w3cschool.cn/jsp/" target="_blank" rel="external">https://www.w3cschool.cn/jsp/</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/03/Java总结（十）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王邸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路要坚持">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/03/Java总结（十）/" itemprop="url">Java总结（十）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-03T08:41:22+08:00">
                2019-09-03
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/09/03/Java总结（十）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/09/03/Java总结（十）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2019/09/03/Java总结（十）/" class="leancloud_visitors" data-flag-title="Java总结（十）">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这周首先学习了JSP，因为在搞自己的系统所以没认真听，考试就吃了大亏，直接拉闸了。然后讲了filter 和 listener。最后讲了一下JSON 和 MVC，以及软件开发的三层架构（controller,service,dao）。之后就开进行项目。还是那句话，一定要多写代码，不要直接去搬人家写的，自己写一遍，自己就知道流程了。在写项目所以更新慢了</p>
<h2 id="星期一（0826）"><a href="#星期一（0826）" class="headerlink" title="星期一（0826）"></a>星期一（0826）</h2><h3 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h3><p>这一部分没好好听，导致考试直接拉闸，现在用一天的时间，重新学习JSP。虽然以后不用了，但是对理解servlet有着非常重要的作用（最后单独来写）</p>
<h2 id="星期二（0827）"><a href="#星期二（0827）" class="headerlink" title="星期二（0827）"></a>星期二（0827）</h2><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>过滤器是Servlet规范的高级特性。<br>过滤器（Filter）技术是从Servlet2.3规范开始引入的。过滤器是一种Web应用程序组件，可以部署在Web应用程序中。过滤器由Servlet容器调用，用来拦截以及处理请求和响应。过滤器本身并不能生成请求和响应对象，但是可以对请求和响应对象进行检查和修改。</p>
<p>过滤器介于客户端与Servlet/JSP等相关的资源之间，对于与过滤器关联的Servlet来说，过滤器可以在Servlet被调用之前检查并且修改request对象。在Servlet调用之后检查并修改response对象。</p>
<h3 id="过滤器工作原理"><a href="#过滤器工作原理" class="headerlink" title="过滤器工作原理"></a>过滤器工作原理</h3><p>以上过程可分为以下步骤：</p>
<pre><code>1．客户端将请求发送给Web容器；
2．Web容器根据客户端发送的请求生成请求对象request和响应对象response。
3．Web容器在调用与过滤器相关联的Web组件（例如Servlet/JSP）之前，先将request对象以及response对象发送给过滤器。
4．过滤器对request对象进行必要的处理；
5．过滤器把处理过的request对象以及response对象传递给Web组件；
6．Web组件调用完成后，再次通过过滤器，此时过滤器对response对象进行必要的处理；
7．过滤器把处理过的response对象传递给Web容器；
8．Web容器将响应的结果返回到客户端，并在浏览器上显示。
</code></pre><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>Servlet规范中使用javax.servlet.Filter接口支持过滤器的使用<br>创建过滤器必须实现Filter接口，该接口中定义了三个方法</p>
<h3 id="void-init-FilterConfig-config-："><a href="#void-init-FilterConfig-config-：" class="headerlink" title="void init(FilterConfig config)："></a>void init(FilterConfig config)：</h3><p>用于初始化过滤器，当容器装载并初始化过滤器时调用。Web容器为此方法传递一个FilterConfig对象，FilterConfig对象可以获取web.xml文件中过滤器初始化参数的配置；利用FilterConfig对象也可以获取当前Filter的名称以及相关联的ServletContext对象。</p>
<h3 id="void-doFilter-ServletRequst-request-ServletResponse-response-FilterChain-chain-："><a href="#void-doFilter-ServletRequst-request-ServletResponse-response-FilterChain-chain-：" class="headerlink" title="void doFilter(ServletRequst request, ServletResponse response, FilterChain chain)："></a>void doFilter(ServletRequst request, ServletResponse response, FilterChain chain)：</h3><p>此方法是Filter接口的核心方法，用于对请求对象和响应对象进行检查和处理。此方法包括三个输入参数。其中，ServletRequest对象为请求对象，包括表单数据、Cookie以及HTTP请求头等信息；ServletResponse对象为响应对象，用于响应使用ServletRequest对象访问的信息；FilterChain用来调用过滤器链中的下一个资源，即将ServletRequest对象以及ServletResponse对象传递给下一个过滤器或者是其它的Servlet/JSP等资源。</p>
<h3 id="void-destroy-："><a href="#void-destroy-：" class="headerlink" title="void destroy( )："></a>void destroy( )：</h3><p>此方法用于销毁过滤器，当容器要销毁过滤器实例时调用此方法，Servlet过滤器占用的资源会被释放。</p>
<h3 id="filter的执行过程"><a href="#filter的执行过程" class="headerlink" title="filter的执行过程"></a>filter的执行过程</h3><p>doFilter的第三个参数FilterChain，（不加第三个参数，filter不会放行到servlet）用来调用过滤器链中的下一个资源，将ServletRequest对象以及ServletResponse对象传给下一个过滤器或者JSP等。从这里我们可以得出一个信息，那就是filter可以设置多个，可以组成串执行。从最开始的Filter开始依次往后传，传给下一个filter，如果没有filter，那就将Request和Response对象传给Servlet或者JSP等。执行过程如下：</p>
<pre><code>filter dofilter before
filter dofilter2 before
filter dofilter3 before
servlet
filter dofilter3 after
filter dofilter2 after
filter dofilter after
</code></pre><p>我们首先执行Filter1的doFilter方法，也就是说该方法入栈了，之后调用FilterChain的doFilter方法，这个方法的作用就是调用这一链上的其他资源入栈。如果是filter的话，就是继续执行下一filter 的doFilter方法，当遇到后面filter的FilterChain的doFilter方法时，重复刚刚的动作，继续调用下一个链上的资源，如果还是filter，那么和之前的过程一样。如果没有filter了，那么调用Servlet或者JSP，当执行完毕之后，出栈，重新返回上一栈，然后依次出栈执行。代码上的表现形式就是入栈时，依次执行FilterChain.doFilter方法以前的代码，出栈时，反向依次执行FilterChain.doFilter方法后面的代码。我们也可以在IDEA的debug模式下，查看这一过程。</p>
<h3 id="JAVA中实现过滤器"><a href="#JAVA中实现过滤器" class="headerlink" title="JAVA中实现过滤器"></a>JAVA中实现过滤器</h3><pre><code>1．创建一个实现Filter接口的Java类；
2．实现init( )方法，如有必要，读取过滤器的初始化参数；
3．实现doFilter( )方法，完成对ServletRequest对象以及ServletResponse对象的检查和处理；
4．在doFilter( )方法中调用FilterChain接口对象chain的doFilter( )方法，以便将过滤器传递给后续的过滤器或资源。
5．在web.xml中注册过滤器，设置参数以及过滤器要过滤的资源。
</code></pre><h3 id="Filter-Chain"><a href="#Filter-Chain" class="headerlink" title="Filter Chain"></a>Filter Chain</h3><p>FilterChain是servlet容器为开发人员提供的对象，它提供了对某一资源的已过滤请求调用链的视图。过滤器使用 FilterChain 调用链中的下一个过滤器，直到最后一个过滤器。多个Filter对同一个资源进行了拦截，那么当我们在开始的Filter中执行chain.doFilter(request,response)时，是访问下一下Filter,直到最后一个Filter执行时，它后面没有了Filter,才会访问web资源。关于多个FIlter的访问顺序问题:它们的执行顺序取决于&lt;filter-mapping&gt;在web.xml文件中配置的先后顺序,之后是注注解的配置，注解配置则是按照类名的ASCII码表顺序（也就是字母大小写排序）；</p>
<h3 id="Filter生命周期"><a href="#Filter生命周期" class="headerlink" title="Filter生命周期"></a>Filter生命周期</h3><p>当服务器启动，会创建Filter对象，并调用init方法，只调用一次.<br>当访问资源时，路径与Filter的拦截路径匹配，会执行Filter中的doFilter方法，这个方法是真正拦截操作的方法.<br>当服务器关闭时，会调用Filter的destroy方法来进行销毁操作.</p>
<h3 id="Filter配置详解"><a href="#Filter配置详解" class="headerlink" title="Filter配置详解"></a>Filter配置详解</h3><p>在web.xml中</p>
<pre><code>&lt;filter&gt;
  &lt;filter-name&gt;filter名称&lt;/filter-name&gt;
  &lt;filter-class&gt;filter类全名&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
  &lt;filter-name&gt;filter名称&lt;/filter-name&gt;
  &lt;url-pattern&gt;映射路径&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre><p>在注解上：</p>
<pre><code>@WebFilter(filterName = &quot;Filter1&quot;,value = &quot;/*&quot;)
</code></pre><p><strong>关于url-pattern配置</strong><br>和servlet的配置差不多：</p>
<pre><code>1.完全匹配
  要求必须以&quot;/&quot;开始.
2.目录匹配
  要求必须以&quot;/&quot;开始，以*结束.
3.扩展名匹配
  不能以“/”开始，以*.xxx结束. （或*）
</code></pre><h3 id="lisenter"><a href="#lisenter" class="headerlink" title="lisenter"></a>lisenter</h3><p>Listener是Java Web三大组件之一，Servlet，Listener，Filter。<br>监听器用于监听Web常用对象HttpServletRequest，HttpSession，ServletContext。监听对象的生命周期以及属性变化（添加，删除，替换等）。<br>在说Listener之前，必须要先说一个概念：<br><strong>接口回调</strong>。在java中，无论什么种类，什么样的Listener形式，本质上，都是接口回调。这个思想很重要。对于JAVA解耦合来说。</p>
<h3 id="接口回调"><a href="#接口回调" class="headerlink" title="接口回调"></a>接口回调</h3><p>在计算机程序设计中，回调函数，或简称回调，是指通过函数参数传递到其它代码的，某一块可执行代码的引用。这一设计允许了底层代码调用在高层定义的子程序。</p>
<h3 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h3><p>员工向老板汇报工作</p>
<pre><code>//Boss.类 适当的时机告诉老板工作完成
public class Boss {
  public void report(){
      System.out.println(&quot;报告老板，工作已经完成&quot;);
  }
}

//员工类
//员工工作，工作完毕，向老板汇报工作完成
public class Employee {
  private Boss boss;
  public Employee(Boss boss) {
      this.boss = boss;
  }
  public void work(){
      System.out.println(&quot;员工正在拼命工作中&quot;);
      boss.report();
  }
}

//测试
public class Test {
  public static void main(String[] args) {
    Employee employee = new Employee(new Boss());
    employee.work();
  }
}
</code></pre><p>这里就是一个简单员工工作完，创建一个boss告诉他我工作完了。如果有一天员工升职了，boss不再是他的老板了，Manager才是他的老板，那么我们是不是要重新创一个manager类去实现一个report()方法，在employee里面再创建一个manager的对象。。。。。。 ？<br>这样一看就是耦合的代码，并不能复用。那么我们能不能想一个办法。employee上级不确定，但是我们可以用一个对象来表示他的上级。这个对象能实现report方法。同时和不同的领导汇报的工作是不同的，所以需要不同的领导report不同。那么我们就想到了接口这个东西，有一个report方法，所有的领导都实现这个接口即可。而employee可以使用这个接口的类型的对象，通过领导向上转型来接收每一个领导。说起来有点抽象，直接上代码：<br>首先需要一个callback接口，表示employee的上级</p>
<p>//Callback.java</p>
<pre><code>public interface Callback {
  void report();
}
</code></pre><p>//不同的领导实现这个接口，也就是说他们拥有这个方法</p>
<pre><code>//Manager.java
public class Manager implements Callback {
  //重写report()
  @override
  void report(){
    System.out.println(&quot;向经理汇报情况！&quot;);
  }
}
</code></pre><p>//employee类 有一个callback 成员，直接调用callback对象的report方法</p>
<pre><code>employee.java
public class employee {
  Callback boss;
  public employee (Callback boss) {
    this.boss = boss;
  }
  //work直接调用callback的report即可
  public void work(){
    System.out.prinln(&quot;working&quot;);
    boss.report()//向领导汇报
  }
}
</code></pre><p>listener就是这样的一个东西，他有很多子类实现这个接口，同时他们自己有自己不同的功能，监听的就是context。<br><strong>Listener的类型虽然有很多种，但是使用方式都是一样的。要想注册一个listener，首先编写一个类实现listener接口。</strong><br>Servlet共提供了三种类型8个监听器。</p>
<h3 id="三个域对象创建和销毁的监听器"><a href="#三个域对象创建和销毁的监听器" class="headerlink" title="三个域对象创建和销毁的监听器"></a>三个域对象创建和销毁的监听器</h3><p><strong>ServletContextListener（例子）</strong></p>
<pre><code>public class MyServletContextListener implements ServletContextListener {
  @Override
  public void contextInitialized(ServletContextEvent servletContextEvent) {
  }
  @Override
  public void contextDestroyed(ServletContextEvent servletContextEvent) {
  }
}

这样是不是就可以了呢？因为web服务器不知道有这么一个listener？你得告诉服务器我新增了一个监听器。在web.xml中注册监听器的信息。
web.xml
&lt;listener&gt;
  &lt;listener-class&gt;MyServletContextListener&lt;/listener-class&gt;
&lt;/listener&gt;

或者在创建的时候写注解：
@WebListener  //写这个注解
public class MyServletContextListener implements ServletContextListener {
  @Override
  public void contextInitialized(ServletContextEvent servletContextEvent) {
  }
  @Override
  public void contextDestroyed(ServletContextEvent servletContextEvent) {
  }
}
</code></pre><p>HttpSessionListener<br>ServletRequestListener</p>
<p><strong>三个域对象的属性变更的监听器</strong><br>ServletContextAttributeListener</p>
<pre><code>public class MyServletContextAttributeListener implements ServletContextAttributeListener {
  @Override
  public void attributeAdded(ServletContextAttributeEvent servletContextAttributeEvent) {
  }

  @Override
  public void attributeRemoved(ServletContextAttributeEvent servletContextAttributeEvent) {
  }

  @Override
  public void attributeReplaced(ServletContextAttributeEvent servletContextAttributeEvent) {
  }
}
</code></pre><p>ServletRequestAttributeListener<br>HttpSessionAttributeListener</p>
<p><strong>监听HttpSession对象中JavaBean状态的改变（不同）</strong><br>这两个Listener的使用方式和之前的有很大不同，不需要通过注册web.xml。 直接在相应的 entity 中实现相应的接口。</p>
<p>HttpSessionBindingListener<br>HttpSessionActivationListener</p>
<h2 id="星期三（0828）"><a href="#星期三（0828）" class="headerlink" title="星期三（0828）"></a>星期三（0828）</h2><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>使用谷歌Gson就行 或者fastJson</p>
<h2 id="星期四（0829）"><a href="#星期四（0829）" class="headerlink" title="星期四（0829）"></a>星期四（0829）</h2><h3 id="重构之前的项目"><a href="#重构之前的项目" class="headerlink" title="重构之前的项目"></a>重构之前的项目</h3><p>通过三层架构分层，然后分成不同的功能模块。虽然以后使用框架来写的，但是大体思路都是这样<br>|-controller<br>|-dao<br>|-filter<br>|-model<br>|-service<br>|-util</p>
<h3 id="考试总结"><a href="#考试总结" class="headerlink" title="考试总结"></a>考试总结</h3><p>非常的不认真，导致非常的不好，大部分错的都是Jsp，所以问题很严重。必须重新学习<br>5.关于http 协议不正确的描述是（C ）<br>A、Http 请求中的Referer 字段的值表示用户从该URL 代表的页面出发访问<br>当前请求的页面<br>B、http 整个消息头部分中的各行消息头可按任何顺序排列<br>C、http 协议响应报文返回状态码302 表示重定向。<br>D、http 请求有说明当前协议的版本号, 响应首部没有。</p>
<p>看错了,响应头不是响应报文。</p>
<p>9.Servlet1 的访问路径为<a href="http://localhost/news/servlet/Servlet1，" target="_blank" rel="external">http://localhost/news/servlet/Servlet1，</a><br>在Servlet1 中使用如下代码设置Cookie：<br>Cookie c = new Cookie(“myCookie”,”xxxx”);<br>response.addCookie(c);</p>
<p>请问当访问哪个Servlet 时可以获取不到这个Cookie 信息？（ C ）<br>A、<a href="http://localhost/news/servlet/Servlet1" target="_blank" rel="external">http://localhost/news/servlet/Servlet1</a><br>B、<a href="http://localhost/news/servlet/Servlet2" target="_blank" rel="external">http://localhost/news/servlet/Servlet2</a><br>C、<a href="http://localhost/news/Servlet3" target="_blank" rel="external">http://localhost/news/Servlet3</a><br>D、<a href="http://localhost/news/servlet/n/Servlet4" target="_blank" rel="external">http://localhost/news/servlet/n/Servlet4</a><br>实验证明确实是这样，只要是/servlet/*下面，以及/servlet。不管有没有servlet来接收这个请求，都会带cookie，而没有/servlet这一层的所有URL就都没有这个cookie。我印象中老师没有讲过，但是我理解应该是一个树的结构，<br>例如：/news/servlet/Servlet1。 当我在这棵树的某个结点设置了cookie，这棵树的父类以及父类的所有子树都能拥有这个cookie 。如果这个结点就是应用下的首层的结点，则整个应用都可以拥有这个cookie。而这题就是在servlet1设置的cookie，所有的/servlet/*<br>和/servlet 都能带上这个 cookie。</p>
<p><strong>这里想到另一个问题，如果我设置cookie时候设置了path是下一层，那么结果会如何</strong>，同样创建了四个servlet来测试其它层都一样就,设置cookie的地方不一样</p>
<pre><code>@WebServlet(name = &quot;Servlet1&quot;, urlPatterns = &quot;/Servlet1&quot;)//就改了这里
public class Servlet1 extends HttpServlet {
  protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
  }
  protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    request.setCharacterEncoding(&quot;utf-8&quot;);
    Cookie c = new Cookie(&quot;myCookie&quot;,&quot;test&quot;);
    c.setPath(&quot;/news/servlet/Servlet2&quot;); //我把 cookie 给到下一层 这一层还有吗？
    response.addCookie(c);
  }
}
</code></pre><p><strong>注意</strong>这就发生了一个很奇怪的现象，这时候并不是Path的路径：servlet下的资源/servlet/*（包括/servlet），都带有这个cookie,和我们刚才的结论就不同了，这里只有Servlet2下面的资源(包括/Servlet2)才有这个cookie。按照之前的结论，我这一层拿到的cookie，应该所有的兄弟结点和兄弟的孩子都可以拿到。但是设置path之后，之后path的子节点和他自己才能拿到。这里就有点诡异。我们从cookie设计的角度出发去看这个问题，如果我们setPath(“”)不是比原来深的资源，而是比原来浅。那么是不是就会有cookie能被整个应用共享的安全隐患。所以我觉得这样设计还是有他的想法的。</p>
<p>13.aa.jsp 要把请求转发给bb.jsp, aa.jsp 位于根目录下的page 文件夹，<br>aa.jsp.bb.jsp 位于helloapp 应用的根目录下。以下哪个选项能使aa.jsp 正确地把<br>请求转发给bb.jsp?（ D ）</p>
<pre><code>A、&lt;a href=“bb.jsp”&gt;bb.jsp&lt;/a&gt;
B、&lt;jsp:forward page=“bb.jsp”/&gt;
C、&lt;jsp:forward page=“${pageContext.request.contextPath }/bb.jsp”/&gt;
D、&lt;jsp:forward page=“/bb.jsp”/&gt;
</code></pre><p>14.在HTTP 请求中包含一个名字为“username”，值为“Tom”的Cookie，以下<br>哪个选项能输在这个Cookie 的名字“username” （ C ）<br>A、${cookie.username.name}<br>B、${cookie.username.value}<br>C、${cookie.username }<br>D、${reques.cookie.username.name}</p>
<p>没学过是，EL表达式，11个隐式对象</p>
<pre><code>pageScope page 作用域
requestScope  request 作用域
sessionScope  session 作用域
applicationScope  application 作用域
param Request 对象的参数，字符串
paramValues Request对象的参数，字符串集合
header  HTTP 信息头，字符串
headerValues  HTTP 信息头，字符串集合
initParam 上下文初始化参数
cookie  Cookie值
pageContext 当前页面的pageContext
</code></pre><p>19.学校数据库中有学生和宿舍两种表，表的结构为学生(学号，姓名)，宿舍(楼名，房间号，床位号，学号)，现在要列出<strong>所有学生</strong>的床位分配情况，则应执行<br>（ C ）、<br>A、交叉连接 B、内连接 C、左外连接 D、隐式连接</p>
<p>题目说是所有的学生，所以左外链接可以把左边所有的数据都查到，也可以查出来学生没有床位的情况。要查出哪边全部数据就在哪边查询；有可能还是会出现幽灵结点。</p>
<p>20.在JSTL的迭代标签 &lt;forEach&gt; 的属性中，用于指定要遍历的对象集合（ B ）<br>A、var B、items C、value D、varStatus<br>没学过，别人能对你也可以</p>
<h3 id="大题"><a href="#大题" class="headerlink" title="大题"></a>大题</h3><p>1.返回什么</p>
<pre><code>Public class Servlet1 extends HttpServlet {
  Public void init() throws ServletException{
  }
  Public void service(HttpServletRequest request,HttpServletResponse response)Throws ServletException,IOException{
    PrintWriter out = response.getWriter();
    out.println(“hello!”);
  }
}
</code></pre><p>HttpServlet 的doGet() 和 doPost()方法并不一定要继承，不是抽象方法，他当然可以重写service方法</p>
<p>2.helloapp 应用中的test.jsp 文件的源代码如下：</p>
<pre><code>&lt;%!
public void amethod(){
  String username=request.getParameter(“username”);
  out.print(username);
}
%&gt;
&lt;%amethod();%&gt;
</code></pre><p>当客户端访问</p>
<pre><code>http://localhost:8080/helloapp/test.jsp?username=Tom 时，打印出的结果是什么？
</code></pre><p>编译错误，因为request是service方法中的局部变量。不能在另一个函数中使用。</p>
<p>4.访问如下jsp 时，浏览器将得到怎样的输出？<br>&lt;% int i = 0; %&gt;<br>&lt;!—<br>&lt;% i=i+100; %&gt;<br>–&gt;<br>&lt;%=i %&gt;<br>输出为100</p>
<p>在JAVA文件会翻译成：</p>
<pre><code>out.write(&quot;  &quot;);
int i = 0;
out.write(&quot;\n&quot;);
out.write(&quot;  &lt;!--\n&quot;);
out.write(&quot;  &quot;);
i=i+100;
out.write(&quot;\n&quot;);
out.write(&quot;  --&gt;\n&quot;);
out.write(&quot;  &quot;);
out.print(i);
</code></pre><p>//学生表<br>Create table t_stu (<br>  t_sid int primary key,<br>  t_sName varchar(10)<br>);</p>
<p>//老师表<br>Create table t_teacher (<br>  t_tid int primary key,<br>  t_tName varchar(10)<br>);</p>
<p>//课程表<br>Create table t_course (<br>  t_cid int Primary key,<br>  t_tid int,<br>  t_cName varchar(10),<br>  Constraint t_tid_fk foreign key(t_tid) references t_teacher(t_tid)<br>);</p>
<p>//分数关联表<br>CREATE TABLE t_sc (<br>  t_Sid INT,<br>  t_cid INT,<br>  score INT,<br>  PRIMARY KEY(t_cid,t_sid),<br>  CONSTRAINT t_sid_fk FOREIGN KEY(t_sid) REFERENCES t_stu(t_sid),<br>  CONSTRAINT t_cid_fk FOREIGN KEY(t_cid) REFERENCES t_course(t_cid)<br>)</p>
<p>问题：</p>
<p>1.查询所有教师所带课程的情况。（4 分）</p>
<pre><code>select * from t_teacher left join t_course on t_teacher.t_tid = t_course.t_tid;
</code></pre><p>2.查询所有满足如下条件的同学的姓名，及其单科成绩：该同学的单科成绩大于其平均成绩</p>
<pre><code>select * from t_stu inner join t_sc on t_stu.t_sid = t_sc.t_Sid where t_sc.score &gt; (select AVG(score) from t_sc);
</code></pre><p>隐式内连接，配合子查询<br>SELECT *  FROM t_stu, t_sc  WHERE t_stu.t_sid = t_sc.t_sid  AND  score &gt; (<br>SELECT AVG(score) FROM t_sc WHERE t_stu.t_sid=t_sc.t_sid)</p>
<p>1）为什么要写两次：t_stu.t_sid=t_sc.t_sid ？<br>第二个不用写，<br>SELECT *  FROM t_stu, t_sc  WHERE t_stu.t_sid = t_sc.t_sid  and  score &gt; (<br>SELECT AVG(score) FROM t_sc);<br>2）AND和where的区别？<br>因为使用了隐式内连接，所以使用and来代替where执行</p>
<h2 id="星期五（0830）"><a href="#星期五（0830）" class="headerlink" title="星期五（0830）"></a>星期五（0830）</h2><p>正式开始项目，开始写项目，那么知识点就变少了，成为CURD boy，编写接口文档。发现最主要的还是mysql的语句的编写，等等。</p>
<h2 id="星期六（0831）"><a href="#星期六（0831）" class="headerlink" title="星期六（0831）"></a>星期六（0831）</h2><h3 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h3><p><strong>sql语句拼接就是核心</strong></p>
<p>public List<admin> getSearchAdmins(Admin admin) throws SQLException {<br>  String account = admin.getAccount();<br>  String name = admin.getName();<br>  String sql = “select * from admin where 1=1 “;<br>  List<object> parameter = new ArrayList&lt;&gt;();<br>  if(!StringUtils.isEmpty(account)) {<br>    sql += “ AND account like ? “;<br>    parameter.add(“%” + account + “%”);<br>  }<br>  if(!StringUtils.isEmpty(name)) {<br>    sql += “ AND name like ? “;<br>    parameter.add(“%” + name + “%”);<br>  }<br>  return adminDao.getSearchAdmins(sql,parameter);<br>}</object></admin></p>
<h2 id="星期日（0901）"><a href="#星期日（0901）" class="headerlink" title="星期日（0901）"></a>星期日（0901）</h2><h3 id="乱码问题"><a href="#乱码问题" class="headerlink" title="乱码问题"></a>乱码问题</h3><p>设置-Dfile.encoding=UTF-8</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/25/乱码问题大总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王邸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路要坚持">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/25/乱码问题大总结/" itemprop="url">乱码问题大总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-25T23:27:04+08:00">
                2019-08-25
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/08/25/乱码问题大总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/08/25/乱码问题大总结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2019/08/25/乱码问题大总结/" class="leancloud_visitors" data-flag-title="乱码问题大总结">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本篇文章目的是总结记录所有乱码问题，从前端到后端，会不断增加和更新。谁TM不是这样过来的。</p>
<h3 id="乱码问题的本质原因"><a href="#乱码问题的本质原因" class="headerlink" title="乱码问题的本质原因"></a>乱码问题的本质原因</h3><p>编解码不一致导致的</p>
<h2 id="默认编码格式"><a href="#默认编码格式" class="headerlink" title="默认编码格式"></a>默认编码格式</h2><p>在总结乱码问题之前，要说明的是默认的编码格式，这TM就很扯淡了，不同的系统的默认的编码格式。</p>
<h3 id="系统的默认的编码格式"><a href="#系统的默认的编码格式" class="headerlink" title="系统的默认的编码格式"></a>系统的默认的编码格式</h3><p>简体中文window操作系统   GBK<br>linux默认的编码方式为    utf-8</p>
<h3 id="服务器的默认编码格式"><a href="#服务器的默认编码格式" class="headerlink" title="服务器的默认编码格式"></a>服务器的默认编码格式</h3><p>tomcat的默认编码格式：tomcat8以后默认编码格式是utf-8；7之前的都是iso8859-1</p>
<h3 id="浏览器的默认编码格式"><a href="#浏览器的默认编码格式" class="headerlink" title="浏览器的默认编码格式"></a>浏览器的默认编码格式</h3><p>浏览器默认编码格式跟随系统，不同的系统默认的编码格式不同</p>
<h3 id="一些方法会调用默认编码"><a href="#一些方法会调用默认编码" class="headerlink" title="一些方法会调用默认编码"></a>一些方法会调用默认编码</h3><p>Java 的String.getByte()///默认把字符串按默认编码格式转成byte类型</p>
<h3 id="编辑器的编码问题"><a href="#编辑器的编码问题" class="headerlink" title="编辑器的编码问题"></a>编辑器的编码问题</h3><p>很多编辑器默认的编码方式是UTF-8，但是有些文本编辑器是以系统的编码方式作为自己的编码方式。window的自带的记事本就是这样。还有一种情况是编辑器会自动把编码格式改变。例如sublime。</p>
<h2 id="显示乱码系列"><a href="#显示乱码系列" class="headerlink" title="显示乱码系列"></a>显示乱码系列</h2><p>接下来总结一些显示的乱码，不涉及请求。就是自生启动就发生乱码的情况。</p>
<h3 id="浏览器显示乱码"><a href="#浏览器显示乱码" class="headerlink" title="浏览器显示乱码"></a>浏览器显示乱码</h3><p>问题：浏览器自己显示乱码。<br>原因：<br>1.和用的编辑器有关。<br>如果你的编辑器默认使用的是GBK编码格式就不出现乱码。有些编辑器的默认编码格式就是UTF-8格式。有些则跟随系统的编码格式。<br>2.和网页的编码格式有关<br>建议：让浏览器以UTF-8显示网页。<br>解答：在HTML页面上加上</p>
<pre><code>&lt;meta charset=&quot;UTF-8&quot;&gt;
</code></pre><h3 id="服务器显示乱码"><a href="#服务器显示乱码" class="headerlink" title="服务器显示乱码"></a>服务器显示乱码</h3><p>背景：目前使用的是tomcat的服务器，通过点击tomcat/bin/startup服务器启动出现的乱码</p>
<p>原因:<br>具体原因我也不清楚，但是解决办法却有一箩筐。接下来总结写一些解决办法<br>解决：<br>1.conf/logging.properties 里的文件把UTF-8全部改成GBK，或者就把最后一个编码改成GBK</p>
<pre><code>java.util.logging.ConsoleHandler.encoding = GBK
</code></pre><p>网上说这个有奇效，但是我写的是UTF-8，也不会出现乱码问题</p>
<p>2.修改 connector 的编码格式<br>在tomcat/config/server.xml文件，设置connector</p>
<pre><code>&lt;Connector port=&quot;80&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt;
</code></pre><p>改成：加URIEncoding=”utf-8”</p>
<pre><code>&lt;Connector URIEncoding=&quot;utf-8&quot; connectionTimeout=&quot;20000&quot; port=&quot;8888&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt;
</code></pre><p>但是我没加也没有显示乱码，这个主要是为了get请求给客户端可能出现乱码准备的。</p>
<p>3.我的方式修改（暴力解决）：<br>把tomcat/config里面所有GBK，全部改成utf-8。使用sublime可以直接搜索出来所有文字为GBK<br>在tomcat/config目录中 一共出现16个UTF-8。大部分是xml的配置文件的编码格式，这个必须改成UTF-8的格式<br>主要还有logging.properties这个配置文件；</p>
<h3 id="idea显示乱码"><a href="#idea显示乱码" class="headerlink" title="idea显示乱码"></a>idea显示乱码</h3><p>解决办法(建议全部都设置！！！)：<br>1.修改IDEA的默认设置，ctrl + alt + s打开设置 搜索encoding<br>打开IntelliJ IDEA&gt;File&gt;Setting&gt;Editor&gt;File Encodings，将Global Encoding、Project Encoding、Default encodeing for properties files这三项都设置成UTF-8，点击OK或者Apply。</p>
<p>2.进入idea的安装目录的bin目录下：<br>修改这两个文件：<br>idea.exe.vmoptions<br>idea64.exe.vmoptions<br>最后都加上：<br>-Dfile.encoding=UTF-8</p>
<p><strong>注意：</strong>以上两点必须重启IDEA，慢就慢点，忍忍吧。</p>
<p>3.前两个设置如果控制台还出现乱码。那这个建议设置一下：<br>打开tomcat配置页面，Edit Configurations。<br>选择项目部署的tomcat，在配置项VM options文本框中输入</p>
<pre><code>-Dfile.encoding=UTF-8
</code></pre><p>点击Apply或OK，然后必须重启服务器（就是点最后一个restart Server!）。<br><strong>如果项目中使用的是字符流来传输文件（getWriter()，….），这个建议最好设置，这样IDEA显示的乱码，你的数据是不会乱码的。就不会带到你要写的文件中，建议必须设置。</strong></p>
<p>4.如果以上三点还没解决乱码问题，相信我肯定不是IDEA的锅！</p>
<h2 id="发送请求服务器显示乱码（request）"><a href="#发送请求服务器显示乱码（request）" class="headerlink" title="发送请求服务器显示乱码（request）"></a>发送请求服务器显示乱码（request）</h2><h3 id="先从浏览器说起"><a href="#先从浏览器说起" class="headerlink" title="先从浏览器说起"></a>先从浏览器说起</h3><p>之前我们已经提及了使用元数据来设置网页的编码格式是UTF-8，但是这个远远不够，因为我们还有表单，还要上传文件，还要去请求，等等。</p>
<h3 id="post请求（上传文件）"><a href="#post请求（上传文件）" class="headerlink" title="post请求（上传文件）"></a>post请求（上传文件）</h3><p>问题：上传文本文件乱码，或者上传的文件的名字乱码<br>解决 ：如果不是特别要求建议所有的文件都用字节流传输，字节流可能比字符流传输慢一点。但是字节流传输只需要在servlet。在获取数据之前设置request的编码格式就行了就像下面这样。</p>
<pre><code>request.setCharacterEncoding(&quot;utf-8&quot;);
</code></pre><p>虽然经历的不多，但是我感觉这样出现的问题会少一些。因为上传文件一般都是POST请求，设置这句话只能对请求体有效。所以对 POST 特别管用。</p>
<h3 id="get请求（提交参数）"><a href="#get请求（提交参数）" class="headerlink" title="get请求（提交参数）"></a>get请求（提交参数）</h3><p>在connection里面加字符编码格式，get请求写在url里面，servlet是那个引擎去那这段参数，所以理所当然修改的tomcat的那个配置文件，上面也有说：</p>
<pre><code>&lt;Connector URIEncoding=&quot;utf-8&quot; connectionTimeout=&quot;20000&quot; port=&quot;8888&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt;
</code></pre><h2 id="接收请求浏览器显示乱码-response"><a href="#接收请求浏览器显示乱码-response" class="headerlink" title="接收请求浏览器显示乱码(response)"></a>接收请求浏览器显示乱码(response)</h2><p>在发送响应给浏览器之前，服务器在家也喜欢搞一些花里胡哨的东西，但是必须时刻记住自己的编码格式<strong>默认并不是UTF-8</strong>。所以在发送给浏览器之前一定要做两件事情：<br>1.自己变成UTF-8格式进行操作数据<br>2.告诉浏览器你必须使用UTF-8进行编码</p>
<pre><code>response.setHeader(&quot;content-type&quot;,&quot;text/html;charset=utf-8&quot;);
//或者
response.setContentType(&quot;text/html;charset=utf-8&quot;);
</code></pre><p>当你从服务器返回一个页面给浏览器的时候，别忘了设置response的编码格式哦</p>
<pre><code>response.setCharacterEncoding(&quot;utf-8&quot;);
</code></pre><h3 id="下载文件时候文件名乱码"><a href="#下载文件时候文件名乱码" class="headerlink" title="下载文件时候文件名乱码"></a>下载文件时候文件名乱码</h3><p>需要这是一下相应头中下载文件名。表示这是可行的。</p>
<pre><code>if(request.getHeader(&quot;User-Agent&quot;).toUpperCase().indexOf(&quot;MSIE&quot;) &gt; 0) {
    response.setHeader(&quot;Content-Disposition&quot;,&quot;attachment;&quot;+ &quot;filename=&quot;+ new String(filename.getBytes(&quot;GBK&quot;),&quot;ISO8859-1&quot;));
} else {//firefox、chrome、safari、opera
  response.setHeader(&quot;Content-Disposition&quot;,&quot;attachment;&quot;+
 &quot;filename=&quot;+ new String(filename.getBytes(&quot;UTF8&quot;), &quot;ISO8859-1&quot;) );
}
</code></pre><h2 id="数据库乱码"><a href="#数据库乱码" class="headerlink" title="数据库乱码"></a>数据库乱码</h2><p>先进入数据库看看数据库是什么编码格式的,查看表是什么格式的</p>
<pre><code>show create database database_name;
show create table table_name;
</code></pre><p>修改数据库的字符编码格式：</p>
<pre><code>Alter database database_name character set utf8;  //这里不是utf-8
</code></pre><p>一劳永逸的办法：<br>修改全局性默认字符集为utf8，操作步骤如下：</p>
<pre><code>C:\ProgramData\MySQL\MySQL Server 5.7
</code></pre><p>目录下找到my.ini文件：不要用记事本打开（programData目录为隐藏目录）<br>在[mysql]下添加</p>
<pre><code>default-character-set=utf8
</code></pre><p>在[mysqld]下添加</p>
<pre><code>character_set_server=utf8
</code></pre><p>然后在重新启动数据库：</p>
<pre><code>net end mysql57
net start mysql57
</code></pre><p>以后创建的数据库默认都是UTF-8的编码</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>乱码先分析问题的原因是什么，是本身的问题，还是客户端和服务端传输过程中的乱码问题。所以这需要我们自己分析和经验的积累。<br>现在的办法就是：<strong>通过打断点来判断到底是什么情况</strong>。我就出现过打断点没有显示乱码，但是idea控制台打印的时候显示了乱码，后来设置了VMOPTIION就好了。<br>这些原理现阶段可能还只是知道怎么用。等到以后遇到更深的问题可能才会触及到本质。加油吧少年。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/25/Java总结（九）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王邸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路要坚持">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/25/Java总结（九）/" itemprop="url">Java总结（九）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-25T23:24:08+08:00">
                2019-08-25
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/08/25/Java总结（九）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/08/25/Java总结（九）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2019/08/25/Java总结（九）/" class="leancloud_visitors" data-flag-title="Java总结（九）">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本周又回到了JAVAEE讲了：http协议，tomcat使用，Servlet 请求和相应,文件的上传和下载等等。<br>主要考虑的还是乱码的问题，其他的东西在SE阶段就已经接触过了，网络编程那一段，其实就是socket封装的response和request。根本就没有什么新东西</p>
<h2 id="星期一（0819）"><a href="#星期一（0819）" class="headerlink" title="星期一（0819）"></a>星期一（0819）</h2><p>今天学习HTTP协议 和 TOMCAT的一些基本用法</p>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>HTTP是JavaEE的基础，所以必须要好好掌握，请求和响应将伴随javaEE<br>HyperText Transport Protocol超文本传输协议<br>协议：规范。两台计算机之间进行通信需要遵循的一个规范<br>传输：双向的。浏览器（发送方）和服务器（接收方）之间进行传输。<br>超文本：区别于普通文本。还有音频，视频，图片等资源。</p>
<p>HyperText Markup Language 超文本标记语言<br>有千丝万缕的关系。http其实最早产生就是用来传输html的。<br>HTTP/0.9  HTTP/1.0  HTTP/1.1  HTTP/2（google）  HTTP/3（google）<br>长连接，短连接</p>
<h3 id="一次完整的http请求"><a href="#一次完整的http请求" class="headerlink" title="一次完整的http请求"></a>一次完整的http请求</h3><p>1.域名解析<br>2.客户端发起TCP的三次握手 （客户端先发送一个数据包给服务端）<br>3.发起HTTP请求（连接成功后）<br>4.服务器响应HTTP（请求）<br>5.浏览器解析HTML代码并请求HTML中需要的css 等静态文件<br>6.浏览器对页面进行渲染</p>
<h3 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h3><p>当我们输入一个URL会发生什么？<br>服务端会返回一个响应，响应的内容是一个html页面。浏览器拿到html页面，会对html进行解析，发现如果还需要css样式文件，js文件，图片资源等，浏览器会自行再发送http请求，去请求相关的资源。</p>
<h3 id="request请求"><a href="#request请求" class="headerlink" title="request请求"></a>request请求</h3><p>请求由请求行 请求头 <strong>空格</strong>  请求体组成</p>
<h3 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h3><p>三部分组成：请求方式   请求资源名称   HTTP版本号</p>
<h3 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h3><p>Get请求和post请求区别：get请求提交数据放在地址栏中拼接，数据一般不超过1k<br>Post请求提交数据是放在请求正文中。 略微安全一些。传输的  数据没有大小限制。传输过程明文传输。</p>
<p>最常用的是Get请求和post请求方式，还有一些其他的请求方式，可能服务器不会接受此方法。<br>HEAD：  只返回除了响应正文的部分，即响应头。部分服务器可能支持，也可能不支持。<br>OPTIONS: 当前url所支持的方法<br>DELETE:  向服务器发送一个删除资源的请求<br>PUT:     向服务器发送一个提交文件的请求</p>
<h3 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h3><p>举例：</p>
<pre><code>GET /books/java.html?Name=value HTTP/1.1  //请求行
Accept: text/html
Accept-Language: en-us
Connection: Keep-Alive
Host: localhost
Referer: http://localhost/links.asp
User-Agent: Mozilla/4.0
Accept-Encoding: gzip, deflate
                                          //一个空行
</code></pre><p>常用请求头：</p>
<pre><code>Accept:浏览器可接受的    MIME类型 */*   (大类型)/(小类型)
Accept-Charset: 浏览器通过这个头告诉服务器，它支持哪种字符集
Accept-Encoding:浏览器能够进行解码的数据编码方式，比如gzip
Accept-Language: 浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到。 可以在浏览器中进行设置。
Host:初始URL中的主机和端口
Referer:包含一个URL，用户从该URL代表的页面出发访问当前请求的页面 （防盗链）
Content-Type:内容类型
If-Modified-Since: Wed, 02 Feb 2011 12:04:56 GMT 服务器利用这个头与服务器的文件进行比对，如果一致，则告诉浏览器从缓存中直接读取文件。
User-Agent:浏览器类型.
Content-Length:表示请求消息正文的长度
Connection:表示是否需要持久连接。如果服务器看到这里的值为“Keep -Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接
Cookie:这是最重要的请求头信息之一
Date：Date: Mon, 22 Aug 2011 01:55:39 GMT请求时间GMT
</code></pre><p>内容类型：MIME类型<br>MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型就是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式</p>
<pre><code>MIME类型：Multipurpose Internet Mail Extensions 媒体类型
MIME：针对html文档而言：text/html;
针对图片等：image/png;image/gif等
声音资源：audio/mp3等
视频：video/mp4、mkv、avi
这里面引出一个MIME类型的概念，
后面我们会发送http响应，如果是普通文档，你设置它的类型是text/html没有问题，但是如果是一个静态资源，比如图片，设置类型是text/html就会引起一系列问题，比如图片无法正常加载。
</code></pre><h3 id="HTTP消息头（HTTP请求或相应的头部的公共规则）"><a href="#HTTP消息头（HTTP请求或相应的头部的公共规则）" class="headerlink" title="HTTP消息头（HTTP请求或相应的头部的公共规则）"></a>HTTP消息头（HTTP请求或相应的头部的公共规则）</h3><p>使用消息头，可以实现HTTP客户机与服务器之间的条件请求和应答，消息头相当于服务器和浏览器之间的一些暗号指令。<br>每个消息头包含一个头字段名称，然后依次是冒号、空格、值、回车和换行符</p>
<pre><code>如： Accept-Encoding: gzip, deflate
</code></pre><p>消息头字段名是不区分大小写的，但习惯上讲每个单词的第一个字母大写，与xml的标签对应<br><strong>整个消息头部分中的各行消息头可按任何顺序排列。</strong><br>许多请求头字段都允许客户端在值部分指定多个可接受的选项，多个选项之间以逗号分隔。<br>有些头字段可以出现多次 .</p>
<h3 id="请求报文的格式"><a href="#请求报文的格式" class="headerlink" title="请求报文的格式"></a>请求报文的格式</h3><pre><code>请求行：  请求方法    请求URL   版本
请求首部： 名: 值
          名: 值
（空行）
请求正文：    （HTTP要传输的内容）
</code></pre><h3 id="HTTP响应消息response"><a href="#HTTP响应消息response" class="headerlink" title="HTTP响应消息response"></a>HTTP响应消息response</h3><p>一个状态行、若干消息头、空格 及响应正文，其中的一些消息头和正文都是可选的，消息头和正文内容之间要用空行隔开。<br>例子:</p>
<pre><code>HTTP/1.1 200 OK
Server: Microsoft-IIS/5.0
Date: Thu, 13 Jul 2000 05:46:53 GMT
Content-Length: 2291
Content-Type: text/html
Cache-control: private

&lt;HTML&gt;
&lt;BODY&gt;
……
</code></pre><h3 id="响应报文的格式"><a href="#响应报文的格式" class="headerlink" title="响应报文的格式"></a>响应报文的格式</h3><pre><code>响应行： 协议版本    状态码   原因短语
首部：  名: 值
                        （空行）
实体的主体部分：（HTTP要传输的内容）
</code></pre><h3 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h3><p>格式： HTTP版本号　状态码　原因叙述<crlf><br>举例：HTTP 1.1 200 OK<br>状态码用于表示服务器对请求的各种不同处理结果和状态，它是一个三位的十进制数。响应状态码分为5类，使用最高位为1到5来进行分类如下所示：</crlf></p>
<table>
<thead>
<tr>
<th style="text-align:right">状态码</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">200～299</td>
<td style="text-align:left">表示成功接收请求并已完成整个处理过程 200 OK   206</td>
</tr>
<tr>
<td style="text-align:right">300～399</td>
<td style="text-align:left">（重定向）为完成请求，客户需进一步细化请求。例如，请求的资源已经移动一个新地址</td>
</tr>
<tr>
<td style="text-align:right">400～499</td>
<td style="text-align:left">客户端的请求有错误</td>
</tr>
<tr>
<td style="text-align:right">500～599</td>
<td style="text-align:left">服务器端出现错误</td>
</tr>
</tbody>
</table>
<h3 id="常用状态码"><a href="#常用状态码" class="headerlink" title="常用状态码"></a>常用状态码</h3><table>
<thead>
<tr>
<th style="text-align:right">状态</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">200</td>
<td style="text-align:left">(正常)表示一切正常，返回的是正常请求结果</td>
</tr>
<tr>
<td style="text-align:right">206</td>
<td style="text-align:left">表示分段的请求OK</td>
</tr>
<tr>
<td style="text-align:right">301、302/307</td>
<td style="text-align:left">(临时重定向)指出被请求的文档已被临时移动到别处，此文档的新的URL在Location响应头中给出。</td>
</tr>
<tr>
<td style="text-align:right">304</td>
<td style="text-align:left">(未修改)表示客户机缓存的版本是最新的，客户机可以继续使用它，无需到服务器请求。</td>
</tr>
<tr>
<td style="text-align:right">404</td>
<td style="text-align:left">(找不到)服务器上不存在客户机所请求的资源。</td>
</tr>
<tr>
<td style="text-align:right">400</td>
<td style="text-align:left">服务器不支持这种请求方式</td>
</tr>
<tr>
<td style="text-align:right">500</td>
<td style="text-align:left">(服务器内部错误)  服务器端的程序发生错误</td>
</tr>
</tbody>
</table>
<h3 id="常用响应头1"><a href="#常用响应头1" class="headerlink" title="常用响应头1"></a>常用响应头1</h3><table>
<thead>
<tr>
<th style="text-align:right">响应头</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">Location:</td>
<td style="text-align:left"><a href="http://www.cskaoyan.com/指示新的资源的位置" target="_blank" rel="external">http://www.cskaoyan.com/指示新的资源的位置</a></td>
</tr>
<tr>
<td style="text-align:right">Server:</td>
<td style="text-align:left">apache tomcat 指示服务器的类型</td>
</tr>
<tr>
<td style="text-align:right">Content-Encoding:</td>
<td style="text-align:left">gzip 服务器发送的数据采用的编码类型</td>
</tr>
<tr>
<td style="text-align:right">Content-Length:</td>
<td style="text-align:left">80 告诉浏览器正文的长度</td>
</tr>
<tr>
<td style="text-align:right">Content-Language:</td>
<td style="text-align:left">zh-cn服务发送的文本的语言</td>
</tr>
<tr>
<td style="text-align:right">Content-Type:</td>
<td style="text-align:left">text/html;  服务器发送的内容的MIME类型</td>
</tr>
<tr>
<td style="text-align:right">Last-Modified:</td>
<td style="text-align:left">Tue, 11 Jul 2000 18:23:51 GMT文件的最后修改时间</td>
</tr>
<tr>
<td style="text-align:right">Refresh:</td>
<td style="text-align:left">1;url=<a href="http://www.cskaoyan.com指示客户端刷新频率。单位是秒" target="_blank" rel="external">http://www.cskaoyan.com指示客户端刷新频率。单位是秒</a></td>
</tr>
<tr>
<td style="text-align:right">Content-Disposition:</td>
<td style="text-align:left">attachment; filename=aaa.zip指示客户端保存文件</td>
</tr>
<tr>
<td style="text-align:right">Set-Cookie:</td>
<td style="text-align:left">SS=Q0=5Lb_nQ; path=/search服务器端发送的Cookie</td>
</tr>
<tr>
<td style="text-align:right">Expires:</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:right">Cache-Control:</td>
<td style="text-align:left">no-cache (1.1)</td>
</tr>
<tr>
<td style="text-align:right">Connection:</td>
<td style="text-align:left">close/Keep-Alive</td>
</tr>
<tr>
<td style="text-align:right">Date:</td>
<td style="text-align:left">Tue, 11 Jul 2000 18:23:51 GMT</td>
</tr>
</tbody>
</table>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>加密的 带证书</p>
<h2 id="2-Tomcat-Java-WebServer"><a href="#2-Tomcat-Java-WebServer" class="headerlink" title="2. Tomcat (Java WebServer)"></a>2. Tomcat (Java WebServer)</h2><p>简单介绍一些tomcat的配置和一些必须知道的知识点</p>
<h3 id="修改端口号"><a href="#修改端口号" class="headerlink" title="修改端口号"></a>修改端口号</h3><p>Conf目录下server.xml在对应http协议的connector上面修改<br>80端口号在访问的时候默认可以省略，不带端口号。</p>
<h3 id="认识Tomcat目录结构"><a href="#认识Tomcat目录结构" class="headerlink" title="认识Tomcat目录结构"></a>认识Tomcat目录结构</h3><p>bin       二进制文件目录，也是启动停止的地方<br>conf      配置文件，可以配置虚拟映射，启动等配置<br>lib       需要的库文件<br>logs      日志文件<br>temp      临时文件存放的目录<br>webapps   项目发布的目录<br>work      工作目录 work目录只是tomcat的工作目录，也就是tomcat把jsp转换为class文件的工作目录。</p>
<h3 id="部署项目"><a href="#部署项目" class="headerlink" title="部署项目"></a>部署项目</h3><p><strong>注意事项</strong>访问webapps目录下的应用，通过域名+端口号/应用名/资源名来访问，其中有一个需要特别注意，ROOT项目，该项目在访问的时候，不需要输入应用名。</p>
<h3 id="直接部署"><a href="#直接部署" class="headerlink" title="直接部署"></a>直接部署</h3><p>在webapps目录下，新建一个目录，该目录名称就是你的应用名，在里面添加你说需要供他人访问的静态或者动态web资源。<br>Localhost:port/应用名/资源名称</p>
<h3 id="打成war包，扔进webapps目录下"><a href="#打成war包，扔进webapps目录下" class="headerlink" title="打成war包，扔进webapps目录下"></a>打成war包，扔进webapps目录下</h3><p>War：web application archive。类似于一种压缩格式。Tomcat启动的时候会自动解压缩。<br>之后访问方法同上。</p>
<h3 id="虚拟映射"><a href="#虚拟映射" class="headerlink" title="虚拟映射"></a>虚拟映射</h3><p>什么叫虚拟映射？？正常情况下，我们发布应用发布到webapps目录下就可以了，但是如果我不想把应用放到该目录下，我可以通过某种方式将其他目录下的应用关联到该webapps目录下，等同于在webapps目录下。</p>
<p>1）在Host节点下新增Context节点<br>比如在D盘有一个应用，我需要发布到网络上，新增Context节点，path表示该应用的应用名，（和放在webapp目录下略有不同，文件夹的名称即为应用名称），docBase指向的是该应用所在的位置。</p>
<pre><code>&lt;Context path=&quot;/second&quot; docBase=&quot;D:\secondapp&quot;&gt;&lt;/Context&gt;
</code></pre><p>2） 在conf/catalina/localhost目录下新增 应用名.xml文件<br>//second.xml</p>
<pre><code>&lt;Context docBase=&quot;D:\secondapp&quot;&gt;&lt;/Context&gt;
</code></pre><h2 id="星期二（0820）"><a href="#星期二（0820）" class="headerlink" title="星期二（0820）"></a>星期二（0820）</h2><h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h3><p>ervlet = Server + applet<br>Servlet是接口，规范，相应的类由谁来实现？？？Web服务器、tomcat：Servlet 容器<br>To implement this interface,<br>you can write a generic servlet that extends javax.servlet.GenericServlet<br>or an HTTP servlet that extends javax.servlet.http.HttpServlet.</p>
<h3 id="手动实现-servlet-（不用IDEA）"><a href="#手动实现-servlet-（不用IDEA）" class="headerlink" title="手动实现 servlet （不用IDEA）"></a>手动实现 servlet （不用IDEA）</h3><p>目的是为了知道怎么运行，<br>因为servlet是一个接口，所以要去文档找他的实现类来进行编写<br>All Known Implementing Classes:</p>
<pre><code>GenericServlet
</code></pre><p>使用实现类实现service方法</p>
<pre><code>public class Servlet enxtends GenericServlet {
  public void service (ServletRequest req, ServletResponse res) {
    System.out.println(&quot;first service&quot;);
  }
}
</code></pre><p>现在的问题是这个：应该放在哪里运行<br>如果直接命令行运行会报错，因为jre里面没有这个jar包，简单说就是jre里面的jar包没有这个class类。<br>所以我们就需要去回顾一下类加载器的问题：</p>
<pre><code>1.  Bootstrap类加载器：负责加载Java的核心类库，JAVA_HOME/jre/下面的类
2.  Extension类加载器：负责加载JAVA/jre/lib/ext下面的类
3.  System类加载器：负责将命令中的classpath或者CLASSPATH环境变量指定的类库加载到内存中。
</code></pre><p>需要导包（不是import）<br>方式一：在Extension类加载器加载时加载<br>把tomcat/lib中的servlet-api.jar包 放在jdk…/jre/lib/ext的目录下直接编译就好了</p>
<pre><code>javac firstServlet.java
</code></pre><p>方法二：System类的加载器加载<br>Javac -classpath jar包的路径 java文件</p>
<pre><code>javac -classpath D:\apache-tomcat-8.5.37\lib firstServlet.java
</code></pre><h3 id="Servlet执行过程"><a href="#Servlet执行过程" class="headerlink" title="Servlet执行过程"></a>Servlet执行过程</h3><pre><code>1.  在浏览器上输入http://localhost/firstservlet/first，发生什么事情？？
2.  首先被监听80端口号的connector HTTP 1.1接收，接收之后将请求转发给Engine处理。
3.  Engine将请求匹配给虚拟主机localhost，如果没有找到，也是匹配给它，这个是默认的虚拟主机。
4.  虚拟主机接收到请求，然后将请求的路径变成/firstservlet/first，之后在该host节点下去搜寻Context节点，应用名
5.  找到firstservlet应用，将请求转发给该应用，/first，之后再去web.xml中去搜索/first，通过url-pattern找到servlet-name，再通过name找到相应的class文件，之后加载该class文件。
6.  检查是否有该servlet的实例，有的话，则不会再次执行init方法，没有的话，则创建一个实例对象，执行init方法。
7.  tomcat创建一个用于封装HTTP请求消息的HttpServletRequest对象和一个代表HTTP响应消息的HttpServletResponse对象，然后调用Servlet的service()方法并将请求和响应对象作为参数传递进去。
8.  WEB应用程序被停止或重新启动之前，Servlet引擎将卸载Servlet，并在卸载之前调用Servlet的destroy()方法。
</code></pre><h3 id="我自己的理解"><a href="#我自己的理解" class="headerlink" title="我自己的理解"></a>我自己的理解</h3><p>1.在浏览器输入一个URL之后，首先服务器会去读取他自己的配置文件：<strong>config/server.xml</strong>的文件。然后去找Connector标签，每个Connector标签对应一种请求的协议，找到对应的Connector，一般都是HTTP的。<br>2.然后去往下找<strong>标签 &lt; engine &gt; 只有Catalina的引擎</strong><br>3.然后往下 <strong>Host标签</strong>，接收到请求，获取到ip后面的部分/firstservlet/first<br>4.Host就去里面找<strong>Context标签</strong>，去上下文中找<strong>应用</strong><br>5.应用1)可以写在Host标签里面，2)也可以放在Catalina里面的最里面以<strong>应用名.xml</strong>读取应用找到firstservlet应用<br>6.然后在应用中找first 这个servlet<br>7.找这个servlet也可以放两个地方:1)可以写在web应用的中的WEB-INFO/web.xml中的servlet标签2）也可以在java的文件上写注解@WebServlet(“/servletName”) 这个之后会重点介绍的</p>
<h3 id="Servlet的运行过程"><a href="#Servlet的运行过程" class="headerlink" title="Servlet的运行过程"></a>Servlet的运行过程</h3><p>Servlet程序是由WEB服务器调用，web服务器收到客户端的Servlet访问请求后：</p>
<pre><code>1.Web服务器首先检查是否已经装载并创建了该Servlet的实例对象。如果是，则直接执行第④步，否则，执行第②步。
2.装载并创建该Servlet的一个实例对象。
3.调用Servlet实例对象的init()方法。
4.tomcat创建一个用于封装HTTP请求消息的HttpServletRequest对象和一个代表HTTP响应消息的HttpServletResponse对象，然后调用Servlet的service()方法并将请求和响应对象作为参数传递进去。
5.WEB应用程序被停止或重新启动之前，Servlet引擎将卸载Servlet，并在卸载之前调用Servlet的destroy()方法。
</code></pre><h3 id="Servlet实现"><a href="#Servlet实现" class="headerlink" title="Servlet实现"></a>Servlet实现</h3><p>Servlet接口SUN公司定义了两个默认实现类，分别为：GenericServlet、HttpServlet。 HttpServlet是GenericServlet的子类</p>
<p>HttpServlet指能够处理HTTP请求的servlet，它在原有Servlet接口上添加了一些与HTTP协议处理方法，它比Servlet接口的功能更为强大。因此开发人员在编写Servlet时，通常应继承这个类，而避免直接去实现Servlet接口。<br>HttpServlet在实现Servlet接口时，覆写了service方法，该方法体内的代码会自动判断用户的请求方式，如为GET请求，则调用HttpServlet的doGet方法，如为Post请求，则调用doPost方法。因此，开发人员在编写Servlet时，通常只需要覆写doGet或doPost方法，而不要去覆写service方法。<br><a href="http://tomcat.apache.org/tomcat-5.5-doc/servletapi/" target="_blank" rel="external">阅读HttpServlet API文档，看一下servlet-api.jar</a></p>
<h3 id="如何使用servlet"><a href="#如何使用servlet" class="headerlink" title="如何使用servlet?"></a>如何使用servlet?</h3><p>由于客户端是通过URL地址访问web服务器中的资源，所以Servlet程序若想被外界访问，必须把servlet程序映射到一个URL地址上，这个工作在web.xml文件中使用&lt;servlet&gt;元素和&lt;servlet-mapping&gt;元素完成。<br>&lt;servlet&gt;元素用于注册Servlet，它包含有两个主要的子元素：&lt;servlet-name&gt;和&lt;servlet-class&gt;，分别用于设置Servlet的注册名称和Servlet的完整类名。<br>一个&lt;servlet-mapping&gt;元素用于映射一个已注册的Servlet的一个对外访问路径，它包含有两个子元素：&lt;servlet-name&gt;和&lt;url-pattern&gt;，分别用于指定Servlet的注册名称和Servlet的对外访问路径。例如：</p>
<pre><code>&lt;web-app&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;AnyName&lt;/servlet-name&gt;
    &lt;servlet-class&gt;HelloServlet&lt;/servlet-class&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;AnyName&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/demo/hello.html&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</code></pre><p><strong>通过注解创界servlet</strong></p>
<pre><code>@WebServlet(name = &quot;UserServlet&quot;, urlPatterns = &quot;/user&quot;)
</code></pre><p><strong>注意事项</strong></p>
<pre><code>同一个Servlet可以被映射到多个URL上，即多个&lt;servlet-mapping&gt;元素的&lt;servlet-name&gt;子元素的设置值可以是同一个Servlet的注册名。
在Servlet映射到的URL中也可以使用*通配符，但是只能有两种固定的格式：    一种格式是“*.扩展名”，一种格式是以正斜杠（/）开头并以“/*”结尾。
</code></pre><h3 id="为什么一个servlet可以对应多个url-pattern-而不能多个servlet去对应一个url-pattern？"><a href="#为什么一个servlet可以对应多个url-pattern-而不能多个servlet去对应一个url-pattern？" class="headerlink" title="为什么一个servlet可以对应多个url_pattern 而不能多个servlet去对应一个url_pattern？"></a>为什么一个servlet可以对应多个url_pattern 而不能多个servlet去对应一个url_pattern？</h3><p>稍加思考你就发现，你再浏览器输入一个servlet请求，那么浏览器发出给服务器，如果多个servlet对应一个url_pattern那么服务器就不懂给哪个servlet去处理这个请求了，所以肯定不行。 就好像你要去进行实名登记（发送请求），要去办公室（服务端），办公室去处理你的登记的时候可以发现有多个和你名字一样的人。但是你不能一个人写两个名字。这样就会<strong>你们要抓的是周树人，和我鲁迅什么关系？</strong></p>
<h3 id="关于url-pattern冲突匹配的问题"><a href="#关于url-pattern冲突匹配的问题" class="headerlink" title="关于url_pattern冲突匹配的问题"></a>关于url_pattern冲突匹配的问题</h3><p>url_pattern固定两种写法：</p>
<pre><code>第一种 /。。。。/。。。。，以/开头  /*  必须要以/开头，要记住
第二种*.后缀
</code></pre><p>对于如下的一些映射关系：<br>Servlet1 映射到 /abc/*<br>Servlet2 映射到 /*<br>Servlet3 映射到 /abc<br>Servlet4 映射到 *.do<br>问题：</p>
<pre><code>当请求URL为“/abc/a.html”，“/abc/*”和“/*”都匹配，哪个servlet响应
  Servlet引擎将调用Servlet1。

当请求URL为“/abc”时，“/abc” /*都匹配，哪个servlet响应
  Servlet引擎将调用Servlet3。

当请求URL为“/abc/a.do”时，“/abc/*”和“*.do”和/*都匹配，哪个servlet响应
  Servlet引擎将调用Servlet1。

当请求URL为“/a.do”时，“/*”和“*.do”都匹配，哪个servlet响应
  Servlet引擎将调用Servlet2。

当请求URL为“/xxx/yyy/a.do”时，“/*”和“*.do”都匹配，哪个servlet响应
  Servlet引擎将调用Servlet2。
</code></pre><p><strong>一些结论</strong><br>1.可以精确匹配，就用最精确的匹配<br>2./*的优先级要高于*.do以/开头的优先级要高于*.后缀的优先级<br>精准匹配要优先级最高，（以/开头的匹配）</p>
<h2 id="关于-和"><a href="#关于-和" class="headerlink" title="关于/ 和 /*"></a>关于/ 和 /*</h2><p>当一个应用里面设置两个servlet，他们的映射的url是’/‘ ‘/*‘时，<br>访问jsp和html页面，均无法访问到，都被/*拦截掉当把/*去掉之后，jsp可以访问到（jsp本质上也是servlet，它有一个url-pattern）但是这个时候依旧不能访问静态的文件。默认情况下处理静态文件的servlet它的url-pattern就是/(其实是tomcat提供了这个servlet)<br>/的优先级最低，缺省servlet，也就是说，任何servlet的url-pattern都匹配不到该路径时，这个时候/来处理。这个时候，如果项目中存在html或者图片，则被/*匹配到，无法显示正常的网页、资源</p>
<p>/* 能匹配到所有不是精准匹配的资源，jsp文件不能显示<br>/ 默认的匹配，默认是处理静态文件资源的，如果自己实现这个servlet，服务器就会使用这个servlet来处理静态请求。</p>
<h3 id="Servlet的生命周期"><a href="#Servlet的生命周期" class="headerlink" title="Servlet的生命周期"></a>Servlet的生命周期</h3><p>Servlet是一个供其他Java程序（Servlet引擎）调用的Java类，它不能独立运行，它的运行完全由Servlet引擎来控制和调度。</p>
<p>针对客户端的多次Servlet请求，通常情况下，服务器只会创建一个Servlet实例对象，也就是说Servlet实例对象一旦创建，它就会驻留在内存中，为后续的其它请求服务，直至web容器退出(或应用停止)，servlet实例对象才会销毁。<br>在Servlet的整个生命周期内，Servlet的<strong>init方法</strong>只被调用一次。而对一个Servlet的每次访问请求都导致Servlet引擎调用一次servlet的<strong>service方法</strong>。对于每次访问请求，Servlet引擎都会创建一个新的HttpServletRequest请求对象和一个新的HttpServletResponse响应对象，然后将这两个对象作为参数传递给它调用的Servlet的service()方法，service方法再根据请求方式分别调用doXXX方法。</p>
<h3 id="如何让servlet自己动起来？"><a href="#如何让servlet自己动起来？" class="headerlink" title="如何让servlet自己动起来？"></a>如何让servlet自己动起来？</h3><p>创建：正常情况下，servlet在第一次访问的时候被创建，被谁创建？？Tomcat。<br>但是，可以通过设置一个参数，让servlet在项目加载的时候自动创建。<br><strong>Load-on-startup</strong>可以更改servlet的生命周期的创建阶段</p>
<pre><code>&lt;servlet&gt;
  &lt;servlet-name&gt;invoker&lt;/servlet-name&gt;
  &lt;servlet-class&gt;
    org.apache.catalina.servlets.InvokerServlet
  &lt;/servlet-class&gt;
  &lt;load-on-startup&gt;2&lt;/load-on-startup&gt;
&lt;/servlet&gt;
</code></pre><p>或者说第一次访问的时候创建，有什么好处？懒加载。什么时候用，什么时候创建。<br>对于一些需要经常访问的servlet，或者说需要在项目启动的时候做一些加载，可以将servlet的load-on-startup设置为一个非负数，这样，则可以减轻服务器的部分压力。<br>正常情况下，默认-1，表示初次访问的时候才会加载。数字大小表示加载的先后顺序，越小则越先加载。</p>
<p>用途：为web应用写一个InitServlet，这个servlet配置为启动时装载，为整个web应用创建必要的数据库表和数据。</p>
<h3 id="ServletConfig对象（没什么卵用，你要取出来又不能修改）"><a href="#ServletConfig对象（没什么卵用，你要取出来又不能修改）" class="headerlink" title="ServletConfig对象（没什么卵用，你要取出来又不能修改）"></a>ServletConfig对象（没什么卵用，你要取出来又不能修改）</h3><p>当servlet配置了初始化参数后，web容器在创建servlet实例对象时，会自动将这些初始化参数封装到ServletConfig对象中，并在调用servlet的init方法时，将ServletConfig对象传递给servlet。进而，程序员通过ServletConfig对象就可以得到当前servlet的初始化参数信息。</p>
<h3 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h3><p>WEB容器在启动时，它会为每个WEB应用程序都创建一个对应的ServletContext对象，它代表当前web应用，就是之前讲的<context>标签<br>ServletConfig对象中维护了ServletContext对象的引用，开发人员在编写servlet时，可以通过ServletConfig.getServletContext方法获得ServletContext对象。<br>由于一个WEB应用中的所有Servlet共享同一个ServletContext对象，因此Servlet对象之间可以通过ServletContext对象来实现通讯。ServletContext对象通常也被称之为context域对象。</context></p>
<h3 id="ServletContext用法"><a href="#ServletContext用法" class="headerlink" title="ServletContext用法"></a>ServletContext用法</h3><p>API的介绍<br>目前常用的就这几个，第一个获取上下文对象，中间三个是获取，设置，删除属性 dispatcher是用转发和包含的 最后一个是获取真实路径</p>
<p> ServletContext getServletContext()<br>          Returns:a ServletContext object, used by the caller to interact with its servlet container（返回一个上下文）</p>
<p> void removeAttribute(java.lang.String name)<br>          Removes the attribute with the given name from the servlet context.（删除一个上下文的属性）</p>
<p> void setAttribute(java.lang.String name, java.lang.Object object)<br>          Binds an object to a given attribute name in this servlet context.</p>
<p> java.lang.Object getAttribute(java.lang.String name)<br>          Returns the servlet container attribute with the given name, or null if there is no attribute by that name.</p>
<p>RequestDispatcher getRequestDispatcher(java.lang.String path)<br>          Returns a RequestDispatcher object that acts as a wrapper for the resource located at the given path.</p>
<p>java.lang.String  getRealPath(java.lang.String path)<br>          Returns a String containing the real path for a given virtual path.</p>
<p>1.共享数据</p>
<pre><code>//Servlet1
getServletContext().setAttribute(&quot;neigui&quot;,&quot;guangtou&quot;)
//Servlet2
(String)getServletContext().getAttribute(&quot;neigui&quot;);  //光头
</code></pre><p>2.获取全局性的初始化参数<br> Web.xml定义一个context-param节点，所有的servlet均可以获取到该初始化参数。与ServletConfig不同。ServletConfig初始化参数的标签叫init-param，这个标签是存在于servlet内部的，所以仅当前servlet可以获取到该初始化参数。</p>
<pre><code>&lt;context-param&gt;
    &lt;param-name&gt;guangtou&lt;/param-name&gt;
    &lt;param-value&gt;neigui&lt;/param-value&gt;
&lt;/context-param&gt;
</code></pre><p>这里写的是String 类型</p>
<pre><code>(String)getServletContext().getAttribute(&quot;neigui&quot;);  //光头
</code></pre><p>3.获取EE项目的文件路径<br>相对路径，相对的是谁的路径？Jdk里面如何描述相对路径的？？相对路径指的是相对java虚拟机调用的目录。在哪个目录下调用jvm，就相对的是哪个路径。SE的项目都是我们自己调用的jre 但是EE项目不是，是tomcat里面有个argument调用了main方法。</p>
<pre><code>File file = new File(&quot;a.html&quot;);
System.out.println(file.getAbsolutePath());//D:\apache-tomcat-8.5.37\bin\a.html

getServletContext.getRealPath(); //获取的是你项目的路径
</code></pre><p><strong>注意事项</strong> getServletContext.getRealPath();获取的是部署目录的应用名的路径，而不是开发路径的，所以就有可能会出线，这是发布路径上面有文件，而且路径是正确的，但是偏偏项目启动却找不到，因为部署目录上面没有这个文件夹。没有对应的文件，这时候有两个解决方案：<br>1.点IDEA上的build project,重新构建一下项目到部署目录<br>2.设置一下开发路径上class文件的编译放的文件路径，他应该会默认重新构建项目，就把东西复制到部署目录了。</p>
<p><strong>ServletContext应用</strong><br>获取WEB应用的初始化参数。(多个serlvet获取相同参数)<br>多个Servlet通过ServletContext对象实现数据共享。<br>实现Servlet的转发（request）。</p>
<h2 id="星期三（0821）"><a href="#星期三（0821）" class="headerlink" title="星期三（0821）"></a>星期三（0821）</h2><h3 id="request（请求）"><a href="#request（请求）" class="headerlink" title="request（请求）"></a>request（请求）</h3><p>一些API的使用，以及转发和包含的功能</p>
<h3 id="HttpServletRequest"><a href="#HttpServletRequest" class="headerlink" title="HttpServletRequest"></a>HttpServletRequest</h3><p>public interface HttpServletRequest extends ServletRequest</p>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><pre><code>getRequestURL方法返回客户端发出请求时的完整URL。
getRequestURI方法返回请求行中的资源名部分。
//getQueryString 方法返回请求行中的参数部分（POST就拿不到参数）。一般不用不能获取请求体中的参数
getRemoteAddr方法返回发出请求的客户机的IP地址
getRemoteHost方法返回发出请求的客户机的完整主机名
getRemotePort方法返回客户机所使用的网络端口号
getLocalAddr方法返回WEB服务器的IP地址。
getLocalName方法返回WEB服务器的主机名
getMethod得到客户机请求方式
</code></pre><h3 id="关于request的三个资源名字："><a href="#关于request的三个资源名字：" class="headerlink" title="关于request的三个资源名字："></a>关于request的三个资源名字：</h3><p>//URI 统一资源标识符 /request  URL 统一资源定位符 <a href="http://localhost/request" target="_blank" rel="external">http://localhost/request</a></p>
<pre><code>    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        request.setCharacterEncoding(&quot;utf-8&quot;);
        String contextPath = request.getContextPath();
        String requestURI = request.getRequestURI();
        StringBuffer requestURL = request.getRequestURL();

        System.out.println(contextPath); //应用名       /0824test_war_exploded（/是内容）
        System.out.println(requestURI);  // 资源标识符   /0824test_war_exploded/Servlet1（/是内容）
        System.out.println(requestURL);  // 资源定位    http://localhost/0824test_war_exploded/Servlet1
    }
}
</code></pre><h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><p>获得客户机请求头</p>
<pre><code>getHeader(name)方法
getHeaders(String name)方法
getHeaderNames方法
</code></pre><p>获得客户机请求参数(客户端提交的数据)</p>
<pre><code>getParameter(name)方法
getParameterValues（String name）方法
getParameterNames方法
getParameterMap()
</code></pre><h3 id="第三方库将用户的参数保存在bean中"><a href="#第三方库将用户的参数保存在bean中" class="headerlink" title="第三方库将用户的参数保存在bean中"></a>第三方库将用户的参数保存在bean中</h3><p>获取用户的请求参数，如果我们一个一个从请求拿出来，然后赋值给我们自己建的bean就很蠢，能否有个工具像DBUtil一样能够直接通过ResultHandler传给他一个对象，他反射来创建bean对象，调用我们bean的方法，来填充我们的bean对象。答案当然是有的：<br>引用两个jar包：</p>
<pre><code>commons-beanutils-1.8.3.jar
commons-logging-1.1.1.jar
</code></pre><p>然后在servlet里面开始操作</p>
<pre><code>    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

//        Enumeration&lt;String&gt; parameterNames = request.getParameterNames();
//        while (parameterNames.hasMoreElements()){
//            String key = parameterNames.nextElement();
//            String[] parameterValues = request.getParameterValues(key);
//            ...然后一个一个把参数放进我们的bean中，就很麻烦，能不能一步到位？
//        }
        Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();
        //还有一种情形，假如我想将获取到的数据封装到一个java bean中，应该怎么做 User
        //反射  调用相应的set方法来完成赋值
        //运用第三方的jar包
        User user = new User();
        try {
            BeanUtils.populate(user,parameterMap);
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        }
        System.out.println(user);
    }
</code></pre><h3 id="前端form表单书写的问题"><a href="#前端form表单书写的问题" class="headerlink" title="前端form表单书写的问题"></a>前端form表单书写的问题</h3><p>1.写全地址</p>
<pre><code>http://127.0.0.1/servlet1
</code></pre><p>这种方式不推荐，原因：在公司开发软件的过程中，会涉及到多个环境，开发环境，测试环境，生产环境。</p>
<p>2.以/开头写法<br>写法：/应用名/资源名。</p>
<p>3.相对当前页面的写法，不以/开头</p>
<p><strong>注意事项</strong>这里又涉及到了路径的问题，之后我会总结路径的问题，这里就提一点，以/开头的路径的写法，如果执行的主体是浏览器，那么要写应用名，就例如这里的表单：</p>
<pre><code>/应用名/资源名
</code></pre><p>但是执行的主体是服务器的时候，不需要写应用名。例如马上回顾的转发和包含。执行主体是ServletContext是服务器主体：</p>
<pre><code>/Servlet_name(资源名)
</code></pre><h3 id="转发和包含-request-getRequestDispatcher"><a href="#转发和包含-request-getRequestDispatcher" class="headerlink" title="转发和包含 request.getRequestDispatcher()"></a>转发和包含 request.getRequestDispatcher()</h3><p>一个Servlet对象无法获得另一个Servelt对象的引用；如果需要多个Servet组件共同协作(数据传递)，只能使用Servelt规范为我们提供的两种方式：</p>
<p>请求转发：Servlet(源组件)先对客户请求做一些预处理操作，然后把请求转发给其他web组件(目标组件)来完成包括生成响应结果在内的后续操作。<br>包含：Servelt(源组件)把其他web组件(目标组件)生成的响应结果包含到自身的响应结果中。</p>
<h3 id="转发forward"><a href="#转发forward" class="headerlink" title="转发forward"></a>转发forward</h3><p>dispatcher.forward(request,response)的处理流程：<br>1、清空用于存放<strong>响应正文</strong>数据的缓冲区，所以源组件依然可以设置响应头<br>2、如果目标组件为Servlet或JSP，tomcat就调用它们，把它们产生的响应结果发送到客户端；如果目标组件为文件系统中的静态HTML文档，tomcat就读取文档中的数据并把它发送给客户端。<br>特点：<br>1、由于forward()方法先清空用于存放响应正文数据的缓冲区，因此源组件生成的响应结果（无论转发前后）不会被发送到客户端，只有目标组件生成的响应结果才会被送到客户端。<br>2、如果源组件在进行请求转发之前，已经提交了响应结果（如调用了response的flush或close方法），那么forward（）方法会抛出IllegalStateException。为了避免该异常，不应该在源组件中提交响应结果。</p>
<h3 id="包含include"><a href="#包含include" class="headerlink" title="包含include"></a>包含include</h3><p>include()方法的处理流程：<br>1、如果目标组件为Servlet或JSP，就执行它们，并把它们产生的响应正文添加到源组件的响应结果中；如果目标组件为HTML文档，就直接把文档的内容添加到源组件的响应结果中。<br>特点：<br>1、源组件与被包含的目标组件的输出数据都会被添加到响应结果中。<br><strong>2、在目标组件中对响应状态代码或者响应头所做的修改都会被忽略</strong></p>
<h3 id="转发和包含的共同点"><a href="#转发和包含的共同点" class="headerlink" title="转发和包含的共同点"></a>转发和包含的共同点</h3><p>源组件和目标组件处理的都是同一个客户请求，源组件和目标组件共享同一个ServeltRequest和ServletResponse对象<br>目标组件都可以为Servlet、JSP或HTML文档都依赖 javax.servlet.RequestDispatcher接口</p>
<p>就相当于把请求转移，请求由谁发送的？？应该由浏览器发送，所以只发送了一次请求。<br>转发是服务器的内部行为，和浏览器没有任何关系。<br>源组件：dispatcher1<br>目标组件： dispatcher2</p>
<pre><code>//dispatcher1
RequestDispatcher requestDispatcher = request.getRequestDispatcher(&quot;/dispatcher2&quot;);
</code></pre><h3 id="转发和包含之间又有什么样的区别"><a href="#转发和包含之间又有什么样的区别" class="headerlink" title="转发和包含之间又有什么样的区别"></a>转发和包含之间又有什么样的区别</h3><p>转发：（源组件）留头（响应头）不留体（响应体）。<br>源组件做了初步处理之后，将请求转发给目标组件，之后源组件对于响应正文的数据不再参与进来，全权由目标组件来完成。但是源组件可以写入响应头信息。<br>包含：（源组件）留头（响应头）也留体（响应体）。（目标组件）不留响应头</p>
<p>无论包含还是转发，执行的先后顺序，源组件执行到include/forward语句之后，就跳转至目标组件<br>目标组件组件执行完毕之后，再次回到源组件forward/include下面的语句执行<br>但是在转发之后，源组件不能在执行response相关的操作。例如不能在返回响应中写东西</p>
<pre><code>protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        request.setCharacterEncoding(&quot;utf-8&quot;);
//        RequestDispatcher requestDispatcher = request.getRequestDispatcher(&quot;/DispatcherServlet2&quot;);
        RequestDispatcher requestDispatcher = request.getRequestDispatcher(&quot;DispatcherServlet2&quot;);
        requestDispatcher.forward(request,response);
        response.getWriter().println(&quot;dispatcher1&quot;);           //无效
        System.out.println(&quot;dispatcher1后面的代码还会执行吗？&quot;); //会执行
    }
</code></pre><h3 id="转发和包含的用途"><a href="#转发和包含的用途" class="headerlink" title="转发和包含的用途"></a>转发和包含的用途</h3><p>最常用的地方就是用于servlet向jsp/html页面跳转，比如登录页面，登录成功，跳转到success页面，登录失败跳转到fail页面。</p>
<h3 id="request域"><a href="#request域" class="headerlink" title="request域"></a>request域</h3><p>一个范围，ServletContext域，也是一个范围。<br>Context域范围：整个web应用下的资源都可以访问到<br>Request域范围：针对同一个request对象内有效。所有共享同一个request对象的组件，都可以共享request域。转发的源组件和目标组件共享request域吗？当然共享，Servlet跳转到jsp页面的话，可以共享同一个request域对象数据。<br>小问题：这里说的跳转是什么意思？和设置响应头的跳转和重定向有关系吗？</p>
<h3 id="请求范围"><a href="#请求范围" class="headerlink" title="请求范围"></a>请求范围</h3><p>web应用范围内的共享数据作为ServeltContext对象的属性而存在(setAttribute)，只要共享ServletContext对象也就共享了其数据。<br>请求范围内的共享数据作为ServletRequest对象的属性而存在(setAttribute)，只要共享ServletRequest对象也就共享了其数据。</p>
<h2 id="星期四（0822）"><a href="#星期四（0822）" class="headerlink" title="星期四（0822）"></a>星期四（0822）</h2><h3 id="response"><a href="#response" class="headerlink" title="response"></a>response</h3><p>Request是对请求报文的封装，response就是对响应报文的封装。其实也就是socket 和 serviceSocket的关系</p>
<h3 id="常见的API"><a href="#常见的API" class="headerlink" title="常见的API"></a>常见的API</h3><p>Response.setStatus 设置相应的状态码<br>Response.setHeader(name,value)通用的一个形式   设置响应头<br>Response.getWriter() /getOutputStream()</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h3 id="1-传输文件"><a href="#1-传输文件" class="headerlink" title="1.传输文件"></a>1.传输文件</h3><p>1.字符流传输文件</p>
<pre><code>String realPath = getServletContext().getRealPath(&quot;/2.png&quot;);
File file = new File(realPath);
FileInputStream fileInputStream = new FileInputStream(file);
int length = 0;
byte[] bytes = new byte[1024];
while ((length = fileInputStream.read(bytes)) != -1){
    response.getOutputStream().write(bytes,0,length);
}
fileInputStream.close();
</code></pre><p><strong>注意事项</strong> 字节流输出中文默认不会乱码： 那是因为getBytes()的将String转字符是以系统的默认编码格式为基准，而浏览器的字符编码格式也是系统的默认编码格式，所以他们的编码格式都是GBK，碰巧就能显示不乱码的情形：</p>
<pre><code>response.getOutputStream().write(&quot;你好&quot;.getBytes()); //不会乱码默认是中文转字符是GBK格式
String csn = Charset.defaultCharset().name();
System.out.println(csn); //gbk  字符流默认编码格式
</code></pre><p>//字节流最常用的使用方式还是传输文件</p>
<pre><code>response.getOutputStream().write(&quot;你好&quot;.getBytes(&quot;utf-8&quot;));
response.setContentType(&quot;text/html;charset=utf-8&quot;);
</code></pre><p>2.字符流传输文件（只能传输文本文件）</p>
<pre><code>request.setCharacterEncoding(&quot;utf-8&quot;); //字符流才有效
response.setContentType(&quot;text/html;charset=utf-8&quot;);
String path = getServletContext().getRealPath(&quot;a.txt&quot;);
System.out.println(path);
FileReader fileReader = new FileReader(new File(path));
PrintWriter writer = response.getWriter();
int len;
char[] chars = new char[1024];
while((len = fileReader.read(chars)) !=-1 ) {
   writer.write(chars);
}
</code></pre><h3 id="2-定时刷新"><a href="#2-定时刷新" class="headerlink" title="2.定时刷新"></a>2.定时刷新</h3><pre><code>//设置响应头，定时刷新 2表示2秒后执行后面的url；还有一种写法，只有一个数字，只执行一次
//response.setHeader(&quot;refresh&quot;,&quot;2;url=http://www.cskaoyan.com&quot;);
//表示每隔2s便会刷新当前页面一次，反复执行
response.setHeader(&quot;refresh&quot;,&quot;2&quot;);
</code></pre><h3 id="3-重定向（）"><a href="#3-重定向（）" class="headerlink" title="3.重定向（）"></a>3.重定向（）</h3><pre><code>response.sendRedirect(&quot;/response/1.html&quot;);
</code></pre><p>//重定向的另外一种写法：</p>
<pre><code>response.setStatus(302);
response.setHeader(&quot;location&quot;,&quot;/response/1.html&quot;);
</code></pre><h3 id="重定向、定时刷新页面、转发和包含区别"><a href="#重定向、定时刷新页面、转发和包含区别" class="headerlink" title="重定向、定时刷新页面、转发和包含区别"></a>重定向、定时刷新页面、转发和包含区别</h3><p>1.转发和包含是服务器介导的，执行主体是服务器，重定向、refresh刷新是浏览器介导的，执行主体是浏览器<br>2.转发和包含地址栏不会发生变化，浏览器只发出一次请求，重定向、refresh地址栏会发生变化，浏览器会发送两次请求<br>3.转发和包含是request介导的，重定向、refresh是response介导的<br>4.转发和包含只可以访问当前应用下的资源，重定向、refresh可以访问其他服务器资源<br>5.转发和包含可以共享同一request域，重定向、refresh不可以。</p>
<h3 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h3><p>设置响应头<br>    response.setHeader(“Content-Disposition”,”attachment; filename=aaa.txt”);</p>
<h3 id="response注意事项"><a href="#response注意事项" class="headerlink" title="response注意事项"></a>response注意事项</h3><p>1.getOutputStream和getWriter方法分别用于得到输出二进制数据、输出文本数据的ServletOuputStream、Printwriter对象。<br>2.getOutputStream和getWriter这两个方法互相排斥，调用了其中的任何一个方法后，就不能再调用另一方法。  会抛异常。<br>3.Servlet程序向ServletOutputStream或PrintWriter对象中写入的数据将被Servlet引擎从response里面获取，Servlet引擎将这些数据当作响应消息的正文，然后再与响应状态行和各响应头组合后输出到客户端。<br>4.Serlvet的service方法结束后，Servlet引擎将检查getWriter或getOutputStream方法返回的输出流对象是否已经调用过close方法，如果没有，Servlet引擎将调用close方法关闭该输出流对象。但是不会自动关闭输入流inputStream  所以要自己手动关闭输入流</p>
<h2 id="星期五（0823）"><a href="#星期五（0823）" class="headerlink" title="星期五（0823）"></a>星期五（0823）</h2><p>今天主要学习会话，也只是使用而已，还有一些小的细节</p>
<h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p>问题：什么是会话？<br>  会话可简单理解为：用户开一个浏览器，点击多个超链接，访问同一个服务器多个web资源，然后关闭浏览器，整个过程称之为一个会话。<br>会话过程中要解决的一些问题？<br>每个用户在使用浏览器与服务器进行会话的过程中，不可避免各自会产生一些数据，程序要想办法为每个用户保存这些数据。<br>例如：用户点击超链接通过一个servlet购买了一个商品，程序应该想办法保存用户购买的商品，以便于用户点结帐servlet时，结帐servlet可以得到用户购买的商品为用户结帐。</p>
<h3 id="HTTP是无状态的协议"><a href="#HTTP是无状态的协议" class="headerlink" title="HTTP是无状态的协议"></a>HTTP是无状态的协议</h3><p>Web应用程序是使用HTTP协议传输数据的。HTTP协议是无状态的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。即用户A购买了一件商品放入购物车内，当再次购买商品时服务器已经无法判断该购买行为是属于用户A的会话还是用户B的会话了。要跟踪该会话，<strong>必须引入一种机制</strong>。<br>cookie<br>由于服务器无法从http协议上分辨不同的用户，所以服务器要想办法给客户端们颁发一个证件，每人一个，无论谁访问都必须携带自己证件。这样服务器就能从每个人的证件上确认客户身份了。这就是Cookie的工作原理。<br>Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。</p>
<h3 id="保存会话数据的两种技术"><a href="#保存会话数据的两种技术" class="headerlink" title="保存会话数据的两种技术"></a>保存会话数据的两种技术</h3><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>Cookie是客户端(浏览器)技术，服务器程序把每个用户的数据以cookie的形式写给用户各自的浏览器。当用户使用浏览器再去访问服务器中的web资源时，就会带着各自的数据去访问。这样，WEB服务器就能通过cookie去识别用户了。web资源处理的就是用户各自的数据了。</p>
<p>Cookie技术–放映（注意顺序）<br>第一次请求：服务器会在响应头设置 set-cookie: 给用户一个cookie，为了标识用户，此时用户自身请求体没有cookie<br>第二次请求：浏览器带cookie去和用户请求，服务器接收到一个cookie数组，在里面查找就能分辨是谁来请求了。</p>
<h3 id="Cookie基本API"><a href="#Cookie基本API" class="headerlink" title="Cookie基本API"></a>Cookie基本API</h3><p>javax.servlet.http.Cookie类用于创建一个Cookie，response接口中定义了一个addCookie方法，它用于在其响应头中增加一个相应的Set-Cookie头字段。 同样，request接口中也定义了一个getCookies方法，它用于获取客户端提交的Cookie。Cookie类的方法：</p>
<pre><code>public Cookie(String name,String value)
setValue与getValue方法
setMaxAge与getMaxAge方法 (秒)
getName方法
setPath与getPath方法
setDomain与getDomain方法（没什么卵用，一般浏览器不会给你改域名的）
</code></pre><p><strong>注意</strong><br>给不给传cookie是由浏览器决定的，取决于MYURL.startWith(domain+path)完全匹配<br>也就是运行的主题是浏览器，所以需要加上应用名</p>
<h3 id="Cookie-细节"><a href="#Cookie-细节" class="headerlink" title="Cookie 细节"></a>Cookie 细节</h3><pre><code>1.一个Cookie只能标识一种信息，它至少含有一个标识该信息的名称（NAME）和设置值（VALUE）value也必须是字符串类型。
2.一个WEB站点可以给一个WEB浏览器发送多个Cookie，一个WEB浏览器也可以存储多个WEB站点提供的Cookie。
3.浏览器一般只允许存放300个Cookie，每个站点最多存放20-50个Cookie，每个Cookie的大小限制为4KB。
4.如果创建了一个cookie，并将他发送到浏览器，默认情况下它是一个会话级别的cookie（即存储在浏览器的内存中），用户退出浏览器之后即被删除。若希望浏览器将该cookie存储在磁盘上，则需要使用maxAge，并给出一个以秒为单位的时间。将最大时效设为0则是命令浏览器删除该cookie。
5.注意，删除 cookie 时，path必须一致，否则不会删除
6.cookie默认的存在是在浏览器的内存中，也就是说默认关闭浏览器cookie就会消失。可以通过setMaxAge来改变
    setMaxAge 是负数，表示和默认一样，关闭浏览器就消失
    setMaxAge 是正数，表示cookie存活的秒数。是从addCookie开始算起的时间，并不是关闭浏览器后存活的时间，而是创建的时候开始算的时间
    setMaxAge 是零， 表示杀死cookie不会再出现，注意杀死的path要一致
7.不同浏览器之间能否共享cookie
</code></pre><h3 id="使用-cookie"><a href="#使用-cookie" class="headerlink" title="使用 cookie"></a>使用 cookie</h3><pre><code>//第一步，新增一个cookie对象
Cookie cookie = new Cookie(&quot;name&quot;,&quot;zhangsan&quot;);
//第二步，将cookie返回给客户端
response.addCookie(cookie);

//之后客户端再请求
 Cookie[] cookies = request.getCookies();
if(cookies != null){
    for (Cookie cookie : cookies) {
        if(&quot;name&quot;.equals(cookie.getName())){
            response.getWriter().println(cookie.getValue());
            //这个时候删除cookie没有删除成功，为什么？
            //删除cookie的时候，cookie的path一定要和创建的时候path保持一致
            cookie.setMaxAge(0);
            cookie.setPath(&quot;/cookie/cookie3&quot;);
            response.addCookie(cookie);
        }
    }
}
</code></pre><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>假如一个cookie的path是/demo/cookie，那么它能否区分一个应用名即demo，然后资源名是cookie，还有一个应用名是/，资源名是/demo/cookie</p>
<p>可以区分，因为是浏览器为主体path写/demo 就是以引用名开头，所以是可以区分的。实际操作也是可以区分的；当请求应用名/,资源名是/demo/cookie什么都没有</p>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>问题：什么是会话？</p>
<pre><code>会话可简单理解为：用户开一个浏览器，点击多个超链接，访问服务器多个web资源，然后关闭浏览器，整个过程称之为一个会话。
</code></pre><p>会话过程中要解决的一些问题？</p>
<pre><code>每个用户在使用浏览器与服务器进行会话的过程中，不可避免各自会产生一些数据，程序要想办法为每个用户保存这些数据。
例如：用户点击超链接通过一个servlet购买了一个商品，程序应该想办法保存用户购买的商品，以便于用户点结帐servlet时，结帐servlet可以得到用户购买的商品为用户结帐。
</code></pre><p>WEB开发中，服务器可以为每个浏览器创建一个会话对象（session对象），注意：把用户数据写到用户浏览器独占的session中，当前用户使一个浏览器独占一个session对象(默认情况下)。因此，在需要保存用户数据时，服务器程序可以用session保存。同一浏览器可以从用户的session中取出该用户的数据，为用户服务。<br>（数据保存在服务器的Session对象中,内存。浏览器怎么拿到？会给用户一个cookie 名字叫：JsessionID）<br>Session对象由服务器创建，开发人员可以调用request对象的getSession方法得到session对象。</p>
<p>问题：跟cookie一样 从request报文中拿到Session数据？<br>并不是，而是通过报文里的JsessionID 去 服务器内存里查找）</p>
<h3 id="Session的创建"><a href="#Session的创建" class="headerlink" title="Session的创建"></a>Session的创建</h3><p>Request.getSession()/getSession(boolean)<br>服务器区分不同浏览器完全是依靠JSESSIONID的值。如果当前浏览器没有JSESSIONID或者携带一个失效的ID，则服务器会给当前浏览器再新建一个session（只有访问request.getSession()方法时才会新建），并且把 session 的 id JSESSIONID 以 cookie 的形式返回给浏览器端。</p>
<p><strong>两个的区别</strong><br>getSession()方法返回一个session，如果当前没有session，则创建一个。<br>getSession（boolean create）,如果create是true的话，有则返回一个session对象，没有则创建一个。如果为false的情形，有则返回一个，没有则不会创建，返回null。</p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>第一次访问服务器set-cookie 给用户一个sessionID,<br>第二次用户自己带着sessionID的cookie去请求服务器，服务器去找到那个session。</p>
<h3 id="关闭浏览器，重新再访问，会创建新的session吗"><a href="#关闭浏览器，重新再访问，会创建新的session吗" class="headerlink" title="关闭浏览器，重新再访问，会创建新的session吗"></a>关闭浏览器，重新再访问，会创建新的session吗</h3><p>会，关不浏览器之后，默认情况下浏览器的cookie就已经过期拉闸了，之前的session已经不可达了，所以要创建一个新的session给他一个新的cookie&gt;</p>
<h3 id="假如重新打开浏览器，仍然可以看到原来的数据，应该做哪些操作。？？？"><a href="#假如重新打开浏览器，仍然可以看到原来的数据，应该做哪些操作。？？？" class="headerlink" title="假如重新打开浏览器，仍然可以看到原来的数据，应该做哪些操作。？？？"></a>假如重新打开浏览器，仍然可以看到原来的数据，应该做哪些操作。？？？</h3><p>这是考试题目？现在我们来实现以下，很简单，就是把cookie设置一个setMaxAge就好了。<br>注意创建的cookie一定要放到response中。要不然肯定没用啦。新的cookie只要name和path和原来的cookie一样，那么这两个就是相同的cookie，新创建的cookie就能覆盖之前的cookie。</p>
<pre><code>protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
   HttpSession httpSession = request.getSession();
   //创建一个新的cookie覆盖 session自己创建的cookie，记得设置存在时间
   Cookie cookie = new Cookie(&quot;JSESSIONID&quot;,httpSession.getId());
   cookie.setMaxAge(1000);
   response.addCookie(cookie);
}
</code></pre><h3 id="Session-生命周期"><a href="#Session-生命周期" class="headerlink" title="Session 生命周期"></a>Session 生命周期</h3><p>注意这里的 seesion 的生命周期，看是说的是 Session 的生命周期，还是里面数据的生命周期，两者是不一样。</p>
<h3 id="Session的生命周期"><a href="#Session的生命周期" class="headerlink" title="Session的生命周期"></a>Session的生命周期</h3><p>当调用request.getSession()如果request没检测到有JSESSIONID的cookie就会创建一个新的session<br>当服务器关闭，应用卸载，Session对象会死亡，但是里面的<strong>数据并不会死亡！</strong>，会放在idea复制的tomcat配置文件的目录下：</p>
<pre><code>C:\Users\lenovo\.IntelliJIdea2019.1\system\tomcat\Tomcat_8_5_37_JavaEE_10\work\Catalina\localhost\ROOT
</code></pre><p>的文件中SESSIONS.ser，当再次创建Session对象，又会从这个文件中读取原先Session的数据，虽然不是同一个Session对象，但是他们的数据是相同的。</p>
<h3 id="Session数据的生命周期"><a href="#Session数据的生命周期" class="headerlink" title="Session数据的生命周期"></a>Session数据的生命周期</h3><p>只要用户还有cookie(JsessionId)就能找到那个session对象的数据，也许服务器关闭，或者servlet拉闸，只要有cookie就能拿到你的数据。<br>就好像银行，只要你有银行卡，不管银行卡关不关门（服务器），或者在不在同一家取（session对象地址是否相同），你都可以取到你的钱。</p>
<p>Session数据拉闸只有两种可能：—-session的有效期<br>1.Session数据默认的存在时间是30分钟，可以在tomcat的conf/web.xml配置文件中去修改这个值</p>
<pre><code>&lt;session-config&gt;
    &lt;session-timeout&gt;30&lt;/session-timeout&gt;
&lt;/session-config&gt;
</code></pre><p>2.调用session.invalidate();数据就会拉闸</p>
<h3 id="Session域"><a href="#Session域" class="headerlink" title="Session域"></a>Session域</h3><p>Session setAttribute/ getAttribute /removeAttribute</p>
<p>Context域  &gt;  Session域   &gt;   Request域</p>
<p>Context域：当前应用下所有的资源均可以使用的一个域<br>Session域：同一个浏览器，都可以访问的一个域（用户登录成功之后，将用户名放入session域中，接着进入个人主页，显示欢迎你，xxxxx，这个数据从session中获取。）<br>Request域：同一次请求内的资源可以访问，转发：源组件和目标组件之间。</p>
<p>也就是说当需要用户使用不同的浏览器都能访问相同的数据时候，我们使用Context域来临时存放属性<br>当用户只需要在同一个浏览器中不同页面进行数据的传输我们使用Session&amp;cookie<br>request只能是当前的请求，只能在转发，包含的页面的servlet或者jsp等资源中</p>
<p>Context：针对的同一个是服务（应用）<br>Session:针对的是同一个浏览器<br>request:针对的是同一个请求</p>
<h3 id="Session和Cookie的主要区别在于："><a href="#Session和Cookie的主要区别在于：" class="headerlink" title="Session和Cookie的主要区别在于："></a>Session和Cookie的主要区别在于：</h3><pre><code>Cookie是把用户的数据写给用户的浏览器（在浏览器保存）。
Session技术把用户的数据写到用户独占的session中。（在服务器端保存）
</code></pre><h2 id="星期六（0824）"><a href="#星期六（0824）" class="headerlink" title="星期六（0824）"></a>星期六（0824）</h2><h3 id="文件上传-FileUpload"><a href="#文件上传-FileUpload" class="headerlink" title="文件上传 FileUpload"></a>文件上传 FileUpload</h3><p>实现web开发中的文件上传功能，需完成如下二步操作：</p>
<pre><code>在web页面中添加上传输入项
在servlet中读取上传文件的数据，并保存到服务器硬盘中。
</code></pre><p>前端实现思路：使用一个input标签type=”file”就可以传输文件，如果你不会可以使用form表单进行提交，或者使用AJAX进行提交，注意跨域的问题。</p>
<p>后端实现的思路：上传的文件会在请求报文中，请求报文被tomcat封装到request对象中，因此，我们只需要从request对象中取出请求报文的请求体，也就是我们上传的文件。看样子和我们从服务器下载文件是相反的一个相同的过程。<br>Request.getInputStream();接下来就是常规的IO操作。</p>
<p><strong>发现问题！！！</strong></p>
<h3 id="问题一：仅上传文件名，不上传文件内容，这TM怎么办？"><a href="#问题一：仅上传文件名，不上传文件内容，这TM怎么办？" class="headerlink" title="问题一：仅上传文件名，不上传文件内容，这TM怎么办？"></a>问题一：仅上传文件名，不上传文件内容，这TM怎么办？</h3><p>注意：&lt;input type=“file”&gt;标签用于在web页面中添加文件上传输入项，设置文件上传输入项时须注意：</p>
<pre><code>1、必须要设置input输入项的name属性，否则浏览器将不会发送上传文件的数据。
２、必须把form的enctype属值设为multipart/form-data.设置该值后，浏览器在上传文件时，将把文件数据附带在http请求消息体中，并使用ＭＩＭＥ协议对上传的文件进行描述，以方便接收方对上传数据进行解析和处理。
3、表单的提交方式要是post
</code></pre><p><strong>为什么提交表单使用post请求？</strong><br>虽然get请求也可以传提交的数据，但是长度只有1k，一般文件都大于1k，除非是图片使用H5的一些技术能把图片转成二进制进行传输，不过这个不常用，还是直接提交图片。使用post请求；</p>
<h3 id="问题二：写代码处理上传，图片无法打开"><a href="#问题二：写代码处理上传，图片无法打开" class="headerlink" title="问题二：写代码处理上传，图片无法打开?"></a>问题二：写代码处理上传，图片无法打开?</h3><p>发现虽然可以上传文件，而且文件的格式也是正确的，使用的也是字节流进行传输，但是就是在服务端保存的文件就是打不开？这是怎么回事<br>当我们使用一个txt文本进行上传，发现文件多了一部分内容。<br>当文件上传和普通form表单数据一起提交的时候，<strong>表单数据被写入到文件中</strong>，因为我们没有写代码来进行分割。<br>这尼玛就很难受了</p>
<pre><code>------WebKitFormBoundaryMJXzkNCcTt6PwnGA
Content-Disposition: form-data; name=&quot;username&quot;

admin
------WebKitFormBoundaryMJXzkNCcTt6PwnGA
Content-Disposition: form-data; name=&quot;password&quot;

admin
------WebKitFormBoundaryMJXzkNCcTt6PwnGA
Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;1.txt&quot;
Content-Type: text/plain

拉闸
------WebKitFormBoundaryMJXzkNCcTt6PwnGA--
</code></pre><p>除此之外，还有什么？？？数据结构？？？？<br>添加multipart/form-data之后的请求报文结构<br>发现那些表单中的参数都没了，也就是说<strong>不能再使用servlet的getParameter这一类的方法获取请求的参数了</strong></p>
<h3 id="文件上传面临的问题"><a href="#文件上传面临的问题" class="headerlink" title="文件上传面临的问题"></a>文件上传面临的问题</h3><p>必须要添加multipart/form-data,不添加则不能上传文件。<br>添加之后，必须手动来处理普通form表单上数据和文件数据。<br>可以利用WebKitFormBoundary来进行分割出各部分数据，方向是对的，但是执行起来很有难度，因此，我们采用一个三方组件，jar包来完成文件上传。</p>
<h3 id="Commons-FileUpload"><a href="#Commons-FileUpload" class="headerlink" title="Commons-FileUpload"></a>Commons-FileUpload</h3><p>阿帕奇牛皮！！！<br>阿里牛皮！！！<br>阿开头的都牛皮</p>
<p>首先引入两个jar包</p>
<pre><code>commons-fileupload-1.3.1.jar
commons-io-2.4.jar
</code></pre><p>然后看教程怎么玩：<a href="http://commons.apache.org/proper/commons-fileupload/using.html" target="_blank" rel="external">官方教你怎么玩</a><br>官方实例的表单：</p>
<pre><code>&lt;form method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot; action=&quot;fup.cgi&quot;&gt;
  File to upload: &lt;input type=&quot;file&quot; name=&quot;upfile&quot;&gt;&lt;br/&gt;
  Notes about the file: &lt;input type=&quot;text&quot; name=&quot;note&quot;&gt;&lt;br/&gt;
  &lt;br/&gt;
  &lt;input type=&quot;submit&quot; value=&quot;Press&quot;&gt; to upload the file!
&lt;/form&gt;
</code></pre><h3 id="isMultipart判断上传的表单是否有写enctype-”multipart-form-data”"><a href="#isMultipart判断上传的表单是否有写enctype-”multipart-form-data”" class="headerlink" title="isMultipart判断上传的表单是否有写enctype=”multipart/form-data”"></a>isMultipart判断上传的表单是否有写enctype=”multipart/form-data”</h3><pre><code>boolean isMultipart = ServletFileUpload.isMultipartContent(request);
</code></pre><h3 id="The-simplest-case"><a href="#The-simplest-case" class="headerlink" title="The simplest case"></a>The simplest case</h3><pre><code>// Create a factory for disk-based file items
DiskFileItemFactory factory = new DiskFileItemFactory();
// Configure a repository (to ensure a secure temp location is used)
ServletContext servletContext = this.getServletConfig().getServletContext();
File repository = (File) servletContext.getAttribute(&quot;javax.servlet.context.tempdir&quot;);
factory.setRepository(repository);
// Create a new file upload handler
ServletFileUpload upload = new ServletFileUpload(factory);
// Parse the request
List&lt;FileItem&gt; items = upload.parseRequest(request);
</code></pre><h3 id="Processing-the-uploaded-items-处理上传的表单的数据"><a href="#Processing-the-uploaded-items-处理上传的表单的数据" class="headerlink" title="Processing the uploaded items 处理上传的表单的数据"></a>Processing the uploaded items 处理上传的表单的数据</h3><pre><code>Iterator&lt;FileItem&gt; iter = items.iterator();
while (iter.hasNext()) {
    FileItem item = iter.next();
    if (item.isFormField()) {
        processFormField(item);
    } else {
        processUploadedFile(item);
    }
}
</code></pre><p>//如果是一个表单的常规参数 ，Process a regular form field</p>
<pre><code>if (item.isFormField()) {
    String name = item.getFieldName();
    String value = item.getString();
    ...
}
</code></pre><p>//如果是上传的文件 Process a file upload</p>
<pre><code>if (!item.isFormField()) {
    String fieldName = item.getFieldName();
    String fileName = item.getName();
    String contentType = item.getContentType();
    boolean isInMemory = item.isInMemory();
    long sizeInBytes = item.getSize();
    ...
}
</code></pre><p>// Process a file upload你可以选择直接写入你的服务器的硬盘，或者使用流读取到你的内存中但是不建议</p>
<pre><code>if (writeToFile) {
    File uploadedFile = new File(...);
    item.write(uploadedFile);
} else {
    InputStream uploadedStream = item.getInputStream();
    ...
    uploadedStream.close();
}
</code></pre><p>大概就是这些,可以自己封装一个上传文件的小工具。</p>
<h3 id="文件上传的问题："><a href="#文件上传的问题：" class="headerlink" title="文件上传的问题："></a>文件上传的问题：</h3><h3 id="1-同名文件上传问题"><a href="#1-同名文件上传问题" class="headerlink" title="1.同名文件上传问题"></a>1.同名文件上传问题</h3><p>使用UUID来给文件取名字：</p>
<h3 id="2-文件过多查找难度问题"><a href="#2-文件过多查找难度问题" class="headerlink" title="2.文件过多查找难度问题"></a>2.文件过多查找难度问题</h3><p>同一目录下文件数过多，会导致文件读取很慢<br>Hashcode 散列 ，其实HashMap底层就是散列存储，然后使用拉链法来解决冲突的。<br>首先得到文件名的Hashcode，转为16进制的字符串。<br>接着将每一位的字符串分别新建一个文件夹 ，一共8级目录，每一级目录16个文件夹<br>最后，在相应的目录下存放对应的文件。</p>
<h3 id="实现前面写的两个问题"><a href="#实现前面写的两个问题" class="headerlink" title="实现前面写的两个问题"></a>实现前面写的两个问题</h3><pre><code>private static void processUploadedFile(FileItem item , Map&lt;String, String[]&gt; parameterMap) throws FileUploadException {
    String fieldName = item.getFieldName();
    //文件名称需要做一个处理，保证每一个文件不会与其他文件重名
    //当前的时间戳加上一些序列数2019082411254790
    String uuid = UUID.randomUUID().toString();

    //第二个问题，一个目录内文件数目过多，应该怎么办？散列
    String fileName = item.getName();
    String contentType = item.getContentType();

    //判断一下是否有上传文件
    if(!(fileName.endsWith(&quot;.png&quot;))&amp;&amp;!(fileName.endsWith(&quot;.jpg&quot;))){
        throw new FileUploadException(&quot;文件的格式不正确！&quot;);
    } else {
        fileName = uuid + &quot;-&quot; + fileName;
        String upload = servletContext.getRealPath(&quot;upload&quot;);
        int hashCode = fileName.hashCode();
        //int 32  16  8   1 2 3 4 a b f 3  16^8 40亿左右
        String s = Integer.toHexString(hashCode);
        String fileInt = &quot;&quot;; //数据库存储的地址
        char[] chars = s.toCharArray();
        for (char aChar : chars) {
            upload = upload + &quot;/&quot; + aChar;
            fileInt = &quot;/&quot; + aChar;
        }
        // 创建路径保存文件
        String filePath = upload + &quot;/&quot; + fileName;
        System.out.println(&quot;保存路径：&quot; + upload);
        //saveFile(item,filePath); //保存图片到服务器
        parameterMap.put(&quot;icon&quot;,new String[]{fileInt + fileName}); //只能保存一个
    }
}
</code></pre><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><p>1.VUE发布到tomcat的一些设置：<br><a href="https://blog.csdn.net/qq_38387487/article/details/78461412" target="_blank" rel="external">https://blog.csdn.net/qq_38387487/article/details/78461412</a><br>2.map的遍历<br>使用entryset遍历<br>for (Map.Entry<integer, integer=""> entry : map.entrySet()) {<br>  System.out.println(“key = “ + entry.getKey() + “, value = “ + entry.getValue());<br>}</integer,></p>
<p>3.反射传参数是数组，invoke时候要强转成objet<br>Method method = userClass.getDeclaredMethod(methodsName,String[].class);<br>   method.setAccessible(true);<br>   method.invoke(user1, (Object) value);</p>
<p>4.调度员（转发和包含）<br>就是一个接口，有两个方法</p>
<pre><code>void  forward(ServletRequest request, ServletResponse response)
      Forwards a request from a servlet to another resource (servlet, JSP file, or HTML file) on the server.
void include(ServletRequest request, ServletResponse response)
      Includes the content of a resource (servlet, JSP page, HTML file) in the response.
</code></pre><p>5.如果 servletA forward 到 servletB<br>在 servletA 设置 response 的响应头才有效！</p>
<p>6.在web-info目录下的文件没有被放到部署路径<br>需要创建一个classes文件夹，设置一下编译的class文件放在classes文件夹下，他就会自动过去了</p>
<p>7.JAVA下载文件中文名是下划线的问题：<br>这应该是由于浏览器的默认编码不同所引起的，需要判断一下，然后进行转码</p>
<pre><code>if(request.getHeader(&quot;User-Agent&quot;).toUpperCase().indexOf(&quot;MSIE&quot;) &gt; 0) {
    response.setHeader(&quot;Content-Disposition&quot;,&quot;attachment;&quot;+ &quot;filename=&quot;+ new
String(filename.getBytes(&quot;GBK&quot;),&quot;ISO8859-1&quot;));
}else{//firefox、chrome、safari、opera
  response.setHeader(&quot;Content-Disposition&quot;,&quot;attachment;&quot;+
 &quot;filename=&quot;+ new String(filename.getBytes(&quot;UTF8&quot;), &quot;ISO8859-1&quot;) );
}
</code></pre><p>8.关于 cookie 存在时间的问题<br>注意设置 setMaxAge（）的单位是秒 ，怪不得之前设置太少了就没保存<br>还有设置完注意：<br>1）如果是刚创建完的时候设置的时间，就没事<br>2）如果不是刚创建完的之后遍历获取cookie然后再修改的，注意把cookie add回去response.addCookie(cookie);</p>
<pre><code>for (Cookie cookie : cookies) {
    String name = cookie.getName();
    String value = cookie.getValue();
    System.out.println(name);
    System.out.println(value);
    if(&quot;name&quot;.equals(name)) {
        cookie.setMaxAge(100);
        cookie.setPath(&quot;/0823_war_exploded/CookieServlet2&quot;);
        response.addCookie(cookie);
    }
}
</code></pre><p>3）配合session使用，让 session 在关闭浏览器后，重新打开还能再使用，就在服务器设置一个cookie，覆盖掉session自己的cookie。</p>
<pre><code>HttpSession HttpSession = request.getSession();
HttpSession.getId();
Cookie cookie = new Cookie(&quot;JSEESIONID&quot;,HttpSession.getId());
cookie.setMaxAge(1000);//1000秒
response.addCookie(cookie);
</code></pre><p>9.文件上传问题，<br>1) 只要有</p>
<pre><code>&lt;form action=&quot;/Upload&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt;&lt;/form&gt;
</code></pre><p>直接提交也会保存文件，这样感觉不太科学<br>就会上传一个空的文件类型的文件。<br>2) 设置了这个enctype。request.getParaMeterValues()..这一类的就无效了</p>
<p>10.JAVA 使用转json的jar包<a href="https://www.w3cschool.cn/fastjson/fastjson-quickstart.html" target="_blank" rel="external">https://www.w3cschool.cn/fastjson/fastjson-quickstart.html</a><br>11.在 bean里面添加成员变量的问题，一定要记得重写toString 的方法，<br>12.第一次创建session 设置 cookie时间问题： <a href="https://www.cnblogs.com/jarl/p/5892996.html" target="_blank" rel="external">https://www.cnblogs.com/jarl/p/5892996.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/18/Java总结（八）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王邸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路要坚持">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/18/Java总结（八）/" itemprop="url">Java总结（八）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-18T22:37:23+08:00">
                2019-08-18
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/08/18/Java总结（八）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/08/18/Java总结（八）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2019/08/18/Java总结（八）/" class="leancloud_visitors" data-flag-title="Java总结（八）">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>总结，本周还是讲的XML前端，不过使用node+vue启动的前端项目</p>
<h2 id="星期一（8-12）"><a href="#星期一（8-12）" class="headerlink" title="星期一（8.12）"></a>星期一（8.12）</h2><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p>文档对象模型，<br>是W3C织制订的一套用于访问HTML文档的标准.允许脚本动态地访问和更新文档的内容、结构和样式.<br>分类</p>
<pre><code>DOM Core
XML DOM
HTML DOM
</code></pre><h3 id="XML-DOM-和-HTML-DOM-关系"><a href="#XML-DOM-和-HTML-DOM-关系" class="headerlink" title="XML DOM 和 HTML DOM 关系"></a>XML DOM 和 HTML DOM 关系</h3><p>XML DOM 定义了访问和处理 XML 文档的标准方法<br>HTML文档格式 符合XML语法标准，所以可以使用XML DOM API<br>在XML DOM每个元素 都会被解析为一个节点Node，而常用的节点类型又分为</p>
<pre><code>元素节点  Element
属性节点  Attr
文本节点  Text
文档节点  Document
</code></pre><p>HTML DOM 定义了针对 HTML文档的对象，可以说是一套 更加适用于 JavaScript 技术开发 的API<br>HTML DOM是对XML DOM的扩展<br>进行 JavaScript DOM开发 可以同时使用 XML DOM和 HTML DOM</p>
<h3 id="Node的特性方法"><a href="#Node的特性方法" class="headerlink" title="Node的特性方法"></a>Node的特性方法</h3><table>
<thead>
<tr>
<th style="text-align:right">特性/方法</th>
<th style="text-align:center">类型/返回类型</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">nodeName</td>
<td style="text-align:center">String</td>
<td style="text-align:left">节点的名字；根据节点的类型而定义</td>
</tr>
<tr>
<td style="text-align:right">nodeValue</td>
<td style="text-align:center">String</td>
<td style="text-align:left">节点的值；根据节点的类型而定义</td>
</tr>
<tr>
<td style="text-align:right">nodeType</td>
<td style="text-align:center">Number</td>
<td style="text-align:left">节点的类型常量值之一</td>
</tr>
<tr>
<td style="text-align:right">ownerDocument</td>
<td style="text-align:center">Document</td>
<td style="text-align:left">指向这个节点所属的文档</td>
</tr>
<tr>
<td style="text-align:right">firstChild</td>
<td style="text-align:center">Node</td>
<td style="text-align:left">指向在childNodes列表中的第一个节点</td>
</tr>
<tr>
<td style="text-align:right">lastChild</td>
<td style="text-align:center">Node</td>
<td style="text-align:left">指向在childNodes列表中的最后一个节点</td>
</tr>
<tr>
<td style="text-align:right">childNodes</td>
<td style="text-align:center">NodeList</td>
<td style="text-align:left">所有子节点的列表</td>
</tr>
<tr>
<td style="text-align:right">parentNode</td>
<td style="text-align:center">Node</td>
<td style="text-align:left">返回一个给定节点的父节点。</td>
</tr>
<tr>
<td style="text-align:right">previousSibling</td>
<td style="text-align:center">Node</td>
<td style="text-align:left">指向前一个兄弟节点；如果这个节点就是第一个兄弟节点，那么该值为null</td>
</tr>
<tr>
<td style="text-align:right">nextSibling</td>
<td style="text-align:center">Node</td>
<td style="text-align:left">指向后一个兄弟节点；如果这个节点就是最后一个兄弟节点，那么该值为null</td>
</tr>
<tr>
<td style="text-align:right">hasChildNodes()</td>
<td style="text-align:center">Boolean</td>
<td style="text-align:left">当childNodes包含一个或多个节点时，返回真</td>
</tr>
<tr>
<td style="text-align:right">attributes</td>
<td style="text-align:center">NamedNodeMap</td>
<td style="text-align:left">包含了代表一个元素的属性的Attr对象；仅用于Element节点</td>
</tr>
<tr>
<td style="text-align:right">appendChild(node)</td>
<td style="text-align:center">Node</td>
<td style="text-align:left">将node添加到childNodes的末尾</td>
</tr>
<tr>
<td style="text-align:right">removeChild(node)</td>
<td style="text-align:center">Node</td>
<td style="text-align:left">从childNodes中删除node</td>
</tr>
<tr>
<td style="text-align:right">replaceChild</td>
<td style="text-align:center">Node</td>
<td style="text-align:left">将childNodes中的oldnode替换成newnode(newnode, oldnode)</td>
</tr>
<tr>
<td style="text-align:right">insertBefore</td>
<td style="text-align:center">Node</td>
<td style="text-align:left">在childNodes中的refnode之前插入newnode(newnode, refnode)</td>
</tr>
</tbody>
</table>
<h3 id="DOM-节点常用属性"><a href="#DOM-节点常用属性" class="headerlink" title="DOM 节点常用属性"></a>DOM 节点常用属性</h3><p>nodeName</p>
<pre><code>如果节点是元素节点，nodeName返回这个元素的名称
如果是属性节点，nodeName返回这个属性的名称
如果是文本节点，nodeName返回一个内容为#text 的字符串
</code></pre><p>nodeType</p>
<pre><code>Node.ELEMENT_NODE    ---1    -- 元素节点
Node.ATTRIBUTE_NODE  ---2    -- 属性节点
Node.TEXT_NODE       ---3    -- 文本节点（空节点）
</code></pre><p>nodeValue</p>
<pre><code>如果给定节点是一个属性节点，返回值是这个属性的值
如果给定节点是一个文本节点，返回值是这个文本节点内容
如果给定节点是一个元素节点，返回值是 null
</code></pre><h2 id="星期二（8-13）"><a href="#星期二（8-13）" class="headerlink" title="星期二（8.13）"></a>星期二（8.13）</h2><h3 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h3><p>这个东西已经过时了，主要用的还是XML的两个常用约束DTD 和 schema，为了更好的理解这两个配置文件的约束，我们先了解一下XML的语法规范</p>
<h3 id="XML的语法规则"><a href="#XML的语法规则" class="headerlink" title="XML的语法规则"></a>XML的语法规则</h3><p><strong>所有的 XML 元素都必须有一个关闭标签</strong><br>在 HTML 中，某些元素不必有一个关闭标签：</p>
<pre><code>&lt;p&gt;This is a paragraph.
&lt;br&gt;
</code></pre><p>在 XML 中，省略关闭标签是非法的。所有元素都必须有关闭标签：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;p&gt;This is a paragraph.&lt;/p&gt;
</code></pre><p>注释：从上面的实例中，您也许已经注意到 XML 第一行中声明没有关闭标签，这不是错误，声明不是 XML 文档本身的一部分，它没有关闭标签。</p>
<p><strong>XML 标签对大小写敏感</strong><br>XML 标签对大小写敏感。</p>
<pre><code>标签 &lt;Message&gt; 与标签 &lt;message&gt; 是不同的。
</code></pre><p>必须使用相同的大小写来编写打开标签和关闭标签：</p>
<pre><code>&lt;Message&gt;This is incorrect&lt;/message&gt;
&lt;message&gt;This is correct&lt;/message&gt;
</code></pre><p>注释：打开标签和关闭标签通常被称为开始标签和结束标签。不论您喜欢哪种术语，它们的概念都是相同的。</p>
<p><strong>XML 必须正确嵌套</strong><br>在 HTML 中，常会看到没有正确嵌套的元素：</p>
<pre><code>&lt;b&gt;&lt;i&gt;This text is bold and italic&lt;/b&gt;&lt;/i&gt; //错误的嵌套
</code></pre><p>在 XML 中，所有元素都必须彼此正确地嵌套：</p>
<pre><code>&lt;b&gt;&lt;i&gt;This text is bold and italic&lt;/i&gt;&lt;/b&gt;
在上面的实例中，正确嵌套的意思是：由于 &lt;i&gt; 元素是在 &lt;b&gt; 元素内打开的，那么它必须在 &lt;b&gt; 元素内关闭。
</code></pre><p><strong>XML 文档必须有根元素</strong><br>XML 文档必须有一个元素是所有其他元素的父元素。该元素称为根元素。</p>
<pre><code>&lt;root&gt;
&lt;child&gt;
&lt;subchild&gt;.....&lt;/subchild&gt;
&lt;/child&gt;
&lt;/root&gt;
</code></pre><p><strong>XML 属性值必须加引号</strong><br>与 HTML 类似，XML 元素也可拥有属性（名称/值的对）。<br>在 XML 中，XML 的属性值必须加引号。<br>请研究下面的两个 XML 文档。 第一个是错误的，第二个是正确的：</p>
<pre><code>&lt;note date=12/11/2007&gt;
&lt;to&gt;Tove&lt;/to&gt;
&lt;from&gt;Jani&lt;/from&gt;
&lt;/note&gt;

&lt;note date=&quot;12/11/2007&quot;&gt;
&lt;to&gt;Tove&lt;/to&gt;
&lt;from&gt;Jani&lt;/from&gt;
&lt;/note&gt;
</code></pre><p>在第一个文档中的错误是，note 元素中的 date 属性没有加引号。</p>
<p><strong>实体引用</strong><br>在 XML 中，一些字符拥有特殊的意义。<br>如果您把字符 “&lt;” 放在 XML 元素中，会发生错误，这是因为解析器会把它当作新元素的开始。<br>这样会产生 XML 错误：</p>
<pre><code>&lt;message&gt;if salary &lt; 1000 then&lt;/message&gt;
</code></pre><p>为了避免这个错误，请用实体引用来代替 “&lt;” 字符：</p>
<p> <message>if salary &lt; 1000 then</message><br>在 XML 中，有 5 个预定义的实体引用：</p>
<pre><code>&amp;lt;    &lt;   less than
&amp;gt;    &gt;   greater than
&amp;amp;   &amp;   ampersand
&amp;apos;  &apos;   apostrophe
&amp;quot;  &quot;   quotation mark
</code></pre><p>注释：在 XML 中，只有字符 “&lt;” 和 “&amp;” 确实是非法的。大于号是合法的，但是用实体引用来代替它是一个好习惯。</p>
<p><strong>XML 中的注释</strong><br>在 XML 中编写注释的语法与 HTML 的语法很相似。</p>
<pre><code>&lt;!-- This is a comment --&gt;
提示：你也可以了解一下“HTML &lt;!--...--&gt; 注释标签”。
</code></pre><p><strong>在 XML 中，空格会被保留</strong><br>HTML 会把多个连续的空格字符裁减（合并）为一个：</p>
<p>HTML:   Hello Tove<br>Output: Hello Tove<br>在 XML 中，文档中的空格不会被删减。</p>
<p><strong>XML 以 LF 存储换行</strong><br>在 Windows 应用程序中，换行通常以一对字符来存储：回车符（CR）和换行符（LF）。<br>在 Unix 和 Mac OSX 中，使用 LF 来存储新行。<br>在旧的 Mac 系统中，使用 CR 来存储新行。<br>XML 以 LF 存储换行。<br>以上就是在使用 XML 时需要注意到的语法规则，按照这些规则，编写一个正确的 XML 文档！</p>
<h3 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h3><p>文档类型定义（DTD）可定义合法的XML文档构建模块。它使用一系列合法的元素来定义文档的结构。<br>DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用</p>
<h3 id="DTD-简介"><a href="#DTD-简介" class="headerlink" title="DTD 简介"></a>DTD 简介</h3><p>对XML DTD 的简介，以及使用它的原因。</p>
<h3 id="内部的-DOCTYPE-声明"><a href="#内部的-DOCTYPE-声明" class="headerlink" title="内部的 DOCTYPE 声明"></a>内部的 DOCTYPE 声明</h3><p>假如 DTD 被包含在您的 XML 源文件中，它应当通过下面的语法包装在一个 DOCTYPE 声明中：</p>
<pre><code>&lt;!DOCTYPE 根元素 [元素声明]&gt;
</code></pre><p>带有 DTD 的 XML 文档实例（请在 IE5 以及更高的版本打开，并选择查看源代码）：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE note [
  &lt;!ELEMENT note (to,from,heading,body)&gt;
  &lt;!ELEMENT to      (#PCDATA)&gt;
  &lt;!ELEMENT from    (#PCDATA)&gt;
  &lt;!ELEMENT heading (#PCDATA)&gt;
  &lt;!ELEMENT body    (#PCDATA)&gt;
]&gt;
&lt;note&gt;
  &lt;to&gt;George&lt;/to&gt;
  &lt;from&gt;John&lt;/from&gt;
  &lt;heading&gt;Reminder&lt;/heading&gt;
  &lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt;
&lt;/note&gt;
</code></pre><p>以上 DTD 解释如下：<br>!DOCTYPE note (第二行)定义此文档是 note 类型的文档。<br>!ELEMENT note (第三行)定义 note 元素有四个元素：”to、from、heading,、body”<br>!ELEMENT to (第四行)定义 to 元素为 “#PCDATA” 类型<br>!ELEMENT from (第五行)定义 from 元素为 “#PCDATA” 类型<br>!ELEMENT heading (第六行)定义 heading 元素为 “#PCDATA” 类型<br>!ELEMENT body (第七行)定义 body 元素为 “#PCDATA” 类型</p>
<p>外部文档声明<br>假如 DTD 位于 XML 源文件的外部，那么它应通过下面的语法被封装在一个 DOCTYPE 定义中：</p>
<pre><code>&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;
</code></pre><p>这个 XML 文档和上面的 XML 文档相同，但是拥有一个外部的 DTD: （在 IE5 中打开，并选择“查看源代码”命令。）</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE note SYSTEM &quot;note.dtd&quot;&gt;
&lt;note&gt;
&lt;to&gt;George&lt;/to&gt;
&lt;from&gt;John&lt;/from&gt;
&lt;heading&gt;Reminder&lt;/heading&gt;
&lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt;
&lt;/note&gt;
</code></pre><p>这是包含 DTD 的 “note.dtd” 文件：</p>
<pre><code>&lt;!ELEMENT note (to,from,heading,body)&gt;
&lt;!ELEMENT to (#PCDATA)&gt;
&lt;!ELEMENT from (#PCDATA)&gt;
&lt;!ELEMENT heading (#PCDATA)&gt;
&lt;!ELEMENT body (#PCDATA)&gt;
</code></pre><h3 id="DTD-XML-构建模块"><a href="#DTD-XML-构建模块" class="headerlink" title="DTD - XML 构建模块"></a>DTD - XML 构建模块</h3><p>可以在 DTD 中定义的 XML 构建模块。<br>所有的 XML 文档（以及 HTML 文档）均由以下简单的构建模块构成：</p>
<pre><code>元素
属性
实体
PCDATA
CDATA
</code></pre><h3 id="DTD-元素"><a href="#DTD-元素" class="headerlink" title="DTD 元素"></a>DTD 元素</h3><p>如何使用 DTD 定义 XML 文档的合法元素。<br>声明一个元素<br>在 DTD 中，XML 元素通过元素声明来进行声明。元素声明使用下面的语法：<br>&lt;!ELEMENT 元素名称 类别&gt;<br>或者<br>&lt;!ELEMENT 元素名称 (元素内容)&gt;<br>只有 PCDATA 的元素<br>只有 PCDATA 的元素通过圆括号中的 #PCDATA 进行声明：</p>
<pre><code>&lt;!ELEMENT 元素名称 (#PCDATA)&gt; 只有 PCDATA 的元素
&lt;!ELEMENT 元素名称 ANY&gt; 带有任何内容的元素
&lt;!ELEMENT 元素名称 (子元素名称 1,子元素名称 2,.....)&gt; 带有子元素（序列）的元素
&lt;!ELEMENT 元素名称 (子元素名称)&gt;声明只出现一次的元素
&lt;!ELEMENT 元素名称 (子元素名称+)&gt; 声明最少出现一次的元素
&lt;!ELEMENT 元素名称 (子元素名称*)&gt; 声明出现零次或多次的元素
&lt;!ELEMENT note (to,from,header,(message|body))&gt;声明“非.../既...”类型的内容 ：&quot;note&quot; 元素必须包含 &quot;to&quot; 元素、&quot;from&quot; 元素、&quot;header&quot; 元素，以及 &quot;message&quot; 元素或&quot;body&quot; 元素。
</code></pre><p>例子：</p>
<pre><code>&lt;!ELEMENT from (#PCDATA)&gt;
&lt;!ELEMENT note (message)&gt;
</code></pre><h3 id="DTD-属性"><a href="#DTD-属性" class="headerlink" title="DTD 属性"></a>DTD 属性</h3><p>如何使用 DTD 定义 XML 元素的合法属性。<br>在 DTD 中，属性通过 ATTLIST 声明来进行声明。<br>声明属性<br>属性声明使用下列语法：</p>
<pre><code>&lt;!ATTLIST 元素名称 属性名称 属性类型 默认值&gt;
</code></pre><p>DTD 实例:</p>
<pre><code>&lt;!ATTLIST payment type CDATA &quot;check&quot;&gt;
</code></pre><p>XML 实例:</p>
<pre><code>&lt;payment type=&quot;check&quot; /&gt;
</code></pre><p>以下是属性类型的选项：</p>
<table>
<thead>
<tr>
<th style="text-align:right">类型</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">CDATA</td>
<td style="text-align:left">值为字符数据 (character data)</td>
</tr>
<tr>
<td style="text-align:right">(en1</td>
<td style="text-align:left">en2</td>
<td>..)</td>
<td>此值是枚举列表中的一个值</td>
</tr>
<tr>
<td style="text-align:right">ID</td>
<td style="text-align:left">值为唯一的 id</td>
</tr>
<tr>
<td style="text-align:right">IDREF</td>
<td style="text-align:left">值为另外一个元素的 id</td>
</tr>
<tr>
<td style="text-align:right">IDREFS</td>
<td style="text-align:left">值为其他 id 的列表</td>
</tr>
<tr>
<td style="text-align:right">NMTOKEN</td>
<td style="text-align:left">值为合法的 XML 名称</td>
</tr>
<tr>
<td style="text-align:right">NMTOKENS</td>
<td style="text-align:left">值为合法的 XML 名称的列表</td>
</tr>
<tr>
<td style="text-align:right">ENTITY</td>
<td style="text-align:left">值是一个实体</td>
</tr>
<tr>
<td style="text-align:right">ENTITIES</td>
<td style="text-align:left">值是一个实体列表</td>
</tr>
<tr>
<td style="text-align:right">NOTATION</td>
<td style="text-align:left">此值是符号的名称</td>
</tr>
<tr>
<td style="text-align:right">xml:</td>
<td style="text-align:left">值是一个预定义的 XML 值</td>
</tr>
</tbody>
</table>
<p>默认值参数可使用下列值：</p>
<pre><code>值 解释
值 属性的默认值
#REQUIRED 属性值是必需的
#IMPLIED  属性不是必需的
#FIXED value  属性值是固定的
</code></pre><p>例子<br>DTD:<br>&lt;!ATTLIST person number CDATA #REQUIRED&gt;<br>合法的 XML:</p>
<pre><code>&lt;person number=&quot;5677&quot; /&gt;
</code></pre><h3 id="DTD-实体"><a href="#DTD-实体" class="headerlink" title="DTD 实体"></a>DTD 实体</h3><h3 id="DTD-验证"><a href="#DTD-验证" class="headerlink" title="DTD 验证"></a>DTD 验证</h3><h3 id="DTD-实例"><a href="#DTD-实例" class="headerlink" title="DTD 实例"></a>DTD 实例</h3><p><a href="https://www.w3school.com.cn/dtd/dtd_examples.asp" target="_blank" rel="external">一些真实的 DTD 案例</a>。</p>
<h3 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h3><p>XML Schema 是基于 XML 的 DTD 替代者。<br>XML Schema 描述 XML 文档的结构。<br>XML Schema 语言也称作 XML Schema 定义（XML Schema Definition，XSD）。</p>
<h3 id="XML-Schema-使用-XML-语法"><a href="#XML-Schema-使用-XML-语法" class="headerlink" title="XML Schema 使用 XML 语法"></a>XML Schema 使用 XML 语法</h3><p>另一个关于 XML Schema 的重要特性是，它们由 XML 编写。<br>由 XML 编写 XML Schema 有很多好处：</p>
<pre><code>不必学习新的语言
可使用 XML 编辑器来编辑 Schema 文件
可使用 XML 解析器来解析 Schema 文件
可通过 XML DOM 来处理 Schema
可通过 XSLT 来转换 Schema
</code></pre><h3 id="XML-Schema-可保护数据通信"><a href="#XML-Schema-可保护数据通信" class="headerlink" title="XML Schema 可保护数据通信"></a>XML Schema 可保护数据通信</h3><p>当数据从发送方被发送到接受方时，其要点是双方应有关于内容的相同的“期望值”。<br>通过 XML Schema，发送方可以用一种接受方能够明白的方式来描述数据。<br>一种数据，比如 “03-11-2004”，在某些国家被解释为11月3日，而在另一些国家为当作3月11日。<br>但是一个带有数据类型的 XML 元素，比如：</p>
<pre><code>&lt;date type=&quot;date&quot;&gt;2004-03-11&lt;/date&gt;，
</code></pre><p>可确保对内容一致的理解，这是因为 XML 的数据类型 “date” 要求的格式是 “YYYY-MM-DD”。</p>
<h3 id="XML-Schema-可扩展"><a href="#XML-Schema-可扩展" class="headerlink" title="XML Schema 可扩展"></a>XML Schema 可扩展</h3><p>XML Schema 是可扩展的，因为它们由 XML 编写。<br>通过可扩展的 Schema 定义，您可以：</p>
<pre><code>在其他 Schema 中重复使用您的 Schema
创建由标准类型衍生而来的您自己的数据类型
在相同的文档中引用多重的 Schema
</code></pre><p>形式良好是不够的，我们把符合 XML 语法的文档称为形式良好的 XML 文档，比如：</p>
<pre><code>它必须以 XML 声明开头
它必须拥有唯一的根元素
开始标签必须与结束标签相匹配
元素对大小写敏感
所有的元素都必须关闭
所有的元素都必须正确地嵌套
必须对特殊字符使用实体
</code></pre><p>即使文档的形式良好，仍然不能保证它们不会包含错误，并且这些错误可能会产生严重的后果。</p>
<h3 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h3><pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;note&gt;
&lt;to&gt;George&lt;/to&gt;
&lt;from&gt;John&lt;/from&gt;
&lt;heading&gt;Reminder&lt;/heading&gt;
&lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt;
&lt;/note&gt;
</code></pre><p>XML Schema<br>下面这个例子是一个名为 “note.xsd” 的 XML Schema 文件，它定义了上面那个 XML 文档的元素：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;xs:schema xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;
targetNamespace=&quot;http://www.w3school.com.cn&quot;
xmlns=&quot;http://www.w3school.com.cn&quot;
elementFormDefault=&quot;qualified&quot;&gt;
&lt;xs:element name=&quot;note&quot;&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
    &lt;xs:element name=&quot;to&quot; type=&quot;xs:string&quot;/&gt;
    &lt;xs:element name=&quot;from&quot; type=&quot;xs:string&quot;/&gt;
    &lt;xs:element name=&quot;heading&quot; type=&quot;xs:string&quot;/&gt;
    &lt;xs:element name=&quot;body&quot; type=&quot;xs:string&quot;/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
&lt;/xs:schema&gt;
</code></pre><p>对 XML Schema 的引用</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;note
xmlns=&quot;http://www.w3school.com.cn&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xsi:schemaLocation=&quot;http://www.w3school.com.cn note.xsd&quot;&gt;

&lt;to&gt;George&lt;/to&gt;
&lt;from&gt;John&lt;/from&gt;
&lt;heading&gt;Reminder&lt;/heading&gt;
&lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt;
&lt;/note&gt;
</code></pre><h3 id="元素"><a href="#元素" class="headerlink" title=" 元素"></a><schema> 元素</schema></h3><pre><code>&lt;schema&gt; 元素可包含属性。一个 schema 声明往往看上去类似这样：

&lt;?xml version=&quot;1.0&quot;?&gt;

&lt;xs:schema xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;
targetNamespace=&quot;http://www.w3school.com.cn&quot;
xmlns=&quot;http://www.w3school.com.cn&quot;
elementFormDefault=&quot;qualified&quot;&gt;

...
...
&lt;/xs:schema&gt;
</code></pre><p>代码解释：<br>下面的片断：</p>
<pre><code>xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;
显示 schema 中用到的元素和数据类型来自命名空间 &quot;http://www.w3.org/2001/XMLSchema&quot;。同时它还规定了来自命名空间 &quot;http://www.w3.org/2001/XMLSchema&quot; 的元素和数据类型应该使用前缀 xs：
</code></pre><p>这个片断：</p>
<pre><code>targetNamespace=&quot;http://www.w3school.com.cn&quot;
显示被此 schema 定义的元素 (note, to, from, heading, body) 来自命名空间： &quot;http://www.w3school.com.cn&quot;。
</code></pre><p>这个片断：</p>
<pre><code>xmlns=&quot;http://www.w3school.com.cn&quot;
指出默认的命名空间是 &quot;http://www.w3school.com.cn&quot;。
</code></pre><p>这个片断：</p>
<pre><code>elementFormDefault=&quot;qualified&quot;
指出任何 XML 实例文档所使用的且在此 schema 中声明过的元素必须被命名空间限定。
</code></pre><p>在 XML 文档中引用 Schema<br>此 XML 文档含有对 XML Schema 的引用：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;

&lt;note xmlns=&quot;http://www.w3school.com.cn&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xsi:schemaLocation=&quot;http://www.w3school.com.cn note.xsd&quot;&gt;

&lt;to&gt;George&lt;/to&gt;
&lt;from&gt;John&lt;/from&gt;
&lt;heading&gt;Reminder&lt;/heading&gt;
&lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt;
&lt;/note&gt;
</code></pre><p>代码解释：<br>下面的片断：</p>
<pre><code>xmlns=&quot;http://www.w3school.com.cn&quot;
规定了默认命名空间的声明。此声明会告知 schema 验证器，在此 XML 文档中使用的所有元素都被声明于 &quot;http://www.w3school.com.cn&quot; 这个命名空间。
</code></pre><p>一旦您拥有了可用的 XML Schema 实例命名空间：</p>
<pre><code>xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
</code></pre><p>您就可以使用 schemaLocation 属性了。此属性有两个值。第一个值是需要使用的命名空间。第二个值是供命名空间使用的 XML schema 的位置：</p>
<pre><code>xsi:schemaLocation=&quot;http://www.w3school.com.cn note.xsd&quot;
</code></pre><h2 id="星期三（8-14）"><a href="#星期三（8-14）" class="headerlink" title="星期三（8.14）"></a>星期三（8.14）</h2><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>类比:(js-&gt;node,,,,,,java-&gt;虚拟机)<br>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。<br> Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型。<br>Npm<br>NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题</p>
<h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><p>WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（TypeScript等），并将其转换和打包为合适的格式供浏览器使用.<br>简单的说就是打包，压缩各种静态资源的工具</p>
<h3 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h3><p>ESLint最初是由Nicholas C. Zakas 于2013年6月创建的开源项目。它的目标是提供一个插件化的javascript代码检测工具。</p>
<h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><p>vue基本语法(简单)</p>
<pre><code>简洁,轻量,快速,数据驱动,模块友好,组件化
</code></pre><p>vue各种插件(完善)vue 官方提供了一系列的工具，如:</p>
<pre><code>路由 vue-router，
状态树管理器 vuex，
网络请求 axios（非 vue 官方出，纯推荐）等。
(如果您不打算做 SPA，那么您是不需要 vue-router 的；假如您的页面不存在非常复杂的交互或数据递进式体验时，您可能不需要 vuex... )总之，官方都为开发者考虑好了，少了技术选型的痛苦。
</code></pre><p>基于Vue<br>Nuxt</p>
<pre><code>SEO问题
页面初次渲染还是有可能很慢，白屏等待时间太长，对日益挑剔的用户群体来说，无法接受。
服务端渲染
</code></pre><p>Weex</p>
<pre><code>Weex 致力于使开发者能基于通用跨平台的 Web 开发语言和开发经验，来构建 Android、iOS 和 Web 应用。简单来说，在集成了 WeexSDK 之后，你可以使用 JavaScript 语言和前端开发经验来开发移动应用。
</code></pre><h2 id="星期四（8-15）"><a href="#星期四（8-15）" class="headerlink" title="星期四（8.15）"></a>星期四（8.15）</h2><h3 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind:"></a>v-bind:</h3><p>用来绑定数据和属性以及表达式，缩写为’：’示例</p>
<pre><code>&lt;div v-bind:title=&quot;text&quot; &gt;hello&lt;/div&gt;
&lt;div v-bind:title=&quot;&apos;***&apos;+text&quot; &gt;hello&lt;/div&gt;
&lt;input type=&quot;text&quot; v-bind:value=&quot;text&quot;&gt;
new Vue({
    el:&quot;#root&quot;,
    data:{
        text:&quot;this is ***&quot;
    },
})
</code></pre><h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model:"></a>v-model:</h3><p>实现双向数据绑定<br>示例<br>输入框:</p>
<pre><code>&lt;input type=&quot;text&quot; v-model=&quot; text&quot; /&gt;
&lt;input type=&quot;text&quot; v-model:value =&quot;text&quot;/&gt;
 &lt;div &gt;{{text}}&lt;/div&gt;
</code></pre><p>单选:</p>
<pre><code> 1:&lt;input type=&quot;radio&quot; value=&quot;one&quot; v-model=&quot;text&quot; /&gt;
 2:&lt;input type=&quot;radio&quot; value=&quot;two&quot; v-model=&quot;text&quot; /&gt;
    &lt;div &gt;{{text}}&lt;/div&gt;
new  Vue({
        el:&quot;#data2&quot;,
        data:{
            text:&quot;-----&quot;
        },
    })
</code></pre><p>单选不需要设置name来确保只能选一个，v-model同一个值就行了</p>
<h3 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h3><pre><code>更新元素的 innerText
</code></pre><h3 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h3><pre><code>更新元素的 innerHTML
</code></pre><h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on:"></a>v-on:</h3><pre><code>绑定事件监听器。可简写@
</code></pre><p>示例</p>
<pre><code>&lt;div v-on:click=&quot;handleClick&quot;&gt;{{text}}&lt;/div&gt;
 new Vue({
    el:&quot;#event&quot;,
    data:{
        text:&quot;hello&quot;
    },
    methods:{
        handleClick:function () {
            alert(&quot;谁在点击我&quot;)
        }
    }
})
</code></pre><h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h3><pre><code>标签控制隐藏,  (display设置none)
</code></pre><h3 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h3><pre><code>根据表达式的值的真假条件渲染元素。
v-else-if , v-else
</code></pre><h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h3><pre><code>基于源数据多次渲染元素或模板块(循环渲染元素)
</code></pre><h3 id="v-slot"><a href="#v-slot" class="headerlink" title="v-slot"></a>v-slot</h3><p>插槽。<br>是组件的一块HTML模版，<br>这块模版由使用组件者即父组件提供。<br>可以说是子组件暴露的一个<br>让父组件传入自定义内容的接口</p>
<h3 id="computed"><a href="#computed" class="headerlink" title="computed:"></a>computed:</h3><pre><code>first:&lt;input  v-model=&quot;firstName&quot; &gt;
last:&lt;input v-model=&quot;lastName&quot;&gt;
&lt;div&gt;{{full}}  &lt;/div&gt;

new Vue({
    el:&quot;#add&quot;,
    data:{
        firstName:0,
        lastName:0
    },
    //计算属性
    //computed：指的是一个属性通过其他属性计算而来
    computed:{
        full: function () {
            return parseInt(this.firstName) + parseInt(this.lastName)
        }
    }
})
</code></pre><p><strong>计算属性是真的牛皮，不是自己的东西都能计算到，使用状态管理，就能监听别的地方改变状态的数据。</strong></p>
<h3 id="watch"><a href="#watch" class="headerlink" title="watch:"></a>watch:</h3><p>监听一个属性改变触发一个事件。</p>
<pre><code>new Vue({
        el:&quot;#add2&quot;,
        data:{
            firstName:0,
            lastName:0
        },
computed:{
            full: function () {
                return parseInt(this.firstName) + parseInt(this.lastName)
            }
        },
watch:{
            firstName:function () {
                this.count++
            },
            lastName:function () {
                this.count++
            },
            full() {
                console.log(&apos;full&apos;)
            }
        }
    })
</code></pre><h3 id="template"><a href="#template" class="headerlink" title="template:"></a>template:</h3><p>一个字符串模板作为 Vue 实例的标识使用。模板将会 替换 挂载的元素。挂载元素的内容都将被忽略(除非模板的内容有分发插槽)。</p>
<pre><code>&lt;div id=&quot;root1&quot;&gt;
    123//这里会被替换
&lt;/div&gt;

&lt;script&gt;
    new  Vue({
        el:&quot;#root1&quot;,
        template:&apos;&lt;h1&gt;--&gt;{{msg}}&lt;/h1&gt;&apos;,
        data:{
            msg: &quot;hello data&quot;
        }
    })
&lt;/script&gt;
</code></pre><h3 id="Vue-component"><a href="#Vue-component" class="headerlink" title="Vue.component"></a>Vue.component</h3><p>项目中用法就是局部组件的用法，就是把组件import进来使用</p>
<pre><code>&lt;todo&gt;&lt;/todo&gt;
123
&lt;to-do&gt;&lt;/to-do&gt;
//定义局部组件
var  todo = {
    template: &apos;&lt;li&gt;todo&lt;/li&gt;&apos;
}
new Vue({
    el:&quot;#to&quot;,
    data:{
    },
    //引用（注册）局部组件
    components:{
        &apos;todo&apos;:todo,
        &apos;ToDo&apos;:todo
    }
})
</code></pre><h2 id="星期五（8-16）"><a href="#星期五（8-16）" class="headerlink" title="星期五（8.16）"></a>星期五（8.16）</h2><p>Vue全家桶：</p>
<h3 id="vue-cli"><a href="#vue-cli" class="headerlink" title="vue-cli"></a>vue-cli</h3><p>Vue.js 开发的标准工具<br>因为很多包都是在国外，所以我们构建一个vue项目一般来说是很慢的。<br>方法一：3.x开始可以这么创建，官方推荐</p>
<p>安装vue-cli</p>
<pre><code>npm install -g @vue/cli    (3.X)
vue –V  (查看版本)
</code></pre><p>创建项目<br>最新版本</p>
<pre><code>vue create hello-world    (3.X)
</code></pre><p>方法二：cli是3.x 想构建2.x的项目<br>安装vue-cli</p>
<pre><code>npm install -g @vue/cli    (3.X)
vue -V  (查看版本)
</code></pre><p>创建项目</p>
<pre><code>npm install -g @vue/cli-init    (2.X桥接工具)
vue init webpack my-project    (2.X)
</code></pre><p>方法三：快速构建方式<br>安装vue-cli</p>
<pre><code>cnpm install -g @vue/cli    (3.X)
</code></pre><p>创建项目</p>
<pre><code>cnpm install -g @vue/cli-init    (2.X桥接工具)
cnpm install -g webpack         (安装webpack)
vue init webpack my-project    (2.X)
</code></pre><p>拒绝npm安装，自己使用cnpm安装</p>
<pre><code>Cnpm install
</code></pre><h3 id="Vue项目的目录结构（cli构建出来的）"><a href="#Vue项目的目录结构（cli构建出来的）" class="headerlink" title="Vue项目的目录结构（cli构建出来的）"></a>Vue项目的目录结构（cli构建出来的）</h3><p>Build           构建脚本目录(webpack相关)<br>Config          项目配置,包括端口号等。我们初学可以使用默认的<br>node_modules    npm 加载的项目依赖模块<br>Src             这里是我们要开发的目录，基本上要做的事情都在这个目录里<br>static          静态资源文件<br>test            测试目录<br>.xxxx文件       这些是一些配置文件，包括语法配置，git配置等。<br>index.html      首页入口文件,可以添加一些 meta 信息或统计代码。<br>package.json    项目配置文件<br>README.md       项目的说明文档，markdown 格式</p>
<h3 id="服务简单配置-端口…"><a href="#服务简单配置-端口…" class="headerlink" title="服务简单配置(端口…)"></a>服务简单配置(端口…)</h3><p>启动端口</p>
<pre><code>Config-&gt;index.js
Dev-&gt;port
</code></pre><p>开发模式(dev)启动时访问（别人可以通过你的ip地址访问你的项目）</p>
<pre><code>Package.json -&gt; dev
--host 0.0.0.0
vue-router
</code></pre><h3 id="bus"><a href="#bus" class="headerlink" title="bus"></a>bus</h3><p>vue bus可以实现不同组件间、不同页面间的通信，比如我在A页面出发点击事件，要B页面发生变化<br>一个中央事件总线bus，可以作为一个简单的组件传递数据，用于解决跨级和兄弟组件通信问题</p>
<pre><code>Bus.js
import Vue from &apos;vue&apos;
const Bus = new Vue()
export default Bus

main.js//全局引用
import bus from &apos;./bus/Bus&apos;
Vue.prototype.bus = bus

//要用的地方监听事件
mounted () {
    this.bus.$on(&apos;add&apos;, a =&gt; {
      this.list.push(a)
    })
},

//通过方法触发事件
 add () {
  this.bus.$emit(&apos;add&apos;, this.a)
}
</code></pre><h3 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h3><p>axios 是一个基于 promise 的 HTTP 库，在浏览器和 node.js 中使用。<br>axios主要是用于向后台发起请求的，还有在请求中做更多是可控功能。<br>xios<br>cnpm install axios  –save</p>
<pre><code>main.js
import axios from &apos;axios’
Vue.prototype.$axios = axios
this.$axios.get(&apos;/terms&apos;)
      .then(this.res1Method).catch((err) =&gt; {
        this.catchMethod(err)
      })
</code></pre><h3 id="Vue-router路由"><a href="#Vue-router路由" class="headerlink" title="Vue-router路由"></a>Vue-router路由</h3><p>路由是根据不同url展示不同的页面或内容<br>Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。</p>
<pre><code>cnpm install vue-router  --save-dev
//src下新建router-&gt;index.js
import Vue from &apos;vue&apos;
import Router from &apos;vue-router&apos;
import HelloWorld from &apos;@/components/HelloWorld&apos;
Vue.use(Router)
export default new Router({
  routes: [
    {
      path: &apos;/&apos;,
      name: &apos;HelloWorld&apos;,
      component: HelloWorld
    },
    {
      path: &apos;/city&apos;,
      name: &apos;City&apos;,
      component: () =&gt; import(&apos;@/components/city/City&apos;)
    }
  ]
})
//main.js
import router from &apos;./router’
new Vue({
  el: &apos;#app&apos;,
  router,
  components: { App },
  template: &apos;&lt;App/&gt;&apos;
})
</code></pre><h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><p>浏览器</p>
<pre><code>http://localhost:8080/#/city
</code></pre><p>声明式</p>
<pre><code>&lt;router-link to=&quot;/city&quot;&gt;跳转到city&lt;/router-link&gt;
</code></pre><p>编程式</p>
<pre><code>this.$router.push(&apos;/city&apos;)
</code></pre><h3 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h3><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，<br>解决vue中各个组件之间传值的痛苦，在vue中我们可以使用vuex来保存我们需要管理的状态值，值一旦被修改，所有引用该值的地方就会自动更新。<br>适用于多个视图依赖于同一状态。来自不同视图的行为需要变更同一状态。<br>(如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的)</p>
<p>安装</p>
<pre><code>npm install vuex –save
</code></pre><p>引入</p>
<pre><code>state：存储状态（变量）
getters：对数据获取之前的再次编译，可以理解为state的计算属性。我们在组件中使用 $sotre.getters.fun()
mutations：修改状态，并且是同步的。在组件中使用$store.commit(&apos;&apos;,params)。这个和我们组件中的自定义事件类似。
actions：异步操作。在组件中使用是$store.dispath(&apos;&apos;)
modules：store的子模块，为了开发大型项目，方便状态管理而使用的。
</code></pre><h3 id="使用state"><a href="#使用state" class="headerlink" title="使用state"></a>使用state</h3><p>src下新建vuex-&gt;store.js</p>
<pre><code>import Vue from &apos;vue&apos;
import Vuex from &apos;vuex&apos;
Vue.use(Vuex)
const state = {
  token: &apos;token&apos;
}
export default new Vuex.Store({
  state
})

Main.js
import store from &apos;./vuex/sotre&apos;
new Vue({
  el: &apos;#app&apos;,
  router,
  store,//把store添加进来
  components: { App },
  template: &apos;&lt;App/&gt;&apos;
})
使用
&lt;h3&gt;{{$store.state. token}}&lt;/h3&gt;
</code></pre><h3 id="Vuex-mutations"><a href="#Vuex-mutations" class="headerlink" title="Vuex-mutations"></a>Vuex-mutations</h3><pre><code>mutations
mutations里面放置的是我们操作state对象属性的方法
Store.js
const mutations = {
  mutationsUpdateToken (state, newtoken = &apos;newtoken&apos;) {
    return (state. token = newtoken)
  },
  mutationsDeleteToken (state, newtoken = &apos;&apos;) {
    return (state. token = newtoken)
  }
}
export default new Vuex.Store({
  state,
  mutations
})
//在我们要用的地方
updateToken () {
  this.$store.commit(&apos;mutationsUpdateToken&apos;, &apos;update&apos;)
},
deleteToken () {
  this.$store.commit(&apos;mutationsDeleteToken&apos;, &apos;delete&apos;)
}
</code></pre><h3 id="Vuex-actions"><a href="#Vuex-actions" class="headerlink" title="Vuex-actions"></a>Vuex-actions</h3><p>actions<br>actions 类似于 mutation，actions 提交的是 mutation，而不是直接变更状态。actions 可以包含任意异步操作。用来异步触发mutations里面的方法<br>里面调用其实还是使用的mutation的commit方法</p>
<pre><code>Store.js
const actions = {
  actionsUpdateToken (context, newtoken = &apos;&apos;) {
    return context.commit(&apos;mutationsUpdateToken&apos;, newtoken)
  },
  actionsDeleteToken ({ commit }, newtoken = &apos;&apos;) {
    return commit(&apos;mutationsDeleteToken&apos;, newtoken)
  }
}
export default new Vuex.Store({
  state,
  mutations,
  actions
})
使用
updateToken () {
 this.$store.dispatch(&apos;actionsUpdateToken&apos;, &apos;updatedispatch’)
},
deleteToken () {
this.$store.dispatch(&apos;actionsDeleteToken&apos;, &apos;deletedispatch’)
}
</code></pre><h3 id="Vuex-getters"><a href="#Vuex-getters" class="headerlink" title="Vuex-getters"></a>Vuex-getters</h3><p>我们一般使用getters来获取我们的state，可以把getters理解为state的计算属性</p>
<pre><code>Store.js
const getters = {
  getters1 () {
    return state.token + &apos;getters1&apos;
  },
  getters2 () {
    return state.token + &apos;getters2&apos;
  }
}
export default new Vuex.Store({
  state,
  mutations,
  actions,
  getters
})
</code></pre><p>使用</p>
<pre><code>{{$store.getters.getters1}}
this.$store.getters.getters1
</code></pre><h2 id="星期六（8-17）"><a href="#星期六（8-17）" class="headerlink" title="星期六（8.17）"></a>星期六（8.17）</h2><p>项目<br>就带着做一个项目。很蠢，并没有体现出VUE的优势，后来又发了一个项目。我们现在来分析一下这个项目<br>（很快补上，今天脑子有点不舒服）</p>
<h3 id="小总结系列"><a href="#小总结系列" class="headerlink" title="小总结系列"></a>小总结系列</h3><h3 id="0-JS的坑"><a href="#0-JS的坑" class="headerlink" title="0.JS的坑"></a>0.JS的坑</h3><p>不要使用变量名为name 浏览器会默认有一个全局的变量name，而且不知道指向的是哪里，还不能被修改。</p>
<h3 id="1-关于DOM获取相邻结点的问题"><a href="#1-关于DOM获取相邻结点的问题" class="headerlink" title="1.关于DOM获取相邻结点的问题"></a>1.关于DOM获取相邻结点的问题</h3><p>nextSibling<br>previousSibling<br>获取紧跟的结点，有可能是空白结点，所以慎用</p>
<h3 id="2-VUE"><a href="#2-VUE" class="headerlink" title="2.VUE"></a>2.VUE</h3><p>vue.js:634 [Vue warn]: Property or method “id” is not defined on the instance but referenced during render.<br>需要在data定义一个id</p>
<h3 id="3-动态参数："><a href="#3-动态参数：" class="headerlink" title="3.动态参数："></a>3.动态参数：</h3><p>官方动态参数报错问题,官网文档这样写的：<br>动态参数<br>2.6.0 新增<br>从 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数：</p>
<pre><code>&lt;a v-bind:[attributeName]=&quot;url&quot;&gt; ... &lt;/a&gt;
</code></pre><p>这里的 attributeName 会被作为一个 JavaScript 表达式进行动态求值，求得的值将会作为最终的参数来使用。例如，如果你的 Vue 实例有一个 data 属性 attributeName，其值为 “href”，那么这个绑定将等价于 v-bind:href。<br>但是实际并不能成功，因为[]里面的名字不能写成attributeName 只要改个名字就可以用了。fk<br>改的名字，必须是小写。不能大小写混写，草 官方文档在下面写了一行小字：</p>
<pre><code>文档有说：另外，如果你在 DOM 中使用模板 (直接在一个 HTML 文件里撰写模板)，需要留意浏览器会把特性名全部强制转为小写
</code></pre><p><strong>动态参数一个数一个特性</strong> 所以不能驼峰写法</p>
<h3 id="4-关于computed属性和methods-写方法"><a href="#4-关于computed属性和methods-写方法" class="headerlink" title="4.关于computed属性和methods 写方法"></a>4.关于computed属性和methods 写方法</h3><p>  1）不能同时存在名字相同的计算属性和方法<br>  2）计算属性只要不改变就会缓存。但是方法不行，方法每次都会执行</p>
<h3 id="5-Lodash"><a href="#5-Lodash" class="headerlink" title="5.Lodash"></a>5.Lodash</h3><p>Lodash 通过降低 array、number、objects、string 等等的使用难度从而让 JavaScript 变得更简单。<br>Lodash 的模块化方法 非常适用于：</p>
<pre><code>遍历 array、object 和 string
对值进行操作和检测
创建符合功能的函数
</code></pre><p>Lodash就是这样的一套工具库，它内部封装了诸多对字符串、数组、对象等常见数据类型的处理函数，其中部分是目前ECMAScript尚未制订的规范</p>
<h3 id="6-注意名字带’-‘-属性名要加””-例如："><a href="#6-注意名字带’-‘-属性名要加””-例如：" class="headerlink" title="6.注意名字带’-‘ 属性名要加”” 例如："></a>6.注意名字带’-‘ 属性名要加”” 例如：</h3><p> “err-err”:true ,建议全都带引号就没问题了吧？</p>
<pre><code>data:{
  &quot;classobject&quot;:{
    &quot;active&quot;:true,
    &quot;err-err&quot;:true
  }
}
</code></pre><h3 id="7-VUE的模块（component）引进来驼峰，写成标签用-代替"><a href="#7-VUE的模块（component）引进来驼峰，写成标签用-代替" class="headerlink" title="7.VUE的模块（component）引进来驼峰，写成标签用-代替"></a>7.VUE的模块（component）引进来驼峰，写成标签用-代替</h3><h3 id="8不要用H5标签做模板名字"><a href="#8不要用H5标签做模板名字" class="headerlink" title="8不要用H5标签做模板名字"></a>8不要用H5标签做模板名字</h3><p>.Do not use built-in or reserved HTML elements as component id: header<br>不能用H5标签作为模板名字</p>
<h3 id="9-vue-项目地址去掉-的方法"><a href="#9-vue-项目地址去掉-的方法" class="headerlink" title="9.vue 项目地址去掉 #的方法"></a>9.vue 项目地址去掉 #的方法</h3><p>使用history模式，在路由里面加入：</p>
<pre><code>mode: &apos;history&apos;,
</code></pre><h3 id="10-v-model正确用法"><a href="#10-v-model正确用法" class="headerlink" title="10 v-model正确用法"></a>10 v-model正确用法</h3><p>一开始他讲错了，v-model就是直接写= 而不是： input默认就会绑定相应的值，输入就绑定value，选择绑定checked，下拉绑定selected,这是官方的写法</p>
<pre><code>&lt;input type=&quot;text&quot; v-model:value=&quot;aaa&quot;&gt; 可以这样写，但是项目中ESLINT肯定报错
&lt;input type=&quot;text&quot; v-model=&quot;aaa&quot;&gt;       标准这样写
</code></pre><h3 id="11-项目小问题"><a href="#11-项目小问题" class="headerlink" title="11 项目小问题"></a>11 项目小问题</h3><pre><code>1.发现有坑
最好不要改项目的名字，在install 包之前就把项目的名字确定好
2.页面的坑
1）如何去除input标签选中的框：
给input设置 outline:none;
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">王邸</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">Artikel</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">Tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王邸</span>

  
</div>


  <div class="powered-by">Erstellt mit  <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'Fn4BuvoixOxjJAhR79TvaD5M-gzGzoHsz',
        appKey: '1uspTrSwPqkmSBSUr948WqxE',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("Fn4BuvoixOxjJAhR79TvaD5M-gzGzoHsz", "1uspTrSwPqkmSBSUr948WqxE");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
