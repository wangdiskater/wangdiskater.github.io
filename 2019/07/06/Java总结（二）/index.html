<!DOCTYPE html>





<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.3.8">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">

<link rel="stylesheet" href="//fonts.proxy.ustclug.org/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="总结时间：0701-0706本周主要内容:代码块介绍，对象继承，final（修饰类，方法，变量），对象的多态，抽象类，接口，打包指令，权限修饰符（public default…），内部类（成员内部类，静态内部类，局部内部类，匿名内部类），Object类（注意他的方法，所有类都可以重写），String类（注意byte数组可以构建String（流对象）），">
<meta property="og:type" content="article">
<meta property="og:title" content="Java总结（二）">
<meta property="og:url" content="http://yoursite.com/2019/07/06/Java总结（二）/index.html">
<meta property="og:site_name" content="路要坚持">
<meta property="og:description" content="总结时间：0701-0706本周主要内容:代码块介绍，对象继承，final（修饰类，方法，变量），对象的多态，抽象类，接口，打包指令，权限修饰符（public default…），内部类（成员内部类，静态内部类，局部内部类，匿名内部类），Object类（注意他的方法，所有类都可以重写），String类（注意byte数组可以构建String（流对象）），">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-08-17T03:03:13.406Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java总结（二）">
<meta name="twitter:description" content="总结时间：0701-0706本周主要内容:代码块介绍，对象继承，final（修饰类，方法，变量），对象的多态，抽象类，接口，打包指令，权限修饰符（public default…），内部类（成员内部类，静态内部类，局部内部类，匿名内部类），Object类（注意他的方法，所有类都可以重写），String类（注意byte数组可以构建String（流对象）），">
  <link rel="canonical" href="http://yoursite.com/2019/07/06/Java总结（二）/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Java总结（二） | 路要坚持</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">路要坚持</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/06/Java总结（二）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王邸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路要坚持">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">Java总结（二）

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-07-06 22:10:02" itemprop="dateCreated datePublished" datetime="2019-07-06T22:10:02+08:00">2019-07-06</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-08-17 11:03:13" itemprop="dateModified" datetime="2019-08-17T11:03:13+08:00">2019-08-17</time>
              </span>
            
          

          
            <span id="/2019/07/06/Java总结（二）/" class="post-meta-item leancloud_visitors" data-flag-title="Java总结（二）" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
        
      
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/07/06/Java总结（二）/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2019/07/06/Java总结（二）/" itemprop="commentCount"></span></a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>总结<br>时间：0701-0706</p><p>本周主要内容:<br>代码块介绍，对象继承，final（修饰类，方法，变量），对象的多态，抽象类，接口，打包指令，权限修饰符（public default…），内部类（成员内部类，静态内部类，局部内部类，匿名内部类），Object类（注意他的方法，所有类都可以重写），String类（注意byte数组可以构建String（流对象）），</p><a id="more"></a>

<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>这周主要把面向对象的内容讲完了。很多东西虽然很熟悉但是却很多细节的处理很重要。是打好基础的关键。但是万变不离其中，离不开三大特性：继承，封装，多态。现在也只能字面意思上去理解到底这些东西是什么。这些东西的规律是什么，但是他为什么这样实现的？最初的构想是什么？等等问题，这不是老师能教你的，你自己需要去学习。上个礼拜简单的讲了什么是封装，但是封装远远没有private那么简单。接下来将总结一下本周的学习内容：</p>
<h2 id="星期一"><a href="#星期一" class="headerlink" title="星期一"></a>星期一</h2><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>用{}括起来的代码<br>分类：<br>局部代码块<br>  位置：方法里面(局部位置)<br>  作用：限制局部变量的生命周期，及早释放，提高内存利用率</p>
<p>构造代码块(语法糖)：<br>  位置：类中方法外(成员位置)<br>  作用：多个构造方法方法中相同的代码存放到一起，每次调用构造都执行，并且在构造方法前执行<br>  相当于放在每个构造函数的首行</p>
<p>静态代码块：<br>  位置: 成员位置 需要用static标识；<br>  作用：对类进行初始化, 在类加载的时候执行, 并且只执行一次</p>
<p>  同步代码块(以后再讲)synchronized:是为了线程安全出现的</p>
<p>这里只需要搞清楚一个问题：这些代码块的执行顺序：<br>静态代码块 &gt;构造代码块(语法糖) &gt; 构造方法<br>先执行父类的,看下面例子：<br><strong>注意：先执行父类静态块，再执行子类静态块。</strong></p>
<pre><code>class Fu {
  static {
    System.out.println(&quot;静态代码块Fu&quot;);
  }

  {
    System.out.println(&quot;构造代码块Fu&quot;);
  }

  public Fu() {
    System.out.println(&quot;构造方法Fu&quot;);
  }
}

class Zi extends Fu {
  static {
    System.out.println(&quot;静态代码块Zi&quot;);
  }

  {
    System.out.println(&quot;构造代码块Zi&quot;);
  }

  public Zi() {
    System.out.println(&quot;构造方法Zi&quot;);
  }
}

class Test2 {
  public static void main(String[] args) {
    new Zi();
  }
}
输出结果：
    静态代码块Fu
    静态代码块Zi
    构造代码块fu
    构造方法fu
    构造代码块zi
    构造方法zi
</code></pre><p>先加载父类静态代码块然后加载子代静态代码块<br>Java中如果有继承关系，对象的初始化是分层初始化</p>
<ol>
<li>父类按照层次依次加载，然后再加载子类</li>
<li>成员变量是按照层次进行初始化的<br>先初始化父类中定义的数据，再初始化子类中定义的数据</li>
</ol>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>(1)把多个类中相同的成员给提取出来定义到一个独立的类中。然后让这多个类和该单独的类产生一个关系，使多个类中具备这个单独的类中定义的成员。<br>  这个关系叫继承。</p>
<p>(2)Java中如何表示继承呢?格式是什么呢?<br>  A:用关键字extends表示<br>  B:格式：class 子类名 extends 父类名 {}</p>
<p>(3)继承的好处：<br>  A: 提高了代码的复用性<br>  B: 提高了代码的维护性<br>  C: 让类与类产生了一个关系，是多态的前提</p>
<p>(4)继承的弊端：<br>  A:让类的耦合性增强。这样某个类的改变，就会影响其他和该类相关的类。<br>    设计原则：低耦合，高内聚。<br>    耦合：类与类的关系<br>    内聚：自己完成某件事情的能力（责任）<br>  B:打破了封装性</p>
<p>(5)Java中继承的特点<br>  A: Java只支持单继承，不支持多继承<br>  B: 但是支持多层继承   界门纲目科属种</p>
<p>(6)继承的注意事项：<br>  A:子类不能继承父类的私有成员（私有成员是被子类隐式继承的，其实私有成员被继承了，但是在子类中不能访问。反射）<br>  B:子类不能继承父类的构造方法，但是可以通过super去访问<br>  C:不要为了部分功能而去继承。如下例子</p>
<pre><code>class A {
  m1();
  m2();
  m3();
  m4();
}
我们现在需要一个类有以下功能：m1(), m2(), m3(), m5();
class B extends A{ (不推荐)
  m5();
}
</code></pre><p>说到功能那就一定要写成接口来实现就好;</p>
<p>(7)什么时候使用继承呢?<br>  A类和B类如果是: is a<br>  is a的关系：</p>
<ul>
<li>Person：<ul>
<li>Student</li>
<li>Teacher</li>
</ul>
</li>
</ul>
<p><strong>(8)Java继承中的成员关系</strong></p>
<p>  A:成员变量</p>
<pre><code>a:子类的成员变量名称和父类中的成员变量名称不一样。
b:子类的成员变量名称和父类中的成员变量名称一样，这个怎么访问呢?
  子类的方法访问变量的查找顺序(一层一层向外)：
  首先找子类的局部变量
  再找子类的成员变量
  再找父类的成员变量 ...
c.子类的成员变量隐藏了父类的成员变量？(就近原则)
  super关键字
    super是内存空间的标识
  super.name //父亲的名字
</code></pre><p>  B:静态成员:</p>
<pre><code>a.静态成员也会被继承
b.如果出现同名的静态变量，那么父类中定义的静态成员只能通过类名访问。
c.如果new一个对象,还是能super访问父类的静态成员的（我自己发现的）
</code></pre><p>  C:构造方法</p>
<pre><code>a:子类的构造方法默认会去访问父类的无参构造方法
  目的：将在父类中定义的成员变量初始化。
b:父类中如果没有无参构造方法，怎么办?
  1)子类通过super去明确调用父类带参构造
  2)子类通过this调用本身的其他构造，**但是一定会有一个去访问了父类的构造**
  3)让父类提供无参构造
  this(...), super(...)只能在构造方法的第一条语句。
</code></pre><p>  D:成员方法</p>
<p>  a:子类的成员方法和父类中的成员方法签名不一样。<br>    相当于两个不同的方法(我们来举个栗子);</p>
<pre><code>public class demo2 {
    public static void main(String[] args) {
        Son son = new Son();
        son.show(&quot;我传入了一个参数&quot;);
        son.show();
    }
}
class Father {
    public void show(String s){
        System.out.println(&quot;我是父类的show方法：&quot; + s);
    }
}
class Son extends  Father {
    public void show() {
        System.out.println(&quot;我是子类的show方法我没有参数&quot;);
    }
}

我是父类的show方法我传入了一个参数
我是子类的show方法我没有参数
</code></pre><p>b:子类的成员方法和父类中的成员方法签名一样，这个怎么访问呢?<br>  父类的方法被重写了，不能再访问父类的方法，此时方法被重写。<br>  通过子类对象访问一个方法的查找顺序：</p>
<pre><code>查找子类的成员方法
再查找父类的成员方法
</code></pre><p>c:重写的成员方法返回值类型（引用类型兼容即可）：<br>  基本数据类型必须一致<br>  <strong>引用数据类型：父类的类型必须兼容子类的类型</strong></p>
<p>d:其他注意事项：<br>  访问权限:子类的方法的访问权限必须大于等于父类的方法<br>  父类中的私有方法不能被重写</p>
<p>E:静态方法<br>  a.静态的方法也可以被继承<br>  b.静态方法可以被”重写”, 但是不能添加Override</p>
<p>(9)方法的重写：<br>  有子父类关系, 方法签名一样。<br>  返回值类型：<br>    基本类型：必须一致<br>    引用类型：父类兼容子类。<br>  访问权限：子类的访问权限必须大于等于父类的访问权限。<br>    Father f = new Son();<br>    f.show();  //多态性，编译看左边，运行看右边；</p>
<p>(10)两个面试题：<br>  A:Override和Overload的区别?<br>    override: 子类重写父类的同名方法。要求子类的返回值类型要被父类兼容，方法名一样，参数列表一样（方法签名一样）子类的访问权限不能比父类的小。<br>    overload：在同一个类中，方法名一样，但是参数列表不一样。与返回值类型无关<br>      如果在子类中定义了一个和父类同名的方法，但是参数列表不一样就表示是不同的方法；<br>      如果在子类中定义了一个和父类同名的方法，但是参数列表一样，但是返回值类型不兼容，会报错。<br>  B:this和super的区别和各自的作用?<br>    this<br>    this.成员变量 super.成员变量<br>    this(…)   super(…) //调用构造方法<br>    this.成员方法() super.成员方法()</p>
<p>(11)数据初始化的面试题<br>  <strong>A:回顾：对象初始化过程</strong><br>    加载Student.class文件进内存<br>    在栈内存为s开辟空间<br>    在堆内存为学生对象开辟空间<br>    对学生对象的成员变量进行默认初始化<br>    对学生对象的成员变量进行显示初始化<br>    通过构造方法对学生对象的成员变量赋值<br>    学生对象初始化完毕，把对象地址赋值给s变量</p>
<p>  B:子类对象的初始化过程（分层初始化：加载父类，然后加载子类）<br>  C:子父类的构造执行过程<br>    加载父类<br>    加载子类<br>    先对父类进行初始化: 父类显示初始化，父类的构造方法。<br>    对子类进行初始化：子类的显示初始化，子类的构造方法。<br>  看下面这个例子更好的理解对象初始化过程：</p>
<pre><code>public class test3 {
  public static void main(String[] args) {
    new Z(); //先进行父类的初始化！！！！！
  }
}

class X {
  Y b = new Y();   //第一步
  int a = 10;
  X() {
    System.out.print(&quot;X&quot;);  //然后初始化X
  }
}

class Y {
  Y() {
    System.out.print(&quot;Y&quot;);  //从X过来第一次打印Y   第二次过来从Z
  }
}

class Z extends X {
  Y y = new Y();   //第三步
  Z() {
    // super();
    System.out.print(&quot;Z&quot;); //最后一次打印
  }
}

运行结果：
Y X Y Z
</code></pre><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>  (1)是最终的意思，可以修饰类，方法，变量。<br>  (2)特点：<br>  A:修饰类，表示这个类不能被继承（绝育手术）<br>  B:修饰变量，表示该变量使常量，它的值不能被修改<br>  基本数据类型：里面的值不能被修改<br>  引用数据类型：它的地址值不能被修改，指向同一个对象，但是对象的内容可以修改<br>  注意事项：<br>    被final的变量只能被赋值一次，即使值相同。<br>    注意final的默认初始化是无效的，所以可以在初始化对象的时候，使用构造方法初始化他，这样写并不会报错：</p>
<pre><code>class Son {
  final int a;
  public Son() {
    a = 10;
  }
}
</code></pre><p>然而这样写，相当于赋值两次就会报错：</p>
<pre><code>class Son {
  final int a;
  a = 10;  //就会报错。
}
</code></pre><p>  C:修饰方法，表示该方法不能被子类重写</p>
<h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>(1)同一个对象在不同时刻体现出来的不同状态。</p>
<p>(2)多态的前提：<br>  A:有继承（实现）关系<br>  B:子类重写父类的方法<br>  C:父类的引用变量指向子类的对象<br>  多态的分类：<br>    a:具体类多态<br>      class Father{}<br>      class Son extends Father{}<br>      Father father = new Son();<br>    b:抽象类多态<br>      abstarct class Father{}<br>      class Son extends Father{}<br>      Father father = new Son();<br>    c:接口多态<br>      interface Father{}<br>      class Son implements Father{}<br>      Father father = new Son();</p>
<p>(3)多态中的成员访问特点<br>  A:成员变量<br>    编译看左边，运行看左边<br>  B:静态变量：<br>    编译看左边，运行看左边<br>  C:成员方法<br>    编译看左边，运行看右边<br>  D:静态方法<br>    编译看左边，运行看左边</p>
<p>(4)多态的好处：<br>  A:提高代码的维护性 (继承体现)<br>  B:提高代码的扩展性 (多态体现)</p>
<p>(5)多态的弊端：<br>  破坏了封装性（继承）<br>  无法访问子类特有的功能</p>
<p>(6)多态中的转型<br>  A:向上转型<br>    子类 –&gt; 父类（Java默认支持）<br>  B:向下转型<br>    父类 –&gt; 子类（可能会出现 ClassCastException）<br>看个例子：</p>
<pre><code>class A{
  public void show(){
    show2();
  }
  public void show2(){
    System.out.println(&quot;我&quot;);
  }
}
class B extends A {
  public void show2(){
    System.out.println(&quot;爱&quot;);
  }
}
class C extends B {
  public void show(){
    super.show();
  }
  public void show2(){
    System.out.println(&quot;你&quot;);
  }
}
public class Test1 {
  public static void main(String[] args) {
    A a = new B();
    a.show();   //爱  成员函数 编译看左边 运行看右边 最终执行b的show2()方法
    B b = new C();
    b.show();   //你  最终执行c的show2()方法
  }
}
</code></pre><p>还有一个例子：</p>
<pre><code>class Animal{}
class Dog extends Animal{}
class Cat extends Animal{}
public class Test3 {
  public static void main(String[] args) {
    Animal p0 = new Animal();
    Dog p1 = new Dog ();
    Cat p2 = new Cat ();
    Animal p3 = new Dog ();
    Animal p4 = new Cat ();
    p0 = p1;          //a  默认向上转型
    // p1 = p2;       //b  //编译报错 不兼容类型
    p1 = (Dog)p3;     //c
    p2 = (Cat)p4;     //d
    // p1 = (Dog)p4;  //e  异常：java.lang.ClassCastException: Cat cannot be cast to Dog
    // p2 = (Cat)p3;  //f  同理也是异常
  }
}
编译报错：
  b
运行报错：
  e f
</code></pre><p>这个例子告诉我们不要乱用转型，学会使用instanceOf先判断是否是该对象的类或者子类然后再转型。</p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>(1)概述：<br>  将类抽象    举例：动物<br>  将方法抽象 比如动物会怎么叫，你不知道，所以你不应该给一个具体的实现，而只要给一个声明就可以</p>
<p>(2)抽象类的特点<br>  A:抽象类和抽象方法必须用关键字abstract修饰<br>  B:抽象类中不一定有抽象方法,但是有抽象方法的类一定是抽象类(但是接口也定义了抽象法方法)<br>  C:抽象类不能实例化 （存在的用途就是被子类继承）<br>  D:抽象类的子类<br>    a:是一个抽象类。可以重写抽象方法，也可以不重写。<br>    b:是一个具体类。一定要重写所有的抽象方法<br>(3)抽象类的成员特点：<br>  A:成员变量<br>    可以是变量，也可以是常量<br>  B:构造方法<br>    有构造方法<br>  C:成员方法<br>    可以是抽象方法，也可以是普通方法<br>(4)抽象类的几个小问题<br>  A:抽象类有构造方法，不能实例化，那么构造方法有什么用?<br>    给子类访问，对在抽象类中定义的成员变量进行初始化<br>  B:一个类如果没有抽象方法,却定义为了抽象类，有什么用?<br>    该类不能被实例化<br>  C:abstract 不能和哪些关键字共存<br>    final: 冲突<br>    private：冲突<br>    static：无意义</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>(1)在Java中，接口一般是用来表示扩展功能的。<br>(2)接口的特点：<br>  A:接口用关键字interface修饰<br>    interface 接口名 {} //接口名一般大写<br>  B:类实现接口用implements修饰<br>    class 类名 implements 接口名 {}<br>  C:接口不能实例化<br>  D:接口的实现类<br>    a:是一个抽象类  可以重写抽象方法，也可以不重写。<br>    b:是一个具体类  一定要重写所有的抽象方法，可以写成匿名对象，如果只有一个方法可以写lambda表达式<br>  E:空的接口<br>    a:就是为了做标记的标记接口JAVA源码中经常看到<br>(3)接口的成员特点：<br>  A:成员变量<br>    只能是静态常量，默认用public static final修饰<br>  B:构造方法<br>    接口没有构造方法<br>  C:成员方法<br>    可以有抽象方法，默认用 public abstract修饰<br>    <strong><em>注意：JDK8以后可以有</em></strong></p>
<pre><code>默认方法：必修用default关键字修饰，默认用 public修饰
静态方法：必修用static修饰，默认用public 修饰
</code></pre><p>(4)类与类,类与接口,接口与接口<br>  A:类与类   单继承<br>  B:类与接口  多实现<br>  C:接口与接口 多继承</p>
<p>(5)抽象类和接口的区别<br>  A:成员区别<br>    抽象类：抽象方法，成员变量，静态成员等等<br>    接口：抽象方法，只能静态常量（static final）<br>  B:关系区别:<br>    类与类：  单继承<br>    类与接口：多实现<br>    接口与接口：多继承<br>  C:设计理念不同<br>    抽象类：和它的子类之间表现的是 is a的关系， 描述的是子类中共性<br>    接口：和它的子类之间表现的是 like a 的关系，描述的是扩展功能</p>
<h3 id="形式参数和返回值的问题"><a href="#形式参数和返回值的问题" class="headerlink" title="形式参数和返回值的问题"></a>形式参数和返回值的问题</h3><p>(1)形式参数：<br>  类名：需要该类或者该类子类的对象<br>  抽象类名：需要该类的子类对象<br>  接口名：需要该接口的实现类对象<br>(2)返回值类型：<br>  类名：返回的是该类或者该类子类的对象<br>  抽象类名：返回的是该类的子类对象<br>  接口名：返回的是该接口的实现类的对象<br>(3)链式编程<br>  对象.方法1().方法2()…….方法n();</p>
<h2 id="星期三-拉闸放假"><a href="#星期三-拉闸放假" class="headerlink" title="星期三(拉闸放假)"></a>星期三(拉闸放假)</h2><h2 id="星期四"><a href="#星期四" class="headerlink" title="星期四"></a>星期四</h2><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><pre><code>命令：javac -d . xxx.java
</code></pre><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><pre><code>命令：java com.cs.kaoyan.demo;
</code></pre><h3 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h3><p>(1)访问不同包的类<br>  a. 指定类的全限定名（例如java.util.Scanner）;<br>  b. 导包<br>(2)格式：<br>  import 包名.类名；<br>  静态导入：（导入静态方法，就好像导入的方法就定义在这个类中一样）<br>    import static 包名.类名.方法名<br>    要求该方法必须是静态的。<br>(3)面试题：package,import,class的在JAVA文件中的顺序<br>  package &gt; import &gt; class<br>  一个  多个  多个(建议一个文件里面只有一个class)</p>
<h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><p>(1)权限修饰符</p>
<table>
<thead>
<tr>
<th>类型</th>
<th style="text-align:center">本类</th>
<th style="text-align:center">同一个包下</th>
<th style="text-align:center">不同包下的子类</th>
<th style="text-align:right">不同包下的无关类</th>
</tr>
</thead>
<tbody>
<tr>
<td>private</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">N</td>
<td style="text-align:center">N</td>
<td style="text-align:right">N</td>
</tr>
<tr>
<td>默认</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">N</td>
<td style="text-align:right">N</td>
</tr>
<tr>
<td>protected</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y(注意)</td>
<td style="text-align:right">N</td>
</tr>
<tr>
<td>public</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:right">Y</td>
</tr>
</tbody>
</table>
<p>  (2)这四种权限修饰符在任意时刻只能出现一种。</p>
<h3 id="常见的修饰符"><a href="#常见的修饰符" class="headerlink" title="常见的修饰符"></a>常见的修饰符</h3><p>(1)分类：<br>  权限修饰符：private,默认,protected,public<br>  状态修饰符：static, final<br>  抽象修饰符：abstract<br>(2)常见的类及其组成的修饰<br>  普通类：默认  public  final abstract<br>  成员变量: private,  默认, protected,  public  static, final<br>  构造方法：private, 默认, protected,  public<br>  成员方法：private, 默认, protected,  public  static, final abstract</p>
<h3 id="内部类（难）"><a href="#内部类（难）" class="headerlink" title="内部类（难）"></a>内部类（难）</h3><p><strong>我这里一定要强调。内部类这里的知识点有点小乱，需要捋一捋才能搞清楚。常用四种内部类<br>分成两个类：成员位置（成员内部类，静态内部类）,局部位置（局部内部类，匿名内部类）。对应着有三种访问：内部类访问外部类，外部类访问内部类，其他类访问内部类</strong><br>(1)把类定义在另一个类的内部，该类就被称为内部类。<br>  举例：把类B定义在类A中，类B就被称为内部类。 A称为外围类</p>
<p>(2) 内部类的作用：<br>  a. 保护内部类<br>  b. 方便内部类和外部类的交互</p>
<p>(3) 内部类的访问规则<br>  A:内部类可以直接访问外部类的成员，包括私有（内部类秘密捕获了一个外部类对象）<br>  B:外部类要想访问内部类成员，必须创建内部类对象</p>
<p>(4) 内部类的分类<br>  A:成员位置（成员内部类，静态内部类）<br>  B:局部位置（局部内部类，匿名内部类）</p>
<p>(5)成员内部类(外部类对象所有)<br>  a. 内部类怎么访问外部类？<br>    直接访问，并且访问外部类的私有成员<br>  b. 外部类怎么访问内部类？<br>    创建对象，并且可以访问内部类私有成员<br>  c. 其他类怎么访问内部类？<br>    创建对象<br>    格式：Outer.Inner inner = new Outer().new Inner()；<br>    受访问权限修饰符的限制。<br>  注意事项：反编译之后，发现内部类秘密捕获了外部类对象。<br>  成员内部类例子如下：</p>
<pre><code>  // 成员内部类
class Outer1 {
  private int a = 10;
  public int b = 20;
  public void method() {
    Inner1 inner = new Inner1();  //访问内部对象需要创建对象
    System.out.println(inner.num1);
    System.out.println(inner.num2);
  }

  class Inner1 {
    // int a = 100;
    // int b = 200;
    private int num1 = 100;
    public int num2 = 200;
    public void show() {
      System.out.println(a); //直接访问外部
      System.out.println(b); //直接访问外部
      // System.out.println(Outer1.a);无法从静态上下文中引用非静态 变量 a
      // System.out.println(Outer1.b); 无法从静态上下文中引用非静态 变量 b
      // System.out.println(Outer1.this.a);
      // System.out.println(Outer1.this.b);
    }
  }
  public static void main(String[] args) {
    //成员内部类想访问外部类时要创建外部类对象
    Outer1 outer = new Outer1();
    Inner1 inner = outer.new Inner1();
    inner.show();
    outer.method();
  }
}
</code></pre><p>(6)静态内部类（外部类所有）<br>  a. 内部类怎么访问外部类？<br>    直接访问，只能访问静态的成员，可以访问外部类私有的（必须是静态的因为在静态上下文中）<br>  b. 外部类怎么访问内部类？<br>    创建对象，并且可以访问内部类私有成员<br>  c. 其他类怎么访问内部类？<br>    创建对象<br>    格式：Outer.Inner inner = new Outer.Inner()；<br>    受访问权限修饰符的限制。<br>    静态内部类的例子：</p>
<pre><code>class Outer2 {
  private int a = 10;
  public int b = 20;
  private static int c = 30;
  public static int d = 40;

  public void method() {
    //全部报错，无法获取静态上下文的成员
    // System.out.println(Inner2.c);
    // System.out.println(Inner2.c);
    // System.out.println(Inner2.num1);
    // System.out.println(Inner2.num2);
    // Inner2.show();
  }

  public static void method2() {
    //只有创建了对象才能在外部类使用
    Inner2 inner2 = new Inner2();

    System.out.println(inner2.c);
    System.out.println(inner2.c);
    System.out.println(inner2.num1);
    System.out.println(inner2.num2);
    inner2.show();
  }

  static class Inner2 {
    // int a;
    // int b;
    int c = 300;
    int d = 400;
    private int num1 = 1;
    public int num2 = 2;
    public void show() {
      // System.out.println(a);
      // System.out.println(b);
      System.out.println(c);
      System.out.println(d);
      // System.out.println(Outer2.this.c);
      // System.out.println(Outer2.this.d);
      System.out.println(Outer2.c);
      System.out.println(Outer2.d);
    }
  }

  public static void main(String[] args) {

    //以下两种创建静态内部类都可以
    System.out.println(&quot;创建内部类访问&quot;);

    Inner2 inner = new Inner2();
    inner.show();
    Outer2.Inner2 inner2 = new Outer2.Inner2();
    inner2.show();

    System.out.println(inner.num1);
    System.out.println(inner.num2);

    System.out.println(&quot;创建外部类访问&quot;);
    Outer2 outer2 = new Outer2();
    outer2.method2();
  }
}
</code></pre><p>写完例子我们就在想，静态内部类到底有什么用？<br>感觉用起来很蠢：</p>
<pre><code>首先外部类是非静态的，所以外部类如果不创建内部类对象是访问不了内部类的成员的。
然后我觉得既然可以直接创建内部类，那还要外部类包装干什么？
和普通的成员内部类区别？
</code></pre><p>  <a href="https://blog.csdn.net/nimeghbia/article/details/87871441" target="_blank" rel="external">内部静态类作用</a><br>  <strong>如果需要内部类需要创静态的成员，就要用到内部类。静态成员是类所有，但这是静态内部类的特性</strong></p>
<p>(7)局部内部类(局部变量)<br>  a. 内部类怎么访问外部类？<br>    直接访问，并且可以访问私有的。<br>    访问外部类的局部变量：要求该局部变量不能改变。（放在常量池中）（通过画图了解和反编译了解）<br>  b. 外部类怎么访问内部类？<br>    只能在该方法中访问。<br>    创建对象，并且可以访问内部类私有成员<br>  c. 其他类怎么访问内部类？<br>    不能！</p>
<p>  A:局部内部类访问局部变量必须是最终量或者是实际的最终量（final）也就是常量,为什么呢?<br>  因为局部变量使用完毕就消失，而堆内存的数据并不会立即消失。<br>  为了让该值还存在，就加final修饰。 –&gt; 常量池</p>
<pre><code>反编译的源码：
class Outer3$1Inner3
{
  final int val$num1;  //把这个值保存成了常量
  final Outer3 this$0;
  Outer3$1Inner3()
  {
    this$0 = final_outer3;
    val$num1 = I.this;
    super();
  }
}
</code></pre><p>下面举个例子来说明：</p>
<pre><code>interface Sing {
  void sing();
}
public class Outer4 {
  public Sing getSing() {
    int a = 10;
    class Inner4 implements Sing {
      @Override
      public void sing() {
        System.out.println(&quot;Inner4.sing()&quot; + a);
      }
    }
    return new Inner4();
  }
  public static void main(String[] args) {
    Outer4 outer = new Outer4();
    Sing sing = outer.getSing();
    sing.sing(); //还能访问a的值
  }
}
</code></pre><p>这个例子说明了当outer调用完getSing()创建一个sing对象之后，却还能访问a的值。就说明a不是定义在getSing()函数中。而是一个常量</p>
<h4 id="8-匿名内部类（必须掌握）"><a href="#8-匿名内部类（必须掌握）" class="headerlink" title="(8)匿名内部类（必须掌握）"></a>(8)匿名内部类（必须掌握）</h4><p>前提：<br>  存在一个类或者接口。<br>  类：可以是普通类, 也可以是抽象类, 但是不能最终类,因为最终类（final）不能有子类<br>    创建了该类的子类。<br>  接口：<br>    创建了该接口的子类</p>
<p>格式：<br>  new 类名或者接口名() {重写方法;}</p>
<p>本质：创建了一个继承了该类或者实现该接口的子类对象。匿名内部类可以实现的，局部内部类一定可以实现；</p>
<p>//定义一个接口</p>
<pre><code>interface Sing {
  void sing();
}
</code></pre><p>//定义一个最终类，不能继承的</p>
<pre><code>final class Dance {
  public void dance() {
  }
}
class Outer6 {
  //局部内部类写法
  public Sing getSing() {
    class Inner6 implements Sing {
      @Override
      public void sing() {
        System.out.println(&quot;sing, sing, sing...&quot;);
      }
    }
    return new Inner6();

  //匿名内部类写法
    return new Sing() {
      @Override
      public void sing() {
        System.out.println(&quot;sing, sing, sing...&quot;);
      }
    };//因为是语句所以要加分号
  }

  public Dance getDance() {
    return new Dance() {
      @Override
      public void dance() {
        System.out.println(&quot;dance,dance,dance...&quot;);
      }
    };
  }

  public static void main(String[] args) {
    Outer6 outer  = new Outer6();
    Sing sing = outer.getSing();
    sing.sing();
    Dance dance = outer.getDance(); //报错无法从final类继承
    dance.dance();
  }
}
</code></pre><p>我要创建一个Sing, 发现它是一个接口, 需要它的子类, 子类还没有定义。然后对这个子类进行定义。</p>
<p>再来看一个题目：</p>
<p>按照要求，补齐代码</p>
<pre><code>interface Inter { void show(); }
class Outer { //补齐代码 }
class OuterDemo {
  public static void main(String[] args) {
      Outer.method().show();
  }
}
</code></pre><p>要求在控制台输出”HelloWorld”</p>
<p>分析：<br>  Outer有个静态的method的方法</p>
<pre><code>Outer.method();
</code></pre><p>  这个方法的返回值是接口类型的对象,然后调用接口的show方法</p>
<pre><code>Outer.method().show();
</code></pre><p>interface Inter {<br>  void show();<br>}</p>
<pre><code>class Outer {
  /*补齐代码*/
  //静态方法属于类 不需要创建对象
  public static Inter method() {
    //局部内部类写法
    class Inner implements Inter {
      @Override
      public void show() {
        System.out.println(&quot;HelloWorld&quot;);
      }
    }
    return  new Inner();  //这里创建了一个局部内部类
    //匿名内部类写法
    return new Inter() {  //直接创建一个接口的子类
      @Override
      public void show() {
        System.out.println(&quot;HelloWorld&quot;);
      }
    };
  }
}
class Test3 {
  public static void main(String[] args) {
    Outer.method().show();
  }
}
</code></pre><h2 id="星期五"><a href="#星期五" class="headerlink" title="星期五"></a>星期五</h2><h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><p>  概述：类 Object 是类层次结构的根类。每个类都使用 Object 作为超类。所有对象（包括数组）都实现这个类的方法。</p>
<p>构造方法：<br>  Object()<br>  为什么子类会默认调用父类的无参构造方法。</p>
<p>  因为object类是所有类的父类，而Object类只有无参构造方法。所以一定会默认调用父类的无参构造方法</p>
<p>成员方法：<br>  protected  Object clone()<br>  boolean equals(Object obj)<br>  protected  void finalize()<br>  Class&lt;?&gt; getClass()<br>  int hashCode()<br>  String toString()</p>
<h3 id="public-final-Class-getClass"><a href="#public-final-Class-getClass" class="headerlink" title="public final Class getClass():"></a>public final Class getClass():</h3><p>  子类不能被重写, 任何一个对象它的 getClass() 行为是一致。<br>  返回此 Object 的运行时类型。</p>
<h3 id="Class-类类型"><a href="#Class-类类型" class="headerlink" title="Class: 类类型"></a>Class: 类类型</h3><p>  概述：Class 类的实例表示正在运行的 Java 应用程序中的类和接口。枚举是一种类，注解是一种接口。<br>  public String getName()：返回该对象的运行时类的全限定名。</p>
<h3 id="public-int-hashCode"><a href="#public-int-hashCode" class="headerlink" title="public int hashCode()"></a>public int hashCode()</h3><p>返回该对象的哈希码值。<br>默认实现：这一般是通过将该对象的内部地址转换成一个整数来实现的</p>
<p>hashcode()的常规协定：<br>1） 一致性. 如果一个对象进行比较的信息没有发生修改，那么在一次程序运行期间，它们的hash值要一致。<br>2) 相等性. 如果两个对象通过 equals 比较是相等的，那么它们的 hashcode 也要相等。<br>3) 哈希碰撞概率低. 如果两个对象不相等，那么它们的 hashcode 最好不相等，这个可以提高哈希表的性能。</p>
<p>哈希函数很像之前数据结构的哈希查找的相关的内容。所以理解起来并不是很困难。</p>
<pre><code>public class hashCode {
    public static void main(String[] args) {
        String s = &quot;我感觉很难受&quot;;
        int hash = hash(s);
    }
    //加法哈希
    public static int hash(String str) {
        int hash = str.length();
        for (int i = 0; i &lt; str.length(); i++) {
            hash += str.charAt(i);  //字符运算默认转换成int
        }
        return hash;
    }
    //位运算哈希
    public static int hash2(String str) {
        int hash = str.length();
        for (int i = 0; i &lt; str.length(); i++) {
            hash = (hash&lt;&lt;4)^(hash&gt;&gt;28)^str.charAt(i);
        }
        return hash;
    }
    //乘法哈希
    public static int hash3(String str) {
        int hash = str.length();
        for (int i = 0; i &lt; str.length(); i++) {
            hash = hash*31+str.charAt(i);
        }
        return hash;
    }
}
</code></pre><h3 id="public-String-toString-（简历）"><a href="#public-String-toString-（简历）" class="headerlink" title="public String toString(): （简历）"></a>public String toString(): （简历）</h3><p>  返回该对象的字符串表示。结果应是一个简明但易于读懂的信息表达式。建议所有子类都重写此方法。<br>  默认实现：return getClass().getName() + “@” + Integer.toHexString(hashCode());</p>
<p>注意事项：<br>  直接打印对象, 默认会调用该对象的 toString() 方法。</p>
<h3 id="public-boolean-equals-Object-obj"><a href="#public-boolean-equals-Object-obj" class="headerlink" title="public boolean equals(Object obj):"></a>public boolean equals(Object obj):</h3><p>  指示其他某个对象是否与此对象”相等”。<br>  默认实现： return (this == obj); 判断两个对象的地址值是否相等 (是否是同一个对象)</p>
<p>实体类：</p>
<pre><code>一个对象对应一个实体。没有必要重写 Object 中的 equals();
</code></pre><p>值类：</p>
<pre><code>String, Point, 重写 equals 方法。
Rectangle:
关键域：length, width
衍生域：area, perimeter
无关域：color
根据关键域进行比较
</code></pre><p>equals方法常规协定：<br>    equals 方法在非空对象引用上实现相等关系：</p>
<pre><code>自反性：对于任何非空引用值 x，x.equals(x) 都应返回true。
对称性：对于任何非空引用值 x 和 y，当且仅当 y.equals(x) 返回true时，x.equals(y)才应返回true。
传递性：对于任何非空引用值 x、y 和 z，如果x.equals(y)返回 true，并且y.equals(z)返回 true，那么 x.equals(z) 应返回 true。
一致性：对于任何非空引用值 x 和 y，多次调用 x.equals(y) 始终返回 true 或始终返回 false，前提是对象上 equals 比较中所用的信息没有被修改。
非空性：对于任何非空引用值 x，x.equals(null) 都应返回 false。
</code></pre><p><strong><em>注意事项：当此方法被重写时，通常有必要重写hashCode方法，在IDEA中使用alt+insert可以自动生成。通常改写是为了比较两个对象是否“相等”，这里的相等，并不是地址值相等。而是成员内容相等。或者用于判断深拷贝是否成功</em></strong></p>
<pre><code>public boolean equals(Object o) {
  if(o == this) return true; //包括了null
  if(o == null || o.getClass() != this.getClass()) return false;
  //比较成员变量
  return id == emp.id &amp;&amp;
            Double.compare(emp.salary, salary) == 0 &amp;&amp;
            Objects.equals(name, emp.name) &amp;&amp;
            Objects.equals(flag, emp.flag);
}
</code></pre><p>instanceof:是 Java 的保留关键字。它的作用是测试它左边的对象是否是它右边的类的实例，返回 boolean 的数据类型。<br>    null instanceof 类名: 返回fasle;<br>    obj instanceof Object: 返回true, 子类能够内父类接受</p>
<p>instanceof可以判断类和类的关系吗？或者对象和对象的？</p>
<pre><code>只能判断对象是否是右边的类的实例或者是子类的实例。
</code></pre><h3 id="protected-void-finalize-throws-Throwable"><a href="#protected-void-finalize-throws-Throwable" class="headerlink" title="protected void finalize() throws Throwable"></a>protected void finalize() throws Throwable</h3><p>概述：当垃圾回收器回收这个对象时，会自动调用此方法。子类重写 finalize 方法，以释放资源。<br>默认实现：什么都没做，空实现。</p>
<p>finalize:</p>
<ol>
<li>可以自动调用, 该对象没有被回收。</li>
<li>当垃圾回收器回收这个对象时，会自动调用此方法。</li>
<li>释放资源最好不要放在 finalize() 里面。为什么？</li>
</ol>
<p>原因是：垃圾回收线程是一个优先级低的线程，当一个对象变成垃圾后，并不会马上被回收，因此资源得不到立刻释放。<br>怎么释放资源呢？<br>    try … catch … finally(异常处理)语句释放资源</p>
<h3 id="protected-Object-clone-throws-CloneNotSupportedException"><a href="#protected-Object-clone-throws-CloneNotSupportedException" class="headerlink" title="protected Object clone() throws CloneNotSupportedException"></a>protected Object clone() throws CloneNotSupportedException</h3><pre><code>创建并返回此对象的一个&quot;副本&quot;.
</code></pre><p>异常：CloneNotSupportedException。<br>解决方案：实现 Cloneable 接口<br>Cloneable(空接口, 标记接口):<br>    此类实现了 Cloneable 接口，以指示 Object.clone() 方法可以合法地对该类实例进行按字段复制。<br>如果在没有实现 Cloneable 接口的实例上调用 Object 的 clone 方法，则会导致抛出CloneNotSupportedException异常。<br>一个接口没有定义任何内容，叫做空接口，在Java中往往起标记作用。</p>
<p>Java的默认实现是浅拷贝和深拷贝？<br>    浅拷贝<br>实现深拷贝的例子：</p>
<p>首先先调用父类的clone()方法获取一个浅拷贝的对象，然后对里面的非基本数据类型的引用数据类型类型成员再clone新的对象赋给外层的成员变量。当然这个操作应该在那个引用数据类型对应的类里面进行编写的</p>
<pre><code>/*
  和在一个文件里面写
  这里注意记得把初始化的数据要传过去
*/
import java.util.Objects;

//第一层
public class FirstLevel implements Cloneable{

    int i;
    int j;
    SecondLevel sec;

    public FirstLevel() {

    }
    public FirstLevel(int i, int j, SecondLevel sec) {
        this.i = i;
        this.j = j;
        this.sec = sec;
    }

    @Override
    protected FirstLevel clone() throws CloneNotSupportedException {
        FirstLevel fl = (FirstLevel)super.clone();

        //如果要克隆的对象本身没有sec
        if(sec == null) {
            fl.sec = null;

        } else {
            //记得传初始化的数值进去给他初始化！
            SecondLevel secondLevel = new SecondLevel(fl.sec.j ,fl.sec.third);

            SecondLevel clone = secondLevel.clone();


            fl.sec = clone;
        }
        return fl;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        FirstLevel that = (FirstLevel) o;
        return i == that.i &amp;&amp;
                j == that.j &amp;&amp;
                Objects.equals(sec, that.sec);
    }

    @Override
    public int hashCode() {
        return Objects.hash(i, j, sec);
    }

    public static void main(String[] args) throws CloneNotSupportedException {
        ThirdLevel tl = new ThirdLevel(10);
        SecondLevel sl = new SecondLevel(20,tl);
        FirstLevel fl = new FirstLevel(30,40,sl);

        FirstLevel fl2 = fl.clone();
        System.out.println(fl == fl2);
        System.out.println(fl.equals(fl2));
        System.out.println(&quot;深拷贝成功&quot;);
    }
}
//第二层
class SecondLevel implements Cloneable {
    double j;
    ThirdLevel third;
    //无参构造方法
    public SecondLevel() {}

    public SecondLevel(double j, ThirdLevel third) {
        this.j = j;
        this.third = third;
    }
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        SecondLevel that = (SecondLevel) o;
        return Double.compare(that.j, j) == 0 &amp;&amp;
                Objects.equals(third, that.third);
    }

    @Override
    public int hashCode() {
        return Objects.hash(j, third);
    }

    protected SecondLevel clone() throws CloneNotSupportedException {
        SecondLevel sl = (SecondLevel)super.clone();
        if(third == null) {
            sl.third = null;
        } else {
            //初始化third对象；
            ThirdLevel tl = new ThirdLevel(third.k);
            ThirdLevel clone = tl.clone();
            sl.third = clone;
        }
        return sl;
    }
}
//第三层
class ThirdLevel implements Cloneable{
    int k;
    //无参构造方法
    public ThirdLevel() {

    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        ThirdLevel that = (ThirdLevel) o;
        return k == that.k;
    }

    @Override
    public int hashCode() {
        return Objects.hash(k);
    }

    public ThirdLevel(int k) {
        this.k = k;
    }
    protected ThirdLevel clone() throws CloneNotSupportedException {
        ThirdLevel tl = (ThirdLevel)super.clone();
        return tl;
    }
}
</code></pre><h2 id="星期六"><a href="#星期六" class="headerlink" title="星期六"></a>星期六</h2><p>介绍了String的构造函数和一些常用的API</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>public String()<br>public String(byte[] bytes)<br>public String(byte[] bytes,int offset,int length)<br>public String(char[] value)<br>public String(char[] value,int offset,int count)<br>public String(String original)</p>
<h3 id="判断功能："><a href="#判断功能：" class="headerlink" title="判断功能："></a>判断功能：</h3><p>boolean equals(Object obj)<br>boolean equalsIgnoreCase(String str)<br>boolean contains(String str)<br>    判断一个字符串是否包含另一个字符串<br>boolean startsWith(String str)<br>    判断字符串是否以给定的字符串开头<br>boolean endsWith(String str)<br>    判断字符串是否以给定的字符串结束<br>boolean isEmpty()<br>    判断一个字符串是否是空串</p>
<h3 id="获取功能："><a href="#获取功能：" class="headerlink" title="获取功能："></a>获取功能：</h3><p>int length()<br>    获取字符的个数<br>char charAt(int index)<br>    获取指定索引的字符<br>int indexOf(int ch)<br>    判断字符在字符串中第一次出现的索引位置，如果该字符不存在返回负数。<br>int indexOf(String str)<br>    判断str在字符串中第一次出现的索引位置，如果该str不存在返回负数。<br>    返回的是第一个字符所在位置的索引<br>int indexOf(int ch,int fromIndex)<br>    从指定的索引位置开始，判断是否包含该字符<br>int indexOf(String str,int fromIndex)<br>    从指定的索引位置开始，判断是否包含该字符串str<br>int lastIndexOf(int ch)<br>int lastIndexOf(int ch, int fromIndex)<br>int lastIndexOf(String str)<br>int lastIndexOf(String str, int fromIndex)</p>
<p>String substring(int start)<br>    截取子串, 从start开始，截取到最后<br>String substring(int start,int end) (包左不包右，包括start，不包括end)<br>     截取子串, 从start开始，截取到end。</p>
<h3 id="转换功能："><a href="#转换功能：" class="headerlink" title="转换功能："></a>转换功能：</h3><p>  byte[] getBytes()<br>  char[] toCharArray()<br>  static String valueOf()<br>  String toLowerCase()<br>  String toUpperCase()<br>  String concat(String str)</p>
<p>byte[] –&gt; String<br>    new String(byte[])<br>String –&gt; byte[]<br>    getBytes()<br>char[] –&gt; String<br>    new String(char[])<br>String –&gt; char[]<br>    toCharArray();</p>
<p>任意类型 –&gt; String<br>    valueOf()</p>
<h3 id="替换功能"><a href="#替换功能" class="headerlink" title="替换功能"></a>替换功能</h3><p>String replace(char old,char new)<br>    将所有的字符old转化成new<br>String replace(String old,String new)<br>    将所有的字符串old转化成new<br>String trim()<br>    修建字符串两边的空白字符</p>
<h3 id="字符串分割："><a href="#字符串分割：" class="headerlink" title="字符串分割："></a>字符串分割：</h3><p>public String[] split(String regex)<br>    根据给定正则表达式的匹配拆分此字符串。</p>
<h3 id="比较功能："><a href="#比较功能：" class="headerlink" title="比较功能："></a>比较功能：</h3><p>Comparable:(可以进行比较，表示对象的一种能力)<br>    int compareTo(T o)<br>    比较此对象与指定对象的顺序。<br>    如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。</p>
<h3 id="markdown格式："><a href="#markdown格式：" class="headerlink" title="markdown格式："></a>markdown格式：</h3><p>表格使用竖杠| 分割，注意要上下都有空格才能显示正确；</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这周的内容比较乱。但是总体还是把类和对象讲完了。脑海也有一个整体的概念。就是内部类的细节和深拷贝有一点难度以外。其他东西都很基础，必须要掌握。对象成员的继承关系，以及子类的初始化过程等等。</p>

    </div>

    
    
    
        
      

      <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2019/06/30/Java总结（一）/" rel="next" title="Java总结（一）">
                  <i class="fa fa-chevron-left"></i> Java总结（一）
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2019/07/14/Java总结（三）上/" rel="prev" title="Java总结（三）上">
                  Java总结（三）上 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          
    
    <div class="comments" id="comments"></div>
  

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#星期一"><span class="nav-number">2.</span> <span class="nav-text">星期一</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#代码块"><span class="nav-number">2.1.</span> <span class="nav-text">代码块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#继承"><span class="nav-number">2.2.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#final"><span class="nav-number">2.3.</span> <span class="nav-text">final</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第二天"><span class="nav-number">3.</span> <span class="nav-text">第二天</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#多态"><span class="nav-number">3.1.</span> <span class="nav-text">多态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#抽象类"><span class="nav-number">3.2.</span> <span class="nav-text">抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接口"><span class="nav-number">3.3.</span> <span class="nav-text">接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#形式参数和返回值的问题"><span class="nav-number">3.4.</span> <span class="nav-text">形式参数和返回值的问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#星期三-拉闸放假"><span class="nav-number">4.</span> <span class="nav-text">星期三(拉闸放假)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#星期四"><span class="nav-number">5.</span> <span class="nav-text">星期四</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#打包"><span class="nav-number">5.1.</span> <span class="nav-text">打包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#执行"><span class="nav-number">5.2.</span> <span class="nav-text">执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#导包"><span class="nav-number">5.3.</span> <span class="nav-text">导包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#权限修饰符"><span class="nav-number">5.4.</span> <span class="nav-text">权限修饰符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常见的修饰符"><span class="nav-number">5.5.</span> <span class="nav-text">常见的修饰符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内部类（难）"><span class="nav-number">5.6.</span> <span class="nav-text">内部类（难）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-匿名内部类（必须掌握）"><span class="nav-number">5.6.1.</span> <span class="nav-text">(8)匿名内部类（必须掌握）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#星期五"><span class="nav-number">6.</span> <span class="nav-text">星期五</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Object类"><span class="nav-number">6.1.</span> <span class="nav-text">Object类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#public-final-Class-getClass"><span class="nav-number">6.2.</span> <span class="nav-text">public final Class getClass():</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Class-类类型"><span class="nav-number">6.3.</span> <span class="nav-text">Class: 类类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#public-int-hashCode"><span class="nav-number">6.4.</span> <span class="nav-text">public int hashCode()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#public-String-toString-（简历）"><span class="nav-number">6.5.</span> <span class="nav-text">public String toString(): （简历）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#public-boolean-equals-Object-obj"><span class="nav-number">6.6.</span> <span class="nav-text">public boolean equals(Object obj):</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#protected-void-finalize-throws-Throwable"><span class="nav-number">6.7.</span> <span class="nav-text">protected void finalize() throws Throwable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#protected-Object-clone-throws-CloneNotSupportedException"><span class="nav-number">6.8.</span> <span class="nav-text">protected Object clone() throws CloneNotSupportedException</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#星期六"><span class="nav-number">7.</span> <span class="nav-text">星期六</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#构造函数"><span class="nav-number">7.1.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#判断功能："><span class="nav-number">7.2.</span> <span class="nav-text">判断功能：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取功能："><span class="nav-number">7.3.</span> <span class="nav-text">获取功能：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#转换功能："><span class="nav-number">7.4.</span> <span class="nav-text">转换功能：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#替换功能"><span class="nav-number">7.5.</span> <span class="nav-text">替换功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串分割："><span class="nav-number">7.6.</span> <span class="nav-text">字符串分割：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#比较功能："><span class="nav-number">7.7.</span> <span class="nav-text">比较功能：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#markdown格式："><span class="nav-number">7.8.</span> <span class="nav-text">markdown格式：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">8.</span> <span class="nav-text">总结</span></a></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/head.jpeg"
      alt="王邸">
  <p class="site-author-name" itemprop="name">王邸</p>
  <div class="site-description" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">40</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span>
        
      </div>
    
  </nav>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王邸</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.3.8</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.4.0</div>

        












        
      </div>
    </footer>
  </div>

  


  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/pisces.js?v=7.4.0"></script>

<script src="/js/next-boot.js?v=7.4.0"></script>



  





















  

  

  


<script>
NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'Fn4BuvoixOxjJAhR79TvaD5M-gzGzoHsz',
    appKey: '1uspTrSwPqkmSBSUr948WqxE',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: true,
    lang: '' || 'zh-cn',
    path: location.pathname
  });
}, window.Valine);
</script>

</body>
</html>
