<!DOCTYPE html>
<html class="full-height">
<head>
  <meta charset="utf-8">
  <link rel="stylesheet" href="//cdn.bootcss.com/bulma/0.4.1/css/bulma.min.css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  
  <title>Java总结（四）下 | 路要坚持</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="接上一篇，上一篇我们总结了：冒泡，插入，希尔，选择，快排，归并排序。这一篇介绍的主要内容是堆和堆排序应用，二分法，以及二分法的变形，以及hashSet,treeSet集合的知识，以及一些还没学习的知识,红黑树，动态规划等等。。 星期五7.19堆就是一个完全二叉树，分为大顶堆小顶堆，注意二叉搜索树不一定是完全二叉树哦； 建堆public class Heap {     //属性     priva">
<meta property="og:type" content="article">
<meta property="og:title" content="Java总结（四）下">
<meta property="og:url" content="http://yoursite.com/2019/07/21/Java总结（四）下/index.html">
<meta property="og:site_name" content="路要坚持">
<meta property="og:description" content="接上一篇，上一篇我们总结了：冒泡，插入，希尔，选择，快排，归并排序。这一篇介绍的主要内容是堆和堆排序应用，二分法，以及二分法的变形，以及hashSet,treeSet集合的知识，以及一些还没学习的知识,红黑树，动态规划等等。。 星期五7.19堆就是一个完全二叉树，分为大顶堆小顶堆，注意二叉搜索树不一定是完全二叉树哦； 建堆public class Heap {     //属性     priva">
<meta property="og:updated_time" content="2019-08-17T03:34:33.886Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java总结（四）下">
<meta name="twitter:description" content="接上一篇，上一篇我们总结了：冒泡，插入，希尔，选择，快排，归并排序。这一篇介绍的主要内容是堆和堆排序应用，二分法，以及二分法的变形，以及hashSet,treeSet集合的知识，以及一些还没学习的知识,红黑树，动态规划等等。。 星期五7.19堆就是一个完全二叉树，分为大顶堆小顶堆，注意二叉搜索树不一定是完全二叉树哦； 建堆public class Heap {     //属性     priva">
  
    <link rel="alternate" href="/" title="路要坚持" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/common.css">
<link rel="stylesheet" href="/css/nav.css">
<link rel="stylesheet" href="/css/layout.css">
  

</head>

<body>
  <header id="navbar" class="overflow-hidden">
  <div class="container">
    <nav class="nav">
         <div class="nav-left">
            <a href="/" class="nav-item" style="font-size: 20px;">
              <span class="logo">王邸</span>'s Blog
            </a>
         </div>
        <div class="nav-center is-hidden position-relative" id="search_container">
            <div class="nav-item full-width full-height">
                <i class="fa fa-search has-padding" aria-hidden="true"></i>
                <input type="text" id="search_input" class="search-input full-height full-width" placeholder="Search post" autofocus>
                <i id="close_search" class="fa fa-times" aria-hidden="true"></i>
            </div>
            <div id="search_result"></div>
        </div>
        <div class="nav-right nav-menu">
            <a class="nav-item" id="search">
                <i class="fa fa-search" aria-hidden="true"></i>
            </a>
            
            <a class="nav-item" href="/">
                Home
            </a>
            
            <a class="nav-item" href="/works">
                My Works
            </a>
            
            <a class="nav-item" href="/about">
                About
            </a>
            
        </div>
        <span class="nav-toggle" id="navMenuDropdown">
            <span></span>
            <span></span>
            <span></span>
        </span>
        <div class="navbar-menu position-absolute full-width content-box is-hidden-desktop is-flex flex-column center" style="top: 100%;">
            
            <a class="nav-item flex-1" href="/">
                Home
            </a>
            
            <a class="nav-item flex-1" href="/works">
                My Works
            </a>
            
            <a class="nav-item flex-1" href="/about">
                About
            </a>
            
        </div>
    </nav>
  </div>
</header>

  <div id="main-wrap" class="position-relative" style="margin-top: 55px;">
      <div class="main-inner-content">
          <!--博文页面-->

<style>
    .header-box {
        height: 370px;
        filter: blur(10px);
        background-size: cover;
        background-color: lightsteelblue;
    }

    .post-box {
        padding: 15px;
        padding-top: 60px;
        min-height: 80vh;
        margin-top: -200px;
        border-radius: 4px;
        background-color: rgba(255,255,255,.8);
    }

    .post-avatar {
        height: 30px;
        width: 30px;
        border-radius: 50%;
    }

    .flow-chart {
        text-align: center;
    }

    img[alt="post-cover"] {
        display: none;
    }
</style>
<header>
    <div id="header_box" class="header-box"></div>
</header>
<section>
    <div class="container post-box">
        <div class="content post-title is-flex center flex-column" style="margin-bottom: 70px; overflow: auto;">
            <h1 class="has-text-centered" style="padding-bottom: 10px; border-bottom: 3px solid #fff">
                <strong>Java总结（四）下</strong>
            </h1>
            
            <div class="is-flex align-center">
                <img class="post-avatar" src="https://q2.qlogo.cn/headimg_dl?bs=996057150&dst_uin=996057150&dst_uin=996057150&;dst_uin=996057150&spec=100&url_enc=0&referer=bu_interface&term_type=PC">
                <span style="padding:0 10px;"> <span class="sub-title">By</span> 王邸</span>
                <span class="post-date sub-title">at: 2019-07-21</span>
            </div>
            
                <div>
                    
                </div>
            
        </div>
        <div class="content" style="overflow: auto">
            <p>接上一篇，上一篇我们总结了：冒泡，插入，希尔，选择，快排，归并排序。这一篇介绍的主要内容是堆和堆排序应用，二分法，以及二分法的变形，以及hashSet,treeSet集合的知识，以及一些还没学习的知识,红黑树，动态规划等等。。</p>
<h2 id="星期五7-19"><a href="#星期五7-19" class="headerlink" title="星期五7.19"></a>星期五7.19</h2><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>就是一个完全二叉树，分为大顶堆小顶堆，<br>注意二叉搜索树不一定是完全二叉树哦；</p>
<h3 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h3><pre><code>public class Heap {
    //属性
    private int[] elements;
    private int size;

    //构造方法
    public Heap(){
        elements = new int[10]; //0的位置不存元素
    }

    //方法

    /**
     * 添加一个元素，先把元素放在末尾然后在判断是否需要往上移动
     * 只用比较该结点和父亲结点，然后再和父亲的父亲比较
     * 假设是大根堆
     * @param value
     * @return
     */
    public boolean add(int value) {
        if(size &gt; elements.length){
            return false;
        }
        size++;
        elements[size] = value;
        // 判断是否需要移动
        int i = size;
        //从下往上进行比较
        while(i &gt; 1) {  //根节点是1 只有大于1才能比较根节点和子结点
            int parent = i/2;
            //短路与这个要放前面
            if(parent &gt; 0 &amp;&amp; elements[i] &gt; elements[parent]) {
                swap(elements,i,parent);
            }
            i = parent;
        }
        return true;
    }

    /**
     * remove只能remove根节点，
     * 然后把最最后一个元素放到堆顶的位置。再从新构造一个堆
     * 这时候需要从上到下进行调整；先从交换的结点开始向下调整
     * @return
     */
    public boolean remove() {
        if(size == 0) return false;
        //交换头节点和最后一个元素的结点
        swap(elements,1,size); //这里size就是表示最后一个数
        size--;//最后一个元素已经出局
        //然后从上到下调整
        //i的左孩子 2*i 右孩子2*i+1;
        int i = 1;
        while(i &lt; size) {
            int left = 2*i;
            int right = 2*i+1;
            int maxIndex = i;
            //先比较左边再比较右边 没有先后顺序
            if(left &lt;= size &amp;&amp; elements[maxIndex] &lt; elements[left]) {
                maxIndex = left;
            }
            if(right &lt;= size &amp;&amp; elements[maxIndex] &lt; elements[right]) {
                maxIndex = right;
            }
            if(maxIndex == i) break; //不用调了
            //交换元素
            swap(elements,maxIndex,i);
            i = maxIndex;
        }
        return true;
    }
}
</code></pre><p>堆的应用：<br>堆排序<br>  a.先进行建堆操作<br>    从第一个非叶子结点开始向下进行建堆操作，一直循环到根节点<br>  b.开始排序<br>    把根节点和最后一个无序元素交换<br>  c.重新构造成一个堆从上到下调整</p>
<pre><code>public class HeapSort {

    public static void sort(int[] arr) {
        //首先进行建堆的过程
        buildHeap(arr);
        //开始排序，把第一个数和最后一个数交换然后再重新调整堆

        int i = 0;
        while(i &lt; arr.length-1){ //最后一次就是两个元素比较吧
            int temp = arr[0];
            arr[0] = arr[arr.length-1-i];
            arr[arr.length-1-i] = temp;
            heapify(arr,0,arr.length-1-i);
            System.out.println(Arrays.toString(arr));
            i++;
        }

    }

    /**
     * 建堆过程
     * @param arr
     */
    private static void buildHeap(int[] arr) {
        // 建堆过程从第一个非叶子结点开始。因为下标从0开始
        // 因为parent(i) = (i - 1)/2;
        //所以第一个非叶子结点就是 (arr.len-2)/2

        for (int i = (arr.length-2)/2; i &gt;=0; i--) {
            heapify(arr, i, arr.length);
        }
    }

    /**
     * 校对是否是堆
     * @param arr
     * @param i
     * @param length
     */
    private static void heapify(int[] arr, int i, int length) {
        while(i &lt; length) {
            int maxIndex = i;
            int left = 2*i+1;
            int right = 2*i+2;
            if(left &lt; length &amp;&amp; arr[left] &gt; arr[maxIndex]) { //left &lt; length防止下标越界 而且必须要放前面 不然下标越界
              maxIndex = left;
            }
            if(right &lt; length &amp;&amp; arr[right] &gt; arr[maxIndex]) {
                maxIndex = right;
            }
            if(maxIndex == i) break;//如果不用换就break;
            // 交换两个元素；
            int temp = arr[i];
            arr[i] = arr[maxIndex];
            arr[maxIndex] = temp;

            i = maxIndex;//对孩子也比较
        }
    }

    public static void main(String[] args) {
        int[] arr = {5, 1, 2, 9, 0, 8, 7, 6, 4, 3};
        System.out.println(Arrays.toString(arr));
        System.out.println(&quot;------------------------------&quot;);
        sort(arr);
    }
}
</code></pre><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>算法很简单但是变种却很有趣：<br>最原始的算法：</p>
<pre><code>public static int search(int[] arr, int value) {
    // 循环
    if (arr == null || arr.length == 0) return -1;
    int low = 0;
    int high = arr.length - 1;
    while (low &lt;= high) {
        int mid = low + ((high - low) &gt;&gt; 1);
        if (arr[mid] &lt; value) {
            low = mid + 1;
        } else if (arr[mid] &gt; value) {
            high = mid - 1;
        } else {
            return mid;
        }
    }
    return -1;
}
</code></pre><h3 id="二分查找的变种"><a href="#二分查找的变种" class="headerlink" title="二分查找的变种"></a>二分查找的变种</h3><p>查找第一个相等的元素</p>
<p>就在while里面多加一个条件就好了</p>
<pre><code>while (low &lt;= high) {
    int mid = low + ((high - low) &gt;&gt; 1);
    if (arr[mid] &lt; value) {
      low = mid + 1;
    } else if (arr[mid] &gt; value) {
      high = mid - 1;
    } else {
      if(mid == 0 || arr[mid-1] &lt; value) {
        return mid;
      }
      high = mid-1; //其他情况把相等看成大于
    }
}
</code></pre><p>查找最后一个相等的元素<br>最后一个相等的元素有两种情况：第一种，这个数就是最后一个数，或者后面的数比他大</p>
<pre><code>while (low &lt;= high) {
   int mid = low + ((high - low) &gt;&gt; 1);
   if (arr[mid] &lt; key) {
       low = mid + 1;
   } else if (arr[mid] &gt; key) {
       high = mid - 1;
   } else {
       if (mid == arr.length - 1 || arr[mid + 1] &gt; key) {
           return mid;
       }
       //找到这个数但是不是最后一个
       low = mid + 1; //找到了但是不能证明是最后一个所以还要向后找
   }
}
</code></pre><p>查找最后一个小于等于的元素<br>如果找到小于等于的数，然后去判断是否是最后一个：<br>要么是最后一个元素，要么后一个元素比他大</p>
<pre><code>while (low &lt;= high) {
    int mid = low + ((high - low) &gt;&gt; 1);
    if (arr[mid] &lt;= key) {
        if (mid == arr.length - 1 || arr[mid + 1] &gt; key) {  //如果是最后一个或者下一个数大于value，就确定是最后一个小于等于value的值
            return mid;
        }
        low = mid + 1;
    } else {
        high = mid - 1;
    }
}

查找第一个大于等于的元素

while (low &lt;= high) {
    int mid = low + ((high - low) &gt;&gt; 1);
    if (arr[mid] &lt; key) {
        low = mid + 1;
    } else {
        if (mid == 0 || arr[mid - 1] &lt; key) { //如果是第一个，或者前一个数小于value就能证明mid就是要找的数
            return mid;
        }
        high = mid - 1;
    }
}
</code></pre><h2 id="星期六7-20"><a href="#星期六7-20" class="headerlink" title="星期六7.20"></a>星期六7.20</h2><p>Collection:<br>  |– List：可以包含重复元素的有序集合.<br>    |– ArrayList: 底层是数组, 增删慢, 查找快, 线程不安全, 效率高。<br>    |– LinkedList 底层是链表, 增删快, 查找慢, 线程不安全, 效率高。<br>    |– Vector 底层是数组, 增删慢, 查找块, 线程安全, 效率低。<br>  |– Set 不可以包含重复元素的集合(可以有序，也可以无序)<br>    |– HashSet 不保证迭代顺序, 底层是HashMap, 元素的唯一性依赖于存储对象的 equals(), hashCode();<br>      |– LinkedHashSet 迭代顺序和插入的顺序一致, 底层是HashMap和链表, HashMap保证元素的唯一性，链表保证迭代的有序性。<br>    |– TreeSet 元素是从小到大排序的。底层是TreeMap, TreeMap的底层是红黑树。如果构造方法没有传递比较器，就要求元素Comparable接口。</p>
<h3 id="HashSet-存储是无序的"><a href="#HashSet-存储是无序的" class="headerlink" title="HashSet:存储是无序的"></a>HashSet:存储是无序的</h3><p>不保证 set 的迭代顺序<br>特别是它不保证该顺序恒久不变。<br>HashSet如何保证元素唯一性</p>
<pre><code>底层数据结构是哈希表(元素是链表的数组)
哈希表依赖于哈希值存储
添加功能底层依赖两个方法：
int hashCode()
boolean equals(Object obj)
</code></pre><p>所以在添加元素之后，修改了元素的属性值，contains就会找不到元素。而出现false;虽然属性名没有变但是属性变了也不行。看下面源码：contains方法调用了map的containsKey方法</p>
<pre><code>//HashSet.java
public boolean contains(Object o) {
    return map.containsKey(o);
}

//HashMap.java
public boolean containsKey(Object key) {
    return getNode(hash(key), key) != null;
}
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
}

public final int hashCode() {
    return Objects.hashCode(key) ^ Objects.hashCode(value);
}

final Node&lt;K,V&gt; getNode(int hash, Object key) {
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;
    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
        (first = tab[(n - 1) &amp; hash]) != null) {
        if (first.hash == hash &amp;&amp; // always check first node
            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))
            return first;
        if ((e = first.next) != null) {
            if (first instanceof TreeNode)
                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);
            do {
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    return e;
            } while ((e = e.next) != null);
        }
    }
    return null;
}
</code></pre><h3 id="TreeSet-这是有序的（如何确定排序的规则？）"><a href="#TreeSet-这是有序的（如何确定排序的规则？）" class="headerlink" title="TreeSet:这是有序的（如何确定排序的规则？）"></a>TreeSet:这是有序的（如何确定排序的规则？）</h3><p>使用元素的自然顺序对元素进行排序需要实现comparable接口</p>
<p>或者根据创建 set 时提供的 Comparator 进行排序<br>具体取决于使用的构造方法。看下面例子：输入五个学生进行排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public class HomeWork3 &#123;</div><div class="line">    public static void main(String[] args) &#123;</div></pre></td></tr></table></figure></p>
<p>下面是实现了comparator的匿名内部类<br>因为接口只用实现一个compare方法所以可以使用lambda表达式</p>
<pre><code>// TreeSet&lt;ScutStudent&gt; set = new TreeSet&lt;&gt;((t1, t2) -&gt; t2.total - t1.total);
</code></pre><p>正常的匿名内部类写法应该是：</p>
<pre><code>TreeSet&lt;ScutStudent&gt; set = new TreeSet&lt;&gt;(new Comparator&lt;ScutStudent&gt;() {
    @Override
    //注意如果这里总分一样需要比较其他科目的分数
    public int compare(ScutStudent t1, ScutStudent t2) {
         // 客户往往给你的主要需求，需要自己分析次要需求,只要比较结果为0就应该继续比较
        int n1 = t2.getTotalScore() - t1.getTotalScore();
        int n2 = n1 != 0 ? n1 : t2.getChinese() - t1.getChinese();
        int n3 = n2 != 0 ? n2 : t2.getMath() - t1.getMath();
        int n4 = n3 != 0 ? n3 : t2.getEnglish() - t1.getEnglish();
        int n5 = n4 != 0 ? n4 : t1.getName().compareTo(t2.getName());
        return n5;
    }
});
Scanner scan = new Scanner(System.in);
System.out.println(&quot;请输入五个学生的名字和各科成绩&quot;);
for (int i = 1; i &lt; 4; i++) {
    System.out.println(&quot;输入第 &quot;+ i +&quot; 学生的姓名&quot;);
    String name = scan.nextLine();
    System.out.println(&quot;输入第&quot;+ i +&quot;学生的语文成绩&quot;);
    int chinese = Integer.valueOf(scan.nextLine());
    System.out.println(&quot;输入第&quot;+ i +&quot;学生的数学成绩&quot;);
    int math = Integer.valueOf(scan.nextLine());
    System.out.println(&quot;输入第&quot;+ i +&quot;学生的英语成绩&quot;);
    int english = Integer.valueOf(scan.nextLine());
    ScutStudent ss = new ScutStudent(name,chinese,math,english);
    set.add(ss);
}
for (ScutStudent s : set) {
    System.out.println(s);
}
</code></pre><p>继承了 comparable 接口写法：重写 comparaTo 方法</p>
<pre><code>class ScutStudent implements Comparable{
    String name;
    int chinese;
    int math;
    int english;
    int total;

    public ScutStudent() {
    }

    public ScutStudent(String name, int chinese, int math, int english) {
        this.name = name;
        this.chinese = chinese;
        this.math = math;
        this.english = english;
        this.total = this.math + this.chinese + this.english;
    }

    @Override
    public String toString() {
        return &quot;ScutStudent{&quot; +
                &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +
                &quot;, chinese=&quot; + chinese +
                &quot;, math=&quot; + math +
                &quot;, english=&quot; + english +
                &quot;, total=&quot; + total +
                &apos;}&apos;;
    }

    @Override
    public int compareTo(Object o) {
        ScutStudent s = (ScutStudent)o;
        return s.total - this.total;
    }
}
</code></pre><h3 id="下午开会："><a href="#下午开会：" class="headerlink" title="下午开会："></a>下午开会：</h3><p>每天知道自己应做什么事情，时间管理，以下内容是否需要调整？<br>时间管理：<br>  例如星期三，星期六下午；<br>  要有自己思考的时间；<br>提前预习<br>  老师讲的自己总是不记得代码，自己去知道今天讲东西的思路，而不是copy书上代码；<br>  提前找题去做<br>上课<br>  认真互动<br>课后复习<br>  总结<br>作业<br>  中午能不能写一些代码？</p>
<p>总结：<br>  bug总结：错题本<br>  项目总结；</p>
<h3 id="冷门小总结"><a href="#冷门小总结" class="headerlink" title="冷门小总结"></a>冷门小总结</h3><p>1.如何判断string是一个数可以是一个小数</p>
<pre><code>正则：
^-?\\d+(\\.\\d+)?$
 Pattern.compile(&quot;^-?\\d+(\\.\\d+)?$&quot;);
 Pattern.mathes(&quot;^-?\\d+(\\.\\d+)?$&quot;);
</code></pre><p>2.对于一些知识点的拓展<br>红黑树，广义平衡二叉树；<br>红黑树是每个节点都带有颜色属性的二叉查找树，颜色或红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求:</p>
<pre><code>性质1. 节点是红色或黑色。
性质2. 根节点是黑色。
性质3 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
性质4. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。
</code></pre><p>3.动态规划：这个东西有点意思，之和部分状态有关，并不是所有的状态<br><a href="https://blog.csdn.net/sinat_34022298/article/details/77653693" target="_blank" rel="external">背包问题</a></p>
<p>4.测试时间的问题<br><a href="https://www.cnblogs.com/jpfss/p/9674054.html" target="_blank" rel="external">测试时间</a></p>
<pre><code>long startTime = System.nanoTime() //纳秒
long startTime = System.currentTimeMillis(); //毫秒
long endTime = System.currentTimeMillis();
System.out.println(&quot;运行时间:&quot; + (endTime - startTime) + &quot;ms&quot;);
</code></pre><p>5.注意IDEA里的绿色波浪线，可能有问题；</p>

        </div>
        <div class="post-reply">
            
                <!-- 来必力City版安装代码 -->
                <div id="lv-container" data-id="city" data-uid="MTAyMC8yOTE4Ni81NzUz">
                    <script type="text/javascript">
                        (function(d, s) {
                            var j, e = d.getElementsByTagName(s)[0];

                            if (typeof LivereTower === 'function') { return; }

                            j = d.createElement(s);
                            j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
                            j.async = true;

                            e.parentNode.insertBefore(j, e);
                        })(document, 'script');
                    </script>
                    <noscript> 为正常使用来必力评论功能请激活JavaScript</noscript>
                </div>
                <!-- City版安装代码已完成 -->
            
            
        </div>
    </div>
</section>
<script>
    // 获取第一张图, 用以当封面背景图
    var img = document.querySelectorAll('img')[1]

    if (img) {
        var header_box = document.querySelector('#header_box')
        header_box.style.backgroundImage = 'url('+ img.src +')'
    }
</script>
      </div>
  </div>
  <style>
  #footer {
    min-height: 10vh;
    background: black;
    color: #fff;
  }

  #footer a {
    color: #e1e1e1;
  }
</style>
<footer id="footer" class="has-text-centered is-flex center">
  <div class="container has-padding">
    <div>
      <div>
        <!--请您保留作者署名, 主题制作来之不易-->
        主题来自 <a href="http://haojen.github.io/">Haojen Ma</a>
        <br>
        Copyright © 王邸 2019
        <!--
          Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        -->
      </div>
    </div>
  </div>
</footer>

<script src="/js/search_core.js"></script>
<script src="/js/script.js"></script>

</body>
</html>