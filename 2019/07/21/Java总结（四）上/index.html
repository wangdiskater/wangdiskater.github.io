<!DOCTYPE html>





<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.3.8">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">

<link rel="stylesheet" href="//fonts.proxy.ustclug.org/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="这周学习的是数据结构，主要还是学习代码的实现，结构的应用的实现等等。二叉排序树的增加和删除，还有一些递归操作用循环实现，最后讲了冒泡，插入，希尔，选择，快排，归并排序，以及他们的比较。星期一（7.15）：线性表顺序印象 非顺序印象栈:先进后出顺序印象 非顺序印象栈的应用：1.反转2.括号匹配3.浏览器history4.深度优先遍历(非递归的写法需要记录走过的结点)5.表达式求值首先先知道前缀表达式">
<meta property="og:type" content="article">
<meta property="og:title" content="Java总结（四）上">
<meta property="og:url" content="http://yoursite.com/2019/07/21/Java总结（四）上/index.html">
<meta property="og:site_name" content="路要坚持">
<meta property="og:description" content="这周学习的是数据结构，主要还是学习代码的实现，结构的应用的实现等等。二叉排序树的增加和删除，还有一些递归操作用循环实现，最后讲了冒泡，插入，希尔，选择，快排，归并排序，以及他们的比较。星期一（7.15）：线性表顺序印象 非顺序印象栈:先进后出顺序印象 非顺序印象栈的应用：1.反转2.括号匹配3.浏览器history4.深度优先遍历(非递归的写法需要记录走过的结点)5.表达式求值首先先知道前缀表达式">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-08-17T03:34:53.531Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java总结（四）上">
<meta name="twitter:description" content="这周学习的是数据结构，主要还是学习代码的实现，结构的应用的实现等等。二叉排序树的增加和删除，还有一些递归操作用循环实现，最后讲了冒泡，插入，希尔，选择，快排，归并排序，以及他们的比较。星期一（7.15）：线性表顺序印象 非顺序印象栈:先进后出顺序印象 非顺序印象栈的应用：1.反转2.括号匹配3.浏览器history4.深度优先遍历(非递归的写法需要记录走过的结点)5.表达式求值首先先知道前缀表达式">
  <link rel="canonical" href="http://yoursite.com/2019/07/21/Java总结（四）上/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Java总结（四）上 | 路要坚持</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">路要坚持</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/21/Java总结（四）上/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王邸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路要坚持">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">Java总结（四）上

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-07-21 23:27:33" itemprop="dateCreated datePublished" datetime="2019-07-21T23:27:33+08:00">2019-07-21</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-08-17 11:34:53" itemprop="dateModified" datetime="2019-08-17T11:34:53+08:00">2019-08-17</time>
              </span>
            
          

          
            <span id="/2019/07/21/Java总结（四）上/" class="post-meta-item leancloud_visitors" data-flag-title="Java总结（四）上" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
        
      
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/07/21/Java总结（四）上/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2019/07/21/Java总结（四）上/" itemprop="commentCount"></span></a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>这周学习的是数据结构，主要还是学习代码的实现，结构的应用的实现等等。二叉排序树的增加和删除，还有一些递归操作用循环实现，最后讲了冒泡，插入，希尔，选择，快排，归并排序，以及他们的比较。</p><h2 id="星期一（7-15）："><a href="#星期一（7-15）：" class="headerlink" title="星期一（7.15）："></a>星期一（7.15）：</h2><p>线性表<br>顺序印象 非顺序印象</p><p>栈:先进后出<br>顺序印象 非顺序印象<br>栈的应用：<br>1.反转<br>2.括号匹配<br>3.浏览器history<br>4.深度优先遍历(非递归的写法需要记录走过的结点)<br>5.表达式求值<br>首先先知道前缀表达式 中缀表达式 后缀表达式<br>前缀表达式：运算符放在前面 +1*23<br>中缀表达式：运算符放中间，就是我们人类熟知的写法 1+2*3<br>后缀表达式：运算符方后面123*+</p><a id="more"></a>


<p>默认就用后缀表达式进行计算<br>这里就有两个问题：<br>1.后缀表达式如何进行计算<br>  需要把操作数入栈<br>  a.遍历字符串<br>  b.遇到操作数入栈<br>  c.遇到操作符就进行计算。从栈中取出两个数进行计算，先出栈的放后面，后出栈的放前面。再把计算结果放回到栈中。<br>  例如：123*+</p>
<pre><code>1,2,3入栈
* :则3先出栈，2后出栈进行计算 2 * 3 = 6;
6入栈，栈中元素为1,6
- :6先出栈，然后1出栈。 1 + 6 = 7；
</code></pre><p>2.如何把中缀表达式转成后缀表达式<br>  需要把运算符入栈<br>  a.遍历字符串<br>  b.遇到数字就略过<br>  c.遇到操作符如下操作：<br>      栈中没有操作符：入栈<br>      栈中有操作符：比较操作符优先级<br>        1）栈中运算符优先级大于等于当前运算符，则栈中运算符出栈，然后再比较栈中运算符和当前运算符<br>        2）栈中运算符优先级小于当前运算符,就进行入栈操作<br>  d.遍历完字符串检查栈中是否还有运算符<br>      有运算符：全部出栈</p>
<p>  可以这么想栈底的运算符优先级是很低的，栈顶优先级很高，所以出栈时越靠近操作数的运算符优先级更高</p>
<p>那么问题来了如何直接计算一个表达式：<br>（两个栈）<br>一个栈放操作数，一个栈放操作符操作步骤如下：<br>  a.遍历字符串<br>  b.遇到操作数就进操作数栈<br>  c.遇到操作符就进行如下操作<br>    栈中没有操作符：入栈<br>    栈中有操作符：比较操作符优先级<br>        1）栈中运算符优先级大于等于当前运算符，则栈中运算符出栈,从操作数栈中出数进行计算，结果放回操作数栈<br>        然后再比较栈中运算符和当前运算符<br>        2）栈中运算符优先级小于当前运算符,就进行入栈操作</p>
<p>  d.遍历完字符串，判断运算符栈是否还有元素<br>  有元素：则依次出栈进行运算操作，直到运算符栈为空<br>具体实现:</p>
<pre><code>public class HomeWork2 {
    public static void main(String[] args) {
        String s1 = &quot;2+3*10-3&quot;;
        String s2 = &quot;((1+(2*3))+10)*10&quot;; //为什么匹配全角和半角括号都可以
        String a = computeNum(s2);
        System.out.println(a);
    }

    private static String computeNum(String s1) {
        String splitArr[] = s1.split(&quot;&quot;); //一开始获取的数组
        String strArrCache[] = new String[s1.length()]; //通过合并后的数组
        List&lt;String&gt; list = new ArrayList&lt;&gt;(); //使用集合代替数组

        String scache = &quot;&quot;;   //表示合并的值
        //int index = 0;        //表示合并后数组的下标
        MyStack numStack = new MyStack();
        MyStack operStack = new MyStack();

        //方法1分成数字数组和运算符数组，但是之后就找不到位置了
        //方法2先把数字放前面然后，判断找到运算符然后移动数组发现不行
        //方法3字符串拼接 可以但是感觉不够好

        // i表示split的指针j表示strArr的指针
        for (int i = 0; i &lt; splitArr.length; i++) {
            if(splitArr[i].matches(&quot;\\d&quot;) &amp;&amp; i != splitArr.length-1){ //非最后一位是数字
                scache += splitArr[i]; //缓存字符串
            } else if(splitArr[i].matches(&quot;\\d&quot;) &amp;&amp; i == splitArr.length-1){ //最后一位是数字
                scache += splitArr[i];
                list.add(scache);
//                strArrCache[index++] = scache;

            } else if(scache != &quot;&quot;){    //这一位是非数字如果上一位是数字的缓存，就先把数字入数组，然后再把当前的符号入数组
                list.add(scache);
                list.add(splitArr[i]);
//                strArrCache[index++] = scache;
//                strArrCache[index++] = splitArr[i];

                scache  = &quot;&quot;; //清零
            } else {   //其他情况，可能是第一个左括号，右括号后面的右括号等情况
                list.add(splitArr[i]);
//                strArrCache[index++] = splitArr[i];
            }
        }

        //获取最后的数组
//        String strArr[] = new String[index];
//        for (int i = 0; i &lt; strArr.length; i++) {
//            strArr[i] = strArrCache[i];
//            System.out.println(&quot;i= &quot;+ i +&quot;  &quot; + strArr[i]+&quot; &quot;);
//        }

        //遍历字符串
//        for (int i = 0; i &lt; strArr.length; i++) {
          for(ListIterator it = list.listIterator();it.hasNext();){
//            String value = strArr[i];
            String value = (String) it.next();

            //如果是数字就入运算符栈
            if(value.matches(&quot;^\\d+&quot;)){  //判断是一个数或者多位数
                numStack.push(value);
            }
            //左括号直接入操作数栈
            if(value.matches(&quot;\\(&quot;)){
                operStack.push(value);
            }

            //如果是运算符判断：
            // 栈空入站 ，
            // 栈不空 判断运算符优先级，1）栈中的优先级大则出栈，从数栈取数进行计算
            //然后重复上面操作，直到栈中的优先级小于当前运算符则入栈
            if(value.matches(&quot;\\-|\\+|\\*|\\/|\\)&quot;)){
                if(operStack.isEmpty()){
                    operStack.push(value);
                } else if(!value.equals(&quot;)&quot;)){
                    String top = operStack.peek();//获取栈顶进行比较

                    while(compareOper(top,value) &gt; 0){ //如果是栈顶元素优先级高
                        String oper = operStack.pop(); //运算符出栈；

                        double last = Double.valueOf(numStack.pop());
                        double first = Double.valueOf(numStack.pop());
                        String result = String.valueOf(getResult(first,last,oper));
                        numStack.push(result); //结果入栈

                        if(operStack.isEmpty()){
                            break; //跳出while 在外面运算符入栈不然会报错
                        } else {
                            top = operStack.peek(); //再比较优先级
                        }
                    }
                    operStack.push(value);
                }//else if
                else {  //说明是右括号 ，直接弹运算符
                    //while 判断括号多个数
                    while(!operStack.peek().equals(&quot;(&quot;)){
                        String oper = operStack.pop(); //运算符出栈；
                        double last = Double.valueOf(numStack.pop());
                        double first = Double.valueOf(numStack.pop());
                        String result = String.valueOf(getResult(first,last,oper));
                        numStack.push(result); //结果入栈
                    }
                    operStack.pop(); //左括号出栈；
                }
            }//if 是运算符
        }//for
        //最后再判断运算符栈是否还有元素在进行计算操作
        while(!operStack.isEmpty()) {
            String oper = operStack.pop(); //运算符出栈；
            double last = Double.valueOf(numStack.pop());
            double first = Double.valueOf(numStack.pop());
            String result = String.valueOf(getResult(first,last,oper));
            numStack.push(result); //结果入栈
        }
        return numStack.pop();
    }

    private static double getResult(double first, double last, String oper) {
        double result = 0;
        switch (oper){
            case &quot;+&quot;:
                result = first + last;
                break;
            case &quot;-&quot;:
                result = first - last;
                break;
            case &quot;*&quot;:
                result = first * last;
                break;
            case &quot;/&quot;:
                result = first / last;
                break;
        }
        return result;
    }

    private static int compareOper(String top, String value) {

        if(top.equals(&quot;*&quot;)|| top.equals(&quot;/&quot;)){          //如果里面的是乘除
            return 1;
        } else if(value.equals(&quot;*&quot;)|| value.equals(&quot;/&quot;)){  //里面不是乘除，外面是乘除
            return -1;
        } else if(top.equals(&quot;(&quot;)){   //如果栈顶是左括号，运算符就入栈；
            return -1;
        }
        return 1; //说明里面是加减外面也是加减，里面优先级高
    }
}
</code></pre><p>队列:先进先出<br>队列应用场景：<br>    a. 普通队列应用场景十分有限<br>    b. 阻塞队列(BlockingQueue)<br>        enque: 当队列满了，会阻塞，等待队列不满的时候，在执行操作，并返回。<br>        deque: 当队列为空，会阻塞，等待队列不空的时候，再出队列，并返回。<br>    c. 并发队列<br>        线程安全的队列。<br>    d. 缓存<br>    e. 广度优先遍历。<br>顺序印象 非顺序印象</p>
<h2 id="星期二（7-16）："><a href="#星期二（7-16）：" class="headerlink" title="星期二（7.16）："></a>星期二（7.16）：</h2><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>今天介绍了树，当然也是学过的，但是希望当人家问你什么是树的时候，你能说出点东西来；<br>树的定义：树(Tree)是n( n&gt;=0 )个结点的有限集合。n=0就是一颗空树。<br>在任意一颗非空树中：<br>  有且仅有一个特定的称为根(root)的节点<br>  当n&gt;1的时，其余节点可分为m( m&gt;0 )个互不相交的有限集T1，T2，…, Tm，其中每一个集合本身又是一棵树，并且称之为根的子树。<br>  互不相交的有限级其实也就是子树之间没有任何相连的关系</p>
<p>在树中，还有一些基本术语：<br>  <strong>树的结点</strong>：包含一个数据元素以及若干指向其子树的分支。节点拥有的子树的数目，称之为结点的度（degree）。<br>  <strong>叶子结点</strong>：度为0的节点称为叶子，或终端节点。度不为0的结点称为非终端结点或分支节点<br>  <strong>孩子结点、双亲结点和兄弟结点</strong>：节点的子树，称为该节点的孩子（child），相应的该节点称为孩子的双亲（parent）同一个双亲的孩子之间互称兄弟（sibling）<br>  <strong>祖先结点和子孙结点</strong>节点的祖先是从根到该节点所经分支上所有的节点。以某节点为根的子树中的任意一节点都称为该结点的子孙<br>  <strong>结点的层次（Level）</strong>从根开始定义，根为第一层，根的孩子为第二层。若某节点在第l层，则其子树的根就在l+1层<br>  <strong>结点的路径</strong>从节点ni 到 nk 的路径定义为节点 n1 n2 … nk (都不在同一层)的一个序列，使得对于 1 &lt;= i &lt; k，节点 ni 是 ni+1 的父亲。这条路径的长是为该路径上边的条数，即 k-1。从每一个节点到它自己有一条长为 0 的路径。注意，在一棵树中从根到每个节点恰好存在一条路径。<br>  <strong>深度</strong>对任意节点ni，ni的深度为从根到ni 的唯一路径的长。因此，根的深度为0。<br>  <strong>高度</strong>ni 的高度是从ni到一片树叶的最长路径的长（可能不是平衡树所以长的才算高度和深度）。因此，所有树叶的高都为0。一颗树的高等于它根的高。</p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>二叉树具有以下重要特性：<br>二叉树，在第i层至多有2^(i-1)个结点（主要是在理论上使用的比较多）<br>层次为k的二叉树至多有2^k-1个结点<br>对任何一颗二叉树T，如果其终端结点数为n0 ,度为2的结点数为n2，则n0 = n2 + 1</p>
<pre><code>n0+n1+n2 = n1+2*n2+1 =&gt; n0 = n2 + 1;
</code></pre><p>具有n个结点的完全二叉树，根节点的深度为log2(n)<br>如果对一颗有n个结点的完全二叉树的节点按层序编号，则对任意一结点，i从1开始<br>1)如果i=1，则结点i是二叉树的根，无双亲；如果i &gt; 1，则其双亲parent(i)的节点：i/2<br>2)如果2i &gt; n，则结点i无左孩子（结点i为叶子结点）；否则其左孩子lchild(i)是节点 2i。<br>3)如果2i+1 &gt; n，则结点i无右孩子，否则，其右孩子rchild(i)是结点2i+1。</p>
<h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><p>二叉树的顺序映像（完全二叉树）<br>用数组来存储元素，使用了连续的存储空间来存储。这里需要有一点进行说明。因为是连续的空间，用数组作为下标。所以下标是从0开始编号的。那么对于之前二叉树的父子结点的下标需要有修正的地方。这里主要是用在堆上，因为堆就是一个完全二叉树。<br>i从0开始<br>i的左孩子结点为： 2*i+1<br>i的右孩子结点为：2*i+2<br>结点i的父亲结点为 (i-1)/2<br>二叉树的非顺序映像<br>二叉树的非顺序映像，是以链表的形式，存储数据元素以及数据元素之间的关系。但是由于数据元素的关系变得更加复杂，因此，链表结点的结构，与线性表中链表的结点有有所不同。因为线性表的是一对一的关系。而树中是一对多的关系；</p>
<h2 id="星期三（7-17）："><a href="#星期三（7-17）：" class="headerlink" title="星期三（7.17）："></a>星期三（7.17）：</h2><h3 id="二叉搜索树（二叉排序树BST）："><a href="#二叉搜索树（二叉排序树BST）：" class="headerlink" title="二叉搜索树（二叉排序树BST）："></a>二叉搜索树（二叉排序树BST）：</h3><p>  左子树结点小于根节点的值<br>  右子树结点大于根节点的值<br>  左右子树同时也是二叉搜索树</p>
<h3 id="二叉搜索树的构建"><a href="#二叉搜索树的构建" class="headerlink" title="二叉搜索树的构建"></a>二叉搜索树的构建</h3><p>  我差点忘记了这一部分的内容，这一部分是非常重要的，对于理解递归和二叉树都非常重要。BST最主要的功能当然是增删改查。以非顺序印象存储值<br>  思路：思路都是类似的，首先判断是否有根节点，然后判断一下根节点和你需要查找，添加的结点的大小，以确定去左边添加还是去右边添加，不讨论相等的情况；删除一个结点时，首先也是同样的思路去找到那个结点，然后在判断：1.是度为2的结点 2.是度为1的结点 3.是叶子结点 ，然后把第一种情况转换为第二种第三种情况；</p>
<pre><code>public class BinarySearchTree {
</code></pre><p>属性</p>
<pre><code>//属性
TreeNode root;  //表示根节点
int size;
static class TreeNode {
    TreeNode leftChild; //指向左孩子
    char val;
    TreeNode rightChild;//指向右孩子
    public TreeNode(char val) {
        this.val = val;
    }
}
</code></pre><p>构造方法</p>
<pre><code>//构造方法
public BinarySearchTree(){
}
</code></pre><p>方法：<br>添加结点：迭代的方法和循环的方法</p>
<pre><code>/**
 * 树中添加结点
 * @param c 添加的值
 * @return
 * 判断：
 *   1.空树newNode 给 root
 *   2.需要两个指针分别指向要添加的地方和添加地方的父节点
 *   最后把父节点和要添加的结点链接，需要在判断一次是在左边添加还是在右边添加
 *   3,如果遇到重复值return false不添加
 */
//使用循环
public boolean add(char c) {
    //添加的是根节点
    if(root == null){
       root = new TreeNode(c);
       return true;
    }
    TreeNode pre = null;
    TreeNode node = root;
    while(node != null) {
        int i = c - node.val; //和父节点比较谁大
        if(i &gt; 0) {    //加入的元素比父节点大
            pre = node;
            node = node.rightChild;
        } else if(i &lt; 0){ //加入的元素比父节点小
            pre = node;
            node = node.leftChild;
        } else {
            return false; //找到一样的拉闸
        }
    }
    //再判断一次pre到底指向的左子树还是右子树
    if(pre.val &gt; c) {
        size++;
        pre.leftChild = new TreeNode(c);
    } else if (pre.val &lt; c){
        size++;
        pre.rightChild = new TreeNode(c);
    } else {  //相同则取消
        return false;
    }
    return true;
}
</code></pre><p>//使用迭代</p>
<pre><code>/**
 * 递归添加元素
 * @param c
 * @return
 * 首先他自己不能递归，需要分成小的部分在哪个节点后面添加；
 * 而不是和整棵树进行比较
 * 所以需要再分一个小函数表示在哪个节点添加的元素
 * add_recursion（TreeNode node, char c）
 */
public boolean add_recursion(char c){
    int temp = size;
    root = add_recursion(root,c);
    return size &gt; temp;
}

/**
 * 这个小函数就是添加元素
 * @param node
 * @param c
 * @return
 * 三种情况：
 *   a.如果这个结点是空的，找到了要添加的位置；
 *   判断父节点和c哪个那
 *     b.父节点大：在node.left添加c
 *     c.c大：在node.right添加c
 */
private TreeNode add_recursion(TreeNode node, char c) {
    if(node == null) {
        size++;  //添加结点
        return new TreeNode(c);
    }
    int cmp = c - node.val;
    if(cmp &gt; 0) { //如果是c大
        //这里要连上，不然新加的不知道连哪里
        node.rightChild = add_recursion(node.rightChild,c);
    } else if(cmp &lt; 0) {
        node.leftChild =  add_recursion(node.leftChild,c);
    }
    //如果有相同的就不加
    return node;
}
</code></pre><p>删除结点</p>
<pre><code>/**
 * 循环实现删除
 * @param c
 * @return
 * 先判断树是否为空
 * 非空就继续
 * 找到那个要删除的结点，同样要保存父节点，有三种情况：
 * 1.该结点是度为2：把他和他前驱的值交换然后去删掉他前驱的，
 * 删前驱就变成下面两种情况
 *   2.度为1,删掉把父节点指向删掉结点的子节点
 *   3.度为0,直接删掉以除后患
 * **注意**
 * 这里不仅需要两个指针来表示要删除的结点和删除结点的父亲节点
 * 而且需要两个结点去表示删除结点的前驱结点和前驱结点的父亲的结点。
 * 然后才能把要删除的结点转化成删除他的前驱结点的过程；
 *
 */
boolean remove(char c){
    //空节点异常
    if(size == 0) {
        throw new EmptyTreeException();
    }
    //说明有结点
    TreeNode parent = null;//要删除结点的父节点
    TreeNode node = root; //要删除的结点
    //先找到那个要删除的结点
    while(node != null &amp;&amp; node.val != c) {
        int cmp = c - node.val;
        if(cmp &gt; 0){  //删除的数比父节点大
            parent = node;
            node = node.rightChild;
        } else if(cmp &lt; 0) {
            parent = node;
            node = node.leftChild;
        }
    }
    if(node == null) return false; //表示没有找到

    //找到要删除的结点
    //删除的是两个结点
    if(node.leftChild != null &amp;&amp; node.rightChild != null) {
        //去找左边的前驱交换值
        // TreeNode tn =getMaxNode(node.leftChild); 因为要获取父节点不能直接拿最大结点

        TreeNode ppNode = node; //删除结点前驱的父节点
        TreeNode pNode = node.leftChild;//删除结点的前驱
        while(pNode.rightChild != null){
            ppNode = pNode;
            pNode = pNode.rightChild;
        }
        把删除转化成删除前驱结点的过程
        node.val = pNode.val;
        parent = ppNode;
        node = pNode;
    }

    //删除的是度为1 或者 叶节点 或者删除结点的子节点
    TreeNode child = node.leftChild != null ? node.leftChild : node.rightChild;
    if(parent == null) { //要删除的根节点，parent没有赋值。可能度为1可能度为0
        root = child;
    }
    if(parent.leftChild == node) {
        parent.leftChild = child;
    }
    if(parent.rightChild == node) {
        parent.rightChild = child;
    }
    size--;
    return true;
}
</code></pre><p>//递归删除</p>
<pre><code>/**
 * 递归实现删除一个结点
 * @param c
 * @return
 * 当然也需要一个子方法来判断删除的结点
 */
boolean remove_recursion(char c){
    int tem = size;
    root = remove_recursion(root,c);
    return tem &gt; size;
}

/**
 * 需要要删除的子方法，为了判断node是否是要删除的
 * @param node
 * @param c
 * @return
 * 判断：
 *  一样的三种情况
 */
private TreeNode remove_recursion(TreeNode node, char c) {
    if(node == null) {
        return null;
    }
    int cmp = c - node.val;
    if(cmp &gt; 0) {
        node.rightChild = remove_recursion(node.rightChild,c);
    } else if(cmp &lt; 0) {
        node.leftChild = remove_recursion(node.leftChild,c);
    } else {
        //说明找到了又是三种判断；
        if(node.leftChild != null &amp;&amp; node.rightChild != null){
            //获取最大值；
            TreeNode maxOfLeft = getMaxNode(node.leftChild);
            node.val = maxOfLeft.val;
            node.leftChild = remove_recursion(node.leftChild,maxOfLeft.val);//改成对前驱删除

        } else if(node.leftChild == null &amp;&amp; node.rightChild == null){
            //叶节点
            size--;
            return null;
        } else {
            //度为1的结点
            size--;
            return node.leftChild != null ? node.leftChild : node.rightChild;
        }
    }
    return node;
}
</code></pre><p>获取树的最大最小值</p>
<pre><code>/**
 * 获取最大最小值
 * @return
 */
public char max(){
    return getMaxNode(root).val;
}
public char min(){
    return getMinNode(root).val;
}

/**
 * 获取最大值的结点就是当前结点最右边的子节点结点
 * @param tn
 */
private TreeNode getMaxNode(TreeNode tn) {
    if(tn.rightChild == null) return tn;
    return getMaxNode(tn.rightChild);
}
private TreeNode getMinNode(TreeNode tn) {
    if(tn.leftChild == null) return tn;
    return getMinNode(tn.leftChild);
}
</code></pre><p>判断是否存在</p>
<pre><code>/**
 * 判断是否有值；
 * @param c
 * @return
 */
boolean contains(char c){
    TreeNode node = root;
    if(node == null) return false;
    while(node != null) {
        int cmp = c - node.val;
        if(cmp &gt; 0) {
            node = node.rightChild;
        }else if(cmp &lt; 0) {
            node = node.leftChild;
        } else {
            return true;
        }
    }
    return false;
}
</code></pre><p>//递归判断是否存在</p>
<pre><code>/**
 * 迭代寻找是否存在
 * @param c
 * @return
 * 同样也需要一个子函数来判断root是否和c相同
 */
boolean contains_recursion(char c) {
    return contains_recursion(root,c);
}
private boolean contains_recursion(TreeNode node, char c) {
  //找不到
    if(node == null) {
        return false;
    }
    int cmp = c - node.val;
    if(cmp &gt; 0) {
        return contains_recursion(node.rightChild,c);
    } else if(cmp &lt; 0) {
        return contains_recursion(node.leftChild,c);
    } else {
        return true;
    }
}
</code></pre><p>求树的层次</p>
<pre><code>/**
 * 使用队列进行层序遍历
 * @return
 * 就是层序遍历把元素放进队列，这里需要注意的是需要去记录每一层的元素有多少个；
 */
public int depth() {
    if(root == null) return 0;
    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
    queue.add(root);//先把根节点入栈
    int deep = 0;
    while(!queue.isEmpty()){
      deep++;
      int length = queue.size();//获取每一层有几个元素入队
      for (int i = 0; i &lt; length; i++) {
          TreeNode node = queue.remove();
          if(node.leftChild != null) {
              queue.add(node.leftChild);
          }
          if(node.rightChild != null) {
              queue.add(node.rightChild);
          }
      }
    }
    return deep;
}
</code></pre><p>//求树高度</p>
<pre><code>/**
 * 递归求深度，后序遍历然后左右结点较高的+1；
 * @return
 */
public int depth_recursion(TreeNode node){
    if(node == null) {
        return 0;
    }
    int left = depth_recursion(node.leftChild);
    int right = depth_recursion(node.rightChild);
    return left &gt; right ? left+1 : right+1;
}
</code></pre><p>先序遍历：两种方法</p>
<pre><code>/**
 * 先序遍历递归
 * @param root
 */
void preOrder_recurion(TreeNode root){
    if(root == null) {
        return;
    }

    System.out.print(root.val + &quot; &quot;);
    if(root.leftChild != null) {
        preOrder(root.leftChild);
    }
    if(root.rightChild != null) {
        preOrder(root.rightChild);
    }
}
</code></pre><p>//非递归先序：<br>思路：用栈，右子树先进栈，后出栈。</p>
<pre><code>/**
 * 先序遍历使用非递归的方法：使用栈
 * 先把根节点入栈，然后判断栈是否为空，出栈。先把右子树入栈，然后再把左子树入栈。因为左子树要先出来，所以要先把右子树入栈后出来；
 * @param root
 */
 List&lt;Character&gt; PreOrder(TreeNode root) {
  List&lt;Character&gt; list = new ArrayList&lt;&gt;();
  if (root == null) return list; //最好是直接返回list以防调用空指针异常
  Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();
  stack.push(root);
  while (!stack.isEmpty()) {
      TreeNode node = stack.pop();
      list.add(node.val);
      if (node.right != null) {
          stack.push(node.right);
      }
      if (node.left != null) {
          stack.push(node.left);
      }
  }
  return list;
 }
</code></pre><p>中序遍历：三种方法</p>
<pre><code>/**
 * 中序迭代
 * @param root
 */
void inOrder_recursion(TreeNode root){
    if(root == null) {
        return;
    }
    if(root.leftChild != null) {
        inOrder(root.leftChild);
    }
    System.out.print(root.val + &quot; &quot;);
    if(root.rightChild != null) {
        inOrder(root.rightChild);
    }
}
</code></pre><p>//中序遍历非递归</p>
<pre><code>/**
 * 中序循环1：模拟栈的实现的过程使用循环：
    a.先根节点入栈判断栈是否为空，
    b.左子树全部入栈
    c.然后出栈，就是第一个元素然后再循环
 * @param root
 */
public List&lt;Character&gt; inOrder() {
  List&lt;Character&gt; list = new ArrayList&lt;&gt;();
  Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();

  if(root == null) return;
  TreeNode curr = root;
  while(curr != null &amp;&amp; !list.isEmpty()){
    //左边的的结点全部进栈
    while(curr!=null) {
      stack.push(curr);
      curr = curr.left;
    }
    //这时栈顶就是第一个结点
    curr = stack.pop();
    list.add(curr);//保存下来
    curr = curr.right;
  }
  return list;
}
</code></pre><p>//中序遍历非遍历2</p>
<pre><code>/**
 * 中序遍历循环2:
  Morris 遍历 不用栈(线索二叉树，利用左前驱右后继) 一个指针代替一个栈
  就是把根节点的前驱结点连接到根节点。在中序遍历过程中：每一个根节点都应该有前驱结点，如果前驱结点遍历过了，下一个遍历的当然就是根节点；

  1.curr = root;
  2.while(curr != null) {  //去找第一个结点
      if(curr.leftChild == null) {  //如果找到了第一个节点
          list.add(curr.val);
          curr = curr.rightChild;   //去第一个结点右边找第二个结点 或者会链接回到curr
      }
      else
          找到左子树的最大节maxNode,就是他的前驱，然后把前驱连接给他
          getMaxNode().rightChild = curr;
          curr = curr.leftChild;
  }
 * @param root
 */
  public List&lt;Character&gt; inOrder3() {
    TreeNode curr = root;
    List&lt;Character&gt; list = new ArrayList();
    if(root == null) return list;

    while(curr != null) {
      //找到第一个结点
      if(curr.leftChild ==null){
        list.add(curr.val);
        curr = curr.rightChild;
      } else {
        //当没有找到第一个结点时，找他的前驱并把前驱连接到这个结点上,为了保证左子树全部遍历完了再遍历curr结点
        TreeNode max = curr.leftChild;
        while(max.rightChild != null &amp;&amp; max.rightChild != curr) { //去找最大的结点,而且确认没有连接到curr上
          max = max.rightChild;
        }
        if(max.rightChild == null) { //确认没有连接
          max.right = curr;
          curr = curr.leftChild;//可以去左子树里面连接了，子树的前驱肯定和根节点的前驱不同
        }

        if(max.rightChild == curr) { //说明左边都遍历过了到curr结点遍历了
          list.add(curr.val);
          max.rightChild == null; //还原
          curr = curr.rightChild;
        }
      }
    }
    return list;
  }
</code></pre><p>后序遍历：两种方法</p>
<pre><code>/**
 * 后序迭代
 * @param root
 */
void postOrder_recursion(TreeNode root){
    if(root == null) {
        return;
    }
    if(root.leftChild != null) {
        postOrder(root.leftChild);
    }
    if(root.rightChild != null) {
        postOrder(root.rightChild);
    }
    System.out.print(root.val + &quot; &quot;);
}
</code></pre><p>//后序非递归</p>
<pre><code>/**
 * 后序非迭代：使用双端队列，入栈的时候就是正常的先栈顶出栈，左子树入栈，然后右子树入栈。进保存的队列时候可以头插法，最先加入的元素就会出现在最后，就相当于后序遍历；
 * @param root
 */
public List&lt;Character&gt; postOrder(){
    LinkedList&lt;Character&gt; list = new LinkedList();
    if(root == null) return list;
    Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();
    stack.push(root);
    while(!stack.isEmpty()) {
        TreeNode node= stack.pop();
        //左子树先进去后出来
        if(node.leftChild != null) {
            stack.push(node.leftChild);
        }
        if(node.rightChild != null) {
            stack.push(node.rightChild);
        }
        list.addFirst(node.val);//头插法
    }
    return list;
}
</code></pre><p>层序遍历</p>
<pre><code>/**
 * 层序；
 */
void levelOrder(TreeNode root){
    if(root == null) {
        return;
    }
    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
    queue.add(root);
    while(!queue.isEmpty()) {
        TreeNode node = queue.remove();
        System.out.print(node.val+&quot; &quot;);
        if(node.leftChild != null){
            queue.add(node.leftChild);
        }
        if(node.rightChild != null) {
            queue.add(node.rightChild);
        }
    }
}
</code></pre><p><strong>注意：这里没有调整二叉树成为一个平衡的二叉树，只是简单的讨论了一下到底应该怎么增删改查；</strong></p>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>前序，中序，后序，层序<br>顾名思义：<br>前序遍历：先遍历根节点，然后遍历左子树然后遍历右子树<br>中序遍历：有左子树先遍历左子树，然后遍历根节点最后遍历有节点<br>后序遍历：先遍历左子树，然后遍历右子树最后遍历根节点；<br>层序遍历：一层一层的遍历，从根节点进行遍历</p>
<h3 id="构建二叉树"><a href="#构建二叉树" class="headerlink" title="构建二叉树"></a>构建二叉树</h3><p>如何构建二叉树？<br>1）前序和中序构建二叉树（可以）<br>2）中序和后序构建二叉树（可以）<br>3）前序和后序构建二叉树（不可以）<br>问题1：为什么前序和后序不能构建唯一的二叉树？<br>首先需要了解构建二叉树的原理：<br>这也是一个遍历的过程，首先你要找到根节点。然后分出来根节点的左子树和右子树是什么<br>然后分别在左子树和右子树在去找他们分别的根节点；一层一层的下去；<br>但是只知道前序和后序是不能去判断哪个节点是根节点。</p>
<p>问题2：层序遍历能否去构建二叉树？<br>答:中序和层序可以构建唯一二叉树，而和前序，后序遍历不能得到唯一的二叉树。<br>理由和上面一样，每次建树操作都要区分出左子树和右子树的结点有哪些。只有层序和中序遍历可以得到，而和其他两种得不到唯一的左子树和右子树；<br>层序和中序构建二叉树的代码如下：</p>
<pre><code>public class CreateTree {
    public static void main(String[] args) {
        String[] level = &quot;ABC&quot;.split(&quot;&quot;);
        String[] in = &quot;BAC&quot;.split(&quot;&quot;);
        int root = 0; //记录根节点下标

        TreeNode head = CreateBinaryTreeByLevelOrderInOrder(level,0,level.length-1,in,0,in.length-1,root);
        System.out.println(head.val);
        InOrder(head);
    }
    public static TreeNode CreateBinaryTreeByLevelOrderInOrder(String[] level,int s1, int e1, String[] in, int s2, int e2,int root){
        boolean isFindRoot =  false;
        boolean isFindLTree = false;
        boolean isFindRTree = false;
        TreeNode node = new TreeNode();
        //遍历字符串
        for (int i = s1; i &lt;=e1; i++) {
            for (int j  = s2; j &lt;= e2; j++) {
                //构建根节点
                if(!isFindRoot &amp;&amp; level[s1].equals(in[j])){
                    root = j;
                    isFindRoot = true;
                    node.val = level[s1];
                    node.leftChild = null;
                    node.rightChild = null;
                    break;
                }
                //在层序中查找中序中左子树的根节点
                if(!isFindLTree &amp;&amp; level[i].equals(in[j]) &amp;&amp; j &lt; root) {
                    node.leftChild = CreateBinaryTreeByLevelOrderInOrder(level, i, e1, in, s2, root - 1, root);
                    isFindLTree = true;
                    break;
                }
                //在层序中查找中序中右子树的根节点
                if(!isFindRTree &amp;&amp; level[i].equals( in[j]) &amp;&amp; j &gt; root) {
                    node.rightChild = CreateBinaryTreeByLevelOrderInOrder(level, i, e1, in, root + 1, e2, root);
                    isFindRTree = true;
                    break;
                }
                //建立完成
                if(isFindRoot &amp;&amp; isFindLTree &amp;&amp; isFindRTree) {
                    break;
                }
            }
        }
        return node;
    }

    private static class TreeNode {
        TreeNode leftChild;
        String val;
        TreeNode rightChild;

        public TreeNode(){

        }
        public TreeNode(String val) {
            this.val = val;
        }
    }
}
</code></pre><p><a href="https://blog.csdn.net/kfyty725/article/details/82808097" target="_blank" rel="external">参考</a></p>
<h2 id="星期四-7-18-："><a href="#星期四-7-18-：" class="headerlink" title="星期四(7.18)："></a>星期四(7.18)：</h2><p>排序:<br>主要是要知道怎么去写，注意一些边界条件。思路都不同很有特点<br>冒泡 简单选择 插入排序 希尔排序 归并排序 快排</p>
<h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1 冒泡排序"></a>1 冒泡排序</h3><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
<p>  1.1 算法描述</p>
<pre><code>比较相邻的元素。如果第一个比第二个大，就交换它们两个；
对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
针对所有的元素重复以上的步骤，除了最后一个；
重复步骤1~3，直到排序完成。每次排序完，最大的数都会沉底到达他最终的位置，
</code></pre><p>  1.2 算法分析</p>
<pre><code>时间复杂度：T(n) = O(n^2)   最好情况O(n)  最坏情况O（n^2）
空间复杂度：O(1)
稳定性：稳定
</code></pre><p>  1.3实现：<br>  需要使用两层循环:<br>  外层循环的边界调节是i包含在：[0，arr.length-2]因为最后一个数不需要在和他后面的比，他前面是有序的他一定是有序的<br>  内层循环需要比较相邻两个元素他的边界j包含[i,arr.length-2-i];表示是是从i开始和后一个数进行比较当然最后一个数没有后一个数，所以只循环到倒数第二个数即可</p>
<pre><code>public static void BubbleSort(int[] arr) {
  for(int i = 0; i &lt; arr.length-2; i++) {
    boolean isOrder = true;//表示一个标志是否需要排序
    for(int j = i; j &lt; arr.length-2-i; j++) {
      if(arr[j] &gt; arr[j+1]) {
        swap(arr,j,j+1)
        isOrder = false;
      }
    }
    if(isOrder == true) {
      return ; //排序完成
    }
  }
}
</code></pre><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><p>  1.1 算法描述<br>    表现最稳定的排序算法之一，因为无论什么数据进去都是O(n^2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。<br>    它的工作原理：首先在未排序序列中找到最小（大）元素，交换到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后交换已排序序列的末尾。以此类推，直到所有元素均排序完毕。<br>  1.2 算法分析<br>    时间复杂度：平均情况 O(n2)  最好情况 O(n^2)  最坏情况 O(n^2)<br>    空间复杂度： O(1)<br>    稳定性：不稳定<br>  1.3实现：</p>
<pre><code>就写核心的两个for循环
for(int i = 0; i &lt; arr.length-1; i++) {
  int minIndex = i;//要去找无序序列当中的最小值
  for(int j = i + 1; j &lt; arr.length; j++) {  //寻找当前最小值的下标
    if(arr[minIndex] &gt; arr[j]) {
      minIndex = j;
    }
  }
  swap(arr,i,minIndex); //i 和 minIndex交换
}
</code></pre><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，<strong>因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位</strong>，为最新元素提供插入空间。<br>  1.1 算法描述</p>
<pre><code>1从第一个元素开始，该元素可以认为已经被排序；
2取出下一个元素，在已经排序的元素序列中从后向前扫描；
3如果该元素（已排序）大于新元素，将该元素移到下一位置；
4重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
5将新元素插入到该位置后；
</code></pre><p>  1.2 算法分析</p>
<pre><code>时间复杂度：平均情况 O(n2)  最好情况 O(n^2)  最坏情况 O(n^2)
空间复杂度： O(1)
稳定性：不稳定,可以稳定
</code></pre><p>  1.3实现：<br>    就写两层循环，第一层遍历数组，第二层j开始去前面的有序的序列去找无序序列第一个元素应该放哪里</p>
<pre><code>for(int i = 1; i &lt; arr.length-1; i++) { //i指向的是无序的第一个元素
  int j;
  int value = arr[i];
  for(j = i-1; j &gt;=0 &amp;&amp; arr[j] &gt; value; j--){ //找到value能插入的地方 只有&gt; 为了稳定
    arr[j+1] = arr[j];//移动
  }
  arr[j+1] = value;
}
</code></pre><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>  1.1 算法描述<br>在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2…1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。<br>先将整个待排序的记录序列分割成为若干子序列分别进行<strong>直接插入排序</strong>，具体算法描述：</p>
<pre><code>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；
按增量序列个数k，对序列进行k 趟排序；
每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列
，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理
，表长度即为整个序列的长度。
</code></pre><p>  1.2 算法分析</p>
<pre><code>时间复杂度：O(nlogn)
空间复杂度：O(1)
稳定性：不稳定
</code></pre><p>  1.3实现：三层循环，一层确定gap 两层直接插入排序</p>
<pre><code>int gap = arr.length/2;
while(gap != 0) {
  for(int i = gap; i &lt; arr.length; i++) {
    int value = arr[gap];
    int j;
    for(j = i - gap; j &gt;=0 &amp;&amp; arr[j]&gt;value; j=j-gap){
      arr[j+gap] = arr[j];
    }
    arr[j+gap] = value;
  }
  gap = gap/2;
}
</code></pre><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>  1.1 算法描述</p>
<pre><code>把长度为n的输入序列分成两个长度为n/2的子序列；
对这两个子序列分别采用归并排序；
将两个排序好的子序列合并成一个最终的排序序列。
</code></pre><p>  1.2 算法分析</p>
<pre><code>最佳情况：T(n) = O(nlogn)
空间复杂度： O(n)
稳定性： 稳定
</code></pre><p>  1.3实现：</p>
<pre><code>public static void sort(int[] arr) {
    if(arr ==null || arr.length &lt;=1) return;
    mergeSort(arr,0,arr.length-1);
}
private static void mergeSort(int[] arr, int low, int high) {
    if(low &gt;= high) return ;
    int mid = low + ((high - low)&gt;&gt;1);
    //对左边进行排序
    mergeSort(arr,low,mid);
</code></pre><p>//        右边排序<br>        mergeSort(arr,mid+1,high);<br>        //合并两个有序数组；<br>        merge(arr,low,mid,high);<br>    }</p>
<pre><code>private static void merge(int[] arr, int low, int mid, int high) {
    //需要额外的内存空间，创建一个数组；
    int left = low;
    int right = mid+1;
    int[] temp = new int[high-low+1];
    int i = 0;
    //左右两个数组都有元素
    while(left &lt;= mid &amp;&amp; right &lt;= high) {
        if(arr[left] &lt;= arr[right]){  // =需要为了稳定性 相同左边先进
            temp[i++] = arr[left++];
        } else {

            temp[i++] = arr[right++];
            count  = count + (mid - left + 1); //可以获取逆序度

        }
    }
    //左边数组还有元素
    while(left &lt;= mid) temp[i++] = arr[left++];
    //右边数组还有元素
    while(right &lt;= high) temp[i++] = arr[right++];

    //把temp数组的元素重新赋值给对应的区间
    for(int j = 0; j &lt; temp.length; j++){
        arr[low+j] = temp[j];
    }
}
</code></pre><h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><p>  1.1 算法描述<br>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>
<pre><code>从数列中挑出一个元素，称为 “基准”（pivot）；
重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。
</code></pre><p>  1.2 算法分析</p>
<pre><code>最佳情况：平均情况：T(n) = O(nlogn)
空间复杂度： O(logn) （栈占用的空间）
稳定性： 不稳定
</code></pre><p>  1.3实现：</p>
<pre><code>private static void quickSort(int[] arr, int low, int high) {
  int left = low;
  int right = hight;
  int pivot = arr[low]; //以第一个元素为轴值
  while(left &lt; right) {
    while(left &lt; right &amp;&amp; pivot &lt;= arr[right]) right--; //必须要写等号不然有可能死循环，这样
    arr[left] = arr[right];;
    while(left &lt; right &amp;&amp; pivot &gt;= arr[left]) left++;
    arr[right] = left;
  }
  arr[left] = pivot;
  //分别对左边和右边进行快排
  quickSort(arr,low,left-1);
  //右边进行排序
  quickSort(arr,left+1,high);
}
</code></pre>
    </div>

    
    
    
        
      

      <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2019/07/14/Java总结（三）下/" rel="next" title="Java总结（三）下">
                  <i class="fa fa-chevron-left"></i> Java总结（三）下
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2019/07/21/Java总结（四）下/" rel="prev" title="Java总结（四）下">
                  Java总结（四）下 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          
    
    <div class="comments" id="comments"></div>
  

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#星期一（7-15）："><span class="nav-number">1.</span> <span class="nav-text">星期一（7.15）：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#星期二（7-16）："><span class="nav-number">2.</span> <span class="nav-text">星期二（7.16）：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#树"><span class="nav-number">2.1.</span> <span class="nav-text">树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉树"><span class="nav-number">2.2.</span> <span class="nav-text">二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉树的存储结构"><span class="nav-number">2.3.</span> <span class="nav-text">二叉树的存储结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#星期三（7-17）："><span class="nav-number">3.</span> <span class="nav-text">星期三（7.17）：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉搜索树（二叉排序树BST）："><span class="nav-number">3.1.</span> <span class="nav-text">二叉搜索树（二叉排序树BST）：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉搜索树的构建"><span class="nav-number">3.2.</span> <span class="nav-text">二叉搜索树的构建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉树的遍历"><span class="nav-number">3.3.</span> <span class="nav-text">二叉树的遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构建二叉树"><span class="nav-number">3.4.</span> <span class="nav-text">构建二叉树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#星期四-7-18-："><span class="nav-number">4.</span> <span class="nav-text">星期四(7.18)：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-冒泡排序"><span class="nav-number">4.1.</span> <span class="nav-text">1 冒泡排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简单选择排序"><span class="nav-number">4.2.</span> <span class="nav-text">简单选择排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#直接插入排序"><span class="nav-number">4.3.</span> <span class="nav-text">直接插入排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#希尔排序"><span class="nav-number">4.4.</span> <span class="nav-text">希尔排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#归并排序"><span class="nav-number">4.5.</span> <span class="nav-text">归并排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#快排"><span class="nav-number">4.6.</span> <span class="nav-text">快排</span></a></li></ol></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/head.jpeg"
      alt="王邸">
  <p class="site-author-name" itemprop="name">王邸</p>
  <div class="site-description" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span>
        
      </div>
    
  </nav>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王邸</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.3.8</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.4.0</div>

        












        
      </div>
    </footer>
  </div>

  


  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/pisces.js?v=7.4.0"></script>

<script src="/js/next-boot.js?v=7.4.0"></script>



  





















  

  

  


<script>
NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'Fn4BuvoixOxjJAhR79TvaD5M-gzGzoHsz',
    appKey: '1uspTrSwPqkmSBSUr948WqxE',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: true,
    lang: '' || 'zh-cn',
    path: location.pathname
  });
}, window.Valine);
</script>

</body>
</html>
