<!DOCTYPE html>
<html class="full-height">
<head>
  <meta charset="utf-8">
  <link rel="stylesheet" href="//cdn.bootcss.com/bulma/0.4.1/css/bulma.min.css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  
  <title>Java总结（四）上 | 路要坚持</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="这周学习的是数据结构，之前学习过。所以主要还是学习代码的实现；但是上课很多东西都还是很重要的。主要是数据结构的代码的实现，结构的应用的实现等等。一些还是有点难度的：二叉排序树的增加和删除；还有一些递归操作用循环实现。 星期一（7.15）：线性表顺序印象 非顺序印象 栈:先进后出顺序印象 非顺序印象栈的应用：1.反转2.括号匹配3.浏览器history4.深度优先遍历(非递归的写法需要记录走过的结点">
<meta property="og:type" content="article">
<meta property="og:title" content="Java总结（四）上">
<meta property="og:url" content="http://yoursite.com/2019/07/21/Java总结（四）上/index.html">
<meta property="og:site_name" content="路要坚持">
<meta property="og:description" content="这周学习的是数据结构，之前学习过。所以主要还是学习代码的实现；但是上课很多东西都还是很重要的。主要是数据结构的代码的实现，结构的应用的实现等等。一些还是有点难度的：二叉排序树的增加和删除；还有一些递归操作用循环实现。 星期一（7.15）：线性表顺序印象 非顺序印象 栈:先进后出顺序印象 非顺序印象栈的应用：1.反转2.括号匹配3.浏览器history4.深度优先遍历(非递归的写法需要记录走过的结点">
<meta property="og:updated_time" content="2019-07-21T15:28:35.659Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java总结（四）上">
<meta name="twitter:description" content="这周学习的是数据结构，之前学习过。所以主要还是学习代码的实现；但是上课很多东西都还是很重要的。主要是数据结构的代码的实现，结构的应用的实现等等。一些还是有点难度的：二叉排序树的增加和删除；还有一些递归操作用循环实现。 星期一（7.15）：线性表顺序印象 非顺序印象 栈:先进后出顺序印象 非顺序印象栈的应用：1.反转2.括号匹配3.浏览器history4.深度优先遍历(非递归的写法需要记录走过的结点">
  
    <link rel="alternate" href="/" title="路要坚持" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/common.css">
<link rel="stylesheet" href="/css/nav.css">
<link rel="stylesheet" href="/css/layout.css">
  

</head>

<body>
  <header id="navbar" class="overflow-hidden">
  <div class="container">
    <nav class="nav">
         <div class="nav-left">
            <a href="/" class="nav-item" style="font-size: 20px;">
              <span class="logo">王邸</span>'s Blog
            </a>
         </div>
        <div class="nav-center is-hidden position-relative" id="search_container">
            <div class="nav-item full-width full-height">
                <i class="fa fa-search has-padding" aria-hidden="true"></i>
                <input type="text" id="search_input" class="search-input full-height full-width" placeholder="Search post" autofocus>
                <i id="close_search" class="fa fa-times" aria-hidden="true"></i>
            </div>
            <div id="search_result"></div>
        </div>
        <div class="nav-right nav-menu">
            <a class="nav-item" id="search">
                <i class="fa fa-search" aria-hidden="true"></i>
            </a>
            
            <a class="nav-item" href="/">
                Home
            </a>
            
            <a class="nav-item" href="/works">
                My Works
            </a>
            
            <a class="nav-item" href="/about">
                About
            </a>
            
        </div>
        <span class="nav-toggle" id="navMenuDropdown">
            <span></span>
            <span></span>
            <span></span>
        </span>
        <div class="navbar-menu position-absolute full-width content-box is-hidden-desktop is-flex flex-column center" style="top: 100%;">
            
            <a class="nav-item flex-1" href="/">
                Home
            </a>
            
            <a class="nav-item flex-1" href="/works">
                My Works
            </a>
            
            <a class="nav-item flex-1" href="/about">
                About
            </a>
            
        </div>
    </nav>
  </div>
</header>

  <div id="main-wrap" class="position-relative" style="margin-top: 55px;">
      <div class="main-inner-content">
          <!--博文页面-->

<style>
    .header-box {
        height: 370px;
        filter: blur(10px);
        background-size: cover;
        background-color: lightsteelblue;
    }

    .post-box {
        padding: 15px;
        padding-top: 60px;
        min-height: 80vh;
        margin-top: -200px;
        border-radius: 4px;
        background-color: rgba(255,255,255,.8);
    }

    .post-avatar {
        height: 30px;
        width: 30px;
        border-radius: 50%;
    }

    .flow-chart {
        text-align: center;
    }

    img[alt="post-cover"] {
        display: none;
    }
</style>
<header>
    <div id="header_box" class="header-box"></div>
</header>
<section>
    <div class="container post-box">
        <div class="content post-title is-flex center flex-column" style="margin-bottom: 70px; overflow: auto;">
            <h1 class="has-text-centered" style="padding-bottom: 10px; border-bottom: 3px solid #fff">
                <strong>Java总结（四）上</strong>
            </h1>
            
            <div class="is-flex align-center">
                <img class="post-avatar" src="https://q2.qlogo.cn/headimg_dl?bs=996057150&dst_uin=996057150&dst_uin=996057150&;dst_uin=996057150&spec=100&url_enc=0&referer=bu_interface&term_type=PC">
                <span style="padding:0 10px;"> <span class="sub-title">By</span> 王邸</span>
                <span class="post-date sub-title">at: 2019-07-21</span>
            </div>
            
                <div>
                    
                </div>
            
        </div>
        <div class="content" style="overflow: auto">
            <p>这周学习的是数据结构，之前学习过。所以主要还是学习代码的实现；但是上课很多东西都还是很重要的。主要是数据结构的代码的实现，结构的应用的实现等等。一些还是有点难度的：二叉排序树的增加和删除；还有一些递归操作用循环实现。</p>
<h2 id="星期一（7-15）："><a href="#星期一（7-15）：" class="headerlink" title="星期一（7.15）："></a>星期一（7.15）：</h2><p>线性表<br>顺序印象 非顺序印象</p>
<p>栈:先进后出<br>顺序印象 非顺序印象<br>栈的应用：<br>1.反转<br>2.括号匹配<br>3.浏览器history<br>4.深度优先遍历(非递归的写法需要记录走过的结点)<br>5.表达式求值<br>首先先知道前缀表达式 中缀表达式 后缀表达式<br>前缀表达式：运算符放在前面 +1*23<br>中缀表达式：运算符放中间，就是我们人类熟知的写法 1+2*3<br>后缀表达式：运算符方后面123*+</p>
<p>默认就用后缀表达式进行计算<br>这里就有两个问题：<br>1.后缀表达式如何进行计算<br>  需要把操作数入栈<br>  a.遍历字符串<br>  b.遇到操作数入栈<br>  c.遇到操作符就进行计算。从栈中取出两个数进行计算，先出栈的放后面，后出栈的放前面。再把计算结果放回到栈中。<br>  例如：123*+<br>  1,2,3入栈<br>  * :则3先出栈，2后出栈进行计算 2*3 = 6;<br>  6入栈，栈中元素为1,6</p>
<ul>
<li>:6先出栈，然后1出栈。 1 + 6 = 7；</li>
</ul>
<p>2.如何把中缀表达式转成后缀表达式<br>  需要把运算符入栈<br>  a.遍历字符串<br>  b.遇到数字就略过<br>  c.遇到操作符如下操作：<br>      栈中没有操作符：入栈<br>      栈中有操作符：比较操作符优先级<br>          1）栈中运算符优先级大于等于当前运算符，则栈中运算符出栈，然后再比较栈中运算符和当前运算符<br>          2）栈中运算符优先级小于当前运算符,就进行入栈操作<br>  d.遍历完字符串检查栈中是否还有运算符<br>      有运算符：全部出栈</p>
<p>  可以这么想栈底的运算符优先级是很低的，栈顶优先级很高，所以出栈时越靠近操作数的运算符优先级更高</p>
<p>那么问题来了如何直接计算一个表达式：<br>（两个栈）<br>一个栈放操作数，一个栈放操作符操作步骤如下：<br>  a.遍历字符串<br>  b.遇到操作数就进操作数栈<br>  c.遇到操作符就进行如下操作<br>    栈中没有操作符：入栈<br>    栈中有操作符：比较操作符优先级<br>        1）栈中运算符优先级大于等于当前运算符，则栈中运算符出栈,从操作数栈中出数进行计算，结果放回操作数栈<br>        然后再比较栈中运算符和当前运算符<br>        2）栈中运算符优先级小于当前运算符,就进行入栈操作</p>
<p>  d.遍历完字符串，判断运算符栈是否还有元素<br>  有元素：则依次出栈进行运算操作，直到运算符栈为空<br>具体实现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div></pre></td><td class="code"><pre><div class="line">public class HomeWork2 &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        String s1 = &quot;2+3*10-3&quot;;</div><div class="line">        String s2 = &quot;((1+(2*3))+10)*10&quot;; //为什么匹配全角和半角括号都可以</div><div class="line">        String a = computeNum(s2);</div><div class="line">        System.out.println(a);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static String computeNum(String s1) &#123;</div><div class="line">        String splitArr[] = s1.split(&quot;&quot;); //一开始获取的数组</div><div class="line">        String strArrCache[] = new String[s1.length()]; //通过合并后的数组</div><div class="line">        List&lt;String&gt; list = new ArrayList&lt;&gt;(); //使用集合代替数组</div><div class="line"></div><div class="line">        String scache = &quot;&quot;;   //表示合并的值</div><div class="line">        //int index = 0;        //表示合并后数组的下标</div><div class="line">        MyStack numStack = new MyStack();</div><div class="line">        MyStack operStack = new MyStack();</div><div class="line"></div><div class="line">        //方法1分成数字数组和运算符数组，但是之后就找不到位置了</div><div class="line">        //方法2先把数字放前面然后，判断找到运算符然后移动数组发现不行</div><div class="line">        //方法3字符串拼接 可以但是感觉不够好</div><div class="line"></div><div class="line">        // i表示split的指针j表示strArr的指针</div><div class="line">        for (int i = 0; i &lt; splitArr.length; i++) &#123;</div><div class="line">            if(splitArr[i].matches(&quot;\\d&quot;) &amp;&amp; i != splitArr.length-1)&#123; //非最后一位是数字</div><div class="line">                scache += splitArr[i]; //缓存字符串</div><div class="line">            &#125; else if(splitArr[i].matches(&quot;\\d&quot;) &amp;&amp; i == splitArr.length-1)&#123; //最后一位是数字</div><div class="line">                scache += splitArr[i];</div><div class="line">                list.add(scache);</div><div class="line">//                strArrCache[index++] = scache;</div><div class="line"></div><div class="line">            &#125; else if(scache != &quot;&quot;)&#123;    //这一位是非数字如果上一位是数字的缓存，就先把数字入数组，然后再把当前的符号入数组</div><div class="line">                list.add(scache);</div><div class="line">                list.add(splitArr[i]);</div><div class="line">//                strArrCache[index++] = scache;</div><div class="line">//                strArrCache[index++] = splitArr[i];</div><div class="line"></div><div class="line">                scache  = &quot;&quot;; //清零</div><div class="line">            &#125; else &#123;   //其他情况，可能是第一个左括号，右括号后面的右括号等情况</div><div class="line">                list.add(splitArr[i]);</div><div class="line">//                strArrCache[index++] = splitArr[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //获取最后的数组</div><div class="line">//        String strArr[] = new String[index];</div><div class="line">//        for (int i = 0; i &lt; strArr.length; i++) &#123;</div><div class="line">//            strArr[i] = strArrCache[i];</div><div class="line">//            System.out.println(&quot;i= &quot;+ i +&quot;  &quot; + strArr[i]+&quot; &quot;);</div><div class="line">//        &#125;</div><div class="line"></div><div class="line">        //遍历字符串</div><div class="line">//        for (int i = 0; i &lt; strArr.length; i++) &#123;</div><div class="line">          for(ListIterator it = list.listIterator();it.hasNext();)&#123;</div><div class="line">//            String value = strArr[i];</div><div class="line">            String value = (String) it.next();</div><div class="line"></div><div class="line">            //如果是数字就入运算符栈</div><div class="line">            if(value.matches(&quot;^\\d+&quot;))&#123;  //判断是一个数或者多位数</div><div class="line">                numStack.push(value);</div><div class="line">            &#125;</div><div class="line">            //左括号直接入操作数栈</div><div class="line">            if(value.matches(&quot;\\(&quot;))&#123;</div><div class="line">                operStack.push(value);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            //如果是运算符判断：</div><div class="line">            // 栈空入站 ，</div><div class="line">            // 栈不空 判断运算符优先级，1）栈中的优先级大则出栈，从数栈取数进行计算</div><div class="line">            //然后重复上面操作，直到栈中的优先级小于当前运算符则入栈</div><div class="line">            if(value.matches(&quot;\\-|\\+|\\*|\\/|\\)&quot;))&#123;</div><div class="line">                if(operStack.isEmpty())&#123;</div><div class="line">                    operStack.push(value);</div><div class="line">                &#125; else if(!value.equals(&quot;)&quot;))&#123;</div><div class="line">                    String top = operStack.peek();//获取栈顶进行比较</div><div class="line"></div><div class="line">                    while(compareOper(top,value) &gt; 0)&#123; //如果是栈顶元素优先级高</div><div class="line">                        String oper = operStack.pop(); //运算符出栈；</div><div class="line"></div><div class="line">                        double last = Double.valueOf(numStack.pop());</div><div class="line">                        double first = Double.valueOf(numStack.pop());</div><div class="line">                        String result = String.valueOf(getResult(first,last,oper));</div><div class="line">                        numStack.push(result); //结果入栈</div><div class="line"></div><div class="line">                        if(operStack.isEmpty())&#123;</div><div class="line">                            break; //跳出while 在外面运算符入栈不然会报错</div><div class="line">                        &#125; else &#123;</div><div class="line">                            top = operStack.peek(); //再比较优先级</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    operStack.push(value);</div><div class="line">                &#125;//else if</div><div class="line">                else &#123;  //说明是右括号 ，直接弹运算符</div><div class="line">                    //while 判断括号多个数</div><div class="line">                    while(!operStack.peek().equals(&quot;(&quot;))&#123;</div><div class="line">                        String oper = operStack.pop(); //运算符出栈；</div><div class="line">                        double last = Double.valueOf(numStack.pop());</div><div class="line">                        double first = Double.valueOf(numStack.pop());</div><div class="line">                        String result = String.valueOf(getResult(first,last,oper));</div><div class="line">                        numStack.push(result); //结果入栈</div><div class="line">                    &#125;</div><div class="line">                    operStack.pop(); //左括号出栈；</div><div class="line">                &#125;</div><div class="line">            &#125;//if 是运算符</div><div class="line">        &#125;//for</div><div class="line">        //最后再判断运算符栈是否还有元素在进行计算操作</div><div class="line">        while(!operStack.isEmpty()) &#123;</div><div class="line">            String oper = operStack.pop(); //运算符出栈；</div><div class="line">            double last = Double.valueOf(numStack.pop());</div><div class="line">            double first = Double.valueOf(numStack.pop());</div><div class="line">            String result = String.valueOf(getResult(first,last,oper));</div><div class="line">            numStack.push(result); //结果入栈</div><div class="line">        &#125;</div><div class="line">        return numStack.pop();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static double getResult(double first, double last, String oper) &#123;</div><div class="line">        double result = 0;</div><div class="line">        switch (oper)&#123;</div><div class="line">            case &quot;+&quot;:</div><div class="line">                result = first + last;</div><div class="line">                break;</div><div class="line">            case &quot;-&quot;:</div><div class="line">                result = first - last;</div><div class="line">                break;</div><div class="line">            case &quot;*&quot;:</div><div class="line">                result = first * last;</div><div class="line">                break;</div><div class="line">            case &quot;/&quot;:</div><div class="line">                result = first / last;</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static int compareOper(String top, String value) &#123;</div><div class="line"></div><div class="line">        if(top.equals(&quot;*&quot;)|| top.equals(&quot;/&quot;))&#123;          //如果里面的是乘除</div><div class="line">            return 1;</div><div class="line">        &#125; else if(value.equals(&quot;*&quot;)|| value.equals(&quot;/&quot;))&#123;  //里面不是乘除，外面是乘除</div><div class="line">            return -1;</div><div class="line">        &#125; else if(top.equals(&quot;(&quot;))&#123;   //如果栈顶是左括号，运算符就入栈；</div><div class="line">            return -1;</div><div class="line">        &#125;</div><div class="line">        return 1; //说明里面是加减外面也是加减，里面优先级高</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>队列:先进先出<br>队列应用场景：<br>    a. 普通队列应用场景十分有限<br>    b. 阻塞队列<br>        enque: 当队列满了，会阻塞，等待队列不满的时候，在执行操作，并返回。<br>        deque: 当队列为空，会阻塞，等待队列不空的时候，再出队列，并返回。<br>    c. 并发队列<br>        线程安全的队列。<br>    d. 缓存<br>    e. 广度优先遍历。<br>顺序印象 非顺序印象</p>
<h2 id="星期二（7-16）："><a href="#星期二（7-16）：" class="headerlink" title="星期二（7.16）："></a>星期二（7.16）：</h2><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>今天介绍了树，当然也是学过的，但是希望当人家问你什么是树的时候，你能说出点东西来；<br>树的定义：树(Tree)是n( n&gt;=0 )个结点的有限集合。n=0就是一颗空树。<br>在任意一颗非空树中：<br>  有且仅有一个特定的称为根(root)的节点<br>  当n&gt;1的时，其余节点可分为m( m&gt;0 )个互不相交的有限集T1，T2，…, Tm，其中每一个集合本身又是一棵树，并且称之为根的子树。<br>  互不相交的有限级其实也就是子树之间没有任何相连的关系</p>
<p>在树中，还有一些基本术语：<br>  <strong>树的结点</strong>：包含一个数据元素以及若干指向其子树的分支。节点拥有的子树的数目，称之为结点的度（degree）。<br>  <strong>叶子结点</strong>：度为0的节点称为叶子，或终端节点。度不为0的结点称为非终端结点或分支节点<br>  <strong>孩子结点、双亲结点和兄弟结点</strong>：节点的子树，称为该节点的孩子（child），相应的该节点称为孩子的双亲（parent）同一个双亲的孩子之间互称兄弟（sibling）<br>  <strong>祖先结点和子孙结点</strong>节点的祖先是从根到该节点所经分支上所有的节点。以某节点为根的子树中的任意一节点都称为该结点的子孙<br>  <strong>结点的层次（Level）</strong>从根开始定义，根为第一层，根的孩子为第二层。若某节点在第l层，则其子树的根就在l+1层<br>  <strong>结点的路径</strong>从节点ni 到 nk 的路径定义为节点 n1 n2 … nk (都不在同一层)的一个序列，使得对于 1 &lt;= i &lt; k，节点 ni 是 ni+1 的父亲。这条路径的长是为该路径上边的条数，即 k-1。从每一个节点到它自己有一条长为 0 的路径。注意，在一棵树中从根到每个节点恰好存在一条路径。<br>  <strong>深度</strong>对任意节点ni，ni的深度为从根到ni 的唯一路径的长。因此，根的深度为0。<br>  <strong>高度</strong>ni 的高度是从ni到一片树叶的最长路径的长（可能不是平衡树所以长的才算高度和深度）。因此，所有树叶的高都为0。一颗树的高等于它根的高。</p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>二叉树具有以下重要特性：<br>二叉树，在第i层至多有2^(i-1)个结点（主要是在理论上使用的比较多）<br>层次为k的二叉树至多有2^k-1个结点<br>对任何一颗二叉树T，如果其终端结点数为n0 ,度为2的结点数为n2，则n0 = n2 + 1</p>
<pre><code>n0+n1+n2 = n1+2*n2+1 =&gt; n0 = n2 + 1;
</code></pre><p>具有n个结点的完全二叉树，根节点的深度为log2(n)<br>如果对一颗有n个结点的完全二叉树的节点按层序编号，则对任意一结点，i从1开始<br>1)如果i=1，则结点i是二叉树的根，无双亲；如果i &gt; 1，则其双亲parent(i)的节点：i/2<br>2)如果2i &gt; n，则结点i无左孩子（结点i为叶子结点）；否则其左孩子lchild(i)是节点 2i。<br>3)如果2i+1 &gt; n，则结点i无右孩子，否则，其右孩子rchild(i)是结点2i+1。</p>
<h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><p>二叉树的顺序映像（完全二叉树）<br>用数组来存储元素，使用了连续的存储空间来存储。这里需要有一点进行说明。因为是连续的空间，用数组作为下标。所以下标是从0开始编号的。那么对于之前二叉树的父子结点的下标需要有修正的地方。这里主要是用在堆上，因为堆就是一个完全二叉树。<br>i从0开始<br>i的左孩子结点为： 2*i+1<br>i的右孩子结点为：2*i+2<br>结点i的父亲结点为 (i-1)/2<br>二叉树的非顺序映像<br>二叉树的非顺序映像，是以链表的形式，存储数据元素以及数据元素之间的关系。但是由于数据元素的关系变得更加复杂，因此，链表结点的结构，与线性表中链表的结点有有所不同。因为线性表的是一对一的关系。而树中是一对多的关系；</p>
<h2 id="星期三（7-17）："><a href="#星期三（7-17）：" class="headerlink" title="星期三（7.17）："></a>星期三（7.17）：</h2><h3 id="二叉搜索树（二叉排序树BST）："><a href="#二叉搜索树（二叉排序树BST）：" class="headerlink" title="二叉搜索树（二叉排序树BST）："></a>二叉搜索树（二叉排序树BST）：</h3><p>  左子树结点小于根节点的值<br>  右子树结点大于根节点的值<br>  左右子树同时也是二叉搜索树</p>
<h3 id="二叉搜索树的构建"><a href="#二叉搜索树的构建" class="headerlink" title="二叉搜索树的构建"></a>二叉搜索树的构建</h3><p>  我差点忘记了这一部分的内容，这一部分是非常重要的，对于理解递归和二叉树都非常重要。BST最主要的功能当然是增删改查。以非顺序印象存储值<br>  思路：思路都是类似的，首先判断是否有根节点，然后判断一下根节点和你需要查找，添加的结点的大小，以确定去左边添加还是去右边添加，不讨论相等的情况；删除一个结点时，首先也是同样的思路去找到那个结点，然后在判断：1.是度为2的结点 2.是度为1的结点 3.是叶子结点 ，然后把第一种情况转换为第二种第三种情况；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public class BinarySearchTree &#123;</div></pre></td></tr></table></figure>
<p>属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//属性</div><div class="line">TreeNode root;  //表示根节点</div><div class="line">int size;</div><div class="line">static class TreeNode &#123;</div><div class="line">    TreeNode leftChild; //指向左孩子</div><div class="line">    char val;</div><div class="line">    TreeNode rightChild;//指向右孩子</div><div class="line">    public TreeNode(char val) &#123;</div><div class="line">        this.val = val;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>构造方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//构造方法</div><div class="line">public BinarySearchTree()&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>方法：<br>添加结点：迭代的方法和循环的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 树中添加结点</div><div class="line"> * @param c 添加的值</div><div class="line"> * @return</div><div class="line"> * 判断：</div><div class="line"> *   1.空树newNode 给 root</div><div class="line"> *   2.需要两个指针分别指向要添加的地方和添加地方的父节点</div><div class="line"> *   最后把父节点和要添加的结点链接，需要在判断一次是在左边添加还是在右边添加；</div><div class="line"> *   3,如果遇到重复值return false不添加</div><div class="line"> */</div><div class="line">//使用循环</div><div class="line">public boolean add(char c) &#123;</div><div class="line">    //</div><div class="line">    if(root == null)&#123;</div><div class="line">       root = new TreeNode(c);</div><div class="line">       return true;</div><div class="line">    &#125;</div><div class="line">    TreeNode pre = null;</div><div class="line">    TreeNode node = root;</div><div class="line">    while(node != null) &#123;</div><div class="line">        int i = c - node.val; //和父节点比较谁大</div><div class="line">        if(i &gt; 0) &#123;    //加入的元素比父节点大</div><div class="line">            pre = node;</div><div class="line">            node = node.rightChild;</div><div class="line">        &#125; else if(i &lt; 0)&#123; //加入的元素比父节点小</div><div class="line">            pre = node;</div><div class="line">            node = node.leftChild;</div><div class="line">        &#125; else &#123;</div><div class="line">            return false; //找到一样的拉闸</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //再判断一次pre到底指向的左子树还是右子树</div><div class="line">    if(pre.val &gt; c) &#123;</div><div class="line">        size++;</div><div class="line">        pre.leftChild = new TreeNode(c);</div><div class="line">    &#125; else if (pre.val &lt; c)&#123;</div><div class="line">        size++;</div><div class="line">        pre.rightChild = new TreeNode(c);</div><div class="line">    &#125; else &#123;  //相同则取消</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    return true;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//使用迭代</div><div class="line">/**</div><div class="line"> * 递归添加元素</div><div class="line"> * @param c</div><div class="line"> * @return</div><div class="line"> * 首先他自己不能递归，需要分成小的部分在哪个节点后面添加；</div><div class="line"> * 而不是和整棵树进行比较</div><div class="line"> * 所以需要再分一个小函数表示在哪个节点添加的元素</div><div class="line"> * add_recursion（TreeNode node, char c）</div><div class="line"> */</div><div class="line">public boolean add_recursion(char c)&#123;</div><div class="line">    int temp = size;</div><div class="line">    root = add_recursion(root,c);</div><div class="line">    return size &gt; temp;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 这个小函数就是添加元素</div><div class="line"> * @param node</div><div class="line"> * @param c</div><div class="line"> * @return</div><div class="line"> * 三种情况：</div><div class="line"> *   a.如果这个结点是空的，找到了要添加的位置；</div><div class="line"> *   判断父节点和c哪个那</div><div class="line"> *     b.父节点大：在node.left添加c</div><div class="line"> *     c.c大：在node.right添加c</div><div class="line"> */</div><div class="line">private TreeNode add_recursion(TreeNode node, char c) &#123;</div><div class="line">    if(node == null) &#123;</div><div class="line">        size++;  //添加结点</div><div class="line">        return new TreeNode(c);</div><div class="line">    &#125;</div><div class="line">    int cmp = c - node.val;</div><div class="line">    if(cmp &gt; 0) &#123; //如果是c大</div><div class="line">        //这里要连上，不然新加的不知道连哪里</div><div class="line">        node.rightChild = add_recursion(node.rightChild,c);</div><div class="line">    &#125; else if(cmp &lt; 0) &#123;</div><div class="line">        node.leftChild =  add_recursion(node.leftChild,c);</div><div class="line">    &#125;</div><div class="line">    //如果有相同的就不加</div><div class="line">    return node;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>删除结点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 循环实现删除</div><div class="line"> * @param c</div><div class="line"> * @return</div><div class="line"> * 先判断树是否为空</div><div class="line"> * 非空就继续</div><div class="line"> * 找到那个要删除的结点，同样要保存父节点，有三种情况：</div><div class="line"> * 1.该结点是度为2：把他和他前驱的值交换然后去删掉他前驱的，</div><div class="line"> * 删前驱就变成下面两种情况</div><div class="line"> *   2.度为1,删掉把父节点指向删掉结点的子节点</div><div class="line"> *   3.度为0,直接删掉以除后患</div><div class="line"> * **注意**</div><div class="line"> * 这里不仅需要两个指针来表示要删除的结点和删除结点的父亲节点</div><div class="line"> * 而且需要两个结点去表示删除结点的前驱结点和前驱结点的父亲的结点。</div><div class="line"> * 然后才能把要删除的结点转化成删除他的前驱结点的过程；</div><div class="line"> *</div><div class="line"> */</div><div class="line">boolean remove(char c)&#123;</div><div class="line">    //空节点异常</div><div class="line">    if(size == 0) &#123;</div><div class="line">        throw new EmptyTreeException();</div><div class="line">    &#125;</div><div class="line">    //说明有结点</div><div class="line">    TreeNode parent = null;//要删除结点的父节点</div><div class="line">    TreeNode node = root; //要删除的结点</div><div class="line">    //先找到那个要删除的结点</div><div class="line">    while(node != null &amp;&amp; node.val != c) &#123;</div><div class="line">        int cmp = c - node.val;</div><div class="line">        if(cmp &gt; 0)&#123;  //删除的数比父节点大</div><div class="line">            parent = node;</div><div class="line">            node = node.rightChild;</div><div class="line">        &#125; else if(cmp &lt; 0) &#123;</div><div class="line">            parent = node;</div><div class="line">            node = node.leftChild;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if(node == null) return false; //表示没有找到</div><div class="line"></div><div class="line">    //找到要删除的结点</div><div class="line">    //删除的是两个结点</div><div class="line">    if(node.leftChild != null &amp;&amp; node.rightChild != null) &#123;</div><div class="line">        //去找左边的前驱交换值</div><div class="line">        // TreeNode tn =getMaxNode(node.leftChild); 因为要获取父节点不能直接拿最大结点</div><div class="line"></div><div class="line">        TreeNode ppNode = node; //删除结点前驱的父节点</div><div class="line">        TreeNode pNode = node.leftChild;//删除结点的前驱</div><div class="line">        while(pNode.rightChild != null)&#123;</div><div class="line">            ppNode = pNode;</div><div class="line">            pNode = pNode.rightChild;</div><div class="line">        &#125;</div><div class="line">        把删除转化成删除前驱结点的过程</div><div class="line">        node.val = pNode.val;</div><div class="line">        parent = ppNode;</div><div class="line">        node = pNode;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //删除的是度为1 或者 叶节点 或者删除结点的子节点</div><div class="line">    TreeNode child = node.leftChild != null ? node.leftChild : node.rightChild;</div><div class="line">    if(parent == null) &#123; //要删除的根节点，parent没有赋值。可能度为1可能度为0</div><div class="line">        root = child;</div><div class="line">    &#125;</div><div class="line">    if(parent.leftChild == node) &#123;</div><div class="line">        parent.leftChild = child;</div><div class="line">    &#125;</div><div class="line">    if(parent.rightChild == node) &#123;</div><div class="line">        parent.rightChild = child;</div><div class="line">    &#125;</div><div class="line">    size--;</div><div class="line">    return true;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 递归实现删除一个结点</div><div class="line"> * @param c</div><div class="line"> * @return</div><div class="line"> * 当然也需要一个子方法来判断删除的结点</div><div class="line"> */</div><div class="line">boolean remove_recursion(char c)&#123;</div><div class="line">    int tem = size;</div><div class="line">    root = remove_recursion(root,c);</div><div class="line">    return tem &gt; size;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 需要要删除的子方法，为了判断node是否是要删除的</div><div class="line"> * @param node</div><div class="line"> * @param c</div><div class="line"> * @return</div><div class="line"> * 判断：</div><div class="line"> *  一样的三种情况</div><div class="line"> */</div><div class="line">private TreeNode remove_recursion(TreeNode node, char c) &#123;</div><div class="line">    if(node == null) &#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">    int cmp = c - node.val;</div><div class="line">    if(cmp &gt; 0) &#123;</div><div class="line">        node.rightChild = remove_recursion(node.rightChild,c);</div><div class="line">    &#125; else if(cmp &lt; 0) &#123;</div><div class="line">        node.leftChild = remove_recursion(node.leftChild,c);</div><div class="line">    &#125; else &#123;</div><div class="line">        //说明找到了又是三种判断；</div><div class="line">        if(node.leftChild != null &amp;&amp; node.rightChild != null)&#123;</div><div class="line">            //获取最大值；</div><div class="line">            TreeNode maxOfLeft = getMaxNode(node.leftChild);</div><div class="line">            node.val = maxOfLeft.val;</div><div class="line">            node.leftChild = remove_recursion(node.leftChild,c);//改成对前驱删除</div><div class="line"></div><div class="line">        &#125; else if(node.leftChild == null &amp;&amp; node.rightChild == null)&#123;</div><div class="line">            //叶节点</div><div class="line">            size--;</div><div class="line">            return null;</div><div class="line">        &#125; else &#123;</div><div class="line">            size--;</div><div class="line">            return node.leftChild != null ? node.leftChild : node.rightChild;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return node;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>获取树的最大最小值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 获取最大最小值</div><div class="line"> * @return</div><div class="line"> */</div><div class="line">public char max()&#123;</div><div class="line">    return getMaxNode(root).val;</div><div class="line">&#125;</div><div class="line">public char min()&#123;</div><div class="line">    return getMinNode(root).val;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 获取最大值的结点就是当前结点最右边的子节点结点</div><div class="line"> * @param tn</div><div class="line"> */</div><div class="line">private TreeNode getMaxNode(TreeNode tn) &#123;</div><div class="line">    if(tn.rightChild == null) return tn;</div><div class="line">    return getMaxNode(tn.rightChild);</div><div class="line">&#125;</div><div class="line">private TreeNode getMinNode(TreeNode tn) &#123;</div><div class="line">    if(tn.leftChild == null) return tn;</div><div class="line">    return getMinNode(tn.leftChild);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>判断是否存在<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 判断是否有值；</div><div class="line"> * @param c</div><div class="line"> * @return</div><div class="line"> */</div><div class="line">boolean contains(char c)&#123;</div><div class="line">    TreeNode node = root;</div><div class="line">    if(node == null) return false;</div><div class="line">    while(node != null) &#123;</div><div class="line">        int cmp = c - node.val;</div><div class="line">        if(cmp &gt; 0) &#123;</div><div class="line">            node = node.rightChild;</div><div class="line">        &#125;else if(cmp &lt; 0) &#123;</div><div class="line">            node = node.leftChild;</div><div class="line">        &#125; else &#123;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return false;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 迭代寻找是否存在</div><div class="line"> * @param c</div><div class="line"> * @return</div><div class="line"> * 同样也需要一个子函数来判断root是否和c相同</div><div class="line"> */</div><div class="line">boolean contains_recursion(char c) &#123;</div><div class="line">    return contains_recursion(root,c);</div><div class="line">&#125;</div><div class="line"></div><div class="line">private boolean contains_recursion(TreeNode node, char c) &#123;</div><div class="line">  //找不到</div><div class="line">    if(node == null) &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    int cmp = c - node.val;</div><div class="line">    if(cmp &gt; 0) &#123;</div><div class="line">        return contains_recursion(node.rightChild,c);</div><div class="line">    &#125; else if(cmp &lt; 0) &#123;</div><div class="line">        return contains_recursion(node.leftChild,c);</div><div class="line">    &#125; else &#123;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>求树的层次<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 使用队列进行层序遍历</div><div class="line"> * @return</div><div class="line"> * 就是层序遍历把元素放进队列，这里需要注意的是需要去记录每一层的元素有多少个；</div><div class="line"> */</div><div class="line">public int depth() &#123;</div><div class="line">    if(root == null) return 0;</div><div class="line">    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</div><div class="line">    queue.add(root);//先把根节点入栈</div><div class="line">    int deep = 0;</div><div class="line">    while(!queue.isEmpty())&#123;</div><div class="line">      deep++;</div><div class="line">      int length = queue.size();//获取每一层有几个元素入队</div><div class="line">      for (int i = 0; i &lt; length; i++) &#123;</div><div class="line">          TreeNode node = queue.remove();</div><div class="line">          if(node.leftChild != null) &#123;</div><div class="line">              queue.add(node.leftChild);</div><div class="line">          &#125;</div><div class="line">          if(node.rightChild != null) &#123;</div><div class="line">              queue.add(node.rightChild);</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    return deep;</div><div class="line">&#125;</div><div class="line">/**</div><div class="line"> * 递归求深度，后序遍历然后左右结点较高的+1；</div><div class="line"> * @return</div><div class="line"> */</div><div class="line">public int depth_recursion(TreeNode node)&#123;</div><div class="line">    if(node == null) &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    int left = depth_recursion(node.leftChild);</div><div class="line">    int right = depth_recursion(node.rightChild);</div><div class="line">    return left &gt; right ? left+1 : right+1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先序遍历：两种方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 先序遍历递归</div><div class="line"> * @param root</div><div class="line"> */</div><div class="line">void preOrder_recurion(TreeNode root)&#123;</div><div class="line">    if(root == null) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    System.out.print(root.val + &quot; &quot;);</div><div class="line">    if(root.leftChild != null) &#123;</div><div class="line">        preOrder(root.leftChild);</div><div class="line">    &#125;</div><div class="line">    if(root.rightChild != null) &#123;</div><div class="line">        preOrder(root.rightChild);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 先序遍历使用非递归的方法：使用栈</div><div class="line"> * 先把根节点入栈，然后判断栈是否为空，出栈。先把右子树入栈，然后再把左子树入栈。因为左子树要先出来，所以要先把右子树入栈后出来；</div><div class="line"> * @param root</div><div class="line"> */</div><div class="line"> List&lt;Character&gt; PreOrder(TreeNode root) &#123;</div><div class="line">  List&lt;Character&gt; list = new ArrayList&lt;&gt;();</div><div class="line">  if (root == null) return list; //最好是直接返回list以防调用空指针异常</div><div class="line">  Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();</div><div class="line">  stack.push(root);</div><div class="line">  while (!stack.isEmpty()) &#123;</div><div class="line">      TreeNode node = stack.pop();</div><div class="line">      list.add(node.val);</div><div class="line">      if (node.right != null) &#123;</div><div class="line">          stack.push(node.right);</div><div class="line">      &#125;</div><div class="line">      if (node.left != null) &#123;</div><div class="line">          stack.push(node.left);</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">  return list;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>中序遍历：三种方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 中序迭代</div><div class="line"> * @param root</div><div class="line"> */</div><div class="line">void inOrder_recursion(TreeNode root)&#123;</div><div class="line">    if(root == null) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    if(root.leftChild != null) &#123;</div><div class="line">        inOrder(root.leftChild);</div><div class="line">    &#125;</div><div class="line">    System.out.print(root.val + &quot; &quot;);</div><div class="line">    if(root.rightChild != null) &#123;</div><div class="line">        inOrder(root.rightChild);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 中序循环1：模拟栈的实现的过程使用循环：</div><div class="line">    a.先根节点入栈判断栈是否为空，</div><div class="line">    b.左子树全部入栈</div><div class="line">    c.然后出栈，就是第一个元素然后再循环</div><div class="line"> * @param root</div><div class="line"> */</div><div class="line">public List&lt;Character&gt; inOrder() &#123;</div><div class="line">  List&lt;Character&gt; list = new ArrayList&lt;&gt;();</div><div class="line">  Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();</div><div class="line"></div><div class="line">  if(root == null) return;</div><div class="line">  TreeNode curr = root;</div><div class="line">  while(curr != null &amp;&amp; !list.isEmpty())&#123;</div><div class="line">    //左边的的结点全部进栈</div><div class="line">    while(curr!=null) &#123;</div><div class="line">      stack.push(curr);</div><div class="line">      curr = curr.left;</div><div class="line">    &#125;</div><div class="line">    //这时栈顶就是第一个结点</div><div class="line">    curr = stack.pop();</div><div class="line">    list.add(curr);//保存下来</div><div class="line">    curr = curr.right;</div><div class="line">  &#125;</div><div class="line">  return list;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 中序遍历循环2:</div><div class="line">  Morris 遍历 不用栈(线索二叉树，利用左前驱右后继) 一个指针代替一个栈</div><div class="line">  就是把根节点的前驱结点连接到根节点。在中序遍历过程中：每一个根节点都应该有前驱结点，如果前驱结点遍历过了，下一个遍历的当然就是根节点；</div><div class="line"></div><div class="line">  1.curr = root;</div><div class="line">  2.while(curr != null) &#123;  //去找第一个结点</div><div class="line">      if(curr.leftChild == null) &#123;  //如果找到了第一个节点</div><div class="line">          list.add(curr.val);</div><div class="line">          curr = curr.rightChild;   //去第一个结点右边找第二个结点 或者会链接回到curr</div><div class="line">      &#125;</div><div class="line">      else</div><div class="line">          找到左子树的最大节maxNode,就是他的前驱，然后把前驱连接给他</div><div class="line">          getMaxNode().rightChild = curr;</div><div class="line">          curr = curr.leftChild;</div><div class="line">  &#125;</div><div class="line"> * @param root</div><div class="line"> */</div><div class="line">  public List&lt;Character&gt; inOrder3() &#123;</div><div class="line">    TreeNode curr = root;</div><div class="line">    List&lt;Character&gt; list = new ArrayList();</div><div class="line">    if(root == null) return list;</div><div class="line"></div><div class="line">    while(curr != null) &#123;</div><div class="line">      //找到第一个结点</div><div class="line">      if(curr.leftChild ==null)&#123;</div><div class="line">        list.add(curr.val);</div><div class="line">        curr = curr.rightChild;</div><div class="line">      &#125; else &#123;</div><div class="line">        //当没有找到第一个结点时，找他的前驱并把前驱连接到这个结点上,为了保证左子树全部遍历完了再遍历curr结点</div><div class="line">        TreeNode max = curr.leftChild;</div><div class="line">        while(max.rightChild != null &amp;&amp; max.rightChild != curr) &#123; //去找最大的结点,而且确认没有连接到curr上</div><div class="line">          max = max.rightChild;</div><div class="line">        &#125;</div><div class="line">        if(max.rightChild == null) &#123; //确认没有连接</div><div class="line">          max.right = curr;</div><div class="line">          curr = curr.leftChild;//可以去左子树里面连接了，子树的前驱肯定和根节点的前驱不同</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if(max.rightChild == curr) &#123; //说明左边都遍历过了到curr结点遍历了</div><div class="line">          list.add(curr.val);</div><div class="line">          max.rightChild == null; //还原</div><div class="line">          curr = curr.rightChild;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    return list;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>后序遍历：两种方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 后序迭代</div><div class="line"> * @param root</div><div class="line"> */</div><div class="line">void postOrder_recursion(TreeNode root)&#123;</div><div class="line">    if(root == null) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    if(root.leftChild != null) &#123;</div><div class="line">        postOrder(root.leftChild);</div><div class="line">    &#125;</div><div class="line">    if(root.rightChild != null) &#123;</div><div class="line">        postOrder(root.rightChild);</div><div class="line">    &#125;</div><div class="line">    System.out.print(root.val + &quot; &quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 后序非迭代：使用双端队列，入栈的时候就是正常的先栈顶出栈，左子树入栈，然后右子树入栈。进保存的队列时候可以头插法，最先加入的元素就会出现在最后，就相当于后序遍历；</div><div class="line"> * @param root</div><div class="line"> */</div><div class="line">public List&lt;Character&gt; postOrder()&#123;</div><div class="line">    LinkedList&lt;Character&gt; list = new LinkedList();</div><div class="line">    if(root == null) return list;</div><div class="line">    Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();</div><div class="line">    stack.push(root);</div><div class="line">    while(!stack.isEmpty()) &#123;</div><div class="line">        TreeNode node= stack.pop();</div><div class="line">        //左子树先进去后出来</div><div class="line">        if(node.leftChild != null) &#123;</div><div class="line">            stack.push(node.leftChild);</div><div class="line">        &#125;</div><div class="line">        if(node.rightChild != null) &#123;</div><div class="line">            stack.push(node.rightChild);</div><div class="line">        &#125;</div><div class="line">        list.addFirst(node.val);</div><div class="line">    &#125;</div><div class="line">    return list;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>层序遍历<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">    /**</div><div class="line">     * 层序；</div><div class="line">     */</div><div class="line">    void levelOrder(TreeNode root)&#123;</div><div class="line">        if(root == null) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</div><div class="line">        queue.add(root);</div><div class="line">        while(!queue.isEmpty()) &#123;</div><div class="line">            TreeNode node = queue.remove();</div><div class="line">            System.out.print(node.val+&quot; &quot;);</div><div class="line">            if(node.leftChild != null)&#123;</div><div class="line">                queue.add(node.leftChild);</div><div class="line">            &#125;</div><div class="line">            if(node.rightChild != null) &#123;</div><div class="line">                queue.add(node.rightChild);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">注意：这里没有调整二叉树成为一个平衡的二叉树，只是简单的讨论了一下到底应该怎么增删改查；</div></pre></td></tr></table></figure></p>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>前序，中序，后序，层序<br>顾名思义：<br>前序遍历：先遍历根节点，然后遍历左子树然后遍历右子树<br>中序遍历：有左子树先遍历左子树，然后遍历根节点最后遍历有节点<br>后序遍历：先遍历左子树，然后遍历右子树最后遍历根节点；<br>层序遍历：一层一层的遍历，从根节点进行遍历</p>
<h3 id="构建二叉树"><a href="#构建二叉树" class="headerlink" title="构建二叉树"></a>构建二叉树</h3><p>如何构建二叉树？<br>1）前序和中序构建二叉树（可以）<br>2）中序和后序构建二叉树（可以）<br>3）前序和后序构建二叉树（不可以）<br>问题1：为什么前序和后序不能构建唯一的二叉树？<br>首先需要了解构建二叉树的原理：<br>这也是一个遍历的过程，首先你要找到根节点。然后分出来根节点的左子树和右子树是什么<br>然后分别在左子树和右子树在去找他们分别的根节点；一层一层的下去；<br>但是只知道前序和后序是不能去判断哪个节点是根节点。</p>
<p>问题2：层序遍历能否去构建二叉树？<br>答:中序和层序可以构建唯一二叉树，而和前序，后序遍历不能得到唯一的二叉树。<br>理由和上面一样，每次建树操作都要区分出左子树和右子树的结点有哪些。只有层序和中序遍历可以得到，而和其他两种得不到唯一的左子树和右子树；<br>层序和中序构建二叉树的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">public class CreateTree &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        String[] level = &quot;ABC&quot;.split(&quot;&quot;);</div><div class="line">        String[] in = &quot;BAC&quot;.split(&quot;&quot;);</div><div class="line">        int root = 0; //记录根节点下标</div><div class="line"></div><div class="line">        TreeNode head = CreateBinaryTreeByLevelOrderInOrder(level,0,level.length-1,in,0,in.length-1,root);</div><div class="line">        System.out.println(head.val);</div><div class="line">        InOrder(head);</div><div class="line">    &#125;</div><div class="line">    public static TreeNode CreateBinaryTreeByLevelOrderInOrder(String[] level,int s1, int e1, String[] in, int s2, int e2,int root)&#123;</div><div class="line">        boolean isFindRoot =  false;</div><div class="line">        boolean isFindLTree = false;</div><div class="line">        boolean isFindRTree = false;</div><div class="line">        TreeNode node = new TreeNode();</div><div class="line">        //遍历字符串</div><div class="line">        for (int i = s1; i &lt;=e1; i++) &#123;</div><div class="line">            for (int j  = s2; j &lt;= e2; j++) &#123;</div><div class="line">                //构建根节点</div><div class="line">                if(!isFindRoot &amp;&amp; level[s1].equals(in[j]))&#123;</div><div class="line">                    root = j;</div><div class="line">                    isFindRoot = true;</div><div class="line">                    node.val = level[s1];</div><div class="line">                    node.leftChild = null;</div><div class="line">                    node.rightChild = null;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                //在层序中查找中序中左子树的根节点</div><div class="line">                if(!isFindLTree &amp;&amp; level[i].equals(in[j]) &amp;&amp; j &lt; root) &#123;</div><div class="line">                    node.leftChild = CreateBinaryTreeByLevelOrderInOrder(level, i, e1, in, s2, root - 1, root);</div><div class="line">                    isFindLTree = true;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                //在层序中查找中序中右子树的根节点</div><div class="line">                if(!isFindRTree &amp;&amp; level[i].equals( in[j]) &amp;&amp; j &gt; root) &#123;</div><div class="line">                    node.rightChild = CreateBinaryTreeByLevelOrderInOrder(level, i, e1, in, root + 1, e2, root);</div><div class="line">                    isFindRTree = true;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                //建立完成</div><div class="line">                if(isFindRoot &amp;&amp; isFindLTree &amp;&amp; isFindRTree) &#123;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return node;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static class TreeNode &#123;</div><div class="line">        TreeNode leftChild;</div><div class="line">        String val;</div><div class="line">        TreeNode rightChild;</div><div class="line"></div><div class="line">        public TreeNode()&#123;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        public TreeNode(String val) &#123;</div><div class="line">            this.val = val;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/kfyty725/article/details/82808097" target="_blank" rel="external">参考</a></p>
<h2 id="星期四-7-18-："><a href="#星期四-7-18-：" class="headerlink" title="星期四(7.18)："></a>星期四(7.18)：</h2><p>排序:<br>主要是要知道怎么去写，注意一些边界条件。思路都不同很有特点<br>冒泡 简单选择 插入排序 希尔排序 归并排序 快排</p>
<h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1 冒泡排序"></a>1 冒泡排序</h3><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
<p>  1.1 算法描述</p>
<pre><code>比较相邻的元素。如果第一个比第二个大，就交换它们两个；
对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
针对所有的元素重复以上的步骤，除了最后一个；
重复步骤1~3，直到排序完成。每次排序完，最大的数都会沉底到达他最终的位置，
</code></pre><p>  1.2 算法分析</p>
<pre><code>时间复杂度：T(n) = O(n^2)   最好情况O(n)  最坏情况O（n^2）
空间复杂度：O(1)
稳定性：稳定
</code></pre><p>  1.3实现：<br>  需要使用两层循环:<br>  外层循环的边界调节是i包含在：[0，arr.length-2]因为最后一个数不需要在和他后面的比，他前面是有序的他一定是有序的<br>  内层循环需要比较相邻两个元素他的边界j包含[i,arr.length-2-i];表示是是从i开始和后一个数进行比较当然最后一个数没有后一个数，所以只循环到倒数第二个数即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public static void BubbleSort(int[] arr) &#123;</div><div class="line">  for(int i = 0; i &lt; arr.length-2; i++) &#123;</div><div class="line">    boolean isOrder = true;//表示一个标志是否需要排序</div><div class="line">    for(int j = i; j &lt; arr.length-2-i; j++) &#123;</div><div class="line">      if(arr[j] &gt; arr[j+1]) &#123;</div><div class="line">        swap(arr,j,j+1)</div><div class="line">        isOrder = false;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    if(isOrder == true) &#123;</div><div class="line">      return ; //排序完成</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><p>  1.1 算法描述<br>    表现最稳定的排序算法之一，因为无论什么数据进去都是O(n^2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。<br>    它的工作原理：首先在未排序序列中找到最小（大）元素，交换到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后交换已排序序列的末尾。以此类推，直到所有元素均排序完毕。<br>  1.2 算法分析<br>    时间复杂度：平均情况 O(n2)  最好情况 O(n^2)  最坏情况 O(n^2)<br>    空间复杂度： O(1)<br>    稳定性：不稳定<br>  1.3实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">就写核心的两个for循环</div><div class="line">for(int i = 0; i &lt; arr.length-1; i++) &#123;</div><div class="line">  int minIndex = i;//要去找无序序列当中的最小值</div><div class="line">  for(int j = i + 1; j &lt; arr.length; j++) &#123;  //寻找当前最小值的下标</div><div class="line">    if(arr[minIndex] &gt; arr[j]) &#123;</div><div class="line">      minIndex = j;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  swap(arr,i,minIndex);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，<strong>因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位</strong>，为最新元素提供插入空间。<br>  1.1 算法描述</p>
<pre><code>1从第一个元素开始，该元素可以认为已经被排序；
2取出下一个元素，在已经排序的元素序列中从后向前扫描；
3如果该元素（已排序）大于新元素，将该元素移到下一位置；
4重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
5将新元素插入到该位置后；
</code></pre><p>  1.2 算法分析</p>
<pre><code>时间复杂度：平均情况 O(n2)  最好情况 O(n^2)  最坏情况 O(n^2)
空间复杂度： O(1)
稳定性：不稳定,可以稳定
</code></pre><p>  1.3实现：<br>    就写两层循环，第一层遍历数组，第二层j开始去前面的有序的序列去找无序序列第一个元素应该放哪里<br>    for(int i = 1; i &lt; arr.length-1; i++) { //i指向的是无序的第一个元素<br>      int j;<br>      int value = arr[i];<br>      for(j = i-1; j &gt;=0 &amp;&amp; arr[j] &gt; value; j–){ //找到value能插入的地方 只有&gt; 为了稳定<br>        arr[j+1] = arr[j];//移动<br>      }<br>      arr[j+1] = value;<br>    }</p>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>  1.1 算法描述<br>在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2…1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。<br>先将整个待排序的记录序列分割成为若干子序列分别进行<strong>直接插入排序</strong>，具体算法描述：</p>
<pre><code>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；
按增量序列个数k，对序列进行k 趟排序；
每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。
</code></pre><p>  1.2 算法分析</p>
<pre><code>时间复杂度：O(nlogn)
空间复杂度：O(1)
稳定性：不稳定
</code></pre><p>  1.3实现：三层循环，一层确定gap 两层直接插入排序<br>    int gap = arr.length/2;<br>    while(gap != 0) {<br>      for(int i = gap; i &lt; arr.length; i++) {<br>        int value = arr[gap];<br>        int j;<br>        for(j = i - gap; j &gt;=0 &amp;&amp; arr[j]&gt;value; j=j-gap){<br>          arr[j+gap] = arr[j];<br>        }<br>        arr[j+gap] = value;<br>      }<br>      gap = gap/2;<br>    }</p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>  1.1 算法描述</p>
<pre><code>把长度为n的输入序列分成两个长度为n/2的子序列；
对这两个子序列分别采用归并排序；
将两个排序好的子序列合并成一个最终的排序序列。
</code></pre><p>  1.2 算法分析</p>
<pre><code>最佳情况：T(n) = O(nlogn)
空间复杂度： O(n)
稳定性： 稳定
</code></pre><p>  1.3实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">    public static void sort(int[] arr) &#123;</div><div class="line">        if(arr ==null || arr.length &lt;=1) return;</div><div class="line">        mergeSort(arr,0,arr.length-1); //</div><div class="line">    &#125;</div><div class="line">    private static void mergeSort(int[] arr, int low, int high) &#123;</div><div class="line">        if(low &gt;= high) return ;</div><div class="line">//        int mid = (low+high)/2;</div><div class="line">        int mid = low + ((high - low)&gt;&gt;1);</div><div class="line">        //对左边进行排序</div><div class="line">        mergeSort(arr,low,mid);</div><div class="line">//        右边排序</div><div class="line">        mergeSort(arr,mid+1,high);</div><div class="line">        //合并两个有序数组；</div><div class="line">        merge(arr,low,mid,high);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static void merge(int[] arr, int low, int mid, int high) &#123;</div><div class="line">        //需要额外的内存空间，创建一个数组；</div><div class="line">        int left = low;</div><div class="line">        int right = mid+1;</div><div class="line">        int[] temp = new int[high-low+1];</div><div class="line">        int i = 0;</div><div class="line">        //左右两个数组都有元素</div><div class="line">        while(left &lt;= mid &amp;&amp; right &lt;= high) &#123;</div><div class="line">            if(arr[left] &lt;= arr[right])&#123;  // =需要为了稳定性 左边先进</div><div class="line">                temp[i++] = arr[left++];</div><div class="line">            &#125; else &#123;</div><div class="line"></div><div class="line">                temp[i++] = arr[right++];</div><div class="line">                count  = count + (mid - left + 1); //可以获取逆序度</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //左边数组还有元素</div><div class="line">        while(left &lt;= mid) temp[i++] = arr[left++];</div><div class="line">        //右边数组还有元素</div><div class="line">        while(right &lt;= high) temp[i++] = arr[right++];</div><div class="line"></div><div class="line">        //把temp数组的元素重新赋值给对应的区间</div><div class="line">        for(int j = 0; j &lt; temp.length; j++)&#123;</div><div class="line">            arr[low+j] = temp[j];</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><p>  1.1 算法描述<br>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>
<pre><code>从数列中挑出一个元素，称为 “基准”（pivot）；
重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。
</code></pre><p>  1.2 算法分析</p>
<pre><code>最佳情况：平均情况：T(n) = O(nlogn)
空间复杂度： O(logn) （栈占用的空间）
稳定性： 不稳定
</code></pre><p>  1.3实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">private static void quickSort(int[] arr, int low, int high) &#123;</div><div class="line">  int left = low;</div><div class="line">  int right = hight;</div><div class="line">  int pivot = arr[low]; //以第一个元素为轴值</div><div class="line">  while(left &lt; right) &#123;</div><div class="line">    while(left &lt; right &amp;&amp; pivot &lt;= arr[right]) right--; //必须要写等号不然有可能死循环，这样</div><div class="line">    arr[left] = arr[right];;</div><div class="line">    while(left &lt; right &amp;&amp; pivot &gt;= arr[left]) left++;</div><div class="line">    arr[right] = left;</div><div class="line">  &#125;</div><div class="line">  arr[left] = pivot;</div><div class="line">  //分别对左边和右边进行快排</div><div class="line">  quickSort(arr,low,left-1);</div><div class="line">  //右边进行排序</div><div class="line">  quickSort(arr,left+1,high);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

        </div>
        <div class="post-reply">
            
                <!-- 来必力City版安装代码 -->
                <div id="lv-container" data-id="city" data-uid="MTAyMC8yOTE4Ni81NzUz">
                    <script type="text/javascript">
                        (function(d, s) {
                            var j, e = d.getElementsByTagName(s)[0];

                            if (typeof LivereTower === 'function') { return; }

                            j = d.createElement(s);
                            j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
                            j.async = true;

                            e.parentNode.insertBefore(j, e);
                        })(document, 'script');
                    </script>
                    <noscript> 为正常使用来必力评论功能请激活JavaScript</noscript>
                </div>
                <!-- City版安装代码已完成 -->
            
            
        </div>
    </div>
</section>
<script>
    // 获取第一张图, 用以当封面背景图
    var img = document.querySelectorAll('img')[1]

    if (img) {
        var header_box = document.querySelector('#header_box')
        header_box.style.backgroundImage = 'url('+ img.src +')'
    }
</script>
      </div>
  </div>
  <style>
  #footer {
    min-height: 10vh;
    background: black;
    color: #fff;
  }

  #footer a {
    color: #e1e1e1;
  }
</style>
<footer id="footer" class="has-text-centered is-flex center">
  <div class="container has-padding">
    <div>
      <div>
        <!--请您保留作者署名, 主题制作来之不易-->
        主题来自 <a href="http://haojen.github.io/">Haojen Ma</a>
        <br>
        Copyright © 王邸 2019
        <!--
          Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        -->
      </div>
    </div>
  </div>
</footer>

<script src="/js/search_core.js"></script>
<script src="/js/script.js"></script>

</body>
</html>