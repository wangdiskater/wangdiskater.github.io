<!DOCTYPE html>





<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.3.8">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">

<link rel="stylesheet" href="//fonts.proxy.ustclug.org/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="不知不觉就20周了，Java的故事我们继续，接下来的故事我们将会分知识点总结，以前是因为每天都有主线，所以按照每天总结是没问题的，现在我们需要按照知识点总结，这样才能更好的分类：dubbo，jdk1.8，JVM相关，redis相关，rocketMq相关，SE基础，Spring，zookeeper相关，并发相关，数据相关，单点登录相关，线程相关，集合相关，hystrix相关">
<meta property="og:type" content="article">
<meta property="og:title" content="Java总结（二十）">
<meta property="og:url" content="http://yoursite.com/2019/11/10/Java总结（二十）/index.html">
<meta property="og:site_name" content="路要坚持">
<meta property="og:description" content="不知不觉就20周了，Java的故事我们继续，接下来的故事我们将会分知识点总结，以前是因为每天都有主线，所以按照每天总结是没问题的，现在我们需要按照知识点总结，这样才能更好的分类：dubbo，jdk1.8，JVM相关，redis相关，rocketMq相关，SE基础，Spring，zookeeper相关，并发相关，数据相关，单点登录相关，线程相关，集合相关，hystrix相关">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://s2.ax1x.com/2019/11/06/MPHspV.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/11/06/MPHHXD.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/11/06/MPqi26.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/11/07/MFJ75V.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/11/07/MFNGEn.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/11/06/MCeyZ9.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/11/09/Me0AXR.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/11/09/MeL4ud.gif">
<meta property="og:image" content="https://s2.ax1x.com/2019/11/09/MeOK56.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/11/09/MeOl8O.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/11/09/MeOgZn.png">
<meta property="og:updated_time" content="2019-11-10T15:00:35.239Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java总结（二十）">
<meta name="twitter:description" content="不知不觉就20周了，Java的故事我们继续，接下来的故事我们将会分知识点总结，以前是因为每天都有主线，所以按照每天总结是没问题的，现在我们需要按照知识点总结，这样才能更好的分类：dubbo，jdk1.8，JVM相关，redis相关，rocketMq相关，SE基础，Spring，zookeeper相关，并发相关，数据相关，单点登录相关，线程相关，集合相关，hystrix相关">
<meta name="twitter:image" content="https://s2.ax1x.com/2019/11/06/MPHspV.png">
  <link rel="canonical" href="http://yoursite.com/2019/11/10/Java总结（二十）/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Java总结（二十） | 路要坚持</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">路要坚持</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/10/Java总结（二十）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王邸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路要坚持">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">Java总结（二十）

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-11-10 22:50:20 / 修改时间：23:00:35" itemprop="dateCreated datePublished" datetime="2019-11-10T22:50:20+08:00">2019-11-10</time>
            </span>
          
            

            
          

          
            <span id="/2019/11/10/Java总结（二十）/" class="post-meta-item leancloud_visitors" data-flag-title="Java总结（二十）" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
        
      
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/11/10/Java总结（二十）/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2019/11/10/Java总结（二十）/" itemprop="commentCount"></span></a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>不知不觉就20周了，Java的故事我们继续，接下来的故事我们将会分知识点总结，以前是因为每天都有主线，所以按照每天总结是没问题的，现在我们需要按照知识点总结，这样才能更好的分类：dubbo，jdk1.8，JVM相关，redis相关，rocketMq相关，SE基础，Spring，zookeeper相关，并发相关，数据相关，单点登录相关，线程相关，集合相关，hystrix相关</p><a id="more"></a>
<h2 id="dubbo"><a href="#dubbo" class="headerlink" title="dubbo"></a>dubbo</h2><h3 id="说一说dubbo的同步-异步调用？"><a href="#说一说dubbo的同步-异步调用？" class="headerlink" title="说一说dubbo的同步/异步调用？"></a>说一说dubbo的同步/异步调用？</h3><p><a href="http://dubbo.apache.org/zh-cn/blog/dubbo-invoke.html" target="_blank" rel="external">http://dubbo.apache.org/zh-cn/blog/dubbo-invoke.html</a></p>
<h3 id="dubbo同步调用"><a href="#dubbo同步调用" class="headerlink" title="dubbo同步调用"></a>dubbo同步调用</h3><p>同步调用是一种阻塞式的调用方式，即 Consumer 端代码一直阻塞等待，直到 Provider 端返回为止；<br>通常，一个典型的同步调用过程如下：</p>
<pre><code>Consumer 业务线程调用远程接口，向 Provider 发送请求，同时当前线程处于阻塞状态；
Provider 接到 Consumer 的请求后，开始处理请求，将结果返回给 Consumer；
Consumer 收到结果后，当前线程继续往后执行。
</code></pre><p>这里有2个问题：</p>
<pre><code>Consumer 业务线程是怎么进入阻塞状态的？
Consumer 收到结果后，如何唤醒业务线程往后执行的？
</code></pre><p>其实，Dubbo 的底层 IO 操作都是异步的。Consumer 端发起调用后，得到一个 Future 对象。对于同步调用，业务线程通过Future#get(timeout)，阻塞等待 Provider 端将结果返回；timeout则是 Consumer 端定义的超时时间。当结果返回后，会设置到此 <strong>Future</strong>，并唤醒阻塞的业务线程；当超时时间到结果还未返回时，业务线程将会异常返回。</p>
<p><strong>小知识：Future类</strong><br>Future的应用场景<br>在并发编程中，我们经常用到非阻塞的模型，在之前的多线程的三种实现中，不管是继承thread类还是实现runnable接口，都无法保证获取到之前的执行结果。通过实现 Callback 接口，并用 Future 可以来接收多线程的执行结果。</p>
<p>Future表示一个可能还没有完成的异步任务的结果，针对这个结果可以添加Callback以便在任务执行成功或失败后作出相应的操作。</p>
<h3 id="Future-的类图结构"><a href="#Future-的类图结构" class="headerlink" title="Future 的类图结构"></a>Future 的类图结构</h3><p>Future接口定义了主要的5个接口方法，有 RunnableFuture 和 SchedualFuture 继承这个接口，以及 CompleteFuture 和 ForkJoinTask 继承这个接口。<br>RunnableFuture</p>
<pre><code>这个接口同时继承Future接口和Runnable接口，在成功执行run（）方法后，可以通过Future访问执行结果。这个接口都实现类是FutureTask,一个可取消的异步计算，这个类提供了Future的基本实现，后面我们的demo也是用这个类实现，它实现了启动和取消一个计算，查询这个计算是否已完成，恢复计算结果。计算的结果只能在计算已经完成的情况下恢复。如果计算没有完成，get方法会阻塞，一旦计算完成，这个计算将不能被重启和取消，除非调用runAndReset方法。
FutureTask能用来包装一个Callable或Runnable对象，因为它实现了Runnable接口，而且它能被传递到Executor进行执行。为了提供单例类，这个类在创建自定义的工作类时提供了protected构造函数。
</code></pre><p>SchedualFuture</p>
<pre><code>这个接口表示一个延时的行为可以被取消。通常一个安排好的future是定时任务SchedualedExecutorService的结果
</code></pre><p>CompleteFuture</p>
<pre><code>一个Future类是显示的完成，而且能被用作一个完成等级，通过它的完成触发支持的依赖函数和行为。当两个或多个线程要执行完成或取消操作时，只有一个能够成功。
</code></pre><p>ForkJoinTask</p>
<pre><code>基于任务的抽象类，可以通过ForkJoinPool来执行。一个ForkJoinTask是类似于线程实体，但是相对于线程实体是轻量级的。大量的任务和子任务会被ForkJoinPool池中的真实线程挂起来，以某些使用限制为代价。
</code></pre><h3 id="dubbo-异步调用"><a href="#dubbo-异步调用" class="headerlink" title="dubbo 异步调用"></a>dubbo 异步调用</h3><p>基于 Dubbo 底层的异步 NIO 实现异步调用，对于 Provider 响应时间较长的场景是必须的，它能有效利用 Consumer 端的资源，相对于 Consumer 端使用多线程来说开销较小。<br>异步调用，对于 Provider 端不需要做特别的配置。下面的例子中，Provider 端接口定义如下：</p>
<pre><code>public interface AsyncService {
  String goodbye(String name);
}
</code></pre><h2 id="jdk1-8"><a href="#jdk1-8" class="headerlink" title="jdk1.8"></a>jdk1.8</h2><pre><code>HashMap
Lambda表达式
函数式接口
\*方法引用和构造器调用
Stream API
接口中的默认方法和静态方法
新时间日期API
</code></pre><h3 id="Map相关"><a href="#Map相关" class="headerlink" title="Map相关"></a>Map相关</h3><pre><code>在jdk1.8中对hashMap等map集合的数据结构优化。hashMap数据结构的优化
原来的hashMap采用的数据结构是哈希表（数组+链表），hashMap默认大小是16，一个0-15索引的数组，如何往里面存储元素，首先调用元素的hashcode
方法，计算出哈希码值，经过哈希算法算成数组的索引值，如果对应的索引处没有元素，直接存放，如果有对象在，那么比较它们的equals方法比较内容
如果内容一样，后一个value会将前一个value的值覆盖，如果不一样，在1.7的时候，后加的放在前面(头插法)，形成一个链表，形成了碰撞，在某些情况下如果链表
无限下去，那么效率极低，碰撞是避免不了的
加载因子：0.75，数组扩容，达到总容量的75%，就进行扩容，但是无法避免碰撞的情况发生
在1.8之后，在数组+链表+红黑树来实现hashMap，初始容量16.当碰撞的元素个数大于8时 &amp; 总容量大于64，会有红黑树的引入

static final int MIN_TREEIFY_CAPACITY = 64;
final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) {
    int n, index; Node&lt;K,V&gt; e;
    if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)
        resize();
    else if ((e = tab[index = (n - 1) &amp; hash]) != null) {
        TreeNode&lt;K,V&gt; hd = null, tl = null;
        do {
            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);
            if (tl == null)
                hd = p;
            else {
                p.prev = tl;
                tl.next = p;
            }
            tl = p;
        } while ((e = e.next) != null);
        if ((tab[index] = hd) != null)
            hd.treeify(tab);
    }
}
除了添加之后，效率都比链表高，1.8之后链表新进元素加到末尾
ConcurrentHashMap (锁分段机制)，concurrentLevel,jdk1.8采用CAS算法 和 synchronized(无锁算法，不再使用锁分段)，数组+链表中也引入了红黑树的使用
</code></pre><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>当一个接口中存在多个抽象方法时，如果使用lambda表达式，并不能智能匹配对应的抽象方法，因此引入了函数式接口的概念</p>
<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>简单来说就是只定义了一个抽象方法的接口（Object类的public方法除外），就是函数式接口，并且还提供了注解：@FunctionalInterface</p>
<p>Consumer <t>：消费型接口，有参无返回值<br>Supplier <t>：供给型接口，无参有返回值<br>Function <t,r>：函数式接口，有参有返回值<br>Predicate<t>： 断言型接口，有参有返回值，返回值是boolean类型</t></t,r></t></t></p>
<h3 id="方法引用和构造器调用"><a href="#方法引用和构造器调用" class="headerlink" title="方法引用和构造器调用"></a>方法引用和构造器调用</h3><p>a) 方法引用<br>三种表现形式：</p>
<pre><code>1. 对象::实例方法名
2. 类::静态方法名
3. 类::实例方法名 （lambda参数列表中第一个参数是实例方法的调用 者，第二个参数是实例方法的参数时可用
</code></pre><h3 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h3><p>Stream API<br>Stream操作的三个步骤</p>
<pre><code>创建stream
中间操作（过滤、map）
终止操作   (terminal)
</code></pre><p>stream的创建：</p>
<pre><code>// 1，校验通过Collection 系列集合提供的stream()或者paralleStream()
List&lt;String&gt; list = new ArrayList&lt;&gt;();
Strean&lt;String&gt; stream1 = list.stream();
// 2.通过Arrays的静态方法stream()获取数组流
String[] str = new String[10];
Stream&lt;String&gt; stream2 = Arrays.stream(str);
// 3.通过Stream类中的静态方法of
Stream&lt;String&gt; stream3 = Stream.of(&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;);
// 4.创建无限流
// 迭代
Stream&lt;Integer&gt; stream4 = Stream.iterate(0,(x) -&gt; x+2);
//生成
Stream.generate(() -&gt;Math.random());
</code></pre><p>Stream的中间操作:</p>
<pre><code>/**
   * 筛选 过滤  去重
   */
  emps.stream()
          .filter(e -&gt; e.getAge() &gt; 10)
          .limit(4)
          .skip(4)
          // 需要流中的元素重写hashCode和equals方法
          .distinct()
          .forEach(System.out::println);

  /**
   *  生成新的流 通过map映射
   */
  emps.stream()
          .map((e) -&gt; e.getAge())
          .forEach(System.out::println);

  /**
   *  自然排序  定制排序
   */
  emps.stream()
          .sorted((e1 ,e2) -&gt; {
              if (e1.getAge().equals(e2.getAge())){
                  return e1.getName().compareTo(e2.getName());
              } else{
                  return e1.getAge().compareTo(e2.getAge());
              }
          })
          .forEach(System.out::println);
</code></pre><p>Stream的终止操作：</p>
<pre><code>/**
        *      查找和匹配
        *      allMatch-检查是否匹配所有元素
        *      anyMatch-检查是否至少匹配一个元素
        *      noneMatch-检查是否没有匹配所有元素
        *      findFirst-返回第一个元素
        *      findAny-返回当前流中的任意元素
        *      count-返回流中元素的总个数
        *      max-返回流中最大值
        *      min-返回流中最小值
        */

       /**
        *  检查是否匹配元素
        */
       boolean b1 = emps.stream()
               .allMatch((e) -&gt; e.getStatus().equals(Employee.Status.BUSY));
       System.out.println(b1);

       boolean b2 = emps.stream()
               .anyMatch((e) -&gt; e.getStatus().equals(Employee.Status.BUSY));
       System.out.println(b2);

       boolean b3 = emps.stream()
               .noneMatch((e) -&gt; e.getStatus().equals(Employee.Status.BUSY));
       System.out.println(b3);

       Optional&lt;Employee&gt; opt = emps.stream()
               .findFirst();
       System.out.println(opt.get());

       // 并行流
       Optional&lt;Employee&gt; opt2 = emps.parallelStream()
               .findAny();
       System.out.println(opt2.get());

       long count = emps.stream()
               .count();
       System.out.println(count);

       Optional&lt;Employee&gt; max = emps.stream()
               .max((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary()));
       System.out.println(max.get());

       Optional&lt;Employee&gt; min = emps.stream()
               .min((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary()));
       System.out.println(min.get());
</code></pre><p>reduce操作： reduce:(T identity,BinaryOperator)/reduce(BinaryOperator)-可以将流中元素反复结合起来，得到一个值<br>collect操作：Collect-将流转换为其他形式，接收一个Collection接口的实现，用于给Stream中元素做汇总的方法</p>
<h3 id="接口中的默认方法和静态方法"><a href="#接口中的默认方法和静态方法" class="headerlink" title="接口中的默认方法和静态方法"></a>接口中的默认方法和静态方法</h3><p>default static方法</p>
<h3 id="新时间日期API"><a href="#新时间日期API" class="headerlink" title="新时间日期API"></a>新时间日期API</h3><p>(JDK1.8 新特性（全）)[<a href="https://blog.csdn.net/qq_29411737/article/details/80835658" target="_blank" rel="external">https://blog.csdn.net/qq_29411737/article/details/80835658</a>]<br>(Java8新特性，你应该了解这些！)[<a href="https://juejin.im/post/5ae6bfb66fb9a07a9b35bac1" target="_blank" rel="external">https://juejin.im/post/5ae6bfb66fb9a07a9b35bac1</a>]</p>
<h2 id="JVM相关"><a href="#JVM相关" class="headerlink" title="JVM相关"></a>JVM相关</h2><p>(全面理解Java内存模型)[<a href="https://blog.csdn.net/suifeng3051/article/details/52611310" target="_blank" rel="external">https://blog.csdn.net/suifeng3051/article/details/52611310</a>]</p>
<h3 id="JVM结构、内存分配、垃圾回收算法、垃圾收集器GC。下面我们一一来看。"><a href="#JVM结构、内存分配、垃圾回收算法、垃圾收集器GC。下面我们一一来看。" class="headerlink" title="JVM结构、内存分配、垃圾回收算法、垃圾收集器GC。下面我们一一来看。"></a>JVM结构、内存分配、垃圾回收算法、垃圾收集器GC。下面我们一一来看。</h3><p>重点讲了内存分配和垃圾回收算法</p>
<p>一、JVM结构<br>根据《java虚拟机规范》规定，JVM的基本结构一般如下图所示 ：</p>
<p><img src="https://s2.ax1x.com/2019/11/06/MPHspV.png" alt="MPHspV.png"><br>从左图可知，JVM主要包括四个部分：</p>
<p>1.类加载器（ClassLoader）:在JVM启动时或者在类运行时将需要的class加载到JVM中。（右图表示了从java源文件到JVM的整个过程，可配合理解。 关于类的加载机制，可以参考<a href="http://blog.csdn.net/tonytfjing/article/details/47212291）" target="_blank" rel="external">http://blog.csdn.net/tonytfjing/article/details/47212291）</a></p>
<p>2.执行引擎：负责执行class文件中包含的字节码指令（执行引擎的工作机制，这里也不细说了，这里主要介绍JVM结构）；</p>
<p>3.内存区（也叫运行时数据区）：是在JVM运行的时候操作所分配的内存区。运行时内存区主要可以划分为5个区域，如图：<br><img src="https://s2.ax1x.com/2019/11/06/MPHHXD.png" alt="MPHHXD.png"></p>
<p><strong>方法区(Method Area)</strong>：用于存储类结构信息的地方，包括常量池、静态变量、构造函数等。虽然JVM规范把方法区描述为堆的一个逻辑部分， 但它却有个别名non-heap（非堆），所以大家不要搞混淆了。方法区还包含一个运行时常量池。<br><strong>java堆(Heap)</strong>：存储java实例或者对象的地方。这块是GC的主要区域（后面解释）。从存储的内容我们可以很容易知道，方法区和堆是被所有java线程共享的。<br><strong>java栈(Stack)</strong>：java栈总是和线程关联在一起，每当创建一个线程时，JVM就会为这个线程创建一个对应的java栈。在这个java栈中又会包含多个栈帧，每运行一个方法就创建一个栈帧，用于存储<strong>局部变量表</strong>、<strong>操作栈</strong>、<strong>方法返回值</strong>等。每一个方法从调用直至执行完成的过程，就对应一个栈帧在java栈中入栈到出栈的过程。所以java栈是线程私有的。<br><strong>程序计数器(PC Register)</strong>：用于保存当前线程执行的内存地址。由于JVM程序是多线程执行的（线程轮流切换），所以为了保证线程切换回来后，还能恢复到原先状态，就需要一个独立的计数器，记录之前中断的地方，可见程序计数器也是线程私有的。<br><strong>本地方法栈(Native Method Stack)</strong>：和java栈的作用差不多，只不过是为JVM使用到的native方法服务的。</p>
<p>4.本地方法接口：主要是调用C或C++实现的本地方法及返回结果。</p>
<p>二、内存分配<br>我觉得了解垃圾回收之前，得先了解JVM是怎么分配内存的，然后识别哪些内存是垃圾需要回收，最后才是用什么方式回收。</p>
<p>Java的内存分配原理与C/C++不同，C/C++每次申请内存时都要malloc进行系统调用，而系统调用发生在内核空间，每次都要中断进行切换，这需要一定的开销，而Java虚拟机是先一次性分配一块较大的空间，然后每次new时都在该空间上进行分配和释放，减少了系统调用的次数，节省了一定的开销，这有点类似于内存池的概念；二是有了这块空间过后，如何进行分配和回收就跟GC机制有关了。</p>
<p>java一般内存申请有两种：<strong>静态内存和动态内存</strong>。很容易理解，编译时就能够确定的内存就是静态内存，即内存是固定的，系统一次性分配，比如int类型变量；动态内存分配就是在程序执行时才知道要分配的存储空间大小，比如java对象的内存空间。根据上面我们知道，java栈、程序计数器、本地方法栈都是<strong>线程私有</strong>的，线程生就生，线程灭就灭，栈中的栈帧随着方法的结束也会撤销，内存自然就跟着回收了。所以这几个区域的内存分配与回收是确定的，我们不需要管的。但是<strong>java堆和方法区则不一样</strong>，我们只有在程序运行期间才知道会创建哪些对象，所以这部分内存的分配和回收都是动态的。一般我们所说的垃圾回收也是针对的这一部分。</p>
<p>总之Stack的内存管理是顺序分配的，而且定长，不存在内存回收问题；而Heap 则是为java对象的实例随机分配内存，不定长度，所以存在内存分配和回收的问题；</p>
<p>三、垃圾检测、回收算法<br>垃圾收集器一般必须完成两件事：检测出垃圾；回收垃圾。怎么检测出垃圾？一般有以下几种方法：</p>
<p>引用计数法：给一个对象添加引用计数器，每当有个地方引用它，计数器就加1；引用失效就减1。</p>
<p>好了，问题来了，如果我有两个对象A和B，互相引用，除此之外，没有其他任何对象引用它们，实际上这两个对象已经无法访问，即是我们说的垃圾对象。但是互相引用，计数不为0，导致无法回收，所以还有另一种方法：<br>可达性分析算法：以根集对象为起始点进行搜索，如果有对象不可达的话，即是垃圾对象。这里的根集一般包括java栈中引用的对象、方法区常量池池中引用的对象<br>本地方法中引用的对象等。<br>总之，JVM在做垃圾回收的时候，会检查堆中的所有对象是否会被这些根集对象引用，不能够被引用的对象就会被垃圾收集器回收。一般回收算法也有如下几种：</p>
<p>1.标记-清除（Mark-sweep）</p>
<p>算法和名字一样，分为两个阶段：标记和清除。标记所有需要回收的对象，然后统一回收。这是最基础的算法，后续的收集算法都是基于这个算法扩展的。<br>不足：效率低；标记清除之后会产生大量碎片。效果图如下：</p>
<p>2.复制（Copying）<br>此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。此算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。当然，此算法的缺点也是很明显的，就是需要两倍内存空间。效果图如下：</p>
<p>3.标记-整理（Mark-Compact）<br>此算法结合了“标记-清除”和“复制”两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。效果图如下：<br>（1,2,3 图文摘自 <a href="http://pengjiaheng.iteye.com/blog/520228，感谢原作者。）" target="_blank" rel="external">http://pengjiaheng.iteye.com/blog/520228，感谢原作者。）</a></p>
<p>4.分代收集算法</p>
<p>这是当前商业虚拟机常用的垃圾收集算法。分代的垃圾回收策略，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。<br><strong>为什么要运用分代垃圾回收策略</strong>？在java程序运行的过程中，会产生大量的对象，因每个对象所能承担的职责不同所具有的功能不同所以也有着不一样的生命周期，有的对象生命周期较长，比如Http请求中的Session对象，线程，Socket连接等；有的对象生命周期较短，比如String对象，由于其不变类的特性，有的在使用一次后即可回收。试想，在不进行对象存活时间区分的情况下，每次垃圾回收都是对整个堆空间进行回收，那么消耗的时间相对会很长，而且对于存活时间较长的对象进行的扫描工作等都是徒劳。因此就需要引入分治的思想，所谓分治的思想就是因地制宜，将对象进行代的划分，把不同生命周期的对象放在不同的代上使用不同的垃圾回收方式。</p>
<p>如何划分？将对象按其生命周期的不同划分成：年轻代(Young Generation)、年老代(Old Generation)、持久代(Permanent Generation)。其中持久代主要存放的是类信息，所以与java对象的回收关系不大，与回收息息相关的是年轻代和年老代。这里有个比喻很形象</p>
<p>“假设你是一个普通的 Java 对象，你出生在 Eden 区，在 Eden 区有许多和你差不多的小兄弟、小姐妹，可以把 Eden 区当成幼儿园，在这个幼儿园里大家玩了很长时间。Eden 区不能无休止地放你们在里面，所以当年纪稍大，你就要被送到学校去上学，这里假设从小学到高中都称为 Survivor 区。开始的时候你在 Survivor 区里面划分出来的的“From”区，读到高年级了，就进了 Survivor 区的“To”区，中间由于学习成绩不稳定，还经常来回折腾。直到你 18 岁的时候，高中毕业了，该去社会上闯闯了。于是你就去了年老代，年老代里面人也很多。在年老代里，你生活了 20 年 (每次 GC 加一岁)，最后寿终正寝，被 GC 回收。有一点没有提，你在年老代遇到了一个同学，他的名字叫爱德华 (慕光之城里的帅哥吸血鬼)，他以及他的家族永远不会死，那么他们就生活在永生代。”</p>
<p>具体区域可以通过VisualVM中的VisaulGC插件查看</p>
<p>年轻代：是所有新对象产生的地方。年轻代被分为3个部分——Eden区和两个Survivor区（From和to）当Eden区被对象填满时，就会执行Minor GC。并把所有存活下来的对象转移到其中一个survivor区（假设为from区）。Minor GC同样会检查存活下来的对象，并把它们转移到另一个survivor区（假设为to区）。这样在一段时间内，总会有一个空的survivor区。经过多次GC周期后，仍然存活下来的对象会被转移到年老代内存空间。通常这是在年轻代有资格提升到年老代前通过设定年龄阈值来完成的。需要注意，Survivor的两个区是对称的，没先后关系，from和to是相对的。</p>
<p>年老代：在年轻代中经历了N次回收后仍然没有被清除的对象，就会被放到年老代中，可以说他们都是久经沙场而不亡的一代，都是生命周期较长的对象。对于年老代和永久代，就不能再采用像年轻代中那样搬移腾挪的回收算法，因为那些对于这些回收战场上的老兵来说是小儿科。通常会在老年代内存被占满时将会触发Full GC,回收整个堆内存。</p>
<p>持久代：用于存放静态文件，比如java类、方法等。持久代对垃圾回收没有显著的影响。</p>
<p>分代回收的效果图如下：<br><img src="https://s2.ax1x.com/2019/11/06/MPqi26.png" alt="MPqi26.png"></p>
<p>我这里之所以最后讲分代，是因为分代里涉及了前面几种算法。年轻代：涉及了复制算法；年老代：涉及了“标记-整理（Mark-Sweep）”的算法。</p>
<p>四、垃圾收集器<br>垃圾收集算法是内存回收的方法论，而实现这些方法论的则是垃圾收集器。不同厂商不同版本JVM所提供的垃圾收集器可能不同，这里参照《深入理解Java虚拟机》说的是JDK1.7版本Hotspot虚拟机，关于垃圾收集器有篇博文总结的不错，我就不说了，详见：<a href="http://blog.csdn.net/java2000_wl/article/details/8030172" target="_blank" rel="external">http://blog.csdn.net/java2000_wl/article/details/8030172</a></p>
<pre><code>栈帧里面包含哪些数据结构
方法执行时在JVM中是怎么保存的
</code></pre><h3 id="深入理解Java虚拟机笔记—运行时栈帧结构"><a href="#深入理解Java虚拟机笔记—运行时栈帧结构" class="headerlink" title="深入理解Java虚拟机笔记—运行时栈帧结构"></a>深入理解Java虚拟机笔记—运行时栈帧结构</h3><p><a href="https://blog.csdn.net/xtayfjpk/article/details/41924283?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">https://blog.csdn.net/xtayfjpk/article/details/41924283?utm_source=tuicool&amp;utm_medium=referral</a></p>
<pre><code>1.局部变量表
2.操作数栈
3.动态链接
4.方法返回地址
5.附加信息
</code></pre><h2 id="Java内存溢出和内存泄漏"><a href="#Java内存溢出和内存泄漏" class="headerlink" title="Java内存溢出和内存泄漏"></a>Java内存溢出和内存泄漏</h2><p>内存泄露：指程序中动态分配内存给一些临时对象，但是对象不会被GC所回收，它始终占用内存。即被分配的对象可达但已无用。<br>内存溢出：指程序运行过程中无法申请到足够的内存而导致的一种错误。内存溢出通常发生于OLD段或Perm段垃圾回收后，仍然无内存空间容纳新的Java对象的情况(OOM)。<br>从定义上可以看出内存泄露是内存溢出的一种诱因，不是唯一因素。</p>
<p>内存泄露分类：</p>
<pre><code>1.常发性内存泄漏。发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。
2.偶发性内存泄漏。发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。
3.一次性内存泄漏。发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。比如，在类的构造函数中分配内存，在析构函数中却没有释放该内存，所以内存泄漏只会发生一次。
4.隐式内存泄漏。程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。
</code></pre><h3 id="内存泄露举例"><a href="#内存泄露举例" class="headerlink" title="内存泄露举例"></a>内存泄露举例</h3><p>1.对象生命周期引发的内存泄露<br>我们知道，对象都是有生命周期的，有的长，有的短，如果长生命周期的对象持有短生命周期的引用，就很可能会出现内存泄露。如下：</p>
<pre><code>Object obj ;
public void test(){
    obj = new Object();
//其他代码
}
</code></pre><p>这里的object实例，其实我们期望它只作用于test()方法中，且其他地方不会再用到它，但是，当test()方法执行完成后，object对象所分配的内存不会马上被认为是可以被释放的对象，只有在Simple类创建的对象被释放后才会被释放，严格的说，这就是一种内存泄露。解决方法就是将object作为test()方法中的局部变量。当然，如果一定要这么写，可以改为这样：</p>
<pre><code>Object obj ;
public void test(){
    obj = new Object();
    //其他代码
    obj = null;
}
</code></pre><p>2.容器使用发生的内存泄漏</p>
<pre><code>void test1(){
    Vector vector = new Vector();
    for (int i = 1; i&lt;100; i++){
        Object object = new Object();
        vector.add(object);
        object = null;
    }
    //...对vector的操作
    //...与vector无关的其他操作
}
</code></pre><p>这里内存泄露指的是在对vector操作完成之后，执行下面与vector无关的代码时，如果发生了GC操作，这一系列的object是没法被回收的，而此处的内存泄露可能是短暂的，因为在整个test1()方法执行完成后，那些对象还是可以被回收。这里要解决很简单，手动赋值为 null 即可。</p>
<pre><code>void test1(){
    Vector vector = new Vector();
    for (int i = 1; i&lt;100; i++) {
        Object object = new Object();
        vector.add(object);
        object = null;
    }
    //...对v的操作
    vector = null;
    //...与v无关的其他操作
}
</code></pre><h3 id="内存溢出类型及解决"><a href="#内存溢出类型及解决" class="headerlink" title="内存溢出类型及解决"></a>内存溢出类型及解决</h3><p>（1）java.lang.OutOfMemoryError: PermGen space<br>PermGen space 的全称是 Permanent Generation space, 是指内存的永久保存区域。这块内存主要是被JVM存放Class和Meta信息的，Class在被Loader时就会被放到PermGenspace中，它和存放类实例(Instance)的Heap区域不同，GC不会在主程序运行期对PermGen space进行清理。<br>JVM由XX:PermSize设置非堆内存初始值，默认是物理内存的1/64；<br>JVM由XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4。<br>该错误常见场合：</p>
<pre><code>a) 应用中有很多Class，web服务器对JSP进行precompile时。
b) Webapp下用了大量的第三方jar,其大小超过了JVM默认的大小(4M)时。
</code></pre><p>（2） java.lang.OutOfMemoryError:Java heap space</p>
<p>在JVM中如果98%的时间是用于GC且可用的Heap size不足2%的时候将抛出此异常信息。<br>JVM初始分配的内存由-Xms指定，默认是物理内存的1/64；<br>JVM最大分配的内存由-Xmx指定，默认是物理内存的1/4。<br>导致OutOfMemoryError异常的常见原因有以下几种：</p>
<pre><code>内存中加载的数据量过于庞大，如一次从数据库取出过多数据；
集合类中有对对象的引用，使用完后未清空，使得JVM不能回收；
代码中存在死循环或循环产生过多重复的对象实体；
使用的第三方软件中的BUG；
启动参数内存值设定的过小；
</code></pre><p>Java代码导致OutOfMemoryError错误的解决：<br>需要重点排查以下几点：</p>
<pre><code>检查代码中是否有死循环或递归调用。
检查是否有大循环重复产生新对象实体。
检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。
检查List、MAP等集合对象是否有使用完后，未清除的问题。List、MAP等集合对象会始终存有对对象的引用，使得这些对象不能被GC回收。
</code></pre><h2 id="redis相关"><a href="#redis相关" class="headerlink" title="redis相关"></a>redis相关</h2><h2 id="redis-配置"><a href="#redis-配置" class="headerlink" title="redis 配置"></a>redis 配置</h2><h3 id="redis-高可用-—-主从哨兵模式（更好的去判断主机是否出故障）"><a href="#redis-高可用-—-主从哨兵模式（更好的去判断主机是否出故障）" class="headerlink" title="redis 高可用 —- 主从哨兵模式（更好的去判断主机是否出故障）"></a>redis 高可用 —- 主从哨兵模式（更好的去判断主机是否出故障）</h3><p><strong>单独配置主从的问题</strong><br>Redis的主从复制模式下。一旦主节点由于故障不能提供服务，需要手动将从节点晋升为主节点，同时还要通知客户端更新 主节点地址，这种故障处理方式从一定程度上是无法接受的。Redis 2.8 以后提供了 Redis Sentinel 哨兵机制 来解决这个问题。</p>
<p>在 Redis 层面，高可用 的含义要宽泛一些，除了保证提供 正常服务（如 主从分离、快速容灾技术 等），还需要考虑 数据容量扩展、数据安全 等等。<br>在 Redis 中，实现 高可用 的技术主要包括 <strong>持久化、复制、哨兵 和 集群</strong>，下面简单说明它们的作用，以及解决了什么样的问题：</p>
<p>持久化：</p>
<pre><code>持久化是 最简单的 高可用方法。它的主要作用是数据备份，即将数据存储在硬盘，保证数据不会因进程退出而丢失。
</code></pre><p>复制：<strong>数据的多机备份</strong></p>
<pre><code>复制是高可用 Redis 的基础，哨兵 和 集群 都是在 复制基础 上实现高可用的。复制主要实现了数据的多机备份以及对于读操作的负载均衡和简单的故障恢复。缺陷是故障恢复无法自动化、写操作无法负载均衡、存储能力受到单机的限制。
</code></pre><p>哨兵：<strong>自动化的故障恢复</strong></p>
<pre><code>在复制的基础上，哨兵实现了自动化的故障恢复。缺陷是 写操作 无法 负载均衡，存储能力 受到 单机 的限制。
</code></pre><p>集群：</p>
<pre><code>通过集群，Redis 解决了写操作无法 负载均衡以及存储能力受到单机限制的问题，实现了较为完善的高可用方案。
</code></pre><p>本文首先对 Redis 实现高可用的几种模式做出了阐述，指出了 Redis 主从复制 的不足之处，进一步引入了RedisSentinel哨兵模式的相关概念，深入说明了RedisSentinel的具体功能，基本原理，高可用搭建和自动故障切换验证等。<br>当然，Redis Sentinel 仅仅解决了 高可用 的问题，对于 主节点 单点写入和单节点无法扩容等问题，还需要引入 Redis Cluster 集群模式 予以解决。</p>
<h3 id="Redis-Sentinel的基本概念"><a href="#Redis-Sentinel的基本概念" class="headerlink" title="Redis Sentinel的基本概念"></a>Redis Sentinel的基本概念</h3><p>Redis Sentinel 是 Redis 高可用 的实现方案。Sentinel 是一个管理多个 Redis 实例的工具，它可以实现对 Redis 的 监控、通知、自动故障转移。下面先对 Redis Sentinel 的 基本概念 进行简单的介绍。</p>
<table>
<thead>
<tr>
<th style="text-align:right">基本名词</th>
<th style="text-align:center">逻辑结构</th>
<th style="text-align:left">物理结构</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">Redis数据节点</td>
<td style="text-align:center">主节点和从节点</td>
<td style="text-align:left">主节点和从节点的进程</td>
</tr>
<tr>
<td style="text-align:right">主节点(master)</td>
<td style="text-align:center">Redis主数据库</td>
<td style="text-align:left">一个独立的Redis进程</td>
</tr>
<tr>
<td style="text-align:right">从节点(slave)</td>
<td style="text-align:center">Redis从数据库</td>
<td style="text-align:left">一个独立的Redis进程</td>
</tr>
<tr>
<td style="text-align:right">Sentinel节点</td>
<td style="text-align:center">监控Redis数据节点</td>
<td style="text-align:left">一个独立的Sentinel进程</td>
</tr>
<tr>
<td style="text-align:right">Sentinel节点集合</td>
<td style="text-align:center">若干Sentinel节点的抽象组合</td>
<td style="text-align:left">若干Sentinel节点进程</td>
</tr>
<tr>
<td style="text-align:right">Redis Sentinel</td>
<td style="text-align:center">Redis高可用实现方案</td>
<td style="text-align:left">Sentinel节点集合和Redis数据节点进程</td>
</tr>
<tr>
<td style="text-align:right">应用客户端</td>
<td style="text-align:center">泛指一个或多个客户端</td>
<td style="text-align:left">一个或者多个客户端进程或者线程</td>
</tr>
</tbody>
</table>
<h3 id="主从复制-同时存在以下几个问题："><a href="#主从复制-同时存在以下几个问题：" class="headerlink" title="主从复制 同时存在以下几个问题："></a>主从复制 同时存在以下几个问题：</h3><p>第一点：一旦主节点宕机，从节点晋升成主节点，同时需要修改应用方 的 主节点地址，还需要命令所有 从节点 去 复制 新的主节点，整个过程需要 人工干预。<br>第二点：主节点 的 写能力 受到 单机的限制。<br>第三点：主节点 的 存储能力 受到 单机的限制。<br>第四点：原生复制 的弊端在早期的版本中也会比较突出，比如：Redis 复制中断 后，从节点 会发起 psync。此时如果 同步不成功，则会进行 全量同步，主库 执行 全量备份 的同时，可能会造成毫秒或秒级的 卡顿。</p>
<h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p><img src="https://s2.ax1x.com/2019/11/07/MFJ75V.png" alt="MFJ75V.png"><br>Sentinel 的主要功能包括 <strong>主节点存活检测</strong>、<strong>主从运行情况检测</strong>、<strong>自动故障转移 （failover）</strong>、<strong>主从切换</strong>。Redis 的 Sentinel 最小配置是 一主一从。</p>
<p>Redis 的 Sentinel 系统可以用来管理多个 Redis 服务器，该系统可以执行以下四个任务：</p>
<p>监控</p>
<pre><code>Sentinel 会不断的检查 主服务器 和 从服务器 是否正常运行。
</code></pre><p>通知</p>
<pre><code>当被监控的某个 Redis 服务器出现问题，Sentinel 通过 API 脚本 向 管理员 或者其他的 应用程序 发送通知。
</code></pre><p>自动故障转移</p>
<pre><code>当 主节点 不能正常工作时，Sentinel 会开始一次 自动的 故障转移操作，它会将与 失效主节点 是 主从关系 的其中一个 从节点 升级为新的 主节点，并且将其他的 从节点 指向 新的主节点。
</code></pre><p>配置提供者</p>
<pre><code>在 Redis Sentinel 模式下，客户端应用 在初始化时连接的是 Sentinel 节点集合，从中获取 主节点 的信息。
</code></pre><h3 id="主观下线和客观下线（目标不同）"><a href="#主观下线和客观下线（目标不同）" class="headerlink" title="主观下线和客观下线（目标不同）"></a>主观下线和客观下线（目标不同）</h3><p>默认情况下，每个 Sentinel 节点会以 每秒一次 的频率对 Redis 节点和 其它 的 Sentinel 节点发送 PING 命令，并通过节点的 回复 来判断节点是否在线。</p>
<p>主观下线<br>主观下线 适用于所有 <strong>主节点 和 从节点</strong>。如果在 down-after-milliseconds 毫秒内，Sentinel 没有收到 目标节点 的有效回复，则会判定 该节点 为 主观下线。</p>
<p>客观下线<br>客观下线 只适用于 <strong>主节点</strong>。如果 主节点 出现故障，Sentinel 节点会通过 sentinel is-master-down-by-addr 命令，向其它 Sentinel 节点询问对该节点的 状态判断。如果超过 &lt;quorum&gt; 个数的节点判定 主节点 不可达，则该 Sentinel 节点会判断 主节点 为 客观下线。</p>
<h3 id="Sentinel的通信命令"><a href="#Sentinel的通信命令" class="headerlink" title="Sentinel的通信命令"></a>Sentinel的通信命令</h3><p>Sentinel 节点连接一个 Redis 实例的时候，会创建 cmd 和 pub/sub 两个 连接。Sentinel 通过 cmd 连接给 Redis 发送命令，通过 pub/sub 连接到 Redis 实例上的其他 Sentinel 实例。<br>Sentinel 与 Redis 主节点 和 从节点 交互的命令，主要包括：</p>
<p>命令         作 用<br>PING        Sentinel 向 Redis 节点发送 PING 命令，检查节点的状态<br>INFO        Sentinel 向 Redis 节点发送 INFO 命令，获取它的 从节点信息<br>PUBLISH     Sentinel 向其监控的 Redis 节点 <strong>sentinel</strong>:hello 这个 channel 发布 自己的信息 及 主节点 相关的配置<br>SUBSCRIBE   Sentinel 通过订阅 Redis 主节点 和 从节点 的 <strong>sentinel</strong>:hello 这个 channnel，获取正在监控相同服务的其他 Sentinel 节点<br>Sentinel 与 Sentinel 交互的命令，主要包括：</p>
<p>命令                              作 用<br>PING                              Sentinel 向其他 Sentinel 节点发送 PING 命令，检查节点的状态<br>SENTINEL:is-master-down-by-addr   和其他 Sentinel 协商 主节点 的状态，如果 主节点 处于 SDOWN 状态，则投票自动选出新的 主节点</p>
<h3 id="Redis-Sentinel的工作原理"><a href="#Redis-Sentinel的工作原理" class="headerlink" title="Redis Sentinel的工作原理"></a>Redis Sentinel的工作原理</h3><p>每个 Sentinel 节点都需要 定期执行 以下任务：<br><strong>1.每个 Sentinel 以 每秒钟 一次的频率，向它所知的 主服务器、从服务器 以及其他 Sentinel 实例 发送一个 PING 命令。</strong></p>
<p><img src="https://s2.ax1x.com/2019/11/07/MFNGEn.png" alt="MFNGEn.png"></p>
<p><strong>2.如果一个 实例（instance）距离 最后一次 有效回复 PING 命令的时间超过 down-after-milliseconds 所指定的值，那么这个实例会被 Sentinel 标记为 主观下线。</strong><br><strong>3.如果一个 主服务器 被标记为 主观下线，那么正在 监视 这个 主服务器 的所有 Sentinel 节点，要以 每秒一次 的频率确认 主服务器 的确进入了 主观下线 状态。</strong><br><strong>4.如果一个 主服务器 被标记为 主观下线，并且有 足够数量 的 Sentinel（至少要达到 配置文件 指定的数量）在指定的 时间范围 内同意这一判断，那么这个 主服务器 被标记为 客观下线。</strong><br><strong>5.在一般情况下， 每个 Sentinel 会以每 10 秒一次的频率，向它已知的所有 主服务器 和 从服务器 发送 INFO 命令。当一个 主服务器 被 Sentinel 标记为 客观下线 时，Sentinel 向 下线主服务器 的所有 从服务器 发送 INFO 命令的频率，会从 10 秒一次改为 每秒一次。</strong><br><strong>6.Sentinel 和其他 Sentinel 协商 主节点 的状态，如果 主节点 处于 SDOWN 状态，则投票自动选出新的 主节点。将剩余的 从节点 指向 新的主节点 进行 数据复制。</strong><br><strong>7.当没有足够数量的 Sentinel 同意主服务器下线时，主服务器的客观下线状态就会被移除。当主服务器重新向Sentinel的PING命令返回有效回复时，主服务器的主观下线状态就会被移除。</strong></p>
<p>写的挺好的：(<a href="https://www.jianshu.com/p/0f58475c6918)[https://www.jianshu.com/p/0f58475c6918" target="_blank" rel="external">https://www.jianshu.com/p/0f58475c6918)[https://www.jianshu.com/p/0f58475c6918</a>]</p>
<h3 id="redis集群原理"><a href="#redis集群原理" class="headerlink" title="redis集群原理"></a>redis集群原理</h3><p>Redis Cluster 集群模式通常具有 高可用、可扩展性、分布式、容错 等特性。Redis 分布式方案一般有两种：<br>客户端分区方案<br>客户端 就已经决定数据会被 存储 到哪个 redis 节点或者从哪个 redis 节点 读取数据。其主要思想是采用 哈希算法 将 Redis 数据的 key 进行散列，通过 hash 函数，特定的 key会 映射 到特定的 Redis 节点上。</p>
<p>代理分区方案<br>客户端 发送请求到一个 代理组件，代理 解析 客户端 的数据，并将请求转发至正确的节点，最后将结果回复给客户端。<br>优点：简化 客户端 的分布式逻辑，客户端 透明接入，切换成本低，代理的 转发 和 存储 分离。<br>缺点：多了一层 代理层，加重了 架构部署复杂度 和 性能损耗。</p>
<h3 id="Redis集群的概念"><a href="#Redis集群的概念" class="headerlink" title="Redis集群的概念"></a>Redis集群的概念</h3><p>介绍<br>Redis 集群是一个可以在多个 Redis 节点之间进行数据共享的设施（installation）。<br>Redis 集群不支持那些需要同时处理多个键的 Redis 命令， 因为执行这些命令需要在多个 Redis 节点之间移动数据， 并且在高负载的情况下， 这些命令将降低 Redis 集群的性能， 并导致不可预测的错误。<br>Redis 集群通过<strong>分区</strong>（partition）来提供一定程度的可用性（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。<br>Redis 集群提供了以下两个好处：</p>
<pre><code>将数据自动切分（split）到多个节点的能力。
当集群中的一部分节点失效或者无法进行通讯时， 仍然可以继续处理命令请求的能力。
</code></pre><h3 id="数据分片"><a href="#数据分片" class="headerlink" title="数据分片"></a>数据分片</h3><p>Redis 集群使用数据分片（sharding）而非一致性哈希（consistency hashing）来实现： 一个 Redis 集群包含 16384 个哈希槽（hash slot）， 数据库中的每个键都属于这 16384 个哈希槽的其中一个， 集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和 。</p>
<p>集群中的每个节点负责处理一部分哈希槽。 举个例子， 一个集群可以有三个哈希槽， 其中：</p>
<p>节点 A 负责处理 0 号至 5500 号哈希槽。<br>节点 B 负责处理 5501 号至 11000 号哈希槽。<br>节点 C 负责处理 11001 号至 16384 号哈希槽。<br>这种将哈希槽分布到不同节点的做法使得用户可以很容易地向集群中添加或者删除节点。 比如说：<br>我现在想设置一个key,叫my_name:</p>
<p>set my_name wangdi</p>
<p>按照Redis Cluster的哈希槽算法，CRC16(‘my_name’)%16384 = 2412 那么这个key就被分配到了节点A上<br>同样的，当我连接(A,B,C)的任意一个节点想获取my_name这个key,都会转到节点A上<br>再比如<br>如果用户将新节点 D 添加到集群中， 那么集群只需要将节点 A 、B 、 C 中的某些槽移动到节点 D 就可以了。<br>增加一个D节点的结果可能如下：</p>
<p>节点A覆盖1365-5460<br>节点B覆盖6827-10922<br>节点C覆盖12288-16383<br>节点D覆盖0-1364,5461-6826,10923-1228<br>与此类似， 如果用户要从集群中移除节点 A ， 那么集群只需要将节点 A 中的所有哈希槽移动到节点 B 和节点 C ， 然后再移除空白（不包含任何哈希槽）的节点 A 就可以了。<br>因为将一个哈希槽从一个节点移动到另一个节点不会造成节点阻塞， 所以无论是添加新节点还是移除已存在节点， 又或者改变某个节点包含的哈希槽数量， 都不会造成集群下线。<br>所以,Redis Cluster的模型大概是这样的形状</p>
<h3 id="主从复制模型-—-主从模型"><a href="#主从复制模型-—-主从模型" class="headerlink" title="主从复制模型 —- 主从模型"></a>主从复制模型 —- 主从模型</h3><p>为了使得集群在一部分节点下线或者无法与集群的大多数（majority）节点进行通讯的情况下， 仍然可以正常运作， Redis 集群对节点使用了主从复制功能： 集群中的每个节点都有 1 个至 N 个复制品（replica）， 其中一个复制品为主节点（master）， 而其余的 N-1 个复制品为从节点（slave）。</p>
<p>在之前列举的节点 A 、B 、C 的例子中， 如果节点 B 下线了， 那么集群将无法正常运行， 因为集群找不到节点来处理 5501 号至 11000号的哈希槽。</p>
<p>另一方面， 假如在创建集群的时候（或者至少在节点 B 下线之前）， 我们为主节点 B 添加了从节点 B1 ， 那么当主节点 B 下线的时候， 集群就会将 B1 设置为新的主节点， 并让它代替下线的主节点 B ， 继续处理 5501 号至 11000 号的哈希槽， 这样集群就不会因为主节点 B 的下线而无法正常运作了。<br>不过如果节点 B 和 B1 都下线的话， Redis 集群还是会停止运作。</p>
<h3 id="Redis一致性保证"><a href="#Redis一致性保证" class="headerlink" title="Redis一致性保证"></a>Redis一致性保证</h3><p>Redis 并不能保证数据的强一致性. 这意味这在实际中集群在特定的条件下可能会丢失写操作：<br>第一个原因是因为集群是用了异步复制. 写操作过程:</p>
<pre><code>客户端向主节点B写入一条命令.
主节点B向客户端回复命令状态.
主节点将写操作复制给他得从节点 B1, B2 和 B3
主节点对命令的复制工作发生在返回命令回复之后， 因为如果每次处理命令请求都需要等待复制操作完成的话， 那么主节点处理命令请求的速度将极大地降低 —— 我们必须在性能和一致性之间做出权衡。 注意：Redis 集群可能会在将来提供同步写的方法。 Redis 集群另外一种可能会丢失命令的情况是集群出现了网络分区， 并且一个客户端与至少包括一个主节点在内的少数实例被孤立。
举个例子 假设集群包含 A 、 B 、 C 、 A1 、 B1 、 C1 六个节点， 其中 A 、B 、C 为主节点， A1 、B1 、C1 为A，B，C的从节点， 还有一个客户端 Z1 假设集群中发生网络分区，那么集群可能会分为两方，大部分的一方包含节点 A 、C 、A1 、B1 和 C1 ，小部分的一方则包含节点 B 和客户端 Z1 .
Z1仍然能够向主节点B中写入, 如果网络分区发生时间较短,那么集群将会继续正常运作,如果分区的时间足够让大部分的一方将B1选举为新的master，那么Z1写入B中得数据便丢失了.
注意，在网络分裂出现期间，客户端Z1可以向主节点B发送写命令的最大时间是有限制的， 这一时间限制称为节点超时时间（node timeout）， 是 Redis 集群的一个重要的配置选项
</code></pre><p>(深入剖析Redis系列(三) - Redis集群模式搭建与原理详解)[<a href="https://www.jianshu.com/p/f4a7775bc4a9" target="_blank" rel="external">https://www.jianshu.com/p/f4a7775bc4a9</a>]<br>(Redis集群的原理和搭建)[<a href="https://www.jianshu.com/p/c869feb5581d" target="_blank" rel="external">https://www.jianshu.com/p/c869feb5581d</a>]</p>
<h2 id="rocketMq相关"><a href="#rocketMq相关" class="headerlink" title="rocketMq相关"></a>rocketMq相关</h2><h2 id="1-rocketMq有哪些组件组成？"><a href="#1-rocketMq有哪些组件组成？" class="headerlink" title="1.rocketMq有哪些组件组成？"></a>1.rocketMq有哪些组件组成？</h2><p>(RocketMq使用的注意事项)[<a href="https://www.jianshu.com/p/cc108aeb08ac" target="_blank" rel="external">https://www.jianshu.com/p/cc108aeb08ac</a>]</p>
<pre><code>namesrv是干嘛的？
broker topic queue这三者的关系
</code></pre><p><img src="https://s2.ax1x.com/2019/11/06/MCeyZ9.png" alt="MCeyZ9.png"><br><strong>Topic</strong><br>一个Topic是一个主题。一个系统中，我们可以将消息划成Topic，这样，将不同的消息发送到不同的queue。</p>
<p><strong>Queue</strong><br>一个topic下，我们可以设置多个queue，每个queue就是我们平时所说的消息队列；因为queue是完全从属于某个特定的topic的，所以当我们要发送消息时，总是要指定该消息所属的topic是什么。然后equeue就能知道该topic下有几个queue了。但是到底发送到哪个queue呢？比如一个topic下有4个queue，那对于这个topic下的消息，发送时，到底该发送到哪个queue呢？那<strong>必定有个消息被路由</strong>的过程。目前equeue的做法是在发送一个消息时，需要用户指定这个消息对应的topic以及一个用来路由的一个object类型的参数。equeue会根据topic得到所有的queue，然后根据该object参数通过<strong>hash code</strong>然后取模queue的个数最后得到要发送的queue的编号，从而知道该发送到哪个queue。这个路由消息的过程是在发送消息的这一方做的，也就是下面要说的producer。之所以不在消息服务器上做是因为这样可以让用户自己决定该如何路由消息，具有更大的灵活性。</p>
<p><strong>producer</strong><br>就是消息队列的生产者。我们知道，消息队列的本质就是实现了publish-subscribe的模式，即生产者-消费者模式。生产者生产消息，消费者消费消息。所以这里的Producer就是用来生产和发送消息的。</p>
<p><strong>Consumer</strong><br>就是消息队列的消费者，一个消息可以有多个消费者。</p>
<p><strong>Consumer Group</strong><br>消费者分组，这可能对大家来说是一个新概念。之所以要搞出一个消费者分组，是为了实现下面要说的集群消费。一个消费者分组中包含了一些消费者，如果这些消费者是要集群消费，那这些消费者会平均消费该分组中的消息。</p>
<p><strong>Broker</strong><br>equeue中的broker负责消息的中转，即接收producer发送过来的消息，然后持久化消息到磁盘，然后接收consumer发送过来的拉取消息的请求，然后根据请求拉取相应的消息给consumer。所以，broker可以理解为消息队列服务器，提供消息的接收、存储、拉取服务。可见，broker对于equeue来说是核心，它绝对不能挂，一旦挂了，那producer，consumer就无法实现publish-subscribe了。</p>
<p><strong>集群消费</strong><br>集群消费是指，一个consumer group下的consumer，平均消费topic下的queue。具体如何平均可以看一下下面的架构图，这里先用文字简单描述一下。假如一个topic下有4个queue，然后当前有一个consumer group，该分组下有4个consumer，那每个consumer就被分配到该topic下的一个queue，这样就达到了平均消费topic下的queue的目的。如果consumer group下只有两个consumer，那每个consumer就消费2个queue。如果有3个consumer，则第一个消费2个queue，后面两个每个消费一个queue，从而达到尽量平均消费。所以，可以看出，我们应该尽量让consumer group下的<strong>consumer的数目和topic的queue的数目一致或成倍数关系</strong>。这样每个consumer消费的queue的数量总是一样的，这样每个consumer服务器的压力才会差不多。当前前提是这个topic下的每个queue里的消息的数量总是差不多多的。这点我们可以对消息根据某个用户自己定义的key来进行hash路由来保证。</p>
<p><strong>广播消费</strong><br>广播消费是指一个consumer只要订阅了某个topic的消息，那它就会收到该topic下的所有queue里的消息，而不管这个consumer的group是什么。所以对于广播消费来说，consumer group没什么实际意义。consumer可以在实例化时，我们可以指定是集群消费还是广播消费。</p>
<p><strong>消费进度</strong><br>消费进度是指，当一个consumer group里的consumer在消费某个queue里的消息时，equeue是通过记录消费位置(offset)来知道当前消费到哪里了。以便该consumer重启后继续从该位置开始消费。比如一个topic有4个queue，一个consumer group有4个consumer，则每个consumer分配到一个queue，然后每个consumer分别消费自己的queue里的消息。equeue会分别记录每个consumer对其queue的消费进度，从而保证每个consumer重启后知道下次从哪里开始继续消费。实际上，也许下次重启后不是由该consumer消费该queue了，而是由group里的其他consumer消费了，这样也没关系，因为我们已经记录了这个<strong>queue的消费位置了</strong>。所以可以看出，消费位置和consumer其实无关，消费位置完全是queue的一个属性，用来记录当前被消费到哪里了。另外一点很重要的是，一个topic可以被多个consumer group里的consumer订阅。不同consumer group里的consumer即便是消费同一个topic下的同一个queue，那消费进度也是分开存储的。也就是说，不同的consumer group内的consumer的消费完全隔离，彼此不受影响。还有一点就是，对于集群消费和广播消费，消费进度持久化的地方是不同的，集群消费的消费进度是放在broker，也就是消息队列服务器上的，而广播消费的消费进度是存储在consumer本地磁盘上的。之所以这样设计是因为，对于集群消费，由于一个queue的消费者可能会更换，因为consumer group下的consumer数量可能会增加或减少，然后就会重新计算每个consumer该消费的queue是哪些，这个能理解的把？所以，当出现一个queue的consumer变动的时候，新的consumer如何知道该从哪里开始消费这个queue呢？如果这个queue的消费进度是存储在前一个consumer服务器上的，那就很难拿到这个消费进度了，因为有可能那个服务器已经挂了，或者下架了，都有可能。而因为broker对于所有的consumer总是在服务的，所以，在集群消费的情况下，被订阅的topic的queue的消费位置是存储在broker上的，存储的时候按照不同的consumer group做隔离，以确保不同的consumer group下的consumer的消费进度互补影响。然后，对于广播消费，由于不会出现一个queue的consumer会变动的情况，所以我们没必要让broker来保存消费位置，所以是保存在consumer自己的服务器上。</p>
<h2 id="2-阿里RocketMQ如何解决消息的顺序-amp-重复两大硬伤？"><a href="#2-阿里RocketMQ如何解决消息的顺序-amp-重复两大硬伤？" class="headerlink" title="2.阿里RocketMQ如何解决消息的顺序&amp;重复两大硬伤？"></a>2.阿里RocketMQ如何解决消息的顺序&amp;重复两大硬伤？</h2><p>(阿里RocketMQ如何解决消息的顺序&amp;重复两大硬伤（内容很丰富）)[<a href="https://dbaplus.cn/news-73-1123-1.html" target="_blank" rel="external">https://dbaplus.cn/news-73-1123-1.html</a>]<br>RocketMQ作为阿里开源的一款高性能、高吞吐量的消息中间件，它是怎样来解决这两个问题的？RocketMQ有哪些关键特性？其实现原理是怎样的？</p>
<h3 id="核心-世界上解决一个计算机问题最简单的方法：“恰好”不需要解决它！——沈询"><a href="#核心-世界上解决一个计算机问题最简单的方法：“恰好”不需要解决它！——沈询" class="headerlink" title="核心:世界上解决一个计算机问题最简单的方法：“恰好”不需要解决它！——沈询"></a>核心:世界上解决一个计算机问题最简单的方法：“恰好”不需要解决它！——沈询</h3><p>不关注乱序的应用实际大量存在<br>队列无序并不意味着消息无序</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>RocketMQ通过轮询所有队列的方式来确定消息被发送到哪一个队列（负载均衡策略）。比如下面的示例中，订单号相同的消息会被先后发送到同一个队列中：<br>在获取到路由信息以后，会根据MessageQueueSelector实现的算法来选择一个队列，同一个OrderId获取到的肯定是同一个队列。</p>
<h3 id="消息重复"><a href="#消息重复" class="headerlink" title="消息重复"></a>消息重复</h3><p>上面在解决消息顺序问题时，引入了一个新的问题，就是消息重复。那么RocketMQ是怎样解决消息重复的问题呢？还是“恰好”不解决。<br>造成消息重复的根本原因是：网络不可达。只要通过网络交换数据，就无法避免这个问题。所以解决这个问题的办法就是绕过这个问题。那么问题就变成了：如果消费端收到两条一样的消息，应该怎样处理？</p>
<pre><code>消费端处理消息的业务逻辑保持幂等性
保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现
</code></pre><p>第1条很好理解，只要保持幂等性，不管来多少条重复消息，最后处理的结果都一样。<br>第2条原理就是利用一张日志表来记录已经处理成功的消息的ID，如果新到的消息ID已经在日志表中，那么就不再处理这条消息。</p>
<p>第1条解决方案，很明显应该在消费端实现，不属于消息系统要实现的功能。第2条可以消息系统实现，也可以业务端实现。正常情况下出现重复消息的概率其实很小，如果由消息系统来实现的话，肯定会对消息系统的吞吐量和高可用有影响，所以最好还是由业务端自己处理消息重复的问题，这也是RocketMQ不解决消息重复的问题的原因。</p>
<h2 id="SE基础"><a href="#SE基础" class="headerlink" title="SE基础"></a>SE基础</h2><h2 id="3-hashcode、equal-方法的作用？编码最佳实践"><a href="#3-hashcode、equal-方法的作用？编码最佳实践" class="headerlink" title="3.hashcode、equal 方法的作用？编码最佳实践"></a>3.hashcode、equal 方法的作用？编码最佳实践</h2><h3 id="一、hashCode-和equals-是什么？"><a href="#一、hashCode-和equals-是什么？" class="headerlink" title="一、hashCode()和equals()是什么？"></a>一、hashCode()和equals()是什么？</h3><p>hashCode()方法和equals()方法的作用其实一样，在Java里都是用来对比两个对象是否相等一致。</p>
<p>看看JDK1.8源码：<br>Object的equals()方法：</p>
<pre><code>public boolean equals(Object obj) {
  return (this == obj);
}
</code></pre><p>Object的hashCode():</p>
<pre><code>/**
* Returns a hash code value for the object. This method is
* supported for the benefit of hash tables such as those provided by
* {@link java.util.HashMap}.
* &lt;p&gt;
* The general contract of {@code hashCode} is:
* &lt;ul&gt;
* &lt;li&gt;Whenever it is invoked on the same object more than once during
*     an execution of a Java application, the {@code hashCode} method
*     must consistently return the same integer, provided no information
*     used in {@code equals} comparisons on the object is modified.
*     This integer need not remain consistent from one execution of an
*     application to another execution of the same application.
* &lt;li&gt;If two objects are equal according to the {@code equals(Object)}
*     method, then calling the {@code hashCode} method on each of
*     the two objects must produce the same integer result.
* &lt;li&gt;It is &lt;em&gt;not&lt;/em&gt; required that if two objects are unequal
*     according to the {@link java.lang.Object#equals(java.lang.Object)}
*     method, then calling the {@code hashCode} method on each of the
*     two objects must produce distinct integer results.  However, the
*     programmer should be aware that producing distinct integer results
*     for unequal objects may improve the performance of hash tables.
* &lt;/ul&gt;
* &lt;p&gt;
* As much as is reasonably practical, the hashCode method defined by
* class {@code Object} does return distinct integers for distinct
* objects. (This is typically implemented by converting the internal
* address of the object into an integer, but this implementation
* technique is not required by the
* Java&amp;trade; programming language.)
*
* @return  a hash code value for this object.
* @see     java.lang.Object#equals(java.lang.Object)
* @see     java.lang.System#identityHashCode
*/
public native int hashCode();
</code></pre><p>hashCode方法是我们自己去实现的。他说已经给我们实现好了是HashMap的HashCode的方法,作为例子</p>
<h3 id="hashMap的-HashCode方法"><a href="#hashMap的-HashCode方法" class="headerlink" title="hashMap的 HashCode方法"></a>hashMap的 HashCode方法</h3><pre><code>public final int hashCode() {
  return Objects.hashCode(key) ^ Objects.hashCode(value);
}
</code></pre><p>调用了objects的hashCode的方法<br>Objects.java，最终还是调用了Object hashCode（）方法</p>
<pre><code>public static int hashCode(Object o) {
  return o != null ? o.hashCode() : 0;
}
</code></pre><p>二、hashCode()和equals()的区别<strong>性能 —- 可靠性</strong></p>
<pre><code>下边从两个角度介绍了他们的区别：一个是性能，一个是可靠性。他们之间的主要区别也基本体现在这里。
</code></pre><p>1、equals()既然已经能实现对比的功能了，为什么还要hashCode()呢？</p>
<pre><code>因为重写的equals（）里一般比较的比较全面比较复杂，这样效率就比较低，而利用hashCode()先进行对比，则只要生成一个hash值进行比较就可以了，效率很高。
</code></pre><p>重写equals方法需要做三件事：<br>1.比较内存地址 this== obj<br>2.判断是否是同一个类（instanceof 并不能判断）通过getClass()判断<br>3.判断成员是否相等（成员也可能是对象，所以使用Objects.equals()方法）</p>
<pre><code>public static boolean equals(Object a, Object b) {
  return (a == b) || (a != null &amp;&amp; a.equals(b));
}
</code></pre><p>2、hashCode()既然效率这么高为什么还要equals()呢？</p>
<pre><code>因为hashCode()并不是完全可靠，有时候不同的对象他们生成的hashcode也会一样（生成hash值得公式可能存在的问题），所以hashCode()只能说是大部分时候可靠，并不是绝对可靠，所以我们可以得出（PS：以下两条结论是重点，很多人面试的时候都说不出来）：
equals()相等的两个对象他们的hashCode()肯定相等，也就是用equals()对比是绝对可靠的。
hashCode()相等的两个对象他们的equals()不一定相等，也就是hashCode()不是绝对可靠的。
</code></pre><p>默认调用的是objects.hash()方法</p>
<pre><code>@Override
public int hashCode() {
  return Objects.hash(name, age);
}

objects的hashCode() 方法
public static int hash(Object... values) {
  return Arrays.hashCode(values);
}
</code></pre><p>三、hashCode()和equals()使用的注意事项</p>
<p>1、<strong>最佳实践</strong>对于需要大量并且快速的对比的话如果都用equals()去做显然效率太低，所以解决方式是，每当需要对比的时候，首先用hashCode()去对比，如果hashCode()不一样，则表示这两个对象肯定不相等（也就是不必再用equals()去再对比了）,如果hashCode()相同，此时再对比他们的equals()，如果equals()也相同，则表示这两个对象是真的相同了，这样既能大大提高了效率也保证了对比的绝对正确性！</p>
<p>2、这种大量的并且快速的对象对比一般使用的hash容器中，比如HashSet,HashMap,HashTable等等，比如HashSet里要求对象不能重复，则他内部必然要对添加进去的每个对象进行对比，而他的对比规则就是像上面说的那样，先hashCode()，如果hashCode()相同，再用equals()验证，如果hashCode()都不同，则肯定不同，这样对比的效率就很高了。</p>
<p>3、然而hashCode()和equals()一样都是基本类Object里的方法，而和equals()一样，Object里hashCode()里面只是返回当前对象的地址，如果是这样的话，那么我们相同的一个类，new两个对象，由于<strong>他们在内存里的地址不同，则他们的hashCode（）不同</strong>，所以这显然不是我们想要的，所以我们必须重写我们类的hashCode()方法，即一个类，在hashCode()里面返回唯一的一个hash值</p>
<p>由于标识这个类的是他的内部的变量num和name,所以我们就根据他们返回一个hash值，作为这个类的唯一hash值。<br>所以如果我们的对象要想放进hashSet，并且发挥hashSet的特性（即不包含一样的对象），则我们就要重写我们类的hashCode()和equals()方法了。像String,Integer等这种类内部都已经重写了这两个方法。</p>
<p>四、扩展<br>1、阿里巴巴开发规范明确规定：</p>
<p><strong>只要重写 equals，就必须重写 hashCode；</strong></p>
<pre><code>因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的对象必须重写这两个方法；
</code></pre><p><strong>如果自定义对象做为 Map 的键，那么必须重写 hashCode 和 equals</strong></p>
<pre><code>String 重写了 hashCode 和 equals 方法，所以我们可以非常愉快地使用 String 对象作为 key 来使用；
</code></pre><p>2、什么时候需要重写？</p>
<p>一般的地方不需要重写hashCode，只有当<strong>类</strong>需要放在HashTable、HashMap、HashSet等等hash结构的集合时才需要重写hashCode。</p>
<p>3、那么为什么要重写hashCode呢？</p>
<pre><code>如果你重写了equals，比如说是基于对象的内容实现的，而保留hashCode的实现不变，那么很可能某两个对象明明是“相等”，而hashCode却不一样。
这样，当你用其中的一个作为键保存到hashMap、hasoTable或hashSet中，再以“相等的”找另一个作为键值去查找他们的时候，则根本找不到。
</code></pre><p>4、为什么equals()相等，hashCode就一定要相等，而hashCode相等，却不要求equals相等?</p>
<pre><code>因为是按照hashCode来访问小内存块，所以hashCode必须相等。
HashMap获取一个对象是比较key的hashCode相等和equals为true。
之所以hashCode相等，却可以equal不等，就比如ObjectA和ObjectB他们都有属性name，那么hashCode都以name计算，所以hashCode一样，但是两个对象属于不同类型，所以equals为false。
</code></pre><p>5、为什么需要hashCode?</p>
<pre><code>通过hashCode可以很快的查到小内存块。
通过hashCode比较比equals方法快，当get时先比较hashCode，如果hashCode不同，直接返回false。
</code></pre><p>总结：<br>1.hashCode 和equals方法 我们不仅需要分开来看问题，也需要合起来看问题<br>2.分开来看表示 对象equals方法并不是直接的联系会调用到hashCode的方法，<br>3.但是当我们把对象存入hashSet这样的哈希的集合时是使用hashCode()去判断他的位置的，所以重写equals方法，阿里建议必须重写hashCode方法</p>
<p>最后附上idea自动给我们生成的hashCode 和 equals</p>
<h3 id="idea自动给我们生成的hashCode-和-equals方法"><a href="#idea自动给我们生成的hashCode-和-equals方法" class="headerlink" title="idea自动给我们生成的hashCode 和 equals方法"></a>idea自动给我们生成的hashCode 和 equals方法</h3><pre><code>@Override
public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    User user = (User) o;
    return Objects.equals(name, user.name) &amp;&amp;
            Objects.equals(age, user.age);
}

@Override
public int hashCode() {
    return Objects.hash(name, age);
}
</code></pre><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h2 id="1、为什么cglib没有接口的对象就能实现动态代理？"><a href="#1、为什么cglib没有接口的对象就能实现动态代理？" class="headerlink" title="1、为什么cglib没有接口的对象就能实现动态代理？"></a>1、为什么cglib没有接口的对象就能实现动态代理？</h2><p>  JDK和cglib作为动态代理在Spring里面的区别</p>
<p>CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类，比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的方法进行代理，因为CGLib原理是动态生成被代理类的子类。、<br>CGLib采用了非常底层的字节码技术，其原理是通过目标类的字节码为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。</p>
<h2 id="2-简述Spring事务，以及事务的回滚"><a href="#2-简述Spring事务，以及事务的回滚" class="headerlink" title="2.简述Spring事务，以及事务的回滚"></a>2.简述Spring事务，以及事务的回滚</h2><p>在spring-tx包中  可以通过spring-jdbc导入</p>
<p>Spring事务管理常用对象</p>
<pre><code>PlatformTransactionManager
TransactionDefinition
TransactionStatus
</code></pre><h3 id="PlatformTransactionManager-事务管理器"><a href="#PlatformTransactionManager-事务管理器" class="headerlink" title="PlatformTransactionManager 事务管理器"></a>PlatformTransactionManager 事务管理器</h3><pre><code>平台事务管理器，spring要管理事务，必须使用事务管理器
进行事务配置时，必须配置事务管理器。
有多种实现，通过实现此接口，Spring可以管理任何实现了这些接口的事务。开发人员可以使用统一的编程模型来控制管理事务。
常见的事务管理器的实现
DataSourceTransactionManager  ，jdbc开发时事务管理器，采用JdbcTemplate
HibernateTransactionManager，hibernate开发时事务管理器，整合hibernate
</code></pre><p>Spring并不直接管理事务，而是提供了多种事务管理器，他们将事务管理的职责委托给Hibernate或者JTA等持久化机制所提供的相关平台框架的事务来实现。<br>Spring事务管理器的接口是org.springframework.transaction.PlatformTransactionManager，通过这个接口，Spring为各个平台如JDBC、Hibernate等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。此接口的内容如下：</p>
<h3 id="PlatformTransactionManager常用API"><a href="#PlatformTransactionManager常用API" class="headerlink" title="PlatformTransactionManager常用API"></a>PlatformTransactionManager常用API</h3><pre><code>TransactionStatus getTransaction(TransactionDefinition definition) ，
    事务管理器 通过“事务详情”，获得“事务状态”，从而管理事务。 获取事务状态后，Spring根据传播行为来决定如何开启事务；
void commit(TransactionStatus status)  根据状态提交
void rollback(TransactionStatus status) 根据状态回滚
</code></pre><h3 id="TransactionStatus"><a href="#TransactionStatus" class="headerlink" title="TransactionStatus"></a>TransactionStatus</h3><p>这个接口的作用就是获取事务的状态（回滚点、是否完成、是否新事物、是否回滚）属性<br>Status从何而来，根据Definition来的</p>
<h3 id="TransactionDefinition"><a href="#TransactionDefinition" class="headerlink" title="TransactionDefinition"></a>TransactionDefinition</h3><p>这个接口的作用就是定义事务的名称、隔离级别、传播行为、超时时间长短、只读属性等。</p>
<h3 id="核心接口"><a href="#核心接口" class="headerlink" title="核心接口"></a>核心接口</h3><p><img src="https://s2.ax1x.com/2019/11/09/Me0AXR.png" alt="Me0AXR.png"></p>
<h3 id="传播行为（七种）"><a href="#传播行为（七种）" class="headerlink" title="传播行为（七种）"></a>传播行为（七种）</h3><p>REQUIRED: 支持当前事务，如果当前没有事务，就新建一个事务。<br>SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行。<br>MANDATORY： 支持当前事务，如果当前没有事务，就抛出异常</p>
<p>REQUIRES_NEW：新建事务，如果当前存在事务，把当前事务挂起<br>NOT_SUPPORTED: 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起<br>NEVER: 以非事务方式执行，如果当前存在事务，则抛出异常</p>
<p>NESTED: 支持当前事务，如果当前事务存在，则执行一个嵌套（父子）事务，如果当前没有事务，就新建一个事务</p>
<h3 id="AOP方式使用"><a href="#AOP方式使用" class="headerlink" title="AOP方式使用"></a>AOP方式使用</h3><p>SpringConfig</p>
<p>1.配置transactionManager</p>
<pre><code>@Bean
public DataSourceTransactionManager dataSourceTransactionManager(DataSource dataSource){
  DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager();
  dataSourceTransactionManager.setDataSource(dataSource);
  return dataSourceTransactionManager;
}
</code></pre><p>2.@EnableTransactionManagement配置在JavaBean上<br>以上两步或者写在application.xml上</p>
<pre><code>&lt;context:component-scan base-package=&quot;com.cskaoyan&quot;/&gt;
&amp;lt;!&amp;ndash;开启一个声明事务的开关&amp;ndash;&amp;gt;
&lt;tx:annotation-driven transaction-manager=&quot;dataSourceTransactionManager&quot;/&gt;
</code></pre><p>3.在方法上添加注解</p>
<pre><code>@Transactional(propagation = Propagation.REQUIRED,isolation = Isolation.DEFAULT)
@Override
public void transfer(int fromId, int destId, int money) {
  int fromMoney = accountDao.queryMoneyById(fromId) - money;
  int destMoney = accountDao.queryMoneyById(destId) + money;
  accountDao.updateMoneyById(fromId, fromMoney);
  //int i = 1/0;  检测事务失败是否回滚
  accountDao.updateMoneyById(destId, destMoney);
}
</code></pre><h2 id="1-Spring-框架思考"><a href="#1-Spring-框架思考" class="headerlink" title="1.Spring 框架思考"></a>1.Spring 框架思考</h2><p> Spring 框架中的核心组件只有三个：Core、Context 和 Beans。它们构建起了整个 Spring 的骨骼架构。没有它们就不可能有 AOP、Web 等上层的特性功能。下面也将主要从这三个组件入手分析 Spring。</p>
<p>Spring 解决了一个非常关键的问题他可以让你把对象之间的依赖关系转而用配置文件来管理，也就是他的依赖注入机制。而这个注入关系在一个叫 Ioc 容器中管理，那 Ioc 容器就是被 Bean 包裹的对象。Spring 正是通过把对象包装在 Bean 中而达到对这些对象的管理以及一些列额外操作的目的。</p>
<p>它这种设计策略完全类似于 Java 实现 OOP 的设计理念，当然了 Java 本身的设计要比 Spring 复杂太多太多，但是都是构建一个数据结构，然后根据这个数据结构设计他的生存环境，并让它在这个环境中按照一定的规律在不停的运动，在它们的不停运动中设计一系列与环境或者与其他个体完成信息交换。这样想来我们用到的其他框架都是大慨类似的设计理念。</p>
<h3 id="核心组件如何协同工作"><a href="#核心组件如何协同工作" class="headerlink" title="核心组件如何协同工作"></a>核心组件如何协同工作</h3><p>前面说 Bean 是 Spring 中关键因素，那 Context 和 Core 又有何作用呢？前面把 Bean 比作一场演出中的演员的话，那 Context 就是这场演出的舞台背景，而 Core 应该就是演出的道具了。只有他们在一起才能具备演出一场好戏的最基本条件。当然有最基本的条件还不能使这场演出脱颖而出，还要他表演的节目足够的精彩，这些节目就是 Spring 能提供的特色功能了。</p>
<h3 id="Context-—-IOC容器"><a href="#Context-—-IOC容器" class="headerlink" title="Context — IOC容器"></a>Context — IOC容器</h3><p>我们知道 Bean 包装的是 Object，而 Object 必然有数据，如何给这些数据提供生存环境就是 Context 要解决的问题，对 Context 来说他就是要发现每个 Bean 之间的关系，为它们建立这种关系并且要维护好这种关系。所以 <strong>Context 就是一个 Bean 关系的集合，这个关系集合又叫 Ioc 容器</strong>，一旦建立起这个 Ioc 容器后 Spring 就可以为你工作了。那 Core 组件又有什么用武之地呢？其实 Core 就是发现、建立和维护每个 Bean 之间的关系所需要的一些列的工具，从这个角度看来，Core 这个组件叫 Util 更能让你理解。<br><img src="https://s2.ax1x.com/2019/11/09/MeL4ud.gif" alt="MeL4ud.gif"></p>
<h2 id="Bean-组件"><a href="#Bean-组件" class="headerlink" title="Bean 组件"></a>Bean 组件</h2><p>前面已经说明了 Bean 组件对 Spring 的重要性，下面看看 Bean 这个组件式怎么设计的。Bean 组件在 Spring 的 org.springframework.beans 包下。这个包下的所有类主要解决了三件事：</p>
<pre><code>Bean 的定义、
Bean 的创建
Bean 的解析
</code></pre><p>对 Spring 的使用者来说唯一需要关心的就是 Bean 的创建，其他两个由 Spring 在内部帮你完成了，对你来说是透明的。</p>
<p>SpringBean的创建时典型的工厂模式，它的顶级接口是BeanFactory<br><img src="https://s2.ax1x.com/2019/11/09/MeOK56.png" alt="MeOK56.png"></p>
<h3 id="BeanFactory-有三个子类：ListableBeanFactory、HierarchicalBeanFactory-和-AutowireCapableBeanFactory-。"><a href="#BeanFactory-有三个子类：ListableBeanFactory、HierarchicalBeanFactory-和-AutowireCapableBeanFactory-。" class="headerlink" title="BeanFactory 有三个子类：ListableBeanFactory、HierarchicalBeanFactory 和 AutowireCapableBeanFactory 。"></a>BeanFactory 有三个子类：ListableBeanFactory、HierarchicalBeanFactory 和 AutowireCapableBeanFactory 。</h3><p>但是从上图中我们可以发现最终的默认实现类是 DefaultListableBeanFactory，实现了所有的接口。那为何要定义这么多层次的接口呢？查阅这些接口的源码和说明发现，每个接口都有使用的场合，它主要是为了区分在 Spring 内部对象的传递和转化过程中，对对象的数据访问所做的限制。例如 ：</p>
<p>ListableBeanFactory 接口表示这些 Bean 是可列表的，而<br>HierarchicalBeanFactory 表示的这些 Bean 是有继承关系的，也就是每个 Bean 有可能有父 Bean。<br>AutowireCapableBeanFactory 接口定义 Bean 的自动装配规则。这四个接口共同定义了 Bean 的集合、Bean 之间的关系、以及 Bean 行为。</p>
<h3 id="Bean定义"><a href="#Bean定义" class="headerlink" title="Bean定义"></a>Bean定义</h3><p>Bean 的定义主要有 <strong>BeanDefinition</strong> 描述，如下图说明了这些类的层次关系：<br><img src="https://s2.ax1x.com/2019/11/09/MeOl8O.png" alt="MeOl8O.png"></p>
<p>Bean 的定义就是完整的描述了在 Spring 的配置文件中你定义的 &lt;bean/&gt; 节点中所有的信息，包括各种子节点。当 Spring 成功解析你定义的一个 &lt;bean/&gt; 节点后，在 Spring 的内部就被转化成 BeanDefinition 对象。以后所有的操作都是对这个对象完成的。</p>
<h3 id="Bean的解析"><a href="#Bean的解析" class="headerlink" title="Bean的解析"></a>Bean的解析</h3><p>Bean 的解析过程非常复杂，功能被分的很细，因为这里需要被扩展的地方很多，必须保证有足够的灵活性，以应对可能的变化。Bean 的解析主要就是对 Spring 配置文件的解析。这个解析过程主要通过下图中的类完成：<br><img src="https://s2.ax1x.com/2019/11/09/MeOgZn.png" alt="MeOgZn.png"></p>
<h2 id="Context组件"><a href="#Context组件" class="headerlink" title="Context组件"></a>Context组件</h2><p>ApplicationContext 继承了 ResourceLoader 接口，使得 ApplicationContext 可以访问到任何外部资源，这将在 Core 中详细说明。<br>ApplicationContext 的子类主要包含两个方面：</p>
<p>ConfigurableApplicationContext 表示该 Context 是可修改的，也就是在构建 Context 中用户可以动态添加或修改已有的配置信息，它下面又有多个子类，其中最经常使用的是可更新的 Context，即 AbstractRefreshableApplicationContext 类。<br>WebApplicationContext 顾名思义，就是为 web 准备的 Context 他可以直接访问到 ServletContext，通常情况下，这个接口使用的少。</p>
<p>总体来说 ApplicationContext 必须要完成以下几件事：</p>
<pre><code>标识一个应用环境
利用 BeanFactory 创建 Bean 对象
保存对象关系表
能够捕获各种事件
</code></pre><p>Context 作为 Spring 的 Ioc 容器，基本上整合了 Spring 的大部分功能，或者说是大部分功能的基础。</p>
<h2 id="Core-组件"><a href="#Core-组件" class="headerlink" title="Core 组件"></a>Core 组件</h2><p>Core 组件作为 Spring 的核心组件，他其中包含了很多的关键类，其中一个重要组成部分就是定义了资源的访问方式。这种把所有资源都抽象成一个接口的方式很值得在以后的设计中拿来学习。下面就重要看一下这个部分在 Spring 的作用。</p>
<h1 id="Spring源码学习"><a href="#Spring源码学习" class="headerlink" title="Spring源码学习"></a>Spring源码学习</h1><p><a href="https://juejin.im/post/5ada8a5cf265da0b9347df8c" target="_blank" rel="external">https://juejin.im/post/5ada8a5cf265da0b9347df8c</a><br>一个简单的例子：</p>
<pre><code>public static void main(String[] args) {
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;application.xml&quot;);
    User userz = (User) applicationContext.getBean(&quot;userz&quot;);
    System.out.println(userz.eat(&quot;meat&quot;));
}
</code></pre><h3 id="ClassPathXmlApplicationContext"><a href="#ClassPathXmlApplicationContext" class="headerlink" title="ClassPathXmlApplicationContext"></a>ClassPathXmlApplicationContext</h3><p>在实现类ClassPathXmlApplicationContext中其实并没有多少重要的操作，主要是在构造函数中配置Spring配置文件的路径：<br>具体的application.xml解析相关的操作都在父类refresh中进行操作。</p>
<h3 id="AbstractXmlApplicationContext-—-loadBeanDefinitions"><a href="#AbstractXmlApplicationContext-—-loadBeanDefinitions" class="headerlink" title="AbstractXmlApplicationContext —- loadBeanDefinitions"></a>AbstractXmlApplicationContext —- loadBeanDefinitions</h3><p>在AbstractXmlApplicationContext中做的操作就是对applicationContext.xml的<strong>解析</strong>操作，主要是由两个函数<br>loadBeanDefinitions(DefaultListableBeanFactory beanFactory)和<br>loadBeanDefinitions(XmlBeanDefinitionReader reader)<br>中实现。</p>
<pre><code>/主要是对spring注入配置文件的解析，主要使用到 BeanDefinitionReader 和BeanDefinitionDocumentReader两个接口相关的实现类
  @Override
  protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {
    // Create a new XmlBeanDefinitionReader for the given BeanFactory.
    //创建XmlBeanDefinitionReader，即创建Bean读取器，并通过回调设置到容器中去，容  器使用该读取器读取Bean定义资源
    XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);

    // Configure the bean definition reader with this context&apos;s
    // resource loading environment.
    //为Bean读取器设置Spring资源加载器，AbstractXmlApplicationContext的
        //祖先父类AbstractApplicationContext继承DefaultResourceLoader，因此，容器本身也是一个资源加载器
    beanDefinitionReader.setEnvironment(this.getEnvironment());
    beanDefinitionReader.setResourceLoader(this);
    beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));

    // Allow a subclass to provide custom initialization of the reader,
    // then proceed with actually loading the bean definitions.
    //当Bean读取器读取Bean定义的Xml资源文件时，启用Xml的校验机制
    initBeanDefinitionReader(beanDefinitionReader);
    //Bean读取器真正实现加载的方法
    loadBeanDefinitions(beanDefinitionReader);
  }
</code></pre><p>loadBeanDefinitions中的操作实际是XmlBeanDefinitionReader来解析applicationContext.xml</p>
<h3 id="AbstractRefreshableApplicationContext"><a href="#AbstractRefreshableApplicationContext" class="headerlink" title="AbstractRefreshableApplicationContext"></a>AbstractRefreshableApplicationContext</h3><p>AbstractRefreshableApplicationContext主要是和容器的刷新与创建有关，调用 refreshBeanFactory 方法完成applicationContext.xml的解析操作，完成容器的初始化操作。</p>
<pre><code>//类似于初始化容器，这里的容器就是DefaultListableBeanFactory
  @Override
  protected final void refreshBeanFactory() throws BeansException {
    //如果已经有容器，销毁容器中的bean，关闭容器
    if (hasBeanFactory()) {
      destroyBeans();
      closeBeanFactory();
    }
    try {
      //创建IoC容器
      DefaultListableBeanFactory beanFactory = createBeanFactory();
      beanFactory.setSerializationId(getId());
      //对IoC容器进行定制化，如设置启动参数，开启注解的自动装配等
      customizeBeanFactory(beanFactory);
      //调用载入Bean定义的方法，主要这里又使用了一个委派模式，在当前类中只定义了抽象的loadBeanDefinitions方法，具体的实现调用子类容器
      loadBeanDefinitions(beanFactory);
      synchronized (this.beanFactoryMonitor) {
        this.beanFactory = beanFactory;
      }
    }
    catch (IOException ex) {
      throw new ApplicationContextException(&quot;I/O error parsing bean definition source for &quot; + getDisplayName(), ex);
    }
  }
</code></pre><h3 id="AbstractApplicationContext（最重要）-—-refresh"><a href="#AbstractApplicationContext（最重要）-—-refresh" class="headerlink" title="AbstractApplicationContext（最重要） — refresh()"></a>AbstractApplicationContext（最重要） — refresh()</h3><p>AbstractApplicationContext是Spring应用上下文中最重要的一个类，这个抽象类中提供了几乎ApplicationContext的所有操作。主要有容器工厂的处理，事件的发送广播，监听器添加，容器初始化操作refresh方法，然后就是bean的生成获取方法接口等。主要还是提供了一些方法，复杂的操作也是没有太多。</p>
<pre><code>public void refresh() throws BeansException, IllegalStateException {
        synchronized(this.startupShutdownMonitor) {
            this.prepareRefresh();
            ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();
            this.prepareBeanFactory(beanFactory);
            try {
                this.postProcessBeanFactory(beanFactory);
                this.invokeBeanFactoryPostProcessors(beanFactory);
                this.registerBeanPostProcessors(beanFactory);
                this.initMessageSource();
                this.initApplicationEventMulticaster();
                this.onRefresh();
                this.registerListeners();
                this.finishBeanFactoryInitialization(beanFactory);
                this.finishRefresh();
            } catch (BeansException var9) {
                if (this.logger.isWarnEnabled()) {
                    this.logger.warn(&quot;Exception encountered during context initialization - cancelling refresh attempt: &quot; + var9);
                }
                this.destroyBeans();
                this.cancelRefresh(var9);
                throw var9;
            } finally {
                this.resetCommonCaches();
            }
        }
    }
</code></pre><p>主要说说后面几个方法：<br>finishBeanFactoryInitialization - 初始化剩余的单实例bean(非懒加载)</p>
<pre><code>protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
  // 初始化conversion转化器
  if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;
      beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {
    beanFactory.setConversionService(
        beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));
  }

  // 如果没有bean后置处理器，注册一个默认的值解析器，这个解析器可以用来处理替换注解中的值
  if (!beanFactory.hasEmbeddedValueResolver()) {
    beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));
  }

  //注册早期的LoadTimeWeaverAware
  String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);
  for (String weaverAwareName : weaverAwareNames) {
    getBean(weaverAwareName);
  }

  // Stop using the temporary ClassLoader for type matching.
  beanFactory.setTempClassLoader(null);

  // Allow for caching all bean definition metadata, not expecting further changes.
  beanFactory.freezeConfiguration();

  // 注册剩余的非懒加载单实例bean
  beanFactory.preInstantiateSingletons();
}
</code></pre><p>finishBeanFactoryInitialization方法负责将剩余的非懒加载(non-lazy-init)的单实例bean初始化，包括以下几种bean:</p>
<pre><code>conversion转化器
如果没有bean后置处理器，注册一个默认的值解析器，用于注解的值解析（PropertyPlaceholderConfigurer），比如那些占位符的值
早期的LoadTimeWeaverAware,他可以用于aop中的通知织入
剩余的非懒加载单实例bean（factoryBean）
</code></pre><h3 id="beanFactory-preInstantiateSingletons-（DefaultListableBeanFactory）"><a href="#beanFactory-preInstantiateSingletons-（DefaultListableBeanFactory）" class="headerlink" title="beanFactory.preInstantiateSingletons(); （DefaultListableBeanFactory）"></a>beanFactory.preInstantiateSingletons(); （DefaultListableBeanFactory）</h3><pre><code>public void preInstantiateSingletons() throws BeansException {
  if (logger.isDebugEnabled()) {
    logger.debug(&quot;Pre-instantiating singletons in &quot; + this);
  }
</code></pre><p>// 先把所有的bean定义名称放入副本列表中</p>
<pre><code>List&lt;String&gt; beanNames = new ArrayList&lt;&gt;(this.beanDefinitionNames);
</code></pre><p>// 找到并注册所有非懒加载的单实例bean(Spring中的单例默认不是懒加载的，原型是懒加载的)</p>
<pre><code>for (String beanName : beanNames) {
  //获取到这个beanName的定义信息
  RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
  //非抽象，单例，非懒加载
  if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) {
    if (isFactoryBean(beanName)) {
      Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);
      //工厂bean只初始化需要立马创建的
      if (bean instanceof FactoryBean) {
        final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;
        boolean isEagerInit; //默认是false

        if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) {
          isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)
                  ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,
              getAccessControlContext());
        }
        else {
          isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp;
              ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());
        }

        if (isEagerInit) {
          getBean(beanName);
        }
      }
    }
    else {
      getBean(beanName);
    }
  }
}
</code></pre><p>// 设置bean初始化时的回调</p>
<pre><code>  for (String beanName : beanNames) {
    Object singletonInstance = getSingleton(beanName);
    if (singletonInstance instanceof SmartInitializingSingleton) {
      final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;
      if (System.getSecurityManager() != null) {
        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; {
          smartSingleton.afterSingletonsInstantiated();
          return null;
        }, getAccessControlContext());
      }
      else {
        smartSingleton.afterSingletonsInstantiated();
      }
    }
  }
}
</code></pre><p>bean真正初始化是在AbstractBeanFactory类的doGetBean方法中：</p>
<h3 id="getBean-AbstractBeanFactory"><a href="#getBean-AbstractBeanFactory" class="headerlink" title="getBean()//AbstractBeanFactory"></a>getBean()//AbstractBeanFactory</h3><pre><code>public Object getBean(String name) throws BeansException {
   return this.doGetBean(name, (Class)null, (Object[])null, false);
}
</code></pre><p>doGetBean方法中的代码有点长，我们对他的功能做个简单的总结：</p>
<pre><code>创建前先尝试从单列bean集合中获取该bean，如果bean曾经被创建的话，会缓存到这个容器中，此时无需重复创建
bean没被缓存过的话开始执行创建流程
如果这个bean是在父容器中创建的，那么让父容器执行doGetBean方法
给需要创建的bean做个标记，表示在创建了，防止其他线程创建该bean
查找该bean依赖的其他bean，如果有依赖的，先创建这些依赖的bean
执行createBean方法创建bean【下面会继续讲怎么】
检查创建的bean是否类型匹配
</code></pre><h3 id="bstractAutowireCapableBeanFactory的createBean-—-createBean-and-doCreateBean"><a href="#bstractAutowireCapableBeanFactory的createBean-—-createBean-and-doCreateBean" class="headerlink" title="bstractAutowireCapableBeanFactory的createBean —- createBean()  and  doCreateBean()"></a>bstractAutowireCapableBeanFactory的createBean —- createBean()  and  doCreateBean()</h3><p>类AbstractAutowireCapableBeanFactory的createBean方法在创建bean前会尝试返回一个该bean的代理对象，如果有代理对象会直接返回，没有的话会执行doCreateBean方法，开始bean初始化逻辑：</p>
<p>通过工厂方法或者构造器方法创建bean实例（这段代码很长，我们就不继续跟了，有兴趣可以自行点进去）<br>调用 applyMergedBeanDefinitionPostProcessors 方法，执行MergedBeanDefinitionPostProcessor类型的后置处理器的postProcessMergedBeanDefinition方法<br>调用 populateBean 方法，给bean的属性赋值  this.autowireByName(beanName, mbd, bw, newPvs);<br>执行 InstantiationAwareBeanPostProcesso r类型的后置处理器的postProcessAfterInstantiation方法<br>执行 InstantiationAwareBeanPostProcessor 类型的后置处理器的postProcessPropertyValues方法<br>执行applyPropertyValues方法设置值给bean<br>调用 initializeBean 方法初始化bean<br>invokeAwareMethods - 执行Aware接口的方法（BeanNameAware，BeanClassLoaderAware，BeanFactoryAware）<br>applyBeanPostProcessorsBeforeInitialization - 执行BeanPostProcessor类型后置处理器的 postProcessBeforeInitialization 方法(wrappedBean)<br>invokeInitMethods - 执行初始化方法<br>如果bean实现了 InitializingBean 接口，执行afterPropertiesSet方法<br>自定义方法，比如xml中设置default-init-method的值，或者@bean注解的initMethod<br>applyBeanPostProcessorsAfterInitialization - 执行 BeanPostProcessor 类型后置处理器的 postProcessAfterInitialization 方法<br>调用 registerDisposableBeanIfNecessary 方法注册bean销毁方法，也就是bean实现DisposableBean接口的destroy方法<br>bean创建出来后，会在 DefaultSingletonBeanRegistry 类中执行 addSingleton 方法，将新建出单例 bean 放入缓存中。</p>
<pre><code>protected void markBeanAsCreated(String beanName) {
    if (!this.alreadyCreated.contains(beanName)) {
        synchronized(this.mergedBeanDefinitions) {
            if (!this.alreadyCreated.contains(beanName)) {
                this.clearMergedBeanDefinition(beanName);
                this.alreadyCreated.add(beanName);
            }
        }
    }
}
</code></pre><h3 id="我们打断点走一遍"><a href="#我们打断点走一遍" class="headerlink" title="我们打断点走一遍"></a>我们打断点走一遍</h3><p>ClassPathXmlApplicationContext —- &gt; 在 abstractApplicationContext初始化 —-》调用refresh()方法</p>
<pre><code>public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, @Nullable ApplicationContext parent) throws BeansException {
    super(parent);
    this.setConfigLocations(configLocations);
    if (refresh) {
        this.refresh();
    }
}
</code></pre><h2 id="zookeeper相关"><a href="#zookeeper相关" class="headerlink" title="zookeeper相关"></a>zookeeper相关</h2><p>2）说一下 zookeeper 的作用？zookeeper在某一个瞬间挂了dubbo服务还能调用吗？如何实现zookeeper的高可用<br>作用：作为注册中心为分布式环境下各个微服务之间的调用提供协调工作<br>问题二：可以的，启动dubbo时，消费者会从zk拉取注册的生产者的地址接口等数据，缓存在本地。每次调用时，按照本地存储的地址进行调用实现高可用：<br>搭建 zookeeper 集群实现高可用。</p>
<p>3)搭建 zookeeper 集群<br>最少：3台Zookeeper关于leader的选举机制，主要提供了三种方式：</p>
<pre><code>LeaderElection
AuthFastLeaderElection
FastLeaderElection
</code></pre><p>默认的算法是 FastLeaderElection<br>在zookeeper的选举过程中，为了保证选举过程最后能选出leader，就一定不能出现两台机器得票相同的僵局，所以一般的，要求zk集群的server数量一定要是奇数，也就是2n+1台，并且，如果集群出现问题，其中存活的机器必须大于n+1台，否则leader无法获得多数server的支持，系统就自动挂掉。所以一般是3个或者3个以上节点。</p>
<p>配置<br>(window配集群)[<a href="https://www.cnblogs.com/jtlgb/p/7792004.html" target="_blank" rel="external">https://www.cnblogs.com/jtlgb/p/7792004.html</a>]<br>(linux配集群)[<a href="https://blog.csdn.net/YZX2018/article/details/90106555" target="_blank" rel="external">https://blog.csdn.net/YZX2018/article/details/90106555</a>]</p>
<h2 id="并发相关"><a href="#并发相关" class="headerlink" title="并发相关"></a>并发相关</h2><h2 id="1-CAS算法-—-乐观锁实现"><a href="#1-CAS算法-—-乐观锁实现" class="headerlink" title="1.CAS算法 —- 乐观锁实现"></a>1.CAS算法 —- 乐观锁实现</h2><p><a href="https://www.cnblogs.com/qjjazry/p/6581568.html" target="_blank" rel="external">https://www.cnblogs.com/qjjazry/p/6581568.html</a><br>　　<br>悲观锁：</p>
<pre><code>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如Java里面的同步原语synchronized关键字的实现也是悲观锁。
</code></pre><p>乐观锁：</p>
<pre><code>顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。
</code></pre><p>悲观锁机制存在以下问题：　　</p>
<pre><code>1.在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。
2.一个线程持有锁会导致其它所有需要此锁的线程挂起。
3.如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。
</code></pre><p>对比于悲观锁的这些问题，另一个更加有效的锁就是乐观锁。其实乐观锁就是：每次不加锁而是假设没有并发冲突而去完成某项操作，<strong>如果因为并发冲突失败就重试，直到成功为止。</strong></p>
<p>上面提到的乐观锁的概念中其实已经阐述了它的具体实现细节：主要就是两个步骤：<strong>冲突检测和数据更新</strong>。其实现方式有一种比较典型的就是 Compare and Swap ( CAS )。<br>CAS是乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。　　　<br>CAS 操作中包含三个操作数 ——<br>1) 需要读写的内存位置（V）、<br>2) 进行比较的预期原值（A）<br>3) 和拟写入的新值(B)。<br>如果内存位置V的值与预期原值A相匹配，那么处理器会自动将该位置值更新为新值B。否则处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前值。）CAS 有效地说明了“ 我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。 ”这其实和乐观锁的冲突检查+数据更新的原理是一样的。</p>
<h3 id="乐观锁问题"><a href="#乐观锁问题" class="headerlink" title="乐观锁问题"></a>乐观锁问题</h3><p>1.ABA</p>
<p>2.循环时间长开销大：<br>自旋CAS（不成功，就一直循环执行，直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</p>
<p>3.只能保证一个共享变量的原子操作：<br>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。</p>
<h2 id="2-多线程"><a href="#2-多线程" class="headerlink" title="2.多线程"></a>2.多线程</h2><p>关于 Java多线程，在面试的时候，问的比较多的就是①悲观锁和乐观锁（ 具体可以看我的这篇文章：面试必备之乐<br>观锁与悲观锁）、②synchronized和lock区别以及volatile和synchronized的区别，③可重入锁与非可重入锁的区<br>别、④多线程是解决什么问题的、⑤线程池解决什么问题、⑥线程池的原理、⑦线程池使用时的注意事项、⑧AQS原<br>理、⑨ReentranLock源码，设计原理，整体过程 等等问题。</p>
<h3 id="volatile-和-synchronized-区别"><a href="#volatile-和-synchronized-区别" class="headerlink" title="volatile 和 synchronized 区别"></a>volatile 和 synchronized 区别</h3><p>先了解JMM模型<br><a href="https://blog.csdn.net/suifeng3051/article/details/52611310" target="_blank" rel="external">https://blog.csdn.net/suifeng3051/article/details/52611310</a></p>
<p>简单学习一下volatile和synchronized</p>
<p>首先需要理解线程安全的两个方面：<strong>执行控制</strong>和<strong>内存可见</strong>。<br>执行控制的目的是控制代码执行（顺序）及是否可以并发执行。<br>内存可见控制的是线程执行结果在内存中对其它线程的可见性。根据Java内存模型的实现，线程在具体执行时，会先拷贝主存数据到线程本地（CPU缓存），操作完成后再把结果从线程本地刷到主存。</p>
<p>第一点： 他们作用不一样：         volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。<br>第二点：他们的使用的目标不一样：   volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的<br>第三点：性能不一样                volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性<br>第四点：是否会造成阻塞            volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。<br>第五点：是否会被编译器优化：       volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化</p>
<h3 id="AQS原理-AbstractQueuedSynchronizer"><a href="#AQS原理-AbstractQueuedSynchronizer" class="headerlink" title="AQS原理 AbstractQueuedSynchronizer"></a>AQS原理 AbstractQueuedSynchronizer</h3><p><a href="https://www.cnblogs.com/waterystone/p/4920797.html" target="_blank" rel="external">https://www.cnblogs.com/waterystone/p/4920797.html</a><br>ReentrantLock<br>AQS定义两种资源共享方式</p>
<pre><code>Exclusive（独占）：只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁：
公平锁：按照线程在队列中的排队顺序，先到者先拿到锁
非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的

Share（共享）：多个线程可同时执行，如Semaphore/CountDownLatch。Semaphore、
CountDownLatCh、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。
</code></pre><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><h3 id="说说自己是怎么使用-synchronized-关键字，在项目中用到了吗"><a href="#说说自己是怎么使用-synchronized-关键字，在项目中用到了吗" class="headerlink" title="说说自己是怎么使用 synchronized 关键字，在项目中用到了吗"></a>说说自己是怎么使用 synchronized 关键字，在项目中用到了吗</h3><p><strong>第一种</strong>：修饰实例方法，作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁<br><strong>第二种</strong>：修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁 。也就是给当前类加锁，会作<br>用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态<br>资源，不管new了多少个对象，只有一份，所以对该类的所有对象都加了锁）。所以如果一个线程A调用一个实<br>例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允<br>许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态<br>synchronized 方法占用的锁是当前实例对象锁。</p>
<p><strong>第三种</strong>：修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。 和 synchronized 方<br>法一样，synchronized(this)代码块也是锁定当前对象的。synchronized 关键字加到 static 静态方法和<br>synchronized(class)代码块上都是是给 Class 类上锁。这里再提一下：synchronized关键字加到非 static 静态<br>方法上是给对象实例上锁。另外需要注意的是：尽量不要使用 synchronized(String a) 因为JVM中，字符串常量<br>池具有缓冲功能！</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="讲一下Java内存模型"><a href="#讲一下Java内存模型" class="headerlink" title="讲一下Java内存模型"></a>讲一下Java内存模型</h3><p>在 JDK1.2 之前，Java的内存模型实现总是从主存（即共享内存）读取变量，是不需要进行特别的注意的。而在当前<br>的 Java 内存模型下，线程可以把变量保存本地内存（比如机器的寄存器）中，而不是直接在主存中进行读写。这就<br>可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数<br>据的不一致。<br>要解决这个问题，就需要把变量声明为 volatile，这就指示 JVM，这个变量是不稳定的，每次使用它都到主存中进行<br>读取。说白了， volatile 关键字的主要作用就是保证变量的可见性然后还有一个作用是防止指令重排序。</p>
<h3 id="为什么使用线程池"><a href="#为什么使用线程池" class="headerlink" title="为什么使用线程池"></a>为什么使用线程池</h3><p>降低资源消耗。 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。<br>提高响应速度。 当任务到达时，任务可以不需要的等到线程创建就能立即执行。<br>提高线程的可管理性。 线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，<br>使用线程池可以进行统一的分配，调优和监控。</p>
<h3 id="实现Runnable接口和-Callable-接口的区别"><a href="#实现Runnable接口和-Callable-接口的区别" class="headerlink" title="实现Runnable接口和 Callable 接口的区别"></a>实现Runnable接口和 Callable 接口的区别</h3><p>如果想让线程池执行任务的话需要实现的Runnable接口或Callable接口。 Runnable接口或Callable接口实现类都可<br>以被ThreadPoolExecutor或ScheduledThreadPoolExecutor执行。两者的区别在于 Runnable 接口不会返回结果但<br>是 Callable 接口可以返回结果。<br>备注： 工具类Executors 可以实现Runnable 对象和Callable 对象之间的相互转换。<br>（ Executors.callable（Runnable task） 或Executors.callable（Runnable task，Object resule） ）。</p>
<h3 id="执行execute-方法和submit-方法的区别是什么呢？"><a href="#执行execute-方法和submit-方法的区别是什么呢？" class="headerlink" title="执行execute()方法和submit()方法的区别是什么呢？"></a>执行execute()方法和submit()方法的区别是什么呢？</h3><p>1) execute() 方法用于提交不需要返回值的任务，所以<strong>无法判断任务是否被线程池执行成功与否</strong>；<br>2) submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断<br>任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用<br>get（long timeout，TimeUnit unit） 方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行<br>完。</p>
<h2 id="原子类（jdk1-5）"><a href="#原子类（jdk1-5）" class="headerlink" title="原子类（jdk1.5）"></a>原子类（jdk1.5）</h2><p>并发包 java.util.concurrent 的原子类都存放在java.util.concurrent.atomic 下,如下图所示。<br>基本类型</p>
<pre><code>使用原子的方式更新基本类型
AtomicInteger：整形原子类
AtomicLong：长整型原子类
AtomicBoolean ：布尔型原子类
</code></pre><p>数组类型</p>
<pre><code>使用原子的方式更新数组里的某个元素
AtomicIntegerArray：整形数组原子类
AtomicLongArray：长整形数组原子类
AtomicReferenceArray ：引用类型数组原子类
</code></pre><p>引用类型</p>
<pre><code>AtomicReference：引用类型原子类
AtomicStampedRerence：原子更新引用类型里的字段原子类
AtomicMarkableReference ：原子更新带有标记位的引用类型
</code></pre><p>对象的属性修改类型</p>
<pre><code>AtomicIntegerFieldUpdater:原子更新整形字段的更新器
AtomicLongFieldUpdater：原子更新长整形字段的更新器
AtomicStampedReference ：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原
子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。
</code></pre><h3 id="讲讲AtomicInteger的使用"><a href="#讲讲AtomicInteger的使用" class="headerlink" title="讲讲AtomicInteger的使用"></a>讲讲AtomicInteger的使用</h3><p>AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免<br>synchronized 的高开销，执行效率大为提升。<br>CAS的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 objectFieldOffset() 方法<br>是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset。另外 value 是一个volatile变<br>量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。<br>关于 Atomic 原子类这部分更多内容可以查看我的这篇文章：并发编程面试必备：JUC 中的 Atomic 原子类总结</p>
<h2 id="3-线程同步方式有哪些"><a href="#3-线程同步方式有哪些" class="headerlink" title="3.线程同步方式有哪些"></a>3.线程同步方式有哪些</h2><p>1.同步方法<br>2.同步代码块<br>3.使用特殊域变量(volatile)实现线程同步</p>
<pre><code>a.volatile关键字为域变量的访问提供了一种免锁机制，
b.使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新，
c.因此每次使用该域就要重新计算（进入公共内存计算），而不是使用寄存器中的值
d.volatile不会提供任何原子操作，它也不能用来修饰final类型的变量
</code></pre><p>4.使用重入锁实现线程同步</p>
<pre><code>在JavaSE5.0中新增了一个java.util.concurrent包来支持同步。
ReentrantLock类是可重入、互斥、实现了Lock接口的锁，
它与使用synchronized方法和快具有相同的基本行为和语义，并且扩展了其能力
</code></pre><p>5.使用局部变量实现线程同步（ThreadLocal）</p>
<pre><code>如果使用ThreadLocal管理变量，则每一个使用该变量的线程都获得该变量的副本，
副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。
</code></pre><p>ThreadLocal 类的常用方法</p>
<pre><code>ThreadLocal() : 创建一个线程本地变量
get() : 返回此线程局部变量的当前线程副本中的值
initialValue() : 返回此线程局部变量的当前线程的&quot;初始值&quot;
set(T value) : 将此线程局部变量的当前线程副本中的值设置为value
</code></pre><p>6.使用阻塞队列实现线程同步<br>前面5种同步方式都是在底层实现的线程同步，但是我们在实际开发当中，应当<strong>尽量远离底层结构</strong>。<br>使用javaSE5.0版本中新增的java.util.concurrent包将有助于简化开发。<br>LinkedBlockingQueue<e>是一个基于已连接节点的，范围任意的blocking queue。<br>队列是先进先出的顺序（FIFO），关于队列以后会详细讲解~</e></p>
<pre><code>LinkedBlockingQueue 类常用方法
LinkedBlockingQueue() : 创建一个容量为Integer.MAX_VALUE的LinkedBlockingQueue
put(E e) : 在队尾添加一个元素，如果队列满则阻塞
size() : 返回队列中的元素个数
take() : 移除并返回队头元素，如果队列空则阻塞
</code></pre><p>7.使用原子变量实现线程同步<br>需要使用线程同步的根本原因在于对普通变量的操作不是原子的。</p>
<pre><code>那么什么是原子操作呢？
原子操作就是指将读取变量值、修改变量值、保存变量值看成一个整体来操作
即-这几种行为要么同时完成，要么都不完成。
在java的util.concurrent.atomic包中提供了创建了原子类型变量的工具类，
</code></pre><p>出处：<br>(java笔记–关于线程同步（7种同步方式）)[<a href="https://www.cnblogs.com/XHJT/p/3897440.html" target="_blank" rel="external">https://www.cnblogs.com/XHJT/p/3897440.html</a>]</p>
<h2 id="数据相关"><a href="#数据相关" class="headerlink" title="数据相关"></a>数据相关</h2><h2 id="1-给定一个10万行的txt文件，用最快的速度把文件导入下面数据库表中。其中日期、姓名、地址三个信息对应的数据若在数据库中已存在，则更新后面的金额。如果没有就插入新纪录"><a href="#1-给定一个10万行的txt文件，用最快的速度把文件导入下面数据库表中。其中日期、姓名、地址三个信息对应的数据若在数据库中已存在，则更新后面的金额。如果没有就插入新纪录" class="headerlink" title="1.给定一个10万行的txt文件，用最快的速度把文件导入下面数据库表中。其中日期、姓名、地址三个信息对应的数据若在数据库中已存在，则更新后面的金额。如果没有就插入新纪录"></a>1.给定一个10万行的txt文件，用最快的速度把文件导入下面数据库表中。其中日期、姓名、地址三个信息对应的数据若在数据库中已存在，则更新后面的金额。如果没有就插入新纪录</h2><p>两种方式：</p>
<pre><code>1.store precedure
2.使用Java批处理

### 先建表设置mysql引擎为MYISAM（米山）
首先，要先有一个数据表，注意数据表的引擎，在建表时使用的是 MyISAM 引擎，MyISAM 的插入比 InnoDB 要快很多，因为 InnoDB 的事务支持要好很多，而且大多数情况下都是默认使用 InnoDB，所以可以在插入数据完成后再修改成 InnoDB。

    CREATE TABLE `tb_data` (
      `id` int(11) DEFAULT NULL,
      `user_name` varchar(100) DEFAULT NULL,
      `create_time` datetime DEFAULT NULL,
      `random` double DEFAULT NULL
    ) ENGINE=MyISAM DEFAULT CHARSET=utf8;

### 1.使用 java 代码，实测插入 100 万条数据耗时 6 秒。

    public class InsertDataDemo {
        static Connection conn = null;
        public static void initConn() throws ClassNotFoundException, SQLException {
          try {
            // 如果从mysql数据库迁移到oracle数据库，需要变更哪些
            // DriverManager. registerDriver(new Driver());
            Properties properties = new Properties();
            FileInputStream fileInputStream = new FileInputStream(new File(&quot;jdbc.properties&quot;));
            properties.load(fileInputStream);
            String url = properties.getProperty(&quot;url&quot;);
            String username = properties.getProperty(&quot;username&quot;);
            String password = properties.getProperty(&quot;password&quot;);
            String driverClassName = properties.getProperty(&quot;driverClassName&quot;);
            Class.forName(driverClassName);
            //硬编码  properties
            conn = DriverManager.getConnection(url,username,password);
          } catch (Exception e) {
              e.printStackTrace();
          }
        }

        public static String randomStr(int size) {
          //定义一个空字符串
          String result = &quot;&quot;;
          for (int i = 0; i &lt; size; ++i) {
            //生成一个97~122之间的int类型整数
            int intVal = (int) (Math.random() * 26 + 97);
            //强制转换（char）intVal 将对应的数值转换为对应的字符，并将字符进行拼接
            result = result + (char) intVal;
          }
          //输出字符串
          return result;
        }


        public static void insert(int insertNum) {
          // 开时时间
          Long begin = System.currentTimeMillis();
          System.out.println(&quot;开始插入数据...&quot;);
          // sql前缀
          String prefix = &quot;INSERT INTO tb_data (id, user_name, create_time, random) VALUES &quot;;

          try {
            // 保存sql后缀
            StringBuffer suffix = new StringBuffer();
            // 设置事务为非自动提交
            conn.setAutoCommit(false);
            PreparedStatement pst = conn.prepareStatement(&quot;&quot;);
            for (int i = 1; i &lt;= insertNum; i++) {
                // 构建sql后缀
                suffix.append(&quot;(&quot; + i +&quot;,&apos;&quot;+ randomStr(8)  + &quot;&apos;, SYSDATE(), &quot; + i * Math.random() + &quot;),&quot;);
            }
            // 构建完整sql
            String sql = prefix + suffix.substring(0, suffix.length() - 1);
            // 添加执行sql
            pst.addBatch(sql);
            // 执行操作
            pst.executeBatch();
            // 提交事务
            conn.commit();

            // 关闭连接
            pst.close();
            conn.close();
          } catch (SQLException e) {
              e.printStackTrace();
          }
          // 结束时间
          Long end = System.currentTimeMillis();
          System.out.println(&quot;插入&quot;+insertNum+&quot;条数据数据完成！&quot;);
          System.out.println(&quot;耗时 : &quot; + (end - begin) / 1000 + &quot; 秒&quot;);
        }
        public static void main(String[] args) throws SQLException, ClassNotFoundException {
          initConn();
          insert(1000000);
        }
    }

注意：
适当增大 mysql 的 max_allowed_packet 参数的值可以使client端到server端传递大数据时，系统能够分配更多的扩展内存来处理。
修改 mysql 配置文件：


### 2.存储过程

    CREATE PROCEDURE myproc ( ) BEGIN
      DECLARE
        num INT;
      SET num = 1;
      WHILE
          num &lt;= 10000000 DO
          INSERT INTO `user` ( username, email, PASSWORD )
        VALUES
          ( CONCAT( &apos;username_&apos;, num ), CONCAT( num, &apos;@qq.com&apos; ), MD5( num ) );
        SET num = num + 1;
      END WHILE;
    END
</code></pre><h2 id="2-group-by-后面可以和-where-连用吗"><a href="#2-group-by-后面可以和-where-连用吗" class="headerlink" title="2.group by 后面可以和 where 连用吗 ?"></a>2.group by 后面可以和 where 连用吗 ?</h2><p>一，group by 字句也和where条件语句结合在一起使用。但是当结合在一起时，where在前，group by 在后。即先对select xx from xx的记录集合用where进行筛选，然后再使用group by 对筛选后的结果进行分组 使用having 字句对分组后的结果进行筛选。</p>
<p>二，需要注意 having 和 where 的用法区别：</p>
<pre><code>1.having只能用在group by之后，对分组后的结果进行筛选(即使用having的前提条件是分组)。
2.where肯定在group by 之前。
3.where后的条件表达式里不允许使用聚合函数，而having可以。
</code></pre><p>三，当一个查询语句同时出现了where,group by,having,order by的时候，执行顺序和编写顺序是：</p>
<pre><code>1.执行where xx对全表数据做筛选，返回第1个结果集。
2.针对第1个结果集使用group by分组，返回第2个结果集。
3.针对第2个结果集中的每1组数据执行select xx，有几组就执行几次，返回第3个结果集。
4.针对第3个结集执行having xx进行筛选，返回第4个结果集。
5.针对第4个结果集排序。
</code></pre><p>也就是说其实where的条件里面不能有聚合函数，因为select语句执行在where之后。</p>
<h2 id="3-数据库分库之后可能会出现的问题"><a href="#3-数据库分库之后可能会出现的问题" class="headerlink" title="3.数据库分库之后可能会出现的问题"></a>3.数据库分库之后可能会出现的问题</h2><p>第一点：join操作问题</p>
<pre><code>业务分库后，原本在同一个数据库中的表分散到不同数据库中，导致无法使用SQL中的join查询
</code></pre><p>第二点：事务问题<br>    原本在同一个数据库中不同的表可以在同一个事物中修改，业务分库后，表分散到不同的数据库中，无法通过事务统一修改，虽然数据库厂商针对此问题提供了一些分布式事务解决方案（例如，MySQL的XA），但是性能实在太低，与高性功能存储的目标是相违背的</p>
<p>第三点：成本问题</p>
<pre><code>业务分库同时也带来了成本的代价，本来1台服务器搞定的事情，现在需要3台，如果考虑备份，那就是2台变成了6台
</code></pre><p>分表  将不同的业务数据分散存储到不同的数据库服务器，能够支撑百万甚至千万用户规模的业务，但是如果业务继续发展，同一个业务的单表数据也会达到单台数据库服务器的处理瓶颈，此时就需要对单表进行拆分，单表数据拆分有两种方式：垂直分表和水平分表</p>
<h2 id="mysql的引擎？"><a href="#mysql的引擎？" class="headerlink" title="mysql的引擎？"></a>mysql的引擎？</h2><pre><code>innodb底层索引结构
为什么是B+树，还有什么？hash
为什么不是二叉树
</code></pre><p>普通索引和主键索引 两者有什么区别<br>主键列要求列的所有内容必须唯一，而普通索引列不要求内容必须唯一。</p>
<h2 id="谈谈数据库表设计冗余的利与弊，以及冗余的适用条件"><a href="#谈谈数据库表设计冗余的利与弊，以及冗余的适用条件" class="headerlink" title="谈谈数据库表设计冗余的利与弊，以及冗余的适用条件"></a>谈谈数据库表设计冗余的利与弊，以及冗余的适用条件</h2><pre><code>1.尽量遵循范式理论的规约，尽可能少的冗余字段，让数据库设计看起来精致、优雅、让人心醉。
2.合理的加入冗余字段这个润滑剂，减少join，让数据库执行性能更高更快。
</code></pre><p>选择哪一种呢？如果你是一个美学狂人，并且财大气粗，非要使用第一种方案，也没关系，这种方案的短板并非不可救药的。比如，你可以增加服务器，从数据库集群入手，进行读写分离，读的时候可以将压力分散到不同的数据库服务器上，这样也可以获得很好的性能，只是多付出了硬件成本和维护成本。或者，你可以在数据库前端架设Memcached之类的缓存服务，减少读写数据库的次数，也可以达到同样的效果。问题在于你确定你需要缓存之类的东西。<br>如果做不到上面的只能选择第二种了，当涉及到修改的时候就需要将所有相关的数据进行修改了。</p>
<p>空间换取时间，到底值不值得，看业务需求与取舍了。<br>原文链接：<a href="https://blog.csdn.net/BinGuoLA/article/details/81416324" target="_blank" rel="external">https://blog.csdn.net/BinGuoLA/article/details/81416324</a></p>
<h2 id="单点登录相关"><a href="#单点登录相关" class="headerlink" title="单点登录相关"></a>单点登录相关</h2><p>1）单点登录传输账号密码，前端传一个加密的账号密码过来是这样的：包装一个对象，然后对这个对象转成json字符串，使用Base64进行加密<br>    SimpleObject User = new User();<br>    User.setUserName(“admin”);<br>    User.setPassword(“admin”);</p>
<pre><code>String jsonString = JSON.toJSONString(User);
String encode = new Base64SecurityAction().doAction(jsonString);
</code></pre><p>进行加密。Base64SecurityAction工具类</p>
<pre><code>public class Base64SecurityAction implements DataSecurityAction {
  @Override
  public String doAction(String beProtected) {
    return Base64Utils.encodeToString(beProtected.getBytes());
  }
  @Override
  public String unlock(String securityCode) {
    byte[] bytes = Base64Utils.decodeFromString(securityCode);
    return new String(bytes);
  }
}
</code></pre><p>对加密的对象生成一个md5的签名，然后封装成一个bean</p>
<pre><code>  String md5 = MD5Util.encrypt(encode + salt);
  BaseTransferEntity baseTransferEntity = new BaseTransferEntity();
  baseTransferEntity.setObject(encode);
  baseTransferEntity.setSign(md5);
}
</code></pre><p>然后把这个对象传给后端，后端通过继承 FastJsonHttpMessageConverter 监听到并把json转成bean</p>
<pre><code>public class WithSignMessageConverter extends FastJsonHttpMessageConverter {
    @Autowired
    JwtProperties jwtProperties;

    @Autowired
    JwtTokenUtil jwtTokenUtil;

    @Autowired
    DataSecurityAction dataSecurityAction;

    @Override
    public Object read(Type type, Class&lt;?&gt; contextClass, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException {

        InputStream in = inputMessage.getBody();
        Object o = JSON.parseObject(in, super.getFastJsonConfig().getCharset(), BaseTransferEntity.class, super.getFastJsonConfig().getFeatures());

        //先转化成原始的对象
        BaseTransferEntity baseTransferEntity = (BaseTransferEntity) o;

        String object = baseTransferEntity.getObject();
        String sign = baseTransferEntity.getSign();

        //判断签名是否正确
        String md5 = MD5Util.encrypt(object + salt);
        if(!md5.equals(sign)){
            return ;
        }
        String json = dataSecurityAction.unlock(object);
        //校验签名后再转化成应该的对象
        return JSON.parseObject(json, type);
    }
}
</code></pre><h3 id="这个账号密码明文传输的问题，我们正常来说是从两个角度来考虑"><a href="#这个账号密码明文传输的问题，我们正常来说是从两个角度来考虑" class="headerlink" title="这个账号密码明文传输的问题，我们正常来说是从两个角度来考虑"></a>这个账号密码明文传输的问题，我们正常来说是从两个角度来考虑</h3><p>1.防止链接被劫持<br>2.对传输信息进行加密</p>
<p>一般来说就是这两种手段，防止链接被劫持就是现在的HTTPS，加了一个ssl，是较为安全的一个传输协议，不容易被劫持<br>使用JWT的手法对信息进行加密，然后后端使用converter进行拦截并返回我们需要的OBJ</p>
<h3 id="SSL加密原理"><a href="#SSL加密原理" class="headerlink" title="SSL加密原理"></a>SSL加密原理</h3><p>(图解SSL/TLS协议)[<a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html</a>]<br>SSL协议的握手过程<br>开始加密通信之前，客户端和服务器首先必须建立连接和交换参数，这个过程叫做握手（handshake）。<br>假定客户端叫做爱丽丝，服务器叫做鲍勃，整个握手过程可以用下图说明（点击看大图）。</p>
<p>握手阶段分成五步。<br>    第一步，爱丽丝给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。<br>    第二步，鲍勃确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。<br>    第三步，爱丽丝确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给鲍勃。<br>    第四步，鲍勃使用自己的私钥，获取爱丽丝发来的随机数（即Premaster secret）。<br>    第五步，爱丽丝和鲍勃根据约定的加密方法，使用前面的三个随机数（客户端两个，服务端一个），生成”对话密钥”（session key），用来加密接下来的整个对话过程。</p>
<p>数字证书就是一个非对称加密的载体</p>
<h2 id="线程相关"><a href="#线程相关" class="headerlink" title="线程相关"></a>线程相关</h2><h3 id="1-在线程池里面的线程执行任务出现异常，不会抛出吗？"><a href="#1-在线程池里面的线程执行任务出现异常，不会抛出吗？" class="headerlink" title="1.在线程池里面的线程执行任务出现异常，不会抛出吗？"></a>1.在线程池里面的线程执行任务出现异常，不会抛出吗？</h3><p>只有运行时异常可以抛出，但是不能被捕获。如果是单线程，抛出异常可以通过重写ThreadGroup的uncaughtException方法来处理异常。但是线程池中的方法怎么办呢？<br><a href="https://www.cnblogs.com/jpfss/p/10272885.html" target="_blank" rel="external">https://www.cnblogs.com/jpfss/p/10272885.html</a></p>
<p>Java线程池抛出异常问题<br><a href="http://www.itxm.cn/post/15211.html" target="_blank" rel="external">http://www.itxm.cn/post/15211.html</a><br>接下来我们来看一下java中的线程池是如何运行我们提交的任务的，详细流程比较复杂，这里我们不关注，我们只关注任务执行的部分。java中的线程池用的是ThreadPoolExecutor，真正执行代码的部分是 <strong>runWorker</strong> 方法：final void runWorker(Worker w)</p>
<pre><code>final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    Runnable task = w.firstTask;
    w.firstTask = null;
    w.unlock(); // allow interrupts
    boolean completedAbruptly = true;
    try {
        while (task != null || (task = getTask()) != null) {
            w.lock();
            // If pool is stopping, ensure thread is interrupted;
            // if not, ensure thread is not interrupted.  This
            // requires a recheck in second case to deal with
            // shutdownNow race while clearing interrupt
            if ((runStateAtLeast(ctl.get(), STOP) ||
                 (Thread.interrupted() &amp;&amp;
                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;
                !wt.isInterrupted())
                wt.interrupt();
            try {
                beforeExecute(wt, task);
                Throwable thrown = null;
                try {
                    task.run();
                } catch (RuntimeException x) {
                    thrown = x; throw x;
                } catch (Error x) {
                    thrown = x; throw x;
                } catch (Throwable x) {
                    thrown = x; throw new Error(x);
                } finally {
                    afterExecute(task, thrown);
                }
            } finally {
                task = null;
                w.completedTasks++;
                w.unlock();
            }
        }
        completedAbruptly = false;
    } finally {
        processWorkerExit(w, completedAbruptly);
    }
}
</code></pre><p>可以看到，程序会捕获包括Error在内的所有异常，并且在程序最后，将出现过的异常和当前任务传递给afterExecute方法。<br>而ThreadPoolExecutor中的afterExecute方法是没有任何实现的：（）</p>
<pre><code>protected void afterExecute(Runnable r, Throwable t) { }
</code></pre><p>也就是说，默认情况下，线程池会捕获任务抛出的所有异常，但是不做任何处理。</p>
<p><strong>存在问题</strong><br>想象下ThreadPoolExecutor这种处理方式会有什么问题？<br>这样做能够保证我们提交的任务抛出了异常不会影响其他任务的执行，同时也不会对用来执行该任务的线程产生任何影响。<br>问题就在：afterExecute方法上，这个方法没有做任何处理，所以如果我们的任务抛出了异常，我们也无法立刻感知到。即使感知到了，也无法查看异常信息。</p>
<p><strong>如何避免这种问题？</strong><br>1.在提交的任务中将异常捕获并处理，不抛给线程池。<br>2.异常抛给线程池，但是我们要及时处理抛第二种思路又有以下几种实现方式：</p>
<pre><code>1.自定义线程池，继承ThreadPoolExecutor并复写其afterExecute(Runnable r, Throwable t)方法。
2.实现Thread.UncaughtExceptionHandler 接口，实现void uncaughtException(Thread t, Throwable e);方法，并将该handler传递给线程池的ThreadFactory
3.采用Future模式， 将返回结果以及异常放到Future中，在Future中处理
4.继承ThreadGroup，覆盖其uncaughtException方法。（与第二种方式类似，因为 ThreadGroup 类本身就实现了Thread.UncaughtExceptionHandler接口)
</code></pre><p>在异常抛给线程池方法的第3种实现中<br>为什么抛出的是 RuntimeException 但是捕获的却是 ExecutionException(JDK7实现的)<br>因为运行时异常在线程池中抛出都会包装成 ExecutionException</p>
<pre><code>ExecutorService pool1 = Executors.newCachedThreadPool();
// &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) 执行任务，并把结果放入 result 中
List&lt;String&gt; result = new ArrayList&lt;&gt;();
Future&lt;List&gt; future = pool1.submit(new Runnable() {
  @Override
  public void run() {
    //建议抛出 unchecked 的异常（运行时异常） ，因为unchecked异常有可能是代码的问题所以跑出来才看得到，checked 的异常只能自己消化
    throw new RuntimeException(&quot;你炸了&quot;);
  }
}, result);

List list = null;
try {
  list = future.get(); // 返回的是结果
} catch (InterruptedException e) {
    e.printStackTrace();
} catch (RuntimeException e) {
    e.printStackTrace();
} catch (ExecutionException e) {
    System.out.println(&quot;感觉还可以&quot;);  //这里捕获的
}
</code></pre><h3 id="2-手写一个线程池"><a href="#2-手写一个线程池" class="headerlink" title="2.手写一个线程池"></a>2.手写一个线程池</h3><pre><code>public class MyThreadPool {

    //存放任务的阻塞队列
    BlockingQueue &lt;Runnable&gt; bq = new ArrayBlockingQueue&lt;&gt;(10);   //put take方法
    //一个简单的线程池
    Collection&lt;WorkThread&gt; threads;
    // 构造方法
    public MyThreadPool(int num) {
      //新建一个方法
      threads = new ArrayList&lt;&gt;(num);
      for (int i = 0; i &lt; num; i++) {
        WorkThread workThread = new WorkThread();
        workThread.start();
        threads.add(workThread);
      }
    }
    // 获取任务放进阻塞队列
    public void execute(Runnable task) {
        try {
            //
            bq.put(task);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    // 工作线程写成内部类的形式
    private class WorkThread extends Thread {
      //重写run方法
      @Override
      public void run() {
        //一直在运行
        while(true) {
          //一直监听是否有任务
          try {
            Runnable task = bq.take(); //阻塞在这  生产者消费者模式
            //运行任务
            task.run();
          } catch (InterruptedException e) {
            e.printStackTrace();
          }
        }
      }
    }
    public static void main(String[] args) {
      Runnable task1 = new Runnable() {
        @Override
        public void run() {
          System.out.println(Thread.currentThread().getName()+ &quot; 开始了朋友&quot;);
          try {
              Thread.sleep(1000);
          } catch (InterruptedException e) {
              e.printStackTrace();
          }
          System.out.println(Thread.currentThread().getName()+ &quot; 结束了&quot;);
        }
      };
      Runnable task2 = new Runnable() {
        @Override
        public void run() {
          for (int i = 0; i &lt; 100; i++) {
              System.out.println(Thread.currentThread().getName() + i);
          }
        }
      };
      MyThreadPool myThreadPool = new MyThreadPool(10);
      myThreadPool.execute(task1);
      myThreadPool.execute(task2);
    }
}
</code></pre><h3 id="线程怎么通讯？"><a href="#线程怎么通讯？" class="headerlink" title="线程怎么通讯？"></a>线程怎么通讯？</h3><p>(全面理解Java内存模型)[<a href="https://blog.csdn.net/suifeng3051/article/details/52611310" target="_blank" rel="external">https://blog.csdn.net/suifeng3051/article/details/52611310</a>]</p>
<p>线程的通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种<strong>共享内存</strong>和<strong>消息传递</strong>。<br>在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信，典型的共享内存通信方式就是通过共享对象进行通信。<br>在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信，在java中典型的消息传递方式就是wait()和notify()。</p>
<p>只有在同步的情况下，线程间才有必要通信。<br>线程间通信：<br>    只有在同步的情况下，线程间才有必要通信。<br>等待唤醒机制：<br>Object (锁) :<br>    void notify()   // 随机一个唤醒等待这把锁的线程<br>    void notifyAll() // 唤醒所以等待这把锁的线程</p>
<pre><code>void wait() // 当前正在执行的线程进入等待状态, 并且释放锁资源，等待被唤醒。
void wait(long timeout) // 支持超时机制，如果在指定的时间内没有被唤醒，就会自动唤醒。
void wait(long timeout, int nanos)
</code></pre><p>为什么 wait() 方法和 notify() 方法不定义在 Thread 类中，而定义在 Object 中呢？<br>    线程间通信是通过锁对象实现的 (锁对象是线程间通信的媒介),<br>    又因为任何对象都可以做为锁，所以这些方法定义在Object类中</p>
<p>注意事项：<br>    a. notify(), notifyAll(): 申请的资源曾经可以利用的。<br>    b. 慎用 notify(), 除非确实考虑周全了，否则都用 notifyAll();</p>
<h2 id="集合相关"><a href="#集合相关" class="headerlink" title="集合相关"></a>集合相关</h2><h3 id="HashMap-中的-Hash-方法"><a href="#HashMap-中的-Hash-方法" class="headerlink" title="HashMap 中的 Hash 方法"></a>HashMap 中的 Hash 方法</h3><p>调用的是key的hashCode方法</p>
<pre><code>static final int hash(Object key) {
  int h;
  return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
}
</code></pre><p>由于和（length-1）运算，length 绝大多数情况小于2的16次方。<br>key.hashCode()是一个int值的32位的数；<br>所以始终是 hashcode 的低16位参与运算。要是高16位也参与运算，会让得到的下标更加散列。<br>所以这样高16位是用不到的，如何让高16也参与运算呢。所以才有hash(Object key)方法。让他的hashCode()和自己的高16位^运算。所以(h &gt;&gt;&gt; 16)得到他的高16位与hashCode()进行^运算。<br>重点来了，为什么用^：因为&amp;和|都会使得结果偏向0或者1 ,并不是均匀的概念,<strong>所以用^（异或）</strong>。</p>
<h3 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a>hashCode方法</h3><pre><code>public int hashCode() {
  int h = 0;
  Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();
  while (i.hasNext())
      h += i.next().hashCode();
  return h;
}
</code></pre><p>会报错</p>
<pre><code>HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();
HashMap&lt;Object, Object&gt; map1 = new HashMap&lt;&gt;();
map.put(map1,&quot;haha&quot;);
map1.put(map,&quot;haha&quot;);
System.out.println(map.hashCode());
</code></pre><h3 id="关于ArrayList-和-vector"><a href="#关于ArrayList-和-vector" class="headerlink" title="关于ArrayList 和 vector"></a>关于ArrayList 和 vector</h3><p>vector是线程安全的，ArrayList是线程不安全</p>
<p>为什么不把ArrayList设计成乐观锁的原理，这样不仅能保证同步，而且可以保证速度</p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>JDK1.8之后<br>相比于之前的版本， JDK1.8之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转<br>化为红黑树，以减少搜索时间。</p>
<pre><code>/**
 * The bin count threshold for using a tree rather than list for a
 * bin.  Bins are converted to trees when adding an element to a
 * bin with at least this many nodes. The value must be greater
 * than 2 and should be at least 8 to mesh with assumptions in
 * tree removal about conversion back to plain bins upon
 * shrinkage.
 */
static final int TREEIFY_THRESHOLD = 8;
if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
  treeifyBin(tab, hash);
break;
</code></pre><p>为什么hashMap的长度都是2^n次幂<br>我们首先可能会想到采用%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是2的幂次则等价于与其<br>除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是2的 n 次方；）。” 并且 采<br>用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。</p>
<h3 id="2-hashMap-or-ConCurrentHashMap的区别"><a href="#2-hashMap-or-ConCurrentHashMap的区别" class="headerlink" title="2.hashMap or ConCurrentHashMap的区别"></a>2.hashMap or ConCurrentHashMap的区别</h3><p>第一点：线程安全问题<br>hashMap线程不安全，concurrentHashMap线程安全</p>
<p>在JDK1.7的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了<br>分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁<br>竞争，提高并发访问率。 到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑<br>树的数据结构来实现，并发控制使用 <strong>synchronized 和 CAS</strong> 来操作。</p>
<h2 id="hystrix相关"><a href="#hystrix相关" class="headerlink" title="hystrix相关"></a>hystrix相关</h2><p>(hystrix使用详解)[<a href="https://www.cnblogs.com/yepei/p/7169127.html" target="_blank" rel="external">https://www.cnblogs.com/yepei/p/7169127.html</a>]<br>二:Hystrix如何解决依赖隔离<br>1:Hystrix使用命令模式HystrixCommand(Command)包装依赖调用逻辑，每个命令在单独线程中/信号授权下执行。<br>2:可配置依赖调用超时时间,超时时间一般设为比99.5%平均时间略高即可.当调用超时时，直接返回或执行fallback逻辑。<br>3:为每个依赖提供一个小的线程池（或信号），如果线程池已满调用将被立即拒绝，默认不采用排队.加速失败判定时间。<br>4:依赖调用结果分:成功，失败（抛出异常），超时，线程拒绝，短路。 请求失败(异常，拒绝，超时，短路)时执行fallback(降级)逻辑。<br>5:提供熔断器组件,可以自动运行或手动调用,停止当前依赖一段时间(10秒)，熔断器默认错误率阈值为50%,超过将自动运行。<br>6:提供近实时依赖的统计和监控</p>
<p>流程说明:</p>
<p>1:每次调用创建一个新的 HystrixCommand ,把依赖调用封装在run()方法中.<br>2:执行execute()/queue做同步或异步调用.<br>3:判断熔断器(circuit-breaker)是否打开,如果打开跳到步骤8,进行降级策略,如果关闭进入步骤.<br>4:判断线程池/队列/信号量是否跑满，如果跑满进入降级步骤8,否则继续后续步骤.<br>5:调用HystrixCommand的run方法.运行依赖逻辑<br>5a:依赖逻辑调用超时,进入步骤8.<br>6:判断逻辑是否调用成功<br>6a:返回成功调用结果<br>6b:调用出错，进入步骤8.<br>7:计算熔断器状态,所有的运行状态(成功, 失败, 拒绝,超时)上报给熔断器，用于统计从而判断熔断器状态.<br>8:getFallback()降级逻辑.<br> 以下四种情况将触发getFallback调用：</p>
<pre><code>(1):run()方法抛出非HystrixBadRequestException异常。
(2):run()方法调用超时
(3):熔断器开启拦截调用
(4):线程池/队列/信号量是否跑满
</code></pre><p>8a:没有实现getFallback的Command将直接抛出异常<br>8b:fallback降级逻辑调用成功直接返回<br>8c:降级逻辑调用失败抛出异常</p>
<p>9:返回执行成功结果</p>

    </div>

    
    
    
        
      

      <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2019/11/03/Java总结（十九）/" rel="next" title="Java总结（十九）">
                  <i class="fa fa-chevron-left"></i> Java总结（十九）
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          
    
    <div class="comments" id="comments"></div>
  

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#dubbo"><span class="nav-number">1.</span> <span class="nav-text">dubbo</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#说一说dubbo的同步-异步调用？"><span class="nav-number">1.1.</span> <span class="nav-text">说一说dubbo的同步/异步调用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dubbo同步调用"><span class="nav-number">1.2.</span> <span class="nav-text">dubbo同步调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Future-的类图结构"><span class="nav-number">1.3.</span> <span class="nav-text">Future 的类图结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dubbo-异步调用"><span class="nav-number">1.4.</span> <span class="nav-text">dubbo 异步调用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jdk1-8"><span class="nav-number">2.</span> <span class="nav-text">jdk1.8</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Map相关"><span class="nav-number">2.1.</span> <span class="nav-text">Map相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lambda表达式"><span class="nav-number">2.2.</span> <span class="nav-text">Lambda表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数式接口"><span class="nav-number">2.3.</span> <span class="nav-text">函数式接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法引用和构造器调用"><span class="nav-number">2.4.</span> <span class="nav-text">方法引用和构造器调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Stream-API"><span class="nav-number">2.5.</span> <span class="nav-text">Stream API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接口中的默认方法和静态方法"><span class="nav-number">2.6.</span> <span class="nav-text">接口中的默认方法和静态方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#新时间日期API"><span class="nav-number">2.7.</span> <span class="nav-text">新时间日期API</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM相关"><span class="nav-number">3.</span> <span class="nav-text">JVM相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM结构、内存分配、垃圾回收算法、垃圾收集器GC。下面我们一一来看。"><span class="nav-number">3.1.</span> <span class="nav-text">JVM结构、内存分配、垃圾回收算法、垃圾收集器GC。下面我们一一来看。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#深入理解Java虚拟机笔记—运行时栈帧结构"><span class="nav-number">3.2.</span> <span class="nav-text">深入理解Java虚拟机笔记—运行时栈帧结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java内存溢出和内存泄漏"><span class="nav-number">4.</span> <span class="nav-text">Java内存溢出和内存泄漏</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内存泄露举例"><span class="nav-number">4.1.</span> <span class="nav-text">内存泄露举例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存溢出类型及解决"><span class="nav-number">4.2.</span> <span class="nav-text">内存溢出类型及解决</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redis相关"><span class="nav-number">5.</span> <span class="nav-text">redis相关</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redis-配置"><span class="nav-number">6.</span> <span class="nav-text">redis 配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#redis-高可用-—-主从哨兵模式（更好的去判断主机是否出故障）"><span class="nav-number">6.1.</span> <span class="nav-text">redis 高可用 —- 主从哨兵模式（更好的去判断主机是否出故障）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-Sentinel的基本概念"><span class="nav-number">6.2.</span> <span class="nav-text">Redis Sentinel的基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#主从复制-同时存在以下几个问题："><span class="nav-number">6.3.</span> <span class="nav-text">主从复制 同时存在以下几个问题：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#哨兵模式"><span class="nav-number">6.4.</span> <span class="nav-text">哨兵模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#主观下线和客观下线（目标不同）"><span class="nav-number">6.5.</span> <span class="nav-text">主观下线和客观下线（目标不同）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sentinel的通信命令"><span class="nav-number">6.6.</span> <span class="nav-text">Sentinel的通信命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-Sentinel的工作原理"><span class="nav-number">6.7.</span> <span class="nav-text">Redis Sentinel的工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis集群原理"><span class="nav-number">6.8.</span> <span class="nav-text">redis集群原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis集群的概念"><span class="nav-number">6.9.</span> <span class="nav-text">Redis集群的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据分片"><span class="nav-number">6.10.</span> <span class="nav-text">数据分片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#主从复制模型-—-主从模型"><span class="nav-number">6.11.</span> <span class="nav-text">主从复制模型 —- 主从模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis一致性保证"><span class="nav-number">6.12.</span> <span class="nav-text">Redis一致性保证</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rocketMq相关"><span class="nav-number">7.</span> <span class="nav-text">rocketMq相关</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-rocketMq有哪些组件组成？"><span class="nav-number">8.</span> <span class="nav-text">1.rocketMq有哪些组件组成？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-阿里RocketMQ如何解决消息的顺序-amp-重复两大硬伤？"><span class="nav-number">9.</span> <span class="nav-text">2.阿里RocketMQ如何解决消息的顺序&重复两大硬伤？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#核心-世界上解决一个计算机问题最简单的方法：“恰好”不需要解决它！——沈询"><span class="nav-number">9.1.</span> <span class="nav-text">核心:世界上解决一个计算机问题最简单的方法：“恰好”不需要解决它！——沈询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#源码分析"><span class="nav-number">9.2.</span> <span class="nav-text">源码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息重复"><span class="nav-number">9.3.</span> <span class="nav-text">消息重复</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SE基础"><span class="nav-number">10.</span> <span class="nav-text">SE基础</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-hashcode、equal-方法的作用？编码最佳实践"><span class="nav-number">11.</span> <span class="nav-text">3.hashcode、equal 方法的作用？编码最佳实践</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、hashCode-和equals-是什么？"><span class="nav-number">11.1.</span> <span class="nav-text">一、hashCode()和equals()是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hashMap的-HashCode方法"><span class="nav-number">11.2.</span> <span class="nav-text">hashMap的 HashCode方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#idea自动给我们生成的hashCode-和-equals方法"><span class="nav-number">11.3.</span> <span class="nav-text">idea自动给我们生成的hashCode 和 equals方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring"><span class="nav-number">12.</span> <span class="nav-text">Spring</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1、为什么cglib没有接口的对象就能实现动态代理？"><span class="nav-number">13.</span> <span class="nav-text">1、为什么cglib没有接口的对象就能实现动态代理？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-简述Spring事务，以及事务的回滚"><span class="nav-number">14.</span> <span class="nav-text">2.简述Spring事务，以及事务的回滚</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#PlatformTransactionManager-事务管理器"><span class="nav-number">14.1.</span> <span class="nav-text">PlatformTransactionManager 事务管理器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PlatformTransactionManager常用API"><span class="nav-number">14.2.</span> <span class="nav-text">PlatformTransactionManager常用API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TransactionStatus"><span class="nav-number">14.3.</span> <span class="nav-text">TransactionStatus</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TransactionDefinition"><span class="nav-number">14.4.</span> <span class="nav-text">TransactionDefinition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#核心接口"><span class="nav-number">14.5.</span> <span class="nav-text">核心接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#传播行为（七种）"><span class="nav-number">14.6.</span> <span class="nav-text">传播行为（七种）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOP方式使用"><span class="nav-number">14.7.</span> <span class="nav-text">AOP方式使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Spring-框架思考"><span class="nav-number">15.</span> <span class="nav-text">1.Spring 框架思考</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#核心组件如何协同工作"><span class="nav-number">15.1.</span> <span class="nav-text">核心组件如何协同工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Context-—-IOC容器"><span class="nav-number">15.2.</span> <span class="nav-text">Context — IOC容器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bean-组件"><span class="nav-number">16.</span> <span class="nav-text">Bean 组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BeanFactory-有三个子类：ListableBeanFactory、HierarchicalBeanFactory-和-AutowireCapableBeanFactory-。"><span class="nav-number">16.1.</span> <span class="nav-text">BeanFactory 有三个子类：ListableBeanFactory、HierarchicalBeanFactory 和 AutowireCapableBeanFactory 。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bean定义"><span class="nav-number">16.2.</span> <span class="nav-text">Bean定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bean的解析"><span class="nav-number">16.3.</span> <span class="nav-text">Bean的解析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Context组件"><span class="nav-number">17.</span> <span class="nav-text">Context组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Core-组件"><span class="nav-number">18.</span> <span class="nav-text">Core 组件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring源码学习"><span class="nav-number"></span> <span class="nav-text">Spring源码学习</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ClassPathXmlApplicationContext"><span class="nav-number">0.1.</span> <span class="nav-text">ClassPathXmlApplicationContext</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AbstractXmlApplicationContext-—-loadBeanDefinitions"><span class="nav-number">0.2.</span> <span class="nav-text">AbstractXmlApplicationContext —- loadBeanDefinitions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AbstractRefreshableApplicationContext"><span class="nav-number">0.3.</span> <span class="nav-text">AbstractRefreshableApplicationContext</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AbstractApplicationContext（最重要）-—-refresh"><span class="nav-number">0.4.</span> <span class="nav-text">AbstractApplicationContext（最重要） — refresh()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#beanFactory-preInstantiateSingletons-（DefaultListableBeanFactory）"><span class="nav-number">0.5.</span> <span class="nav-text">beanFactory.preInstantiateSingletons(); （DefaultListableBeanFactory）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#getBean-AbstractBeanFactory"><span class="nav-number">0.6.</span> <span class="nav-text">getBean()//AbstractBeanFactory</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bstractAutowireCapableBeanFactory的createBean-—-createBean-and-doCreateBean"><span class="nav-number">0.7.</span> <span class="nav-text">bstractAutowireCapableBeanFactory的createBean —- createBean()  and  doCreateBean()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#我们打断点走一遍"><span class="nav-number">0.8.</span> <span class="nav-text">我们打断点走一遍</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#zookeeper相关"><span class="nav-number">1.</span> <span class="nav-text">zookeeper相关</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#并发相关"><span class="nav-number">2.</span> <span class="nav-text">并发相关</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-CAS算法-—-乐观锁实现"><span class="nav-number">3.</span> <span class="nav-text">1.CAS算法 —- 乐观锁实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#乐观锁问题"><span class="nav-number">3.1.</span> <span class="nav-text">乐观锁问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-多线程"><span class="nav-number">4.</span> <span class="nav-text">2.多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile-和-synchronized-区别"><span class="nav-number">4.1.</span> <span class="nav-text">volatile 和 synchronized 区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AQS原理-AbstractQueuedSynchronizer"><span class="nav-number">4.2.</span> <span class="nav-text">AQS原理 AbstractQueuedSynchronizer</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized"><span class="nav-number">5.</span> <span class="nav-text">synchronized</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#说说自己是怎么使用-synchronized-关键字，在项目中用到了吗"><span class="nav-number">5.1.</span> <span class="nav-text">说说自己是怎么使用 synchronized 关键字，在项目中用到了吗</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程池"><span class="nav-number">6.</span> <span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#讲一下Java内存模型"><span class="nav-number">6.1.</span> <span class="nav-text">讲一下Java内存模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么使用线程池"><span class="nav-number">6.2.</span> <span class="nav-text">为什么使用线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现Runnable接口和-Callable-接口的区别"><span class="nav-number">6.3.</span> <span class="nav-text">实现Runnable接口和 Callable 接口的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#执行execute-方法和submit-方法的区别是什么呢？"><span class="nav-number">6.4.</span> <span class="nav-text">执行execute()方法和submit()方法的区别是什么呢？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原子类（jdk1-5）"><span class="nav-number">7.</span> <span class="nav-text">原子类（jdk1.5）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#讲讲AtomicInteger的使用"><span class="nav-number">7.1.</span> <span class="nav-text">讲讲AtomicInteger的使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-线程同步方式有哪些"><span class="nav-number">8.</span> <span class="nav-text">3.线程同步方式有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据相关"><span class="nav-number">9.</span> <span class="nav-text">数据相关</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-给定一个10万行的txt文件，用最快的速度把文件导入下面数据库表中。其中日期、姓名、地址三个信息对应的数据若在数据库中已存在，则更新后面的金额。如果没有就插入新纪录"><span class="nav-number">10.</span> <span class="nav-text">1.给定一个10万行的txt文件，用最快的速度把文件导入下面数据库表中。其中日期、姓名、地址三个信息对应的数据若在数据库中已存在，则更新后面的金额。如果没有就插入新纪录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-group-by-后面可以和-where-连用吗"><span class="nav-number">11.</span> <span class="nav-text">2.group by 后面可以和 where 连用吗 ?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-数据库分库之后可能会出现的问题"><span class="nav-number">12.</span> <span class="nav-text">3.数据库分库之后可能会出现的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mysql的引擎？"><span class="nav-number">13.</span> <span class="nav-text">mysql的引擎？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#谈谈数据库表设计冗余的利与弊，以及冗余的适用条件"><span class="nav-number">14.</span> <span class="nav-text">谈谈数据库表设计冗余的利与弊，以及冗余的适用条件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单点登录相关"><span class="nav-number">15.</span> <span class="nav-text">单点登录相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#这个账号密码明文传输的问题，我们正常来说是从两个角度来考虑"><span class="nav-number">15.1.</span> <span class="nav-text">这个账号密码明文传输的问题，我们正常来说是从两个角度来考虑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SSL加密原理"><span class="nav-number">15.2.</span> <span class="nav-text">SSL加密原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程相关"><span class="nav-number">16.</span> <span class="nav-text">线程相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-在线程池里面的线程执行任务出现异常，不会抛出吗？"><span class="nav-number">16.1.</span> <span class="nav-text">1.在线程池里面的线程执行任务出现异常，不会抛出吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-手写一个线程池"><span class="nav-number">16.2.</span> <span class="nav-text">2.手写一个线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程怎么通讯？"><span class="nav-number">16.3.</span> <span class="nav-text">线程怎么通讯？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集合相关"><span class="nav-number">17.</span> <span class="nav-text">集合相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap-中的-Hash-方法"><span class="nav-number">17.1.</span> <span class="nav-text">HashMap 中的 Hash 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hashCode方法"><span class="nav-number">17.2.</span> <span class="nav-text">hashCode方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于ArrayList-和-vector"><span class="nav-number">17.3.</span> <span class="nav-text">关于ArrayList 和 vector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap"><span class="nav-number">17.4.</span> <span class="nav-text">HashMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-hashMap-or-ConCurrentHashMap的区别"><span class="nav-number">17.5.</span> <span class="nav-text">2.hashMap or ConCurrentHashMap的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hystrix相关"><span class="nav-number">18.</span> <span class="nav-text">hystrix相关</span></a></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/head.jpeg"
      alt="王邸">
  <p class="site-author-name" itemprop="name">王邸</p>
  <div class="site-description" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">35</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span>
        
      </div>
    
  </nav>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王邸</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.3.8</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.4.0</div>

        












        
      </div>
    </footer>
  </div>

  


  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/pisces.js?v=7.4.0"></script>

<script src="/js/next-boot.js?v=7.4.0"></script>



  





















  

  

  


<script>
NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'Fn4BuvoixOxjJAhR79TvaD5M-gzGzoHsz',
    appKey: '1uspTrSwPqkmSBSUr948WqxE',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: true,
    lang: '' || 'zh-cn',
    path: location.pathname
  });
}, window.Valine);
</script>

</body>
</html>
