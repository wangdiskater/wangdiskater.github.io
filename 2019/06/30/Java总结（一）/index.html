<!DOCTYPE html>
<html class="full-height">
<head>
  <meta charset="utf-8">
  <link rel="stylesheet" href="//cdn.bootcss.com/bulma/0.4.1/css/bulma.min.css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  
  <title>Java总结（一） | 路要坚持</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1.把第三章的客户题写完了；放在第一行代码HomeWork中2.总结本周学习的内容： 前言我发现之前还有一部分的基础知识还没有中总结，直到复习的时候才发现。已经过去一个月了。但是前面的知识还是很重要的，所以，把所有的JAVASE的知识点补充完整很重要。今天还要考试，加油吧！ 预备知识标识符：概述：就是给类,接口,方法,变量等起名字时使用的字符序列组成规则： 英文大小写字母 数字 $和_ 注意事项：">
<meta property="og:type" content="article">
<meta property="og:title" content="Java总结（一）">
<meta property="og:url" content="http://yoursite.com/2019/06/30/Java总结（一）/index.html">
<meta property="og:site_name" content="路要坚持">
<meta property="og:description" content="1.把第三章的客户题写完了；放在第一行代码HomeWork中2.总结本周学习的内容： 前言我发现之前还有一部分的基础知识还没有中总结，直到复习的时候才发现。已经过去一个月了。但是前面的知识还是很重要的，所以，把所有的JAVASE的知识点补充完整很重要。今天还要考试，加油吧！ 预备知识标识符：概述：就是给类,接口,方法,变量等起名字时使用的字符序列组成规则： 英文大小写字母 数字 $和_ 注意事项：">
<meta property="og:updated_time" content="2019-08-01T05:58:56.978Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java总结（一）">
<meta name="twitter:description" content="1.把第三章的客户题写完了；放在第一行代码HomeWork中2.总结本周学习的内容： 前言我发现之前还有一部分的基础知识还没有中总结，直到复习的时候才发现。已经过去一个月了。但是前面的知识还是很重要的，所以，把所有的JAVASE的知识点补充完整很重要。今天还要考试，加油吧！ 预备知识标识符：概述：就是给类,接口,方法,变量等起名字时使用的字符序列组成规则： 英文大小写字母 数字 $和_ 注意事项：">
  
    <link rel="alternate" href="/" title="路要坚持" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/common.css">
<link rel="stylesheet" href="/css/nav.css">
<link rel="stylesheet" href="/css/layout.css">
  

</head>

<body>
  <header id="navbar" class="overflow-hidden">
  <div class="container">
    <nav class="nav">
         <div class="nav-left">
            <a href="/" class="nav-item" style="font-size: 20px;">
              <span class="logo">王邸</span>'s Blog
            </a>
         </div>
        <div class="nav-center is-hidden position-relative" id="search_container">
            <div class="nav-item full-width full-height">
                <i class="fa fa-search has-padding" aria-hidden="true"></i>
                <input type="text" id="search_input" class="search-input full-height full-width" placeholder="Search post" autofocus>
                <i id="close_search" class="fa fa-times" aria-hidden="true"></i>
            </div>
            <div id="search_result"></div>
        </div>
        <div class="nav-right nav-menu">
            <a class="nav-item" id="search">
                <i class="fa fa-search" aria-hidden="true"></i>
            </a>
            
            <a class="nav-item" href="/">
                Home
            </a>
            
            <a class="nav-item" href="/works">
                My Works
            </a>
            
            <a class="nav-item" href="/about">
                About
            </a>
            
        </div>
        <span class="nav-toggle" id="navMenuDropdown">
            <span></span>
            <span></span>
            <span></span>
        </span>
        <div class="navbar-menu position-absolute full-width content-box is-hidden-desktop is-flex flex-column center" style="top: 100%;">
            
            <a class="nav-item flex-1" href="/">
                Home
            </a>
            
            <a class="nav-item flex-1" href="/works">
                My Works
            </a>
            
            <a class="nav-item flex-1" href="/about">
                About
            </a>
            
        </div>
    </nav>
  </div>
</header>

  <div id="main-wrap" class="position-relative" style="margin-top: 55px;">
      <div class="main-inner-content">
          <!--博文页面-->

<style>
    .header-box {
        height: 370px;
        filter: blur(10px);
        background-size: cover;
        background-color: lightsteelblue;
    }

    .post-box {
        padding: 15px;
        padding-top: 60px;
        min-height: 80vh;
        margin-top: -200px;
        border-radius: 4px;
        background-color: rgba(255,255,255,.8);
    }

    .post-avatar {
        height: 30px;
        width: 30px;
        border-radius: 50%;
    }

    .flow-chart {
        text-align: center;
    }

    img[alt="post-cover"] {
        display: none;
    }
</style>
<header>
    <div id="header_box" class="header-box"></div>
</header>
<section>
    <div class="container post-box">
        <div class="content post-title is-flex center flex-column" style="margin-bottom: 70px; overflow: auto;">
            <h1 class="has-text-centered" style="padding-bottom: 10px; border-bottom: 3px solid #fff">
                <strong>Java总结（一）</strong>
            </h1>
            
            <div class="is-flex align-center">
                <img class="post-avatar" src="https://q2.qlogo.cn/headimg_dl?bs=996057150&dst_uin=996057150&dst_uin=996057150&;dst_uin=996057150&spec=100&url_enc=0&referer=bu_interface&term_type=PC">
                <span style="padding:0 10px;"> <span class="sub-title">By</span> 王邸</span>
                <span class="post-date sub-title">at: 2019-06-30</span>
            </div>
            
                <div>
                    
                </div>
            
        </div>
        <div class="content" style="overflow: auto">
            <p>1.把第三章的客户题写完了；放在第一行代码HomeWork中<br>2.总结本周学习的内容：</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我发现之前还有一部分的基础知识还没有中总结，直到复习的时候才发现。已经过去一个月了。但是前面的知识还是很重要的，所以，把所有的JAVASE的知识点补充完整很重要。今天还要考试，加油吧！</p>
<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="标识符："><a href="#标识符：" class="headerlink" title="标识符："></a>标识符：</h3><p>概述：就是给类,接口,方法,变量等起名字时使用的字符序列<br>组成规则：</p>
<pre><code>英文大小写字母
数字
$和_
</code></pre><p>注意事项：</p>
<pre><code>不能以数字开头
不能是java中的关键字
区分大小写
</code></pre><p>命名规范：见名知义<br>  包：(其实就是文件夹,用于解决相同类名问题)<br>    单级包: 全部小写</p>
<pre><code>henson
</code></pre><p>  多级包：单词全部小写, 域名反转,单词之间以.分隔</p>
<pre><code>cskaoyan.com --&gt; com.cskaoyan
</code></pre><p>类和接口：<br>  一个单词：首字母大写，其余字母小写</p>
<pre><code>Student, Cloneable
</code></pre><p>  多个单词：所有单词首字母大写 (驼峰命名法)</p>
<pre><code>HelloWorld
</code></pre><p>方法和变量<br>  一个单词：全部小写</p>
<pre><code>main() age
</code></pre><p>  多个单词：第一个单词首字母小写，其余单词首字母大写</p>
<pre><code>showAllNames() maxAge
</code></pre><p>常量<br>  一个单词：全部大写</p>
<pre><code>PI
</code></pre><p>  多个单词：全部大写，单词之间以_分隔</p>
<pre><code>MAX_VALUE
</code></pre><h3 id="常量："><a href="#常量：" class="headerlink" title="常量："></a>常量：</h3><p>概述：在程序运行过程中，值不会发生改变的量。<br>分类：</p>
<pre><code>字面值常量
字符串常量：用双引号括起来的内容 &quot;Hello, world!&quot;
整数常量：0, 1, 100 (默认是int类型)
浮点数常量： 3.14, 2.67
字符常量： &apos;A&apos;, &apos;0&apos;, &apos;中&apos;
布尔常量： true, false
空常量： null

自定义常量(final)
</code></pre><h3 id="整数常量的四种表现形式"><a href="#整数常量的四种表现形式" class="headerlink" title="整数常量的四种表现形式"></a>整数常量的四种表现形式</h3><pre><code>二进制：0b100
八进制: 0100
十进制: 100
十六进制：0x100
</code></pre><p>注意事项：<br>  a.默认表现形式是十进制<br>  b.在JAVA是以补码的方式计算的，所以你<strong>输进去的时候就必须是补码</strong>看下面例子</p>
<pre><code>class homework3{
  public static void main(String[] args){
    System.out.println(Long.toHexString(0x100000000L + 0xcafebabe));//打印出cafebabe 并不需要转
  }
}
</code></pre><h3 id="数据类型："><a href="#数据类型：" class="headerlink" title="数据类型："></a>数据类型：</h3><p>  Java语言是强类型语言，对于每一种数据都定义了明确的具体数据类型。<br>  分类：<br>  <strong>基本数据类型(8种)</strong></p>
<table>
<thead>
<tr>
<th>整数</th>
<th style="text-align:center">字节</th>
<th style="text-align:center">范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td style="text-align:center">1</td>
<td style="text-align:center">-128 ~ 127</td>
</tr>
<tr>
<td>short</td>
<td style="text-align:center">2</td>
<td style="text-align:center">65536</td>
</tr>
<tr>
<td>int</td>
<td style="text-align:center">4</td>
<td style="text-align:center">43亿(int不能表示全体人类)</td>
</tr>
<tr>
<td>long</td>
<td style="text-align:center">8</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>表示方式：</p>
<pre><code>二进制：0b
八进制：0
十进制：
十六进制：0x
</code></pre><table>
<thead>
<tr>
<th>浮点数</th>
<th style="text-align:center">字节</th>
<th style="text-align:center">范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>float</td>
<td style="text-align:center">4</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>double</td>
<td style="text-align:center">8</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>表示方式：</p>
<pre><code>十进制数形式，如: 3.14   314.0
科学记数法：如：3.14e0  3.14e2
</code></pre><table>
<thead>
<tr>
<th>类型</th>
<th style="text-align:center">字节</th>
<th style="text-align:center">举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>字符char</td>
<td style="text-align:center">2</td>
<td style="text-align:center">‘中’</td>
</tr>
<tr>
<td>布尔boolean</td>
<td style="text-align:center">1</td>
<td style="text-align:center">true, false。</td>
</tr>
</tbody>
</table>
<p>引用数据类型</p>
<pre><code>类, 接口, 数组
</code></pre><p>注意事项：</p>
<pre><code>char占用两个字节，在Java中char采用是Unicode编码。
在Java中不能用0表示false, 非0表示true。
整数字面值常量默认是int类型，如果要表示long类型的整数，后面要加l或L, 最好使用大写L.
浮点数字面值常量默认是double类型。如果要表示float类型，后面要加f或F.
</code></pre><p>看例子：</p>
<pre><code>/*
猜测答案：66666
实际答案：17777
注意数的类型
*/
class DataTypeDemo3 {
  public static void main(String[] args) {
    System.out.println(12345 + 5432l); //这是小写的L
    System.out.println(12345 + 5432L);
  }
}
</code></pre><h3 id="隐式转化："><a href="#隐式转化：" class="headerlink" title="隐式转化："></a>隐式转化：</h3><pre><code>byte --&gt; short --&gt; int --&gt; long --&gt; float --&gt; double.
char --&gt; int
</code></pre><p>注意事项：</p>
<pre><code>byte b = 10;编译器会判断常量值是否超出byte的表示范围，如果超出了就编译不通过，否则就赋值成功。
boolean 不能和其他基本类型转换。
char能够转换成int类型。(把char看成特殊的整型)
</code></pre><p>问题：long占用8个字节, float占用4个字节, 为什么 long –&gt; float？</p>
<pre><code>原因是整数和浮点数在计算机中存储的方式不一样。float的表数范围是比long类型大的。
2^63 &lt; 8^21 &lt; 3.4*10^38
</code></pre><p>面试题</p>
<pre><code>byte b1=3,  b2=4, b;
b = b1 + b2; (1)
b = 3 + 4;   (2)
</code></pre><p>哪句是编译失败的呢？为什么呢？<br>第一句编译失败，加法会隐式转化成int类型相加<br>第二句两个常量值相加为7没有超过byte的范围不会报错</p>
<p>注意事项：</p>
<pre><code>byte, short, char 参与运算的会自动提升为int类型。即使是同一种数据类型参与运算。
</code></pre><h3 id="强制类型转换："><a href="#强制类型转换：" class="headerlink" title="强制类型转换："></a>强制类型转换：</h3><p>  目标类型 变量名= (目标类型)(被转换的数据);<br>  一般建议，最好不要随意使用强制类型转换，容易造成数据精度的损失。<br>  1) 表数范围大的数据类型转换为表数范围小的数据类型时，要加上强制转换符，但可能造成精度损失；使用时要格外注意。<br>  2) 有多种类型的数据混合运算时，系统首先自动的将所有数据转换成容量最大的那一种数据类型，然后再进行计算。</p>
<p><strong>看题目（注意强制类型转换是否有符号位转换）</strong></p>
<pre><code>class DataTypeDemo4 {
  public static void main(String[] args) {
    /*int i = -1;
    System.out.println(i);*/
    int i = (int)(char)(byte) -1;
    System.out.println(i); //65535
  }
}

int： 1111 1111 1111 1111 1111 1111 1111 1111
byte: 1111 1111(有符号的整数, 符号位扩展)
char: 1111 1111 1111 1111 (无符号的整数, 执行0扩展)
int:  0000 0000 0000 0000 1111 1111 1111 1111

/*
猜测结果：1000000
答案：-21
原因：nanosPerday超出int的表示范围。
1. 把nanosPerDay声明成long类型。
  结果还是-21. 为什么？因为计算的结果int 之后在转成long的。所以应该在第一个数开始加L
2. 24 * 60 * 60 * 1000 * 1000 * 1000它的结果就已经出现了精度损失。怎么改进？在后面添加L.
  答案是5794.
3. 24 * 60 * 60 * 1000 * 1000 就已经超出int的表数范围，出现了精度损失
建议在第一个数前面加L这样计算就都以long类型来计算了
*/
class DataTypeDemo5 {
  public static void main(String[] args) {
    int millisPerDay = 24 * 60 * 60 * 1000;
    //int nanosPerDay = 24 * 60 * 60 * 1000 * 1000 * 1000;
    long nanosPerDay = 24L * 60 * 60 * 1000 * 1000 * 1000;
    System.out.println(nanosPerDay / millisPerDay); // 1000*1000
  }
}
</code></pre><p>请写出下列程序结果</p>
<pre><code>System.out.println(‘a’);
System.out.println(‘a’+1);  //98
System.out.println(“hello”+’a’+1);   //helloa1
System.out.println(‘a’+1+”hello”);   //98hello
System.out.println(“5+5=”+5+5);
System.out.println(5+5+”=5+5”);
</code></pre><p>char 就是特殊的整型，可以转换成无符号的int<br>+都是从左到右结合</p>
<h3 id="JAVA关于余数的处理"><a href="#JAVA关于余数的处理" class="headerlink" title="JAVA关于余数的处理"></a>JAVA关于余数的处理</h3><pre><code>/*
算术运算符：
  + - * / % ++ --
  +：
    a. 加法操作
    b. 表示正数
    c. 表示字符串的拼接 (运算符的重载)

  /: 整数之间相除，结果是整数。(向0取整)
    四舍五入, 向上取整, 向下取整, 向0取整
    如果想得到浮点数，怎么办？
    在前面乘以1.0即可

  %：定义： a % b = a - (a / b) * b;
    取余%操作是一个复杂的操作，比较耗时。在一些对性能要求比较高的应用中，最好不要用取余操作。

注意取余数：
  JAVA取余数和现实取余数是不同的。
  现实的余数都是正的，
  JAVA的余数可是是负数
*/
class OperatorDemo3 {
  public static void main(String[] args) {
    int a = 3;
    int b = 4;
    System.out.println(a + b); // 7
    System.out.println(a - b); // -1
    System.out.println(a * b); // 12
    System.out.println(a / b); // 0
    System.out.println(1.0 * a b); // 0.75

    System.out.println(&quot;--------------------------&quot;);
    //%：java定义： a % b = a - (a / b) * b;
    System.out.println(a % b);  // 3 mod 4 = 3,     3 % 4 = 3 - (3 / 4) * 4 = 3;
    System.out.println(-a % b); // -3 mod 4 = 1,    -3 % 4 = -3 - (-3 / 4) * 4 = -3
    System.out.println(a % -b); // 3 mod -4 = 3     3 % -4 = 3 - (3 / -4) * -4 = 3;
    System.out.println(-a % -b); // -3 mod -4 = 1   -3 % -4 = -3 - (-3 / -4) * -4 = -3;
  }
}
</code></pre><h3 id="关于自增自减的问题"><a href="#关于自增自减的问题" class="headerlink" title="关于自增自减的问题"></a>关于自增自减的问题</h3><p>自增：++</p>
<pre><code>前自增：++a; 先自增再参与计算
后自增：a++; 先参与计算，再自增
</code></pre><p>自减：–</p>
<pre><code>前自减：--a; 先自减再参与计算
后自减：a--; 先参与计算，再自减
</code></pre><p>注意事项：</p>
<pre><code>单独使用效果相同
参与运算使用，在操作数的前后效果不同


class OperatorDemo4 {
  public static void main(String[] args) {
    int a = 10;
    int b = 10;
    int c = 10;

    a = b++; // a=10, b=11, c=10
    c = --a; // a=9, b=11, c=9
    b = ++a;// a=10, b=10, c=9
    a = c--;// a=9, b=10, c=8

    System.out.println(&quot;a=&quot; + a); // a=9
    System.out.println(&quot;b=&quot; + b); // b=10
    System.out.println(&quot;c=&quot; + c); // c=8
</code></pre><p>//算数运算符是从左到右结合的；</p>
<pre><code>int a = 4;
int b = (a++) + (++a) + (a*10); // b = 4 + 6 + 60 = 70
</code></pre><p><strong> 注意运算符的优先级，自增自减优先级是大于乘除和加减的</strong></p>
<p>答案：</p>
<pre><code>b = a++ = 4   (a = 5)
b = 4 + (++a) = 4 + 6 = 10 (a = 6)
b = 10 + a* 10 = 70
</code></pre><p>问题二</p>
<pre><code>    int i = 12;
    System.out.println(i+=i-=i*=i) ;

    //先写成：
    i = i + i
    i = i - i
    i = i * i
    //然后把每行的结果放到上一行
    i = i + i - i*i;
    // 12+12-（12*12）= -120

  }
}
</code></pre><p>//问题三</p>
<pre><code>class OperatorDemo5 {
  public static void main(String[] args) {
    int a = 3;
    a = a++;
    a = a++;
    a = a++;
    a = a++;// 3

    // a = ++a;
    // a = ++a;
    // a = ++a;
    // a = ++a; //7
    System.out.println(a);
  }
}


int b = a++;
  int temp = a;
  a = a + 1;
  b = temp;
a = a++
  int temp = a; //先赋值
  a = a + 1;   //再加加了
  a = temp;
先加加再赋值
int b = ++a;
  a = a + 1;
  b = a;
</code></pre><h2 id="星期一"><a href="#星期一" class="headerlink" title="星期一"></a>星期一</h2><h3 id="赋值运算符："><a href="#赋值运算符：" class="headerlink" title="赋值运算符："></a>赋值运算符：</h3><p>基本运算符 =<br>拓展赋值运算符： += -= 等<br>a=b=10<br>1.赋值表达式是有值的<br>  a+b<br>  b=10; //它的值等于赋值运算符右边表达式的值；<br>2.赋值运算符从右向左结合的； 但是算数运算符是从左到右结合的；<br>  a += 20; –&gt; a = a + 20;  不能写a = 20 + a;<br>  左边一定要放在左边；a -= b –&gt; a = a-b; 只改变a的值；</p>
<p>注意事项：<br>    扩展的赋值运算符隐含了强制类型转换；<br>    btye b1 = 10;<br>    btye b2 = 20;<br>    <strong>b1 = b1 + b2;  //会报错，运算换变成int进行计算，再赋值回给byte肯定不行</strong><br>    b1 += b2;  –&gt;（byte）(b1+b2);//不会报错；<br>    System.out.println(b1); //不会报错</p>
<h3 id="关系运算符："><a href="#关系运算符：" class="headerlink" title="关系运算符："></a>关系运算符：</h3><pre><code>== ！= &lt; &gt; &lt;= &gt;= instanceof
</code></pre><p>注意事项：</p>
<pre><code>instanceof 运算符不能用于基本数据类型;用于判断两个类是否相同
比较运算符结果是布尔型 true or  false;
比较运算符不要写成赋值运算符，特别在if的判断中;
</code></pre><h3 id="逻辑运算符："><a href="#逻辑运算符：" class="headerlink" title="逻辑运算符："></a>逻辑运算符：</h3><p>&amp;&amp;:第一个是false，第二个表达式就不会被计算<br>||：第一个是true, 第二个表达式也不会计算；</p>
<p>在以后开发中，我们可以&amp; ，| 还是&amp;&amp; ||<br>答：使用&amp;&amp; || 节约时间 方便编码，看下面的例子</p>
<pre><code>if(i &lt; arr.length &amp;&amp;  arr[i] &lt; arr[arr.length])
</code></pre><p>这样写就不会出现数组下标越界的异常，如果写&amp; 两个都判断就可能出现数组下标越界的异常</p>
<h3 id="位运算-难-："><a href="#位运算-难-：" class="headerlink" title="位运算(难)："></a>位运算(<strong><em>难</em></strong>)：</h3><pre><code>&lt;&lt;   &gt;&gt;   &gt;&gt;&gt; （无符号右移） &amp; | ^ ~
</code></pre><p>按位与： &amp;  同时为1 结果为1；<br>按位或： |  同时为0 结果为0 否则为1<br>按位异或： ^ 不同为1 其余为0<br>按位取反： ~  单目运算符</p>
<p>注意事项：<br>    位运算只能用于整数和char(char类型可以看成无符号的整数)；<br>    位运算的效率是最高的</p>
<p>一些用位运算题目：</p>
<h4 id="1-对2的n次幂取余-都可以转成位运算"><a href="#1-对2的n次幂取余-都可以转成位运算" class="headerlink" title="1.对2的n次幂取余 都可以转成位运算"></a>1.对2的n次幂取余 都可以转成位运算</h4><p>a % 64 == a &amp;（2^n-1）;<br>2^n:<br>    1101 1101<br>%<br>    0100 0000</p>
<p>可以转换成：<br>    1101 1101<br>&amp;<br>    0011 1111</p>
<p>应用1：判断一个数是奇数还是偶数<br>a &amp; 1 = 1 -&gt; 奇数<br>a &amp; 1 = 0 -&gt; 偶数</p>
<p>应用2：在hashMap的数组中，在求index时候就会求余数的操作。而且hashMap的数组长度是2^n就是为了方便取余数。使用的就是这里的方法；</p>
<h4 id="2-判断一个数是否是2的n次幂？"><a href="#2-判断一个数是否是2的n次幂？" class="headerlink" title="2.判断一个数是否是2的n次幂？"></a>2.判断一个数是否是2的n次幂？</h4><p>  2^n :因子都是2；<br>  时间复杂度：log n;</p>
<p>能否在常量时间复杂度内，判断一个数是否是2^n;<br>  2^n的存储特点：只有一个1 ，后面全部0；<br>  a &amp; (a-1) == 0;</p>
<p>  0100 0000<br>&amp; 0011 1111<br>  0000 0000</p>
<h4 id="3-两个整数变量的交换"><a href="#3-两个整数变量的交换" class="headerlink" title="3.两个整数变量的交换"></a>3.两个整数变量的交换</h4><p>int a = 4;<br>int b = 3;<br>a = a ^ b;  //  a = 4 ^ 3 ,b = 3<br>b = a ^ b;  //  a = 4 ^ 3 ,b = 4^3^3= 4<br>a = a ^ b;  //  a = 4 ^ 3 ^ 4 = 3 ,b = 4</p>
<h4 id="4-有一堆数字，都是成对出现了。只有一个是单独出现的。找出那个单独的整数"><a href="#4-有一堆数字，都是成对出现了。只有一个是单独出现的。找出那个单独的整数" class="headerlink" title="4.有一堆数字，都是成对出现了。只有一个是单独出现的。找出那个单独的整数"></a>4.有一堆数字，都是成对出现了。只有一个是单独出现的。找出那个单独的整数</h4><p>  可以不是排序的<br>  1,1,2,2,a,a+1,a+1,a+2,a+2….</p>
<p>  0 ^ 1 ^ 1 ^ 2 ^ 2 ….</p>
<p>因为a^a = 0<br>0 ^ 任何数 = 任何数 所以能直接找出单独的数。<br>但是这里有个问题，如果a = 0能否找出?<br>如果最后的结果是0是有两种答案：<br>1）没有单独的数<br>2）单独的数就是0</p>
<p>&lt;&lt; 左移： 低位补0 高位丢失<br>&gt;&gt; 右移： 高位补符号位 低位丢弃<br>&gt;&gt;&gt;无符号右移：高位补0 低位丢弃</p>
<p>注意事项：<br>    左移：左移N个单位，相当乘以2^n;<br>    右移：右移n个单位，相当于除以2^n;<br>    对于移位运算符来说，当操作数超出字长时；实际移动n mod 字长<br>    int a = 64<br>    a&gt;&gt; 32 = a</p>
<h2 id="星期二"><a href="#星期二" class="headerlink" title="星期二"></a>星期二</h2><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>  switch表示这是switch语句<br>  表达式的取值：byte, short, int, char<br>    JDK5以后可以是：枚举<br>    JDK7以后可以是：String<br>  case后面跟的是要和表达式进行比较的值<br>  语句体部分可以是一条或多条语句<br>  break表示中断，结束的意思，可以结束switch语句<br>  default语句表示所有情况都不匹配的时候，就执行该处的内容，和if语句的else相似。</p>
<p>注意事项:<br>  a. case后面只能是常量，不能是变量，而且，多个case后面的值不能出现相同的<br>  b. default可以省略吗?<br>    可以省略。一般不建议。除非判断的值是固定的。(单选题)<br>  c. break可以省略吗?<br>    可以省略，一般不建议。否则结果可能不是你想要的 (case穿越)<br>  d. default的位置一定要在最后吗?<br>    可以出现在switch语句任意位置。<br>  e. switch语句的结束条件<br>    遇到break<br>    执行到程序的末尾</p>
<p>使用场景<br>  a. if语句是通用的。<br>  b. case只有几种常量的情况, 对于常量还有一些限制。(比较单一)<br>    byte, short, int, char, enum, String</p>
<h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>死循环,注意下面这个例子</p>
<pre><code>for(int i = Integer.MAX_VALUE - 10; i &lt;= Integer.MAX_VALUE; i++) {
  System.out.println(&quot;我爱刘亦菲!&quot;);
}
for(int i = Integer.MAX_VALUE - 10; i &lt;= Integer.MAX_VALUE; i++) {
  System.out.println(&quot;我爱刘亦菲!&quot;);
}
</code></pre><p><strong>上面这个for循环会一直出不了。因为整数最大值加到最大，就变成了最小值。然后再加上来，又循环</strong></p>
<pre><code>// for(;;);
// System.out.println(&quot;我爱学JAVA!&quot;); 无法访问的语句

// while(true);
// System.out.println(&quot;我爱学JAVA!&quot;); 无法访问的语句
</code></pre><p>循环的题目：<br>请统计1-1000之间同时满足如下条件的数据有多少个：<br>  对3整除余2<br>  对5整除余3<br>  对7整除余2</p>
<p>分析：</p>
<ol>
<li>定义统计变量 count = 0;</li>
<li>循环：1 ~ 1000;<br>判断这个数是够满足：<br> 对3整除余2<br> 对5整除余3<br> 对7整除余2<br>满足：输出这个数,count++</li>
<li>输出count</li>
</ol>
<p>小学生的痛苦：<br>  求满足这个条件最小正整数：<br>    对3整除余2<br>    对5整除余3<br>    对7整除余2</p>
<p>（注意这个思路）<br>  a. 假设s满足条件, 下一个满足条件的数是多少？<br>    下一个数：s + 105n (n = 1,2,3,4…)也满足条件<br>  b. 构建一个数满足这个条件<br>    3 X 5 = 15<br>      15 % 7 == 1<br>    3 X 7 = 21<br>      21 % 5 == 1<br>    5 X 7 =35<br>      35 % 3 == 2<br>    p = 15a + 21b + 35c (a,b,c为余数)<br>      p % 7 == a<br>      p % 5 == b<br>      p % 3 == 2c<br>      a = 2, b = 3, c=1<br>    p = 30 + 63 + 35 = 128;<br>    p - 105 =23;</p>
<p>while语句和for语句的区别：</p>
<ol>
<li>变量的作用范围</li>
<li>使用场景<br>for更适合循环次数确定情况。<br>while更适合循环次数不明确的情况。</li>
</ol>
<h3 id="跳转控制语句："><a href="#跳转控制语句：" class="headerlink" title="跳转控制语句："></a>跳转控制语句：</h3><p>  break: 中断<br>  continue: 继续<br>  return: 返回</p>
<p>break<br>使用场景：<br>  a. switch语句<br>  b. 循环语句</p>
<p>  break会跳出离他最近的外层循环。<br>  如果想跳出多层循环怎么办呢？</p>
<p>标签:<br>  格式<br>    标签名: 要标识的语句</p>
<p>  标签可以标识任意语句<br>标签害人不浅看下面的代码</p>
<pre><code>class TagDemo {
  public static void main(String[] args) {
    https://www.cskaoyan.com
    System.out.println(&quot;我爱中华!&quot;);
  }
}
</code></pre><p>编译能通过而且运行不会报错问题就是：</p>
<pre><code>https:被当成了标签
//www.cskaoyan.com被当成了注释
</code></pre><h3 id="方法（上）："><a href="#方法（上）：" class="headerlink" title="方法（上）："></a>方法（上）：</h3><p>  概述：完成特定功能的代码块。<br>    类比：数学中的函数<br>    在其他语言里面都有函数(function)的定义<br>    函数在Java中被称为方法 (method)</p>
<p>  格式：<br>    修饰符 返回值类型 方法名(参数类型 参数名1, 参数类型 参数名2…) {<br>      函数体;<br>      return 返回值;<br>    }</p>
<p>  方法格式解释<br>    修饰符 比较多，后面会详细介绍。目前 public static<br>    返回值类型 用于限定返回值的数据类型<br>    方法名 标识符，为了方便我们调用方法<br>    参数类型 限定调用方法时传入参数的数据类型<br>    参数名 是一个变量，接收调用方法时传入的参数<br>    方法体 完成功能的代码<br>    return 结束方法以及返回方法指定类型的值<br>    返回值 程序被return带回的结果，返回给调用者</p>
<p>  如何写一个方法：<br>    a. 明确功能<br>    b. 返回值类型<br>    c. 参数列表</p>
<p>  练习：求两个数据之和</p>
<pre><code>/*
  功能：求两个数据的和
  返回值类型：int
  参数列表： int int
*/
</code></pre><p>  返回值类型不为void方法的调用：<br>    a. 单独调用<br>    b. 输出调用<br>    c. 赋值调用</p>
<p>注意事项：<br>  方法不调用不执行。</p>
<h2 id="星期三："><a href="#星期三：" class="headerlink" title="星期三："></a>星期三：</h2><h3 id="方法-下"><a href="#方法-下" class="headerlink" title="方法(下)"></a>方法(下)</h3><p>包：同一个包下面能够有两个名字相同的类吗？<br>    不能<br>同一个类下面能有两个名字相同的方法吗？<br>    可以。方法的重载。</p>
<p>方法重载：<br>  a. 在同一个类<br>  b. 方法名字相同<br>  c. 参数列表不同(参数类型, 参数个数, 参数顺序)</p>
<p>术语：方法的签名(signature) 方法名 + 参数列表<br>  同一个类中方法名字可以相同，但是方法的签名不能相同</p>
<p>问题：方法的签名为什么与返回值类型无关？<br>  如果包括返回值类型，那么函数运行就不知道应该是走去void 的 还是去int返回值的方法。<br>  但是感觉再智能一点就能判断；<br>  单独调用时，就不能区分到底使用哪个方法。</p>
<p>问题2：求两个数据的和。参数类型分别为两个byte类型，两个short类型，两个int类型，两个long类型，并在main方法中进行测试。</p>
<p>问题： 如果传入的参数类型不同会怎么样,如下代码：</p>
<pre><code>public int add(int a, int b) {
  return a+b;
}
public double add(double a, double b) {
  reuturn a+b;
}
add(10,10.111);
</code></pre><p>  A 编译不通过<br>  B 运行报错<br>  C 可以运行</p>
<p>答案：C 结果是double类型</p>
<p>建议：<br>  如果方法实现一样，但是数据类型兼容。就没有必要使用方法的重载。<br>  他会默认选择大的范围进行调用</p>
<h3 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h3><p>数组的初始化：<br>  就是为数组中的数组元素分配内存空间，并为每个数组元素赋初值。</p>
<p>动态初始化：<br>  由程序员指定长度，系统决定初始值。<br>  格式：<br>    数据类型[] 数组名 = new 数据类型[数组的长度];<br>  举例：<br>    int[] arr = new int[3];</p>
<p>解释：<br>  [I@15db9742<br>  [: 一维数组<br>  I: 数组元素是int类型<br>  @: 表示分隔符<br>  15db9742：16进制的数, 内存地址的映射<br>实际是一个哈希值：</p>
<pre><code>public String toString() {
  return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());
}
</code></pre><p>打印一个对象时，默认调用toString()方法，可以看到其实就是把对象名转成哈希值然后转成16进制。</p>
<p>java的内存分配<br>  栈：局部变量, 执行方法<br>  堆：new出来的东西 (对象)<br>  方法区<br>  本地方法栈<br>  程序计数器：字节码的行号指示器</p>
<p>怎么引用数组中的元素值呢？<br>  索引(从0开始编号)<br>  数组名[索引]</p>
<p>堆上的数据都会有默认初始值<br>  向堆申请空间的时候，都会把这片内存空间清0<br>  默认值：<br>    byte    0<br>    short   0<br>    int     0<br>    long    0L<br>    float   0.0f<br>    double    0.0<br>    boolean   false<br>    char    \u0000<br>    引用数据  null</p>
<p>注意事项：<br>  如果数组索引超出范围，会报 java.lang.ArrayIndexOutOfBoundsException.</p>
<p>空常量：null<br>  可以给所有的引用数据类型赋值<br>空指针异常：<br>  java.lang.NullPointerException</p>
<h2 id="星期四："><a href="#星期四：" class="headerlink" title="星期四："></a>星期四：</h2><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>结论：<br>  a. Java中只有值传递。<br>  b. 基本数据类型传递参数的时候相当于c语言中值传递。<br>  c. 引用数据类型传递参数的时候相当于c语言中地址传递。</p>
<p>需要注意以下问题：</p>
<pre><code>int[] arr1 = {1, 2, 3};
int[] arr2 = {4, 5, 6};
System.out.println(Arrays.toString(arr1)); //[1, 2, 3]
System.out.println(Arrays.toString(arr2)); //[4, 5, 6]
change(arr1, arr2);
System.out.println(Arrays.toString(arr1)); //[1, 2, 3]
System.out.println(Arrays.toString(arr2)); //[4, 5, 6]

public static void change(int[] arr1, int[] arr2) {
  int[] temp = arr1;
  arr1 = arr2;
  arr2 = temp;
}
</code></pre><p>这里并不会交换数组。不要死记硬背说引用类型会修改。这里只是在调用change函数时，<br>把两个数组位置变化。并没有影响main函数中的值。所以打印出来自然就不会变了</p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>  方法定义中调用方法本身的现象<br>  java.lang.StackOverflowError：死递归, 递归太深了<br>  递归小心重复计算的问题</p>
<p>递归和循环在某些情况下可以相互转换。</p>
<pre><code>class RecursionDemo3 {
  public static void main(String[] args) {
    System.out.println(factorial(4));
  }

  /*public static long factorial(int n) {
    long result = 1;
    for(int i = 2; i &lt;= n; i++) {
      result *= i;
    }
    return result;
  }*/

  public static long factorial(int n) {
    if(n == 1) return 1;
    return n * factorial(n-1);
  }
}
</code></pre><h3 id="递归经典问题-难"><a href="#递归经典问题-难" class="headerlink" title="递归经典问题(难)"></a>递归经典问题(<strong><em>难</em></strong>)</h3><p><strong>汉诺塔问题</strong>：<br>汉诺塔是根据一个传说形成的数学问题：</p>
<p>有三根杆子A，B，C。A杆上有 N 个 (N&gt;1) 穿孔圆盘，盘的尺寸由下到上依次变小。要求按下列规则将所有圆盘移至 C 杆：</p>
<p>每次只能移动一个圆盘；<br>大盘不能叠在小盘上面。<br>提示：可将圆盘临时置于 B 杆，也可将从 A 杆移出的圆盘重新移回 A 杆，但都必须遵循上述两条规则。</p>
<p>问：最少要移动多少次？如何移？</p>
<p>分析：<br>n=1:<br>  A –&gt; C<br>  count = 1</p>
<p>n=2:<br>  A –&gt; B<br>  A –&gt; C<br>  B –&gt; C<br>  count = 3</p>
<p>n=3:<br>  A –&gt; C<br>  A –&gt; B<br>  C –&gt; B<br>  A –&gt; C<br>  B –&gt; A<br>  B –&gt; C<br>  A –&gt; C<br>  count=7;</p>
<p>分析：<br>  假设移动n个圆盘最小需要count(n)次，递归的公式：<br>  count(1) = 1;<br>  count(n) = 2* count(n-1) + 1 （n &gt; 1）; // 两个count(n-1)次 一次是把上面n-1个移动到B 第二次是把n-1个从B移动到C</p>
<p>  h(1) = 1;<br>  h(n) = 2h(n-1) + 1;<br>  h(n) + 1 = 2 (h(n-1) + 1);<br>  h(n) + 1 = 2 * 2^(n-1) = 2^n;<br>  h(n) = 2^n - 1;</p>
<p><strong>结论：从以上可以看出，递归解决的不是计算移动多少次的问题。而是要去解决如何去移动的问题</strong></p>
<p>  如何移？<br>  定义一个函数表示把n个盘子从begin,通过middle,移动到end上面。<br>  返回值类型: void<br>  参数列表：int n, char begin, char middle, char end</p>
<p>  递推公式：<br>    把n-1盘子从begin,经过end,移动到middle<br>    把最大的盘子从begin移动到end.<br>    把n-1盘子从middle,经过begin,移动到end</p>
<p>可以使用递归的条件：</p>
<ol>
<li>大问题可以分解成子问题。</li>
<li>子问题的解决方法和大问题一模一样，只是数据规模不一样。</li>
<li>有终止条件。</li>
</ol>
<p>使用递归需要注意事项：<br>  a.StackOverflowError<br>  b.警惕重复计算的问题</p>
<pre><code>class RecursionDemo5 {
  public static void main(String[] args) {
    System.out.println(&quot;请输入盘子的个数：&quot;);
    Scanner sc = new Scanner(System.in);
    int n = sc.nextInt();
    /*long count = count(n);
    System.out.println(&quot;count=&quot; + count);*/
    hanoi(n, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;);
  }

  public static long count(int n) {  //移动多少次，使用递归效率低下
    //使用递归效率低下
    /*if(n==1) return 1;
    return 2 * count(n-1) + 1;*/

    //可以直接通过得到的递归公式求出答案更快h(n) = 2^n - 1;
    return (long)Math.pow(2, n) - 1;
  }

  //定义一个函数表示把n个盘子从begin,通过middle,移动到end上面
  //递归要解决的不是最后的结果，而是过程是怎么算的
  public static void hanoi(int n, char begin, char middle, char end) {
    if(n == 1) {
      System.out.println(begin + &quot; --&gt; &quot; + end);
      return ;
    }
    hanoi(n-1, begin, end, middle);
    System.out.println(begin + &quot; --&gt; &quot; + end);
    hanoi(n-1, middle, begin, end);
  }
}
</code></pre><p><strong>计算n条直线最多能把平面分成多少部分？</strong><br>分析：<br>  第一条线:可以分成两个平面<br>  第二条线：出现一个交点将分多两个平面<br>  第三条线：多分出两个焦点 两个交点分出多3个平面；<br>  。。。。<br>  之后多产生的n个焦点就多出n+1个平面<br>  第n条线时将在原来的基础上多产生n-1个焦点，即在原来的基础上多产生n个面，所以递推公式为：<br>  f(n) = f(n-1) + n;</p>
<p>  f(1) = 2;<br>  f(n) = f(n-1) + n;</p>
<p>  f(n) = f(n-1) + n<br>     = f(n-2) + n-1 + n<br>     = f(n-3) + n-2 + n<br>     = f(1) + 2 + 3 + … + n = n(n+1)/2 + 1;</p>
<pre><code>import java.util.Scanner;
class RecursionDemo6 {
  public static void main(String[] args) {
    System.out.println(&quot;请输入直线的条数：&quot;);
    Scanner sc = new Scanner(System.in);
    int n = sc.nextInt();
    System.out.println(f(n));
  }
  public static int f(int n) {
    /*if(n == 1) return 2;
    return f(n-1) + n;*/
    return n * (n+1) / 2 + 1;
  }
}
</code></pre><p><strong>约瑟夫环</strong><br>  有n个人站成一个环,每个一个人,干掉一个人,直到只有一个人。<br>  问编号为几的人会活下来？</p>
<p>  返回值类型: int<br>  参数列表: int</p>
<p>分析：<br>  joseph(1) = 1<br>  joseph(2) = 1 = 2 <em> 1 - 1 = 1;<br>  joseph(3) = 3 = 2 </em> 1 + 1 = 3<br>  joseph(4) = 1 = 2 <em> 1 - 1 = 1<br>  joseph(5) = 3 = 2 </em> 1 + 1 = 3<br>  joseph(6) = 2 * 3 - 1 = 5</p>
<p>  递推公式：<br>  joseph(1) = 1;<br>  joseph(2n) = 2 <em> joseph(n) - 1;<br>  joseph(2n+1) = 2 </em> joseph(n) + 1;</p>
<p>  解释：<br>  这和网上看到n和n-1的关系式子不一样。网上的是：<br>  f(N,M) = (f(N-1,M) + M) % N;<br>  N表示N个人，M表示叫到M的人出列；<br>  正着推就是：<br>  N个人当叫到M的人出列时，就会重新开始报数，这样就变成N-1个人的游戏。所有的没出列的人的下标都会减M。<br>  反过来说，<br>  当N-1个人参加时，要变成N个人的比赛，就要加上M，就是之前往前走的下标。但是可能会出现溢出情况。所以要对N取余数</p>
<p>  而老师给的递推式：<br>  先来看偶数的情况：第一轮结束：<br>  1,2,3,4,5,6 = 》 1,3,5（剩下三个人）<br>  而我们知道只有三个人时：<br>  1,2,3 =》 3 最后幸存的就是3 对应上面 1 3 5 最后活着的就是 5。<br>  1,3,5 =》 5<br>  这里就有关系就是 f(6) = f(3)<em>2 - 1 即 5 = 3</em>2 -1；</p>
<p>  再来看奇数的情况：<br>  1,2,3,4,5,6,7 =》 1,3,5,7 =》 3,5,7 =》 7<br>  这里我要说明的是，1,3,5,7并不是第一轮剩下的人，因为奇数个的情况，所以第一轮结束1一定会死,因为剩下最后一个奇数位置的人，而在理解时候相当于在最后一个人和1之间还有一个人，这时一轮下来1就死了。接下去继续<br>  这里3,5,7 就相当于上面的 1,2,3=》3<br>  那么最后活着的就是7<br>  f(7) = f(3)<em>2 + 1 即 7 = 3</em>2 +1</p>
<pre><code>import java.util.Scanner;
class RecursionDemo7 {
  public static void main(String[] args) {
    Scanner scan = new Scanner(System.in);
    int n = scan.nextInt();
    System.out.println(joseph(n));
  }
  public static int joseph(int n) {
    if(n &lt;= 0) return 0; //n=0会一直循环
    if(n == 1) return 1;
    if (n % 2 == 0) {  //偶数的情况
      return 2 * joseph(n / 2) - 1;
    }
    return 2 * joseph(n / 2) + 1;  //奇数的情况
  }
}
</code></pre><h2 id="星期五"><a href="#星期五" class="headerlink" title="星期五"></a>星期五</h2><h3 id="面向对象部分"><a href="#面向对象部分" class="headerlink" title="面向对象部分"></a>面向对象部分</h3><p>变量<br>成员变量和局部变量的区别<br>  a.在内存中位置不同</p>
<pre><code>局部变量: 栈
成员变量：堆
</code></pre><p>  b.初始化值不同</p>
<pre><code>局部变量: 没有默认值, 没有初始化，就不能使用。
成员变量：有默认值。
  byte, short, int, long  0
  float, double     0.0
  char          &apos;\u0000&apos;
  boolean         false
  引用类型        null
</code></pre><p><strong>局部变量一定要记得给初始化的值，并不像成员变量。这点很容易忘记，所以你要记得！</strong></p>
<p>  c.在类中位置不同</p>
<pre><code>局部变量: 方法内或者方法声明上
成员变量：类中,方法外
</code></pre><p>  d.生命周期不同</p>
<pre><code>局部变量: 随着方法的入栈而开始，随着方法的出栈而消亡
成员变量：随着对象的创建而开始, 随着对象的死亡而消亡
</code></pre><p>  匿名对象：</p>
<pre><code>就是没有名字的对象。
是对象的一种简化表示形式
</code></pre><p>  匿名对象的两种使用情况</p>
<pre><code>对象仅仅使用一次的时候
作为实际参数传递
</code></pre><p>封装：<br>封装(encapsulation)<br>  封装是一种信息隐藏技术。</p>
<p>  好处：<br>    a. 隐藏类的实现细节,实现了信息的隐藏及安全性；<br>    b. 提高了程序的模块化，且易于维护；<br>    c. 保证了数据的安全和系统的严密性;<br>    d. 将类的设计者和类的使用者分开。<br>  封装的技术包括：包, 类, 方法, 访问权限修饰符。</p>
<p>private:<br>  私有的。是一种访问权限修饰符。<br>  被private修饰的成员变量或者成员方法只能在本类进行访问.</p>
<p>  最常见的用法：<br>    把成员变量用private修饰<br>    然后提供getXxx()/setXxx()方法   getter &amp; setter</p>
<p>构造方法：<br>  作用：给对象的数据进行初始化<br>  格式：<br>    方法名与类名相同<br>    没有返回值类型<br>  注意事项：</p>
<pre><code>a. 如果没写构造方法,系统会提供无参构造方法(默认的构造方法)。
b. 如果提供了构造方法, 系统将不再提供无参的构造方法。(建议: 自己写一个无参的构造方法)
c. 构造方法也是可以重载的
</code></pre><h2 id="星期六"><a href="#星期六" class="headerlink" title="星期六"></a>星期六</h2><h3 id="static"><a href="#static" class="headerlink" title="static:"></a>static:</h3><p>  静态的, 可以修饰成员<br>  特点：</p>
<pre><code>a.随着类的加载而加载
b.优先于对象存在
c.被类的所有对象共享，这也是我们判断是否使用静态关键字的条件
d.可以通过类名调用(推荐使用类名调用, 不要用对象名调用)
</code></pre><p>  静态的成员是类所有<br>  非静态成员是对象所有</p>
<p>注意事项：<br>  在静态方法中是没有this关键字的<br>  静态方法只能访问静态的成员<br>  非静态的方法可以访问静态的成员也可以访问非静态的成员。<br>  但是静态方法只能访问静态成员。静态上下文只能访问静态的东西。<br>  比如：静态内部类就只能访问外部类静态的属性或者方法。</p>
<h3 id="成员变量和静态变量区别"><a href="#成员变量和静态变量区别" class="headerlink" title="成员变量和静态变量区别"></a>成员变量和静态变量区别</h3><p>  a.所属不同</p>
<pre><code>成员变量：对象
静态变量：类
</code></pre><p>  b.内存中位置不同：</p>
<pre><code>成员变量：堆
静态变量：方法区
</code></pre><p>  c.生命周期不同：</p>
<pre><code>成员变量：随着对象的创建而开始, 随着对象的死亡而消失
静态变量：随着类的加载而开始, 随着类的卸载而消失
</code></pre><p>  d.调用方法不同：</p>
<pre><code>成员变量：只能通过对象调用
静态变量：可以通过对象调用，也可以用类名调用(推荐使用类名调用)
</code></pre><h3 id="帮助文档"><a href="#帮助文档" class="headerlink" title="帮助文档"></a>帮助文档</h3><h4 id="以Scanner为例"><a href="#以Scanner为例" class="headerlink" title="以Scanner为例:"></a>以Scanner为例:</h4><p>包：java.util<br>  如果不再java.lang包下，就需要导包<br>类的层次结构：public final class Scanner extends Object implements Iterator<string><br>  继承关系<br>简单的概述：<br>   一个可以使用正则表达式来解析基本类型和字符串的简单文本扫描器。<br>版本信息：<br>  1.5（JDK的发展历史）<br>构造方法：<br>  创建对象<br>方法：查看简要信息以及详细信息<br>  String nextLine()</string></p>
<h4 id="制作帮助文档："><a href="#制作帮助文档：" class="headerlink" title="制作帮助文档："></a>制作帮助文档：</h4><p>首先你要写好一个工具类：<br>公共类的名字必须和文件的名字一致<br>一个文件里面最多只能有一个公共类<br>默认只解析 public 和 protected 的文档注释信息</p>
<pre><code>/**
这是一个基本的数学工具类, 提供简单的加减乘除运算
@author Henson_z
@version v1.0
*/
public class MyMath {
  /**
    将构造方法私有化, 外界不能创建对象
  */
  private MyMath(){

  }
  /**
  求两个数之和
  */
  public static int add(int a, int b) {
    return a + b;
  }
  /**
  求两个数之差
  */
  public static int minus(int a, int b) {
    return a - b;
  }
  /**
  求两个数之积
  */
  public static long multiply(int a, int b) {
    return a * b;
  }
  /**
  求两个数之商
  */
  public static double divide(int a, int b) {
    return 1.0 * a / b;
  }
}
</code></pre><p>然后到命令行输入：</p>
<pre><code>javadoc -d 目录 -author -version MyMath.java
</code></pre><h2 id="markdown一些使用格式问题"><a href="#markdown一些使用格式问题" class="headerlink" title="markdown一些使用格式问题"></a>markdown一些使用格式问题</h2><p>表示大于号小于号不能直接写要</p>
<pre><code>大于&amp;gt;小于号是&amp;lt;
</code></pre><p>大于&gt;小于号&lt;</p>
<h2 id="总结最后"><a href="#总结最后" class="headerlink" title="总结最后"></a>总结最后</h2><p>这是一周的内容，感觉还是很多的，还有一些东西需要消化。知道不是很难但是需要踏实的去运用。而不是瞎几把死记硬背。<br>纸上得来终觉浅，绝知此事要躬行。加油吧</p>

        </div>
        <div class="post-reply">
            
                <!-- 来必力City版安装代码 -->
                <div id="lv-container" data-id="city" data-uid="MTAyMC8yOTE4Ni81NzUz">
                    <script type="text/javascript">
                        (function(d, s) {
                            var j, e = d.getElementsByTagName(s)[0];

                            if (typeof LivereTower === 'function') { return; }

                            j = d.createElement(s);
                            j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
                            j.async = true;

                            e.parentNode.insertBefore(j, e);
                        })(document, 'script');
                    </script>
                    <noscript> 为正常使用来必力评论功能请激活JavaScript</noscript>
                </div>
                <!-- City版安装代码已完成 -->
            
            
        </div>
    </div>
</section>
<script>
    // 获取第一张图, 用以当封面背景图
    var img = document.querySelectorAll('img')[1]

    if (img) {
        var header_box = document.querySelector('#header_box')
        header_box.style.backgroundImage = 'url('+ img.src +')'
    }
</script>
      </div>
  </div>
  <style>
  #footer {
    min-height: 10vh;
    background: black;
    color: #fff;
  }

  #footer a {
    color: #e1e1e1;
  }
</style>
<footer id="footer" class="has-text-centered is-flex center">
  <div class="container has-padding">
    <div>
      <div>
        <!--请您保留作者署名, 主题制作来之不易-->
        主题来自 <a href="http://haojen.github.io/">Haojen Ma</a>
        <br>
        Copyright © 王邸 2019
        <!--
          Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        -->
      </div>
    </div>
  </div>
</footer>

<script src="/js/search_core.js"></script>
<script src="/js/script.js"></script>

</body>
</html>