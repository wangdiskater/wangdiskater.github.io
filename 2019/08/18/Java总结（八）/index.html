<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="总结，本周还是讲的XML前端，不过使用node+vue启动的前端项目 星期一（8.12）DOM文档对象模型，是W3C织制订的一套用于访问HTML文档的标准.允许脚本动态地访问和更新文档的内容、结构和样式.分类 DOM Core XML DOM HTML DOM XML DOM 和 HTML DOM 关系XML DOM 定义了访问和处理 XML 文档的标准方法HTML文档格式 符合XML语法标准，所">
<meta property="og:type" content="article">
<meta property="og:title" content="Java总结（八）">
<meta property="og:url" content="http://yoursite.com/2019/08/18/Java总结（八）/index.html">
<meta property="og:site_name" content="路要坚持">
<meta property="og:description" content="总结，本周还是讲的XML前端，不过使用node+vue启动的前端项目 星期一（8.12）DOM文档对象模型，是W3C织制订的一套用于访问HTML文档的标准.允许脚本动态地访问和更新文档的内容、结构和样式.分类 DOM Core XML DOM HTML DOM XML DOM 和 HTML DOM 关系XML DOM 定义了访问和处理 XML 文档的标准方法HTML文档格式 符合XML语法标准，所">
<meta property="og:updated_time" content="2019-08-27T01:23:23.064Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java总结（八）">
<meta name="twitter:description" content="总结，本周还是讲的XML前端，不过使用node+vue启动的前端项目 星期一（8.12）DOM文档对象模型，是W3C织制订的一套用于访问HTML文档的标准.允许脚本动态地访问和更新文档的内容、结构和样式.分类 DOM Core XML DOM HTML DOM XML DOM 和 HTML DOM 关系XML DOM 定义了访问和处理 XML 文档的标准方法HTML文档格式 符合XML语法标准，所">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/08/18/Java总结（八）/"/>





  <title>Java总结（八） | 路要坚持</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">路要坚持</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/18/Java总结（八）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王邸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路要坚持">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java总结（八）</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-18T22:37:23+08:00">
                2019-08-18
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/08/18/Java总结（八）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/08/18/Java总结（八）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2019/08/18/Java总结（八）/" class="leancloud_visitors" data-flag-title="Java总结（八）">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>总结，本周还是讲的XML前端，不过使用node+vue启动的前端项目</p>
<h2 id="星期一（8-12）"><a href="#星期一（8-12）" class="headerlink" title="星期一（8.12）"></a>星期一（8.12）</h2><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p>文档对象模型，<br>是W3C织制订的一套用于访问HTML文档的标准.允许脚本动态地访问和更新文档的内容、结构和样式.<br>分类</p>
<pre><code>DOM Core
XML DOM
HTML DOM
</code></pre><h3 id="XML-DOM-和-HTML-DOM-关系"><a href="#XML-DOM-和-HTML-DOM-关系" class="headerlink" title="XML DOM 和 HTML DOM 关系"></a>XML DOM 和 HTML DOM 关系</h3><p>XML DOM 定义了访问和处理 XML 文档的标准方法<br>HTML文档格式 符合XML语法标准，所以可以使用XML DOM API<br>在XML DOM每个元素 都会被解析为一个节点Node，而常用的节点类型又分为</p>
<pre><code>元素节点  Element
属性节点  Attr
文本节点  Text
文档节点  Document
</code></pre><p>HTML DOM 定义了针对 HTML文档的对象，可以说是一套 更加适用于 JavaScript 技术开发 的API<br>HTML DOM是对XML DOM的扩展<br>进行 JavaScript DOM开发 可以同时使用 XML DOM和 HTML DOM</p>
<h3 id="Node的特性方法"><a href="#Node的特性方法" class="headerlink" title="Node的特性方法"></a>Node的特性方法</h3><table>
<thead>
<tr>
<th style="text-align:right">特性/方法</th>
<th style="text-align:center">类型/返回类型</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">nodeName</td>
<td style="text-align:center">String</td>
<td style="text-align:left">节点的名字；根据节点的类型而定义</td>
</tr>
<tr>
<td style="text-align:right">nodeValue</td>
<td style="text-align:center">String</td>
<td style="text-align:left">节点的值；根据节点的类型而定义</td>
</tr>
<tr>
<td style="text-align:right">nodeType</td>
<td style="text-align:center">Number</td>
<td style="text-align:left">节点的类型常量值之一</td>
</tr>
<tr>
<td style="text-align:right">ownerDocument</td>
<td style="text-align:center">Document</td>
<td style="text-align:left">指向这个节点所属的文档</td>
</tr>
<tr>
<td style="text-align:right">firstChild</td>
<td style="text-align:center">Node</td>
<td style="text-align:left">指向在childNodes列表中的第一个节点</td>
</tr>
<tr>
<td style="text-align:right">lastChild</td>
<td style="text-align:center">Node</td>
<td style="text-align:left">指向在childNodes列表中的最后一个节点</td>
</tr>
<tr>
<td style="text-align:right">childNodes</td>
<td style="text-align:center">NodeList</td>
<td style="text-align:left">所有子节点的列表</td>
</tr>
<tr>
<td style="text-align:right">parentNode</td>
<td style="text-align:center">Node</td>
<td style="text-align:left">返回一个给定节点的父节点。</td>
</tr>
<tr>
<td style="text-align:right">previousSibling</td>
<td style="text-align:center">Node</td>
<td style="text-align:left">指向前一个兄弟节点；如果这个节点就是第一个兄弟节点，那么该值为null</td>
</tr>
<tr>
<td style="text-align:right">nextSibling</td>
<td style="text-align:center">Node</td>
<td style="text-align:left">指向后一个兄弟节点；如果这个节点就是最后一个兄弟节点，那么该值为null</td>
</tr>
<tr>
<td style="text-align:right">hasChildNodes()</td>
<td style="text-align:center">Boolean</td>
<td style="text-align:left">当childNodes包含一个或多个节点时，返回真</td>
</tr>
<tr>
<td style="text-align:right">attributes</td>
<td style="text-align:center">NamedNodeMap</td>
<td style="text-align:left">包含了代表一个元素的属性的Attr对象；仅用于Element节点</td>
</tr>
<tr>
<td style="text-align:right">appendChild(node)</td>
<td style="text-align:center">Node</td>
<td style="text-align:left">将node添加到childNodes的末尾</td>
</tr>
<tr>
<td style="text-align:right">removeChild(node)</td>
<td style="text-align:center">Node</td>
<td style="text-align:left">从childNodes中删除node</td>
</tr>
<tr>
<td style="text-align:right">replaceChild</td>
<td style="text-align:center">Node</td>
<td style="text-align:left">将childNodes中的oldnode替换成newnode(newnode, oldnode)</td>
</tr>
<tr>
<td style="text-align:right">insertBefore</td>
<td style="text-align:center">Node</td>
<td style="text-align:left">在childNodes中的refnode之前插入newnode(newnode, refnode)</td>
</tr>
</tbody>
</table>
<h3 id="DOM-节点常用属性"><a href="#DOM-节点常用属性" class="headerlink" title="DOM 节点常用属性"></a>DOM 节点常用属性</h3><p>nodeName</p>
<pre><code>如果节点是元素节点，nodeName返回这个元素的名称
如果是属性节点，nodeName返回这个属性的名称
如果是文本节点，nodeName返回一个内容为#text 的字符串
</code></pre><p>nodeType</p>
<pre><code>Node.ELEMENT_NODE    ---1    -- 元素节点
Node.ATTRIBUTE_NODE  ---2    -- 属性节点
Node.TEXT_NODE       ---3    -- 文本节点（空节点）
</code></pre><p>nodeValue</p>
<pre><code>如果给定节点是一个属性节点，返回值是这个属性的值
如果给定节点是一个文本节点，返回值是这个文本节点内容
如果给定节点是一个元素节点，返回值是 null
</code></pre><h2 id="星期二（8-13）"><a href="#星期二（8-13）" class="headerlink" title="星期二（8.13）"></a>星期二（8.13）</h2><h3 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h3><p>这个东西已经过时了，主要用的还是XML的两个常用约束DTD 和 schema，为了更好的理解这两个配置文件的约束，我们先了解一下XML的语法规范</p>
<h3 id="XML的语法规则"><a href="#XML的语法规则" class="headerlink" title="XML的语法规则"></a>XML的语法规则</h3><p><strong>所有的 XML 元素都必须有一个关闭标签</strong><br>在 HTML 中，某些元素不必有一个关闭标签：</p>
<pre><code>&lt;p&gt;This is a paragraph.
&lt;br&gt;
</code></pre><p>在 XML 中，省略关闭标签是非法的。所有元素都必须有关闭标签：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;p&gt;This is a paragraph.&lt;/p&gt;
</code></pre><p>注释：从上面的实例中，您也许已经注意到 XML 第一行中声明没有关闭标签，这不是错误，声明不是 XML 文档本身的一部分，它没有关闭标签。</p>
<p><strong>XML 标签对大小写敏感</strong><br>XML 标签对大小写敏感。</p>
<pre><code>标签 &lt;Message&gt; 与标签 &lt;message&gt; 是不同的。
</code></pre><p>必须使用相同的大小写来编写打开标签和关闭标签：</p>
<pre><code>&lt;Message&gt;This is incorrect&lt;/message&gt;
&lt;message&gt;This is correct&lt;/message&gt;
</code></pre><p>注释：打开标签和关闭标签通常被称为开始标签和结束标签。不论您喜欢哪种术语，它们的概念都是相同的。</p>
<p><strong>XML 必须正确嵌套</strong><br>在 HTML 中，常会看到没有正确嵌套的元素：</p>
<pre><code>&lt;b&gt;&lt;i&gt;This text is bold and italic&lt;/b&gt;&lt;/i&gt; //错误的嵌套
</code></pre><p>在 XML 中，所有元素都必须彼此正确地嵌套：</p>
<pre><code>&lt;b&gt;&lt;i&gt;This text is bold and italic&lt;/i&gt;&lt;/b&gt;
在上面的实例中，正确嵌套的意思是：由于 &lt;i&gt; 元素是在 &lt;b&gt; 元素内打开的，那么它必须在 &lt;b&gt; 元素内关闭。
</code></pre><p><strong>XML 文档必须有根元素</strong><br>XML 文档必须有一个元素是所有其他元素的父元素。该元素称为根元素。</p>
<pre><code>&lt;root&gt;
&lt;child&gt;
&lt;subchild&gt;.....&lt;/subchild&gt;
&lt;/child&gt;
&lt;/root&gt;
</code></pre><p><strong>XML 属性值必须加引号</strong><br>与 HTML 类似，XML 元素也可拥有属性（名称/值的对）。<br>在 XML 中，XML 的属性值必须加引号。<br>请研究下面的两个 XML 文档。 第一个是错误的，第二个是正确的：</p>
<pre><code>&lt;note date=12/11/2007&gt;
&lt;to&gt;Tove&lt;/to&gt;
&lt;from&gt;Jani&lt;/from&gt;
&lt;/note&gt;

&lt;note date=&quot;12/11/2007&quot;&gt;
&lt;to&gt;Tove&lt;/to&gt;
&lt;from&gt;Jani&lt;/from&gt;
&lt;/note&gt;
</code></pre><p>在第一个文档中的错误是，note 元素中的 date 属性没有加引号。</p>
<p><strong>实体引用</strong><br>在 XML 中，一些字符拥有特殊的意义。<br>如果您把字符 “&lt;” 放在 XML 元素中，会发生错误，这是因为解析器会把它当作新元素的开始。<br>这样会产生 XML 错误：</p>
<pre><code>&lt;message&gt;if salary &lt; 1000 then&lt;/message&gt;
</code></pre><p>为了避免这个错误，请用实体引用来代替 “&lt;” 字符：</p>
<p> <message>if salary &lt; 1000 then</message><br>在 XML 中，有 5 个预定义的实体引用：</p>
<pre><code>&amp;lt;    &lt;   less than
&amp;gt;    &gt;   greater than
&amp;amp;   &amp;   ampersand
&amp;apos;  &apos;   apostrophe
&amp;quot;  &quot;   quotation mark
</code></pre><p>注释：在 XML 中，只有字符 “&lt;” 和 “&amp;” 确实是非法的。大于号是合法的，但是用实体引用来代替它是一个好习惯。</p>
<p><strong>XML 中的注释</strong><br>在 XML 中编写注释的语法与 HTML 的语法很相似。</p>
<pre><code>&lt;!-- This is a comment --&gt;
提示：你也可以了解一下“HTML &lt;!--...--&gt; 注释标签”。
</code></pre><p><strong>在 XML 中，空格会被保留</strong><br>HTML 会把多个连续的空格字符裁减（合并）为一个：</p>
<p>HTML:   Hello Tove<br>Output: Hello Tove<br>在 XML 中，文档中的空格不会被删减。</p>
<p><strong>XML 以 LF 存储换行</strong><br>在 Windows 应用程序中，换行通常以一对字符来存储：回车符（CR）和换行符（LF）。<br>在 Unix 和 Mac OSX 中，使用 LF 来存储新行。<br>在旧的 Mac 系统中，使用 CR 来存储新行。<br>XML 以 LF 存储换行。<br>以上就是在使用 XML 时需要注意到的语法规则，按照这些规则，编写一个正确的 XML 文档！</p>
<h3 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h3><p>文档类型定义（DTD）可定义合法的XML文档构建模块。它使用一系列合法的元素来定义文档的结构。<br>DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用</p>
<h3 id="DTD-简介"><a href="#DTD-简介" class="headerlink" title="DTD 简介"></a>DTD 简介</h3><p>对XML DTD 的简介，以及使用它的原因。</p>
<h3 id="内部的-DOCTYPE-声明"><a href="#内部的-DOCTYPE-声明" class="headerlink" title="内部的 DOCTYPE 声明"></a>内部的 DOCTYPE 声明</h3><p>假如 DTD 被包含在您的 XML 源文件中，它应当通过下面的语法包装在一个 DOCTYPE 声明中：</p>
<pre><code>&lt;!DOCTYPE 根元素 [元素声明]&gt;
</code></pre><p>带有 DTD 的 XML 文档实例（请在 IE5 以及更高的版本打开，并选择查看源代码）：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE note [
  &lt;!ELEMENT note (to,from,heading,body)&gt;
  &lt;!ELEMENT to      (#PCDATA)&gt;
  &lt;!ELEMENT from    (#PCDATA)&gt;
  &lt;!ELEMENT heading (#PCDATA)&gt;
  &lt;!ELEMENT body    (#PCDATA)&gt;
]&gt;
&lt;note&gt;
  &lt;to&gt;George&lt;/to&gt;
  &lt;from&gt;John&lt;/from&gt;
  &lt;heading&gt;Reminder&lt;/heading&gt;
  &lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt;
&lt;/note&gt;
</code></pre><p>以上 DTD 解释如下：<br>!DOCTYPE note (第二行)定义此文档是 note 类型的文档。<br>!ELEMENT note (第三行)定义 note 元素有四个元素：”to、from、heading,、body”<br>!ELEMENT to (第四行)定义 to 元素为 “#PCDATA” 类型<br>!ELEMENT from (第五行)定义 from 元素为 “#PCDATA” 类型<br>!ELEMENT heading (第六行)定义 heading 元素为 “#PCDATA” 类型<br>!ELEMENT body (第七行)定义 body 元素为 “#PCDATA” 类型</p>
<p>外部文档声明<br>假如 DTD 位于 XML 源文件的外部，那么它应通过下面的语法被封装在一个 DOCTYPE 定义中：</p>
<pre><code>&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;
</code></pre><p>这个 XML 文档和上面的 XML 文档相同，但是拥有一个外部的 DTD: （在 IE5 中打开，并选择“查看源代码”命令。）</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE note SYSTEM &quot;note.dtd&quot;&gt;
&lt;note&gt;
&lt;to&gt;George&lt;/to&gt;
&lt;from&gt;John&lt;/from&gt;
&lt;heading&gt;Reminder&lt;/heading&gt;
&lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt;
&lt;/note&gt;
</code></pre><p>这是包含 DTD 的 “note.dtd” 文件：</p>
<pre><code>&lt;!ELEMENT note (to,from,heading,body)&gt;
&lt;!ELEMENT to (#PCDATA)&gt;
&lt;!ELEMENT from (#PCDATA)&gt;
&lt;!ELEMENT heading (#PCDATA)&gt;
&lt;!ELEMENT body (#PCDATA)&gt;
</code></pre><h3 id="DTD-XML-构建模块"><a href="#DTD-XML-构建模块" class="headerlink" title="DTD - XML 构建模块"></a>DTD - XML 构建模块</h3><p>可以在 DTD 中定义的 XML 构建模块。<br>所有的 XML 文档（以及 HTML 文档）均由以下简单的构建模块构成：</p>
<pre><code>元素
属性
实体
PCDATA
CDATA
</code></pre><h3 id="DTD-元素"><a href="#DTD-元素" class="headerlink" title="DTD 元素"></a>DTD 元素</h3><p>如何使用 DTD 定义 XML 文档的合法元素。<br>声明一个元素<br>在 DTD 中，XML 元素通过元素声明来进行声明。元素声明使用下面的语法：<br>&lt;!ELEMENT 元素名称 类别&gt;<br>或者<br>&lt;!ELEMENT 元素名称 (元素内容)&gt;<br>只有 PCDATA 的元素<br>只有 PCDATA 的元素通过圆括号中的 #PCDATA 进行声明：</p>
<pre><code>&lt;!ELEMENT 元素名称 (#PCDATA)&gt; 只有 PCDATA 的元素
&lt;!ELEMENT 元素名称 ANY&gt; 带有任何内容的元素
&lt;!ELEMENT 元素名称 (子元素名称 1,子元素名称 2,.....)&gt; 带有子元素（序列）的元素
&lt;!ELEMENT 元素名称 (子元素名称)&gt;声明只出现一次的元素
&lt;!ELEMENT 元素名称 (子元素名称+)&gt; 声明最少出现一次的元素
&lt;!ELEMENT 元素名称 (子元素名称*)&gt; 声明出现零次或多次的元素
&lt;!ELEMENT note (to,from,header,(message|body))&gt;声明“非.../既...”类型的内容 ：&quot;note&quot; 元素必须包含 &quot;to&quot; 元素、&quot;from&quot; 元素、&quot;header&quot; 元素，以及 &quot;message&quot; 元素或&quot;body&quot; 元素。
</code></pre><p>例子：</p>
<pre><code>&lt;!ELEMENT from (#PCDATA)&gt;
&lt;!ELEMENT note (message)&gt;
</code></pre><h3 id="DTD-属性"><a href="#DTD-属性" class="headerlink" title="DTD 属性"></a>DTD 属性</h3><p>如何使用 DTD 定义 XML 元素的合法属性。<br>在 DTD 中，属性通过 ATTLIST 声明来进行声明。<br>声明属性<br>属性声明使用下列语法：</p>
<pre><code>&lt;!ATTLIST 元素名称 属性名称 属性类型 默认值&gt;
</code></pre><p>DTD 实例:</p>
<pre><code>&lt;!ATTLIST payment type CDATA &quot;check&quot;&gt;
</code></pre><p>XML 实例:</p>
<pre><code>&lt;payment type=&quot;check&quot; /&gt;
</code></pre><p>以下是属性类型的选项：</p>
<table>
<thead>
<tr>
<th style="text-align:right">类型</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">CDATA</td>
<td style="text-align:left">值为字符数据 (character data)</td>
</tr>
<tr>
<td style="text-align:right">(en1</td>
<td style="text-align:left">en2</td>
<td>..)</td>
<td>此值是枚举列表中的一个值</td>
</tr>
<tr>
<td style="text-align:right">ID</td>
<td style="text-align:left">值为唯一的 id</td>
</tr>
<tr>
<td style="text-align:right">IDREF</td>
<td style="text-align:left">值为另外一个元素的 id</td>
</tr>
<tr>
<td style="text-align:right">IDREFS</td>
<td style="text-align:left">值为其他 id 的列表</td>
</tr>
<tr>
<td style="text-align:right">NMTOKEN</td>
<td style="text-align:left">值为合法的 XML 名称</td>
</tr>
<tr>
<td style="text-align:right">NMTOKENS</td>
<td style="text-align:left">值为合法的 XML 名称的列表</td>
</tr>
<tr>
<td style="text-align:right">ENTITY</td>
<td style="text-align:left">值是一个实体</td>
</tr>
<tr>
<td style="text-align:right">ENTITIES</td>
<td style="text-align:left">值是一个实体列表</td>
</tr>
<tr>
<td style="text-align:right">NOTATION</td>
<td style="text-align:left">此值是符号的名称</td>
</tr>
<tr>
<td style="text-align:right">xml:</td>
<td style="text-align:left">值是一个预定义的 XML 值</td>
</tr>
</tbody>
</table>
<p>默认值参数可使用下列值：</p>
<pre><code>值 解释
值 属性的默认值
#REQUIRED 属性值是必需的
#IMPLIED  属性不是必需的
#FIXED value  属性值是固定的
</code></pre><p>例子<br>DTD:<br>&lt;!ATTLIST person number CDATA #REQUIRED&gt;<br>合法的 XML:</p>
<pre><code>&lt;person number=&quot;5677&quot; /&gt;
</code></pre><h3 id="DTD-实体"><a href="#DTD-实体" class="headerlink" title="DTD 实体"></a>DTD 实体</h3><h3 id="DTD-验证"><a href="#DTD-验证" class="headerlink" title="DTD 验证"></a>DTD 验证</h3><h3 id="DTD-实例"><a href="#DTD-实例" class="headerlink" title="DTD 实例"></a>DTD 实例</h3><p><a href="https://www.w3school.com.cn/dtd/dtd_examples.asp" target="_blank" rel="external">一些真实的 DTD 案例</a>。</p>
<h3 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h3><p>XML Schema 是基于 XML 的 DTD 替代者。<br>XML Schema 描述 XML 文档的结构。<br>XML Schema 语言也称作 XML Schema 定义（XML Schema Definition，XSD）。</p>
<h3 id="XML-Schema-使用-XML-语法"><a href="#XML-Schema-使用-XML-语法" class="headerlink" title="XML Schema 使用 XML 语法"></a>XML Schema 使用 XML 语法</h3><p>另一个关于 XML Schema 的重要特性是，它们由 XML 编写。<br>由 XML 编写 XML Schema 有很多好处：</p>
<pre><code>不必学习新的语言
可使用 XML 编辑器来编辑 Schema 文件
可使用 XML 解析器来解析 Schema 文件
可通过 XML DOM 来处理 Schema
可通过 XSLT 来转换 Schema
</code></pre><h3 id="XML-Schema-可保护数据通信"><a href="#XML-Schema-可保护数据通信" class="headerlink" title="XML Schema 可保护数据通信"></a>XML Schema 可保护数据通信</h3><p>当数据从发送方被发送到接受方时，其要点是双方应有关于内容的相同的“期望值”。<br>通过 XML Schema，发送方可以用一种接受方能够明白的方式来描述数据。<br>一种数据，比如 “03-11-2004”，在某些国家被解释为11月3日，而在另一些国家为当作3月11日。<br>但是一个带有数据类型的 XML 元素，比如：</p>
<pre><code>&lt;date type=&quot;date&quot;&gt;2004-03-11&lt;/date&gt;，
</code></pre><p>可确保对内容一致的理解，这是因为 XML 的数据类型 “date” 要求的格式是 “YYYY-MM-DD”。</p>
<h3 id="XML-Schema-可扩展"><a href="#XML-Schema-可扩展" class="headerlink" title="XML Schema 可扩展"></a>XML Schema 可扩展</h3><p>XML Schema 是可扩展的，因为它们由 XML 编写。<br>通过可扩展的 Schema 定义，您可以：</p>
<pre><code>在其他 Schema 中重复使用您的 Schema
创建由标准类型衍生而来的您自己的数据类型
在相同的文档中引用多重的 Schema
</code></pre><p>形式良好是不够的，我们把符合 XML 语法的文档称为形式良好的 XML 文档，比如：</p>
<pre><code>它必须以 XML 声明开头
它必须拥有唯一的根元素
开始标签必须与结束标签相匹配
元素对大小写敏感
所有的元素都必须关闭
所有的元素都必须正确地嵌套
必须对特殊字符使用实体
</code></pre><p>即使文档的形式良好，仍然不能保证它们不会包含错误，并且这些错误可能会产生严重的后果。</p>
<h3 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h3><pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;note&gt;
&lt;to&gt;George&lt;/to&gt;
&lt;from&gt;John&lt;/from&gt;
&lt;heading&gt;Reminder&lt;/heading&gt;
&lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt;
&lt;/note&gt;
</code></pre><p>XML Schema<br>下面这个例子是一个名为 “note.xsd” 的 XML Schema 文件，它定义了上面那个 XML 文档的元素：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;xs:schema xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;
targetNamespace=&quot;http://www.w3school.com.cn&quot;
xmlns=&quot;http://www.w3school.com.cn&quot;
elementFormDefault=&quot;qualified&quot;&gt;
&lt;xs:element name=&quot;note&quot;&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
    &lt;xs:element name=&quot;to&quot; type=&quot;xs:string&quot;/&gt;
    &lt;xs:element name=&quot;from&quot; type=&quot;xs:string&quot;/&gt;
    &lt;xs:element name=&quot;heading&quot; type=&quot;xs:string&quot;/&gt;
    &lt;xs:element name=&quot;body&quot; type=&quot;xs:string&quot;/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
&lt;/xs:schema&gt;
</code></pre><p>对 XML Schema 的引用</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;note
xmlns=&quot;http://www.w3school.com.cn&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xsi:schemaLocation=&quot;http://www.w3school.com.cn note.xsd&quot;&gt;

&lt;to&gt;George&lt;/to&gt;
&lt;from&gt;John&lt;/from&gt;
&lt;heading&gt;Reminder&lt;/heading&gt;
&lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt;
&lt;/note&gt;
</code></pre><h3 id="元素"><a href="#元素" class="headerlink" title=" 元素"></a><schema> 元素</schema></h3><pre><code>&lt;schema&gt; 元素可包含属性。一个 schema 声明往往看上去类似这样：

&lt;?xml version=&quot;1.0&quot;?&gt;

&lt;xs:schema xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;
targetNamespace=&quot;http://www.w3school.com.cn&quot;
xmlns=&quot;http://www.w3school.com.cn&quot;
elementFormDefault=&quot;qualified&quot;&gt;

...
...
&lt;/xs:schema&gt;
</code></pre><p>代码解释：<br>下面的片断：</p>
<pre><code>xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;
显示 schema 中用到的元素和数据类型来自命名空间 &quot;http://www.w3.org/2001/XMLSchema&quot;。同时它还规定了来自命名空间 &quot;http://www.w3.org/2001/XMLSchema&quot; 的元素和数据类型应该使用前缀 xs：
</code></pre><p>这个片断：</p>
<pre><code>targetNamespace=&quot;http://www.w3school.com.cn&quot;
显示被此 schema 定义的元素 (note, to, from, heading, body) 来自命名空间： &quot;http://www.w3school.com.cn&quot;。
</code></pre><p>这个片断：</p>
<pre><code>xmlns=&quot;http://www.w3school.com.cn&quot;
指出默认的命名空间是 &quot;http://www.w3school.com.cn&quot;。
</code></pre><p>这个片断：</p>
<pre><code>elementFormDefault=&quot;qualified&quot;
指出任何 XML 实例文档所使用的且在此 schema 中声明过的元素必须被命名空间限定。
</code></pre><p>在 XML 文档中引用 Schema<br>此 XML 文档含有对 XML Schema 的引用：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;

&lt;note xmlns=&quot;http://www.w3school.com.cn&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xsi:schemaLocation=&quot;http://www.w3school.com.cn note.xsd&quot;&gt;

&lt;to&gt;George&lt;/to&gt;
&lt;from&gt;John&lt;/from&gt;
&lt;heading&gt;Reminder&lt;/heading&gt;
&lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt;
&lt;/note&gt;
</code></pre><p>代码解释：<br>下面的片断：</p>
<pre><code>xmlns=&quot;http://www.w3school.com.cn&quot;
规定了默认命名空间的声明。此声明会告知 schema 验证器，在此 XML 文档中使用的所有元素都被声明于 &quot;http://www.w3school.com.cn&quot; 这个命名空间。
</code></pre><p>一旦您拥有了可用的 XML Schema 实例命名空间：</p>
<pre><code>xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
</code></pre><p>您就可以使用 schemaLocation 属性了。此属性有两个值。第一个值是需要使用的命名空间。第二个值是供命名空间使用的 XML schema 的位置：</p>
<pre><code>xsi:schemaLocation=&quot;http://www.w3school.com.cn note.xsd&quot;
</code></pre><h2 id="星期三（8-14）"><a href="#星期三（8-14）" class="headerlink" title="星期三（8.14）"></a>星期三（8.14）</h2><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>类比:(js-&gt;node,,,,,,java-&gt;虚拟机)<br>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。<br> Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型。<br>Npm<br>NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题</p>
<h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><p>WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（TypeScript等），并将其转换和打包为合适的格式供浏览器使用.<br>简单的说就是打包，压缩各种静态资源的工具</p>
<h3 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h3><p>ESLint最初是由Nicholas C. Zakas 于2013年6月创建的开源项目。它的目标是提供一个插件化的javascript代码检测工具。</p>
<h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><p>vue基本语法(简单)</p>
<pre><code>简洁,轻量,快速,数据驱动,模块友好,组件化
</code></pre><p>vue各种插件(完善)vue 官方提供了一系列的工具，如:</p>
<pre><code>路由 vue-router，
状态树管理器 vuex，
网络请求 axios（非 vue 官方出，纯推荐）等。
(如果您不打算做 SPA，那么您是不需要 vue-router 的；假如您的页面不存在非常复杂的交互或数据递进式体验时，您可能不需要 vuex... )总之，官方都为开发者考虑好了，少了技术选型的痛苦。
</code></pre><p>基于Vue<br>Nuxt</p>
<pre><code>SEO问题
页面初次渲染还是有可能很慢，白屏等待时间太长，对日益挑剔的用户群体来说，无法接受。
服务端渲染
</code></pre><p>Weex</p>
<pre><code>Weex 致力于使开发者能基于通用跨平台的 Web 开发语言和开发经验，来构建 Android、iOS 和 Web 应用。简单来说，在集成了 WeexSDK 之后，你可以使用 JavaScript 语言和前端开发经验来开发移动应用。
</code></pre><h2 id="星期四（8-15）"><a href="#星期四（8-15）" class="headerlink" title="星期四（8.15）"></a>星期四（8.15）</h2><h3 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind:"></a>v-bind:</h3><p>用来绑定数据和属性以及表达式，缩写为’：’示例</p>
<pre><code>&lt;div v-bind:title=&quot;text&quot; &gt;hello&lt;/div&gt;
&lt;div v-bind:title=&quot;&apos;***&apos;+text&quot; &gt;hello&lt;/div&gt;
&lt;input type=&quot;text&quot; v-bind:value=&quot;text&quot;&gt;
new Vue({
    el:&quot;#root&quot;,
    data:{
        text:&quot;this is ***&quot;
    },
})
</code></pre><h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model:"></a>v-model:</h3><p>实现双向数据绑定<br>示例<br>输入框:</p>
<pre><code>&lt;input type=&quot;text&quot; v-model=&quot; text&quot; /&gt;
&lt;input type=&quot;text&quot; v-model:value =&quot;text&quot;/&gt;
 &lt;div &gt;{{text}}&lt;/div&gt;
</code></pre><p>单选:</p>
<pre><code> 1:&lt;input type=&quot;radio&quot; value=&quot;one&quot; v-model=&quot;text&quot; /&gt;
 2:&lt;input type=&quot;radio&quot; value=&quot;two&quot; v-model=&quot;text&quot; /&gt;
    &lt;div &gt;{{text}}&lt;/div&gt;
new  Vue({
        el:&quot;#data2&quot;,
        data:{
            text:&quot;-----&quot;
        },
    })
</code></pre><p>单选不需要设置name来确保只能选一个，v-model同一个值就行了</p>
<h3 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h3><pre><code>更新元素的 innerText
</code></pre><h3 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h3><pre><code>更新元素的 innerHTML
</code></pre><h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on:"></a>v-on:</h3><pre><code>绑定事件监听器。可简写@
</code></pre><p>示例</p>
<pre><code>&lt;div v-on:click=&quot;handleClick&quot;&gt;{{text}}&lt;/div&gt;
 new Vue({
    el:&quot;#event&quot;,
    data:{
        text:&quot;hello&quot;
    },
    methods:{
        handleClick:function () {
            alert(&quot;谁在点击我&quot;)
        }
    }
})
</code></pre><h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h3><pre><code>标签控制隐藏,  (display设置none)
</code></pre><h3 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h3><pre><code>根据表达式的值的真假条件渲染元素。
v-else-if , v-else
</code></pre><h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h3><pre><code>基于源数据多次渲染元素或模板块(循环渲染元素)
</code></pre><h3 id="v-slot"><a href="#v-slot" class="headerlink" title="v-slot"></a>v-slot</h3><p>插槽。<br>是组件的一块HTML模版，<br>这块模版由使用组件者即父组件提供。<br>可以说是子组件暴露的一个<br>让父组件传入自定义内容的接口</p>
<h3 id="computed"><a href="#computed" class="headerlink" title="computed:"></a>computed:</h3><pre><code>first:&lt;input  v-model=&quot;firstName&quot; &gt;
last:&lt;input v-model=&quot;lastName&quot;&gt;
&lt;div&gt;{{full}}  &lt;/div&gt;

new Vue({
    el:&quot;#add&quot;,
    data:{
        firstName:0,
        lastName:0
    },
    //计算属性
    //computed：指的是一个属性通过其他属性计算而来
    computed:{
        full: function () {
            return parseInt(this.firstName) + parseInt(this.lastName)
        }
    }
})
</code></pre><p><strong>计算属性是真的牛皮，不是自己的东西都能计算到，使用状态管理，就能监听别的地方改变状态的数据。</strong></p>
<h3 id="watch"><a href="#watch" class="headerlink" title="watch:"></a>watch:</h3><p>监听一个属性改变触发一个事件。</p>
<pre><code>new Vue({
        el:&quot;#add2&quot;,
        data:{
            firstName:0,
            lastName:0
        },
computed:{
            full: function () {
                return parseInt(this.firstName) + parseInt(this.lastName)
            }
        },
watch:{
            firstName:function () {
                this.count++
            },
            lastName:function () {
                this.count++
            },
            full() {
                console.log(&apos;full&apos;)
            }
        }
    })
</code></pre><h3 id="template"><a href="#template" class="headerlink" title="template:"></a>template:</h3><p>一个字符串模板作为 Vue 实例的标识使用。模板将会 替换 挂载的元素。挂载元素的内容都将被忽略(除非模板的内容有分发插槽)。</p>
<pre><code>&lt;div id=&quot;root1&quot;&gt;
    123//这里会被替换
&lt;/div&gt;

&lt;script&gt;
    new  Vue({
        el:&quot;#root1&quot;,
        template:&apos;&lt;h1&gt;--&gt;{{msg}}&lt;/h1&gt;&apos;,
        data:{
            msg: &quot;hello data&quot;
        }
    })
&lt;/script&gt;
</code></pre><h3 id="Vue-component"><a href="#Vue-component" class="headerlink" title="Vue.component"></a>Vue.component</h3><p>项目中用法就是局部组件的用法，就是把组件import进来使用</p>
<pre><code>&lt;todo&gt;&lt;/todo&gt;
123
&lt;to-do&gt;&lt;/to-do&gt;
//定义局部组件
var  todo = {
    template: &apos;&lt;li&gt;todo&lt;/li&gt;&apos;
}
new Vue({
    el:&quot;#to&quot;,
    data:{
    },
    //引用（注册）局部组件
    components:{
        &apos;todo&apos;:todo,
        &apos;ToDo&apos;:todo
    }
})
</code></pre><h2 id="星期五（8-16）"><a href="#星期五（8-16）" class="headerlink" title="星期五（8.16）"></a>星期五（8.16）</h2><p>Vue全家桶：</p>
<h3 id="vue-cli"><a href="#vue-cli" class="headerlink" title="vue-cli"></a>vue-cli</h3><p>Vue.js 开发的标准工具<br>因为很多包都是在国外，所以我们构建一个vue项目一般来说是很慢的。<br>方法一：3.x开始可以这么创建，官方推荐</p>
<p>安装vue-cli</p>
<pre><code>npm install -g @vue/cli    (3.X)
vue –V  (查看版本)
</code></pre><p>创建项目<br>最新版本</p>
<pre><code>vue create hello-world    (3.X)
</code></pre><p>方法二：cli是3.x 想构建2.x的项目<br>安装vue-cli</p>
<pre><code>npm install -g @vue/cli    (3.X)
vue -V  (查看版本)
</code></pre><p>创建项目</p>
<pre><code>npm install -g @vue/cli-init    (2.X桥接工具)
vue init webpack my-project    (2.X)
</code></pre><p>方法三：快速构建方式<br>安装vue-cli</p>
<pre><code>cnpm install -g @vue/cli    (3.X)
</code></pre><p>创建项目</p>
<pre><code>cnpm install -g @vue/cli-init    (2.X桥接工具)
cnpm install -g webpack         (安装webpack)
vue init webpack my-project    (2.X)
</code></pre><p>拒绝npm安装，自己使用cnpm安装</p>
<pre><code>Cnpm install
</code></pre><h3 id="Vue项目的目录结构（cli构建出来的）"><a href="#Vue项目的目录结构（cli构建出来的）" class="headerlink" title="Vue项目的目录结构（cli构建出来的）"></a>Vue项目的目录结构（cli构建出来的）</h3><p>Build           构建脚本目录(webpack相关)<br>Config          项目配置,包括端口号等。我们初学可以使用默认的<br>node_modules    npm 加载的项目依赖模块<br>Src             这里是我们要开发的目录，基本上要做的事情都在这个目录里<br>static          静态资源文件<br>test            测试目录<br>.xxxx文件       这些是一些配置文件，包括语法配置，git配置等。<br>index.html      首页入口文件,可以添加一些 meta 信息或统计代码。<br>package.json    项目配置文件<br>README.md       项目的说明文档，markdown 格式</p>
<h3 id="服务简单配置-端口…"><a href="#服务简单配置-端口…" class="headerlink" title="服务简单配置(端口…)"></a>服务简单配置(端口…)</h3><p>启动端口</p>
<pre><code>Config-&gt;index.js
Dev-&gt;port
</code></pre><p>开发模式(dev)启动时访问（别人可以通过你的ip地址访问你的项目）</p>
<pre><code>Package.json -&gt; dev
--host 0.0.0.0
vue-router
</code></pre><h3 id="bus"><a href="#bus" class="headerlink" title="bus"></a>bus</h3><p>vue bus可以实现不同组件间、不同页面间的通信，比如我在A页面出发点击事件，要B页面发生变化<br>一个中央事件总线bus，可以作为一个简单的组件传递数据，用于解决跨级和兄弟组件通信问题</p>
<pre><code>Bus.js
import Vue from &apos;vue&apos;
const Bus = new Vue()
export default Bus

main.js//全局引用
import bus from &apos;./bus/Bus&apos;
Vue.prototype.bus = bus

//要用的地方监听事件
mounted () {
    this.bus.$on(&apos;add&apos;, a =&gt; {
      this.list.push(a)
    })
},

//通过方法触发事件
 add () {
  this.bus.$emit(&apos;add&apos;, this.a)
}
</code></pre><h3 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h3><p>axios 是一个基于 promise 的 HTTP 库，在浏览器和 node.js 中使用。<br>axios主要是用于向后台发起请求的，还有在请求中做更多是可控功能。<br>xios<br>cnpm install axios  –save</p>
<pre><code>main.js
import axios from &apos;axios’
Vue.prototype.$axios = axios
this.$axios.get(&apos;/terms&apos;)
      .then(this.res1Method).catch((err) =&gt; {
        this.catchMethod(err)
      })
</code></pre><h3 id="Vue-router路由"><a href="#Vue-router路由" class="headerlink" title="Vue-router路由"></a>Vue-router路由</h3><p>路由是根据不同url展示不同的页面或内容<br>Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。</p>
<pre><code>cnpm install vue-router  --save-dev
//src下新建router-&gt;index.js
import Vue from &apos;vue&apos;
import Router from &apos;vue-router&apos;
import HelloWorld from &apos;@/components/HelloWorld&apos;
Vue.use(Router)
export default new Router({
  routes: [
    {
      path: &apos;/&apos;,
      name: &apos;HelloWorld&apos;,
      component: HelloWorld
    },
    {
      path: &apos;/city&apos;,
      name: &apos;City&apos;,
      component: () =&gt; import(&apos;@/components/city/City&apos;)
    }
  ]
})
//main.js
import router from &apos;./router’
new Vue({
  el: &apos;#app&apos;,
  router,
  components: { App },
  template: &apos;&lt;App/&gt;&apos;
})
</code></pre><h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><p>浏览器</p>
<pre><code>http://localhost:8080/#/city
</code></pre><p>声明式</p>
<pre><code>&lt;router-link to=&quot;/city&quot;&gt;跳转到city&lt;/router-link&gt;
</code></pre><p>编程式</p>
<pre><code>this.$router.push(&apos;/city&apos;)
</code></pre><h3 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h3><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，<br>解决vue中各个组件之间传值的痛苦，在vue中我们可以使用vuex来保存我们需要管理的状态值，值一旦被修改，所有引用该值的地方就会自动更新。<br>适用于多个视图依赖于同一状态。来自不同视图的行为需要变更同一状态。<br>(如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的)</p>
<p>安装</p>
<pre><code>npm install vuex –save
</code></pre><p>引入</p>
<pre><code>state：存储状态（变量）
getters：对数据获取之前的再次编译，可以理解为state的计算属性。我们在组件中使用 $sotre.getters.fun()
mutations：修改状态，并且是同步的。在组件中使用$store.commit(&apos;&apos;,params)。这个和我们组件中的自定义事件类似。
actions：异步操作。在组件中使用是$store.dispath(&apos;&apos;)
modules：store的子模块，为了开发大型项目，方便状态管理而使用的。
</code></pre><h3 id="使用state"><a href="#使用state" class="headerlink" title="使用state"></a>使用state</h3><p>src下新建vuex-&gt;store.js</p>
<pre><code>import Vue from &apos;vue&apos;
import Vuex from &apos;vuex&apos;
Vue.use(Vuex)
const state = {
  token: &apos;token&apos;
}
export default new Vuex.Store({
  state
})

Main.js
import store from &apos;./vuex/sotre&apos;
new Vue({
  el: &apos;#app&apos;,
  router,
  store,//把store添加进来
  components: { App },
  template: &apos;&lt;App/&gt;&apos;
})
使用
&lt;h3&gt;{{$store.state. token}}&lt;/h3&gt;
</code></pre><h3 id="Vuex-mutations"><a href="#Vuex-mutations" class="headerlink" title="Vuex-mutations"></a>Vuex-mutations</h3><pre><code>mutations
mutations里面放置的是我们操作state对象属性的方法
Store.js
const mutations = {
  mutationsUpdateToken (state, newtoken = &apos;newtoken&apos;) {
    return (state. token = newtoken)
  },
  mutationsDeleteToken (state, newtoken = &apos;&apos;) {
    return (state. token = newtoken)
  }
}
export default new Vuex.Store({
  state,
  mutations
})
//在我们要用的地方
updateToken () {
  this.$store.commit(&apos;mutationsUpdateToken&apos;, &apos;update&apos;)
},
deleteToken () {
  this.$store.commit(&apos;mutationsDeleteToken&apos;, &apos;delete&apos;)
}
</code></pre><h3 id="Vuex-actions"><a href="#Vuex-actions" class="headerlink" title="Vuex-actions"></a>Vuex-actions</h3><p>actions<br>actions 类似于 mutation，actions 提交的是 mutation，而不是直接变更状态。actions 可以包含任意异步操作。用来异步触发mutations里面的方法<br>里面调用其实还是使用的mutation的commit方法</p>
<pre><code>Store.js
const actions = {
  actionsUpdateToken (context, newtoken = &apos;&apos;) {
    return context.commit(&apos;mutationsUpdateToken&apos;, newtoken)
  },
  actionsDeleteToken ({ commit }, newtoken = &apos;&apos;) {
    return commit(&apos;mutationsDeleteToken&apos;, newtoken)
  }
}
export default new Vuex.Store({
  state,
  mutations,
  actions
})
使用
updateToken () {
 this.$store.dispatch(&apos;actionsUpdateToken&apos;, &apos;updatedispatch’)
},
deleteToken () {
this.$store.dispatch(&apos;actionsDeleteToken&apos;, &apos;deletedispatch’)
}
</code></pre><h3 id="Vuex-getters"><a href="#Vuex-getters" class="headerlink" title="Vuex-getters"></a>Vuex-getters</h3><p>我们一般使用getters来获取我们的state，可以把getters理解为state的计算属性</p>
<pre><code>Store.js
const getters = {
  getters1 () {
    return state.token + &apos;getters1&apos;
  },
  getters2 () {
    return state.token + &apos;getters2&apos;
  }
}
export default new Vuex.Store({
  state,
  mutations,
  actions,
  getters
})
</code></pre><p>使用</p>
<pre><code>{{$store.getters.getters1}}
this.$store.getters.getters1
</code></pre><h2 id="星期六（8-17）"><a href="#星期六（8-17）" class="headerlink" title="星期六（8.17）"></a>星期六（8.17）</h2><p>项目<br>就带着做一个项目。很蠢，并没有体现出VUE的优势，后来又发了一个项目。我们现在来分析一下这个项目<br>（很快补上，今天脑子有点不舒服）</p>
<h3 id="小总结系列"><a href="#小总结系列" class="headerlink" title="小总结系列"></a>小总结系列</h3><h3 id="0-JS的坑"><a href="#0-JS的坑" class="headerlink" title="0.JS的坑"></a>0.JS的坑</h3><p>不要使用变量名为name 浏览器会默认有一个全局的变量name，而且不知道指向的是哪里，还不能被修改。</p>
<h3 id="1-关于DOM获取相邻结点的问题"><a href="#1-关于DOM获取相邻结点的问题" class="headerlink" title="1.关于DOM获取相邻结点的问题"></a>1.关于DOM获取相邻结点的问题</h3><p>nextSibling<br>previousSibling<br>获取紧跟的结点，有可能是空白结点，所以慎用</p>
<h3 id="2-VUE"><a href="#2-VUE" class="headerlink" title="2.VUE"></a>2.VUE</h3><p>vue.js:634 [Vue warn]: Property or method “id” is not defined on the instance but referenced during render.<br>需要在data定义一个id</p>
<h3 id="3-动态参数："><a href="#3-动态参数：" class="headerlink" title="3.动态参数："></a>3.动态参数：</h3><p>官方动态参数报错问题,官网文档这样写的：<br>动态参数<br>2.6.0 新增<br>从 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数：</p>
<pre><code>&lt;a v-bind:[attributeName]=&quot;url&quot;&gt; ... &lt;/a&gt;
</code></pre><p>这里的 attributeName 会被作为一个 JavaScript 表达式进行动态求值，求得的值将会作为最终的参数来使用。例如，如果你的 Vue 实例有一个 data 属性 attributeName，其值为 “href”，那么这个绑定将等价于 v-bind:href。<br>但是实际并不能成功，因为[]里面的名字不能写成attributeName 只要改个名字就可以用了。fk<br>改的名字，必须是小写。不能大小写混写，草 官方文档在下面写了一行小字：</p>
<pre><code>文档有说：另外，如果你在 DOM 中使用模板 (直接在一个 HTML 文件里撰写模板)，需要留意浏览器会把特性名全部强制转为小写
</code></pre><p><strong>动态参数一个数一个特性</strong> 所以不能驼峰写法</p>
<h3 id="4-关于computed属性和methods-写方法"><a href="#4-关于computed属性和methods-写方法" class="headerlink" title="4.关于computed属性和methods 写方法"></a>4.关于computed属性和methods 写方法</h3><p>  1）不能同时存在名字相同的计算属性和方法<br>  2）计算属性只要不改变就会缓存。但是方法不行，方法每次都会执行</p>
<h3 id="5-Lodash"><a href="#5-Lodash" class="headerlink" title="5.Lodash"></a>5.Lodash</h3><p>Lodash 通过降低 array、number、objects、string 等等的使用难度从而让 JavaScript 变得更简单。<br>Lodash 的模块化方法 非常适用于：</p>
<pre><code>遍历 array、object 和 string
对值进行操作和检测
创建符合功能的函数
</code></pre><p>Lodash就是这样的一套工具库，它内部封装了诸多对字符串、数组、对象等常见数据类型的处理函数，其中部分是目前ECMAScript尚未制订的规范</p>
<h3 id="6-注意名字带’-‘-属性名要加””-例如："><a href="#6-注意名字带’-‘-属性名要加””-例如：" class="headerlink" title="6.注意名字带’-‘ 属性名要加”” 例如："></a>6.注意名字带’-‘ 属性名要加”” 例如：</h3><p> “err-err”:true ,建议全都带引号就没问题了吧？</p>
<pre><code>data:{
  &quot;classobject&quot;:{
    &quot;active&quot;:true,
    &quot;err-err&quot;:true
  }
}
</code></pre><h3 id="7-VUE的模块（component）引进来驼峰，写成标签用-代替"><a href="#7-VUE的模块（component）引进来驼峰，写成标签用-代替" class="headerlink" title="7.VUE的模块（component）引进来驼峰，写成标签用-代替"></a>7.VUE的模块（component）引进来驼峰，写成标签用-代替</h3><h3 id="8不要用H5标签做模板名字"><a href="#8不要用H5标签做模板名字" class="headerlink" title="8不要用H5标签做模板名字"></a>8不要用H5标签做模板名字</h3><p>.Do not use built-in or reserved HTML elements as component id: header<br>不能用H5标签作为模板名字</p>
<h3 id="9-vue-项目地址去掉-的方法"><a href="#9-vue-项目地址去掉-的方法" class="headerlink" title="9.vue 项目地址去掉 #的方法"></a>9.vue 项目地址去掉 #的方法</h3><p>使用history模式，在路由里面加入：</p>
<pre><code>mode: &apos;history&apos;,
</code></pre><h3 id="10-v-model正确用法"><a href="#10-v-model正确用法" class="headerlink" title="10 v-model正确用法"></a>10 v-model正确用法</h3><p>一开始他讲错了，v-model就是直接写= 而不是： input默认就会绑定相应的值，输入就绑定value，选择绑定checked，下拉绑定selected,这是官方的写法</p>
<pre><code>&lt;input type=&quot;text&quot; v-model:value=&quot;aaa&quot;&gt; 可以这样写，但是项目中ESLINT肯定报错
&lt;input type=&quot;text&quot; v-model=&quot;aaa&quot;&gt;       标准这样写
</code></pre><h3 id="11-项目小问题"><a href="#11-项目小问题" class="headerlink" title="11 项目小问题"></a>11 项目小问题</h3><pre><code>1.发现有坑
最好不要改项目的名字，在install 包之前就把项目的名字确定好
2.页面的坑
1）如何去除input标签选中的框：
给input设置 outline:none;
</code></pre>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/08/11/Java总结（七）/" rel="next" title="Java总结（七）">
                <i class="fa fa-chevron-left"></i> Java总结（七）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/08/25/Java总结（九）/" rel="prev" title="Java总结（九）">
                Java总结（九） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Inhaltsverzeichnis
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Übersicht
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">王邸</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">Artikel</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">Tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#星期一（8-12）"><span class="nav-number">1.</span> <span class="nav-text">星期一（8.12）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DOM"><span class="nav-number">1.1.</span> <span class="nav-text">DOM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#XML-DOM-和-HTML-DOM-关系"><span class="nav-number">1.2.</span> <span class="nav-text">XML DOM 和 HTML DOM 关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Node的特性方法"><span class="nav-number">1.3.</span> <span class="nav-text">Node的特性方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DOM-节点常用属性"><span class="nav-number">1.4.</span> <span class="nav-text">DOM 节点常用属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#星期二（8-13）"><span class="nav-number">2.</span> <span class="nav-text">星期二（8.13）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#XML"><span class="nav-number">2.1.</span> <span class="nav-text">XML</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#XML的语法规则"><span class="nav-number">2.2.</span> <span class="nav-text">XML的语法规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DTD"><span class="nav-number">2.3.</span> <span class="nav-text">DTD</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DTD-简介"><span class="nav-number">2.4.</span> <span class="nav-text">DTD 简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内部的-DOCTYPE-声明"><span class="nav-number">2.5.</span> <span class="nav-text">内部的 DOCTYPE 声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DTD-XML-构建模块"><span class="nav-number">2.6.</span> <span class="nav-text">DTD - XML 构建模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DTD-元素"><span class="nav-number">2.7.</span> <span class="nav-text">DTD 元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DTD-属性"><span class="nav-number">2.8.</span> <span class="nav-text">DTD 属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DTD-实体"><span class="nav-number">2.9.</span> <span class="nav-text">DTD 实体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DTD-验证"><span class="nav-number">2.10.</span> <span class="nav-text">DTD 验证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DTD-实例"><span class="nav-number">2.11.</span> <span class="nav-text">DTD 实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Schema"><span class="nav-number">2.12.</span> <span class="nav-text">Schema</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#XML-Schema-使用-XML-语法"><span class="nav-number">2.13.</span> <span class="nav-text">XML Schema 使用 XML 语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#XML-Schema-可保护数据通信"><span class="nav-number">2.14.</span> <span class="nav-text">XML Schema 可保护数据通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#XML-Schema-可扩展"><span class="nav-number">2.15.</span> <span class="nav-text">XML Schema 可扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一个简单的例子"><span class="nav-number">2.16.</span> <span class="nav-text">一个简单的例子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#元素"><span class="nav-number">2.17.</span> <span class="nav-text"> 元素</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#星期三（8-14）"><span class="nav-number">3.</span> <span class="nav-text">星期三（8.14）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Node"><span class="nav-number">3.1.</span> <span class="nav-text">Node</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#webpack"><span class="nav-number">3.2.</span> <span class="nav-text">webpack</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ESLint"><span class="nav-number">3.3.</span> <span class="nav-text">ESLint</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue"><span class="nav-number">3.4.</span> <span class="nav-text">Vue</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#星期四（8-15）"><span class="nav-number">4.</span> <span class="nav-text">星期四（8.15）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#v-bind"><span class="nav-number">4.1.</span> <span class="nav-text">v-bind:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#v-model"><span class="nav-number">4.2.</span> <span class="nav-text">v-model:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#v-text"><span class="nav-number">4.3.</span> <span class="nav-text">v-text</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#v-html"><span class="nav-number">4.4.</span> <span class="nav-text">v-html</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#v-on"><span class="nav-number">4.5.</span> <span class="nav-text">v-on:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#v-show"><span class="nav-number">4.6.</span> <span class="nav-text">v-show</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#v-if"><span class="nav-number">4.7.</span> <span class="nav-text">v-if</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#v-for"><span class="nav-number">4.8.</span> <span class="nav-text">v-for</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#v-slot"><span class="nav-number">4.9.</span> <span class="nav-text">v-slot</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#computed"><span class="nav-number">4.10.</span> <span class="nav-text">computed:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#watch"><span class="nav-number">4.11.</span> <span class="nav-text">watch:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#template"><span class="nav-number">4.12.</span> <span class="nav-text">template:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue-component"><span class="nav-number">4.13.</span> <span class="nav-text">Vue.component</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#星期五（8-16）"><span class="nav-number">5.</span> <span class="nav-text">星期五（8.16）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#vue-cli"><span class="nav-number">5.1.</span> <span class="nav-text">vue-cli</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue项目的目录结构（cli构建出来的）"><span class="nav-number">5.2.</span> <span class="nav-text">Vue项目的目录结构（cli构建出来的）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#服务简单配置-端口…"><span class="nav-number">5.3.</span> <span class="nav-text">服务简单配置(端口…)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bus"><span class="nav-number">5.4.</span> <span class="nav-text">bus</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Axios"><span class="nav-number">5.5.</span> <span class="nav-text">Axios</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue-router路由"><span class="nav-number">5.6.</span> <span class="nav-text">Vue-router路由</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#访问"><span class="nav-number">5.7.</span> <span class="nav-text">访问</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vuex"><span class="nav-number">5.8.</span> <span class="nav-text">vuex</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#概念"><span class="nav-number">5.9.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用state"><span class="nav-number">5.10.</span> <span class="nav-text">使用state</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vuex-mutations"><span class="nav-number">5.11.</span> <span class="nav-text">Vuex-mutations</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vuex-actions"><span class="nav-number">5.12.</span> <span class="nav-text">Vuex-actions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vuex-getters"><span class="nav-number">5.13.</span> <span class="nav-text">Vuex-getters</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#星期六（8-17）"><span class="nav-number">6.</span> <span class="nav-text">星期六（8.17）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#小总结系列"><span class="nav-number">6.1.</span> <span class="nav-text">小总结系列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0-JS的坑"><span class="nav-number">6.2.</span> <span class="nav-text">0.JS的坑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-关于DOM获取相邻结点的问题"><span class="nav-number">6.3.</span> <span class="nav-text">1.关于DOM获取相邻结点的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-VUE"><span class="nav-number">6.4.</span> <span class="nav-text">2.VUE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-动态参数："><span class="nav-number">6.5.</span> <span class="nav-text">3.动态参数：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-关于computed属性和methods-写方法"><span class="nav-number">6.6.</span> <span class="nav-text">4.关于computed属性和methods 写方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Lodash"><span class="nav-number">6.7.</span> <span class="nav-text">5.Lodash</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-注意名字带’-‘-属性名要加””-例如："><span class="nav-number">6.8.</span> <span class="nav-text">6.注意名字带’-‘ 属性名要加”” 例如：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-VUE的模块（component）引进来驼峰，写成标签用-代替"><span class="nav-number">6.9.</span> <span class="nav-text">7.VUE的模块（component）引进来驼峰，写成标签用-代替</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8不要用H5标签做模板名字"><span class="nav-number">6.10.</span> <span class="nav-text">8不要用H5标签做模板名字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-vue-项目地址去掉-的方法"><span class="nav-number">6.11.</span> <span class="nav-text">9.vue 项目地址去掉 #的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-v-model正确用法"><span class="nav-number">6.12.</span> <span class="nav-text">10 v-model正确用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-项目小问题"><span class="nav-number">6.13.</span> <span class="nav-text">11 项目小问题</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王邸</span>

  
</div>


  <div class="powered-by">Erstellt mit  <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'Fn4BuvoixOxjJAhR79TvaD5M-gzGzoHsz',
        appKey: '1uspTrSwPqkmSBSUr948WqxE',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("Fn4BuvoixOxjJAhR79TvaD5M-gzGzoHsz", "1uspTrSwPqkmSBSUr948WqxE");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
