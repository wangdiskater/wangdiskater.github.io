<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="这周学习了JDBC批处理，事务(默认提交)，连接池（DBCP,C3P0,Druid），DButil，单元测试，也学习了前端，但是讲的太水了，不敢苟同。所以自己去整理，但是自己也没有书，只有去MDN去学习，发现讲的很全面，虽然是火狐浏览器为基础的。但是讲的都是很标准的东西。想要通过几天把前端都回顾完是不可能的，还有很多坑在里面。只有一步步来。每天都复习一点。 星期一（8.5）JDBC批处理就是多次进">
<meta property="og:type" content="article">
<meta property="og:title" content="Java总结（七）">
<meta property="og:url" content="http://yoursite.com/2019/08/11/Java总结（七）/index.html">
<meta property="og:site_name" content="路要坚持">
<meta property="og:description" content="这周学习了JDBC批处理，事务(默认提交)，连接池（DBCP,C3P0,Druid），DButil，单元测试，也学习了前端，但是讲的太水了，不敢苟同。所以自己去整理，但是自己也没有书，只有去MDN去学习，发现讲的很全面，虽然是火狐浏览器为基础的。但是讲的都是很标准的东西。想要通过几天把前端都回顾完是不可能的，还有很多坑在里面。只有一步步来。每天都复习一点。 星期一（8.5）JDBC批处理就是多次进">
<meta property="og:updated_time" content="2019-08-19T14:54:09.178Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java总结（七）">
<meta name="twitter:description" content="这周学习了JDBC批处理，事务(默认提交)，连接池（DBCP,C3P0,Druid），DButil，单元测试，也学习了前端，但是讲的太水了，不敢苟同。所以自己去整理，但是自己也没有书，只有去MDN去学习，发现讲的很全面，虽然是火狐浏览器为基础的。但是讲的都是很标准的东西。想要通过几天把前端都回顾完是不可能的，还有很多坑在里面。只有一步步来。每天都复习一点。 星期一（8.5）JDBC批处理就是多次进">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/08/11/Java总结（七）/"/>





  <title>Java总结（七） | 路要坚持</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">路要坚持</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/11/Java总结（七）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王邸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路要坚持">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java总结（七）</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-11T23:43:08+08:00">
                2019-08-11
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/08/11/Java总结（七）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/08/11/Java总结（七）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2019/08/11/Java总结（七）/" class="leancloud_visitors" data-flag-title="Java总结（七）">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>这周学习了JDBC批处理，事务(默认提交)，连接池（DBCP,C3P0,Druid），DButil，单元测试，也学习了前端，但是讲的太水了，不敢苟同。所以自己去整理，但是自己也没有书，只有去MDN去学习，发现讲的很全面，虽然是火狐浏览器为基础的。但是讲的都是很标准的东西。想要通过几天把前端都回顾完是不可能的，还有很多坑在里面。只有一步步来。每天都复习一点。</p>
<h2 id="星期一（8-5）"><a href="#星期一（8-5）" class="headerlink" title="星期一（8.5）"></a>星期一（8.5）</h2><h3 id="JDBC批处理"><a href="#JDBC批处理" class="headerlink" title="JDBC批处理"></a>JDBC批处理</h3><p>就是多次进行处理，没有批处理，我们如何批量新增数据<br>也许应该是这样：使用循环然后statement.executeUpdate()来插入数据；</p>
<pre><code>//批量插入数据 500条
Connection connection = null;
Statement statement = null;
try {
    connection = JdbcUtil.getConnection();
    statement = connection.createStatement();
    for (int i = 0; i &lt; 500; i++) {
        statement.executeUpdate(&quot;insert into user values (null,&apos;&quot; + i + &quot;&apos;,&apos;&quot; + i + &quot;&apos;)&quot;);
    }
} catch (IOException e) {
    e.printStackTrace();
} catch (ClassNotFoundException e) {
    e.printStackTrace();
} catch (SQLException e) {
    e.printStackTrace();
}finally {
    try {
        JdbcUtil.releaseConnection(connection,null,statement);
    } catch (SQLException e) {
        e.printStackTrace();
    }
}
</code></pre><h3 id="使用statement的批处理："><a href="#使用statement的批处理：" class="headerlink" title="使用statement的批处理："></a>使用statement的批处理：</h3><pre><code>statement.addBatch(sql); 相当于将砖放到一个小推车里
statement.executeBatch(); 推着小推车去目的地
statement.clearBatch();  将小推车里面的砖块卸了，再回到目的地

//批量插入数据 500条
Connection connection = null;
Statement statement = null;
try {
    connection = JdbcUtil.getConnection();
    statement = connection.createStatement();
    for (int i = 0; i &lt; 500; i++) {
        statement.addBatch(&quot;insert into user values (null,&apos;&quot; + i + &quot;&apos;,&apos;&quot; + i + &quot;&apos;)&quot;);
        statement.addBatch(&quot;delete from user where id = 1&quot;);
        if(i == 249){
          statement.executeBatch();
          statement.clearBatch();  //第一次搬砖
        }
    }
    statement.executeBatch();      //第二次搬砖
</code></pre><p>特点：<br>较为灵活，可以执行多条不同类型的sql语句。</p>
<h3 id="prepareStatement批处理："><a href="#prepareStatement批处理：" class="headerlink" title="prepareStatement批处理："></a>prepareStatement批处理：</h3><pre><code>Connextion connection = null;
PrepareStatement preparedStatement = null;
try{
  connection = JdbcUtil.getConnection();
  String sql = &quot;insert into user values (&apos;null&apos;,?,?)&quot;;
  preparedStatement = connection.prepareStatement(sql);
  for(int i = 0; i &lt; 500; i++) {
    preparedStatement.setString(1,i+&quot;&quot;);
    preparedStatement.setString(2,i+&quot;&quot;);
    preparedStatement.addBatch();

    if(i = ((500-1)&gt;&gt;1)){ //先把一半的砖都拿走
      preparedStatement.executeBatch();
      prepatedStatement.clearBatch();
    }
  }
  preparedStatement.executeBatch();//办第二次
  preparedStatement.clearBatch();
} catch (IOException e) {
    e.printStackTrace();
} catch (ClassNotFoundException e) {
    e.printStackTrace();
} catch (SQLException e) {
    e.printStackTrace();
}finally {
    try {
        JdbcUtil.releaseConnection(connection,null,preparedStatement);
    } catch (SQLException e) {
        e.printStackTrace();
    }
}
</code></pre><p>仅能执行类型相同而参数不同的sql语句。但是效率很高</p>
<p>采用PreparedStatement.addBatch()实现批处理<br>优点：与数据库通信次数在批量操作时，PreparedStatment的通信次数远少于Statment。<br>缺点：只能应用在SQL语句相同，但参数不同的批处理中。因此此种形式的批处理经常用于在同一个表中批量插入数据，或批量更新表的数据。</p>
<p><strong>注意事项</strong>：<br>1.默认情况下Mysql的批处理仍然是一条一条执行，需要在url后面添加rewriteBatchedStatements=true参数例如：</p>
<pre><code>url=jdbc:mysql://localhost:3306/bank?characterEncoding=utf8&amp;rewriteBatchedStatements=true
</code></pre><p>2.PreparedStatement.addBatch()注意内存溢出问题</p>
<p>为什么addBatch()会内存溢出？</p>
<pre><code>// private byte[][] parameterValues = (byte[][])null;
public synchronized void addBatch() throws SQLException {
  if (this.batchedArgs == null) {
    this.batchedArgs = new ArrayList();
  }
  for(int i = 0; i &lt; this.parameterValues.length; ++i) {
    this.checkAllParametersSet(this.parameterValues[i], this.parameterStreams[i], i);
  }
  this.batchedArgs.add(new PreparedStatement.BatchParams(this.parameterValues, this.parameterStreams, this.isStream, this.streamLengths, this.isNull));
}
</code></pre><p>看到是一个ArrayList存储的不知道哪里可能会出现内存溢出<br>网上搜了一下：数据库存取内存溢出的问题：</p>
<p>1.是ibatis 频繁读取数据库的问题，换成jdbc就好了<br>2.jdbc statement.executeQuery(sql) 造成内存溢出。<br>如果你要读取一个超大的表，使用下面的语句有可能会造成内存溢出：</p>
<pre><code>Statement statement = conn.createStatement(
                    ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
ResultSet rs = statement.executeQuery(sql);
这是因为如果不设置statement的fetchSize的话，mysql驱动默认会将数据全部载入到内存中，所以就会OutOfMemoryError了。
</code></pre><p>解决的方法有两种，在执行statement.executeQuery(sql);添加下面两行中的一行，即可：</p>
<pre><code>statement.setFetchSize(Integer.MIN_VALUE);
 ((com.mysql.jdbc.Statement)stat).enableStreamingResults();
</code></pre><p>3.<a href="https://antival.iteye.com/blog/1340774" target="_blank" rel="external">JDBC批处理内存溢出问题分析</a>关键点：</p>
<pre><code>第五步，分析发现19万分每次5000笔也是38次，38次connnection和PreparedStatement可能有问题。因此修改代码，将链接(connection)和PreparedStatement都提出来，在循环之外。然后每次批量执行完毕都执行清理操作（pstat.clearBatch()）。内存稳定，没有增加，问题解决。
结论：PreparedStatement批量执行方式占用内存有可能非常大（跟批量数据量有关系），如果只是使用close，包括connection的close，并不能及时释放，哪怕是强制gc也不能释放。
解决的方法就是使用统一个PreparedStatement，那么假设它占用50M的空间，循环使用的情况下，只是覆盖没有新new一些地址，可能就是解决问题的思路。
</code></pre><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务指逻辑上的一组操作，组成这组操作的各个单元，要么全部成功，要么全部不成功。</p>
<p>Mysql数据库在默认情况下是自动提交事务的，这点需要与oracle数据库做一个区分。Oracle数据库执行完之后，需要手动执行commit操作。<br>命令行开启事务的方式：</p>
<pre><code>start transaction  开启事务DTL 取消自动提交事务
rollback           回滚到start transaction
commit             提交
</code></pre><h3 id="事务的四个特性-ACID"><a href="#事务的四个特性-ACID" class="headerlink" title="事务的四个特性(ACID)"></a>事务的四个特性(ACID)</h3><p>原子性（Atomicity）</p>
<pre><code>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 
</code></pre><p>一致性（Consistency）</p>
<pre><code>事务必须使数据库从一个一致性状态变换到另外一个一致性状态。
</code></pre><p><strong>隔离性（Isolation）</strong></p>
<pre><code>事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。
</code></pre><p>持久性（Durability）</p>
<pre><code>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障(软件故障)也不应该对其有任何影响。
</code></pre><h3 id="事务的隔离性"><a href="#事务的隔离性" class="headerlink" title="事务的隔离性"></a>事务的隔离性</h3><p>隔离性做的不够好（对应于不同的隔离等级），会有哪些问题产生：</p>
<pre><code>脏读：一个事务读取到了另外一个事务未提交的数据。
不可重复读：一个事务读取到了另外一个事务已经提交的数据。
虚读：一个事务读取到了另外一个事务新增的数据。
</code></pre><p>脏读是最低级的，虚读是最高级的。</p>
<p>下面就来说说这几种隔离性不好的问题的差异，我们还是在命令行操作，首先使用两个命令行窗口，</p>
<pre><code>窗口一，窗口二同时开始事务 输入命令：start transaction
第一个命令行窗口只做操作，
第二个命令行窗口只去数据库读取信息
</code></pre><p>窗口二只读取数据库三次：</p>
<pre><code>1.在窗口一开始操作之前读
2.在窗口一设置数据之后，未提交之前读
3.在窗口一提交之后读数据库
</code></pre><p>我们分别把这三个结果叫 结果1，结果2，结果3<br>当我们设置隔离等级是read uncommitted ，为了能表示出脏读</p>
<pre><code>set global transaction isolation level read uncommitted;
</code></pre><p>我们可以得出 结果1 ！= 结果2时，就发生了脏读:事务二读取到了事务一的未提交的数据</p>
<p>当我们设置隔离等级是read committed ，为了能表示出不可重复读</p>
<pre><code>set global transaction isolation level read committed;
</code></pre><p>得出： 结果1 = 结果2 ！= 结果3 ：一个事务重新读取前面读取过的数据， 发现该数据已经被另一个已提交的事务修改过。<br>表现出不可重复读</p>
<p><strong>注意事项</strong>Mysql是表现不出虚读的，因为Mysql在隔离级别Repeatable read就避免phantom read（虚读）但是在别的数据库里虚读的表现和不可重读读是类似的也是：结果1 = 结果2 ！= 结果3，但是这就表现出的是行数的不同，而不是数据的不同。</p>
<h3 id="数据库提供了四种不同级别的隔离等级："><a href="#数据库提供了四种不同级别的隔离等级：" class="headerlink" title="数据库提供了四种不同级别的隔离等级："></a>数据库提供了四种不同级别的隔离等级：</h3><pre><code>Read uncommitted ：以上三种情况均不能避免
Read committed：可避免脏读的发生
Repeatable read：可避免脏读，不可重复读发生
Serializable：可避免所有问题发生（串行化，一个一个走）
</code></pre><p>查看和设置事务隔离级别命令：在Mysql的命令下：</p>
<pre><code>select @@transaction_isolation;                                 //查看隔离级别
set session/global transaction isolation level read uncommitted //这是隔离级别
</code></pre><h3 id="JDBC启用事务模式"><a href="#JDBC启用事务模式" class="headerlink" title="JDBC启用事务模式"></a>JDBC启用事务模式</h3><p>当Jdbc程序向数据库获得一个Connection对象时，默认情况下这个Connection对象会自动向数据库提交commit在它上面发送的SQL语句。若想关闭这种默认提交方式，让多条SQL在一个事务中执行，可使用下列语句：<br>JDBC控制事务语句|对应的命令行操作<br>-:|:-<br>Connection.setAutoCommit(false)  |  start transaction<br>Connection.rollback();           |  rollback<br>Connection.commit();             |  commit</p>
<h3 id="设置事务回滚点Connection-rollback"><a href="#设置事务回滚点Connection-rollback" class="headerlink" title="设置事务回滚点Connection.rollback()"></a>设置事务回滚点Connection.rollback()</h3><pre><code>Savepoint sp = conn.setSavepoint();
Conn.rollback(sp);
Conn.commit();   //回滚后必须要提交
</code></pre><p>看下面的例子</p>
<p>//jdbc设置事务：老板给员工转账问题<br>设置事务的回滚点：<br>比如公司老板给多名员工同时发工资，发到一半时，出现了问题，这个时候，我们可以回滚到出错的上一个人位置，而不必直接rollback到最开始的时候。<br>1.首先老板选择需要发放工资的员工人员，接下来，他直接操作，最终程序自动完成转账功能。<br>2.每个员工的薪水是不同的，具体的薪水存放在薪水表中。从新水表获取到需要发放工资的员工对应的薪水，<br>3.之后，进入转账环节，转账成功同时要写入相应的转账记录。</p>
<p>需要的表如下：<br>员工表（包含每个员工应该得的工资） 金额表（每个员工自己的资金是多少）  转账记录表记录转账</p>
<p>员工表：</p>
<pre><code>emp   | CREATE TABLE `emp` (
 `id` int(11) NOT NULL AUTO_INCREMENT,
 `name` varchar(30) DEFAULT NULL,
 `salary` double DEFAULT NULL,
 `flag` enum(&apos;成功&apos;,&apos;失败&apos;) DEFAULT &apos;失败&apos;,
 PRIMARY KEY (`id`)
</code></pre><p>金额表：</p>
<pre><code>account | CREATE TABLE `account` (
 `id` int(11) NOT NULL AUTO_INCREMENT,
 `name` varchar(255) DEFAULT NULL,
 `money` double NOT NULL,
 `eid` int(11) NOT NULL,
 PRIMARY KEY (`id`)
</code></pre><p>转账记录表：</p>
<pre><code>`id` int(11) NOT NULL AUTO_INCREMENT,
  `getId` int(11) DEFAULT NULL,
  `getName` varchar(30) DEFAULT NULL,
  `supplyId` int(11) DEFAULT NULL,
  `supplyName` varchar(30) DEFAULT NULL,
  `money` double DEFAULT NULL,
  `time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
</code></pre><p>这个表使用一个字段来标记是否转账成功，以避免事务中途被强制结束，有一些转账成功，一些转账失败，导致重复转账的情况，下面上代码，这里注意，还是用了之前的jdbcUtil的方法来获取连接和释放资源；<br>首先先需要一个bean(pojo)来保存数据库取出的数据</p>
<pre><code>package practise.pojo;
//java bean设计的一些注意事项
//字段属性设置private，然后提供get和set方法
//提供无参构造函数，如果写了有参，则要把无参另外写出来
public class Emp {
    private int id;
    private String name;
    private double salary;
    private String flag;
    public Emp() {}
    public Emp(int id, String name, double salary) {
        this.id = id;
        this.name = name;
        this.salary = salary;
    }
    public int getId() {return id;}
    public void setId(int id) {this.id = id;}
    public String getName() {return name;}
    public void setName(String name) {this.name = name;}
    public double getSalary() {return salary;}
    public void setSalary(double salary) {this.salary = salary;}
    public String getFlag() {return flag;}
    public void setFlag(String flag) {this.flag = flag;}
}
</code></pre><p>2.编写一个重数据库取出数据的类LoadSalary</p>
<pre><code>public class LoadSalar{
    public static void main(String[] args) {
        Connection connection = null;
        PreparedStatement preparedstatement = null;
        ResultSet resultSet = null;
        List&lt;Emp&gt; list = new ArrayList&lt;&gt;();
        try{
            connection = jdbcUtil.getConnection();
            String s1 = &quot;select * from emp&quot;;
            preparedStatement = connection.prepareStatement(s1);
            resultSet = preparedStatement.executeQuery();
            while(result.next){
                Emp employee = new Emp();
                int id = resultSet.getInt(&quot;id&quot;);
                String name = resultSet.getString(&quot;name&quot;);
                double salary = resultSet.getDouble(&quot;salary&quot;);
                String flag = resultSet.getString(&quot;flag&quot;);
                employee.setId(id);
                employee.setName(name);
                employee.setSalary(salary);
                employee.setFlag(flag);
                list.add(employee);
            }
            TransSalary.transfer(list);// 进行转账操作
        } catch(Exception e) {
            e.printStackTrace();
        } finally {
            try{
                JdbcUtil.releaseConnection(connection,resultSet,preparedStatement);
            } catch(SQLException e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre><p>3.编写转账的JDBC</p>
<pre><code>public class TransSalary{
    public static void transfer(List&lt;Emp&gt; list) {
        //先把boss从list里面拿出来
        Emp boss = new Emp();
        for(Emp emp1 : list) {
            if(&quot;佟掌柜&quot;.equals(emp1.getName)) {
                boss = emp1;
                break;
            }
        }
        Connection connection = null;
        //需要两个prepareStatement来操作两个数据库
        PrepareStatement preparedStatement1 = null;
        PrepareStatement preparedStatement2 = null;
        Savepoint savepoint = nulll; //设置回滚点

        ResultSet resultSet = null;
        try{

            connection = JdbcUtil.getConnection();
            //手动开启事务
            connection.setAutoCommit(false);
            //转账sql
            String sql = &quot;update account set money = money - ? where eid = ?&quot;;
            //修改emp标记sql
            String sql2 = &quot;update emp set flag = &apos;成功&apos; where id = ?&quot;;

            preparement1 = connection.prepareStatement(sql);
            preparement2 = connection.prepareStatement(sql2);

            //转账开始
            for(Emp emp : list) {

                //给钱
                preparement1.setDouble(1,-list.getSalary());
                preparement1.setInt(2,emp.getId());
                preparement1.executeUpdate();  //返回影响的行数

                //老板扣钱
                preparement1.setDouble(1,list.getSalary());
                preparement1.setInt(2,boss.getId());
                preparement1.executeUpdate();

                //设置emp的标签为成功
                preparement2.setInt(1,emp.getId());
                prepatement2.executeUpdate();

                //到这里说明成功，成功就写记录到数据库
                //被转账的人信息  转账人的信息 转账金额 日期
                RecordSalary.record(emp.getId(), emp.getName(), boss.getId(), boss.getName(), emp.getSalary());

                //转账成功记录保存点
                savepoint = connection.setSavepoint();
            }
        connection.commit();//提交事务
        } catch (Exception e) {
            //发生异常需要回滚
            e.printStackTrace();

            //判断一下回滚点是否是null
            if(savepoint == null) {
                connection.rollback();//就停止了
            } else {
                connection.rollback(savepoint);
                //记得提交事务
                connection.commit();
            }

            connection.rollback(savepoint);
        } finnaly{
            try{
                JdbcUtil.releaseConnection(connection,null,preparedStatement);
                preparement2.close();
            } catch(SQLExeception e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre><p>4.向record写入记录</p>
<pre><code>public class RecordSalary {
    public static void record(int getId,String getName, int supplyId, String supplyName, double salary ) {
        Connection connection  = null;
        PreparedStatement preparedStatement = null;
        //id getid getName supplyId supplyName,salary,dateTime
        String sql = &quot;Insert into record values(null,?,?,?,?,?,now())&quot;;
        try {
            connection = JdbcUtil.getConnection();
            preparedStatement = connection.prepareStatement(sql);
            preparedStatement.setInt(1,getId);
            preparedStatement.setString(2,getName);
            preparedStatement.setInt(3,supplyId);
            preparedStatement.setString(4,supplyName);
            preparedStatement.setDouble(5,salary);
            preparedStatement.executeUpdate();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (SQLException e) {
            e.printStackTrace();
        } finally{
            try {
                JdbcUtil.releaseConnection(connection,null,preparedStatement);
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre><p><strong>注意事项</strong><br>1.这里注意rollback方法，回到的是savepoint的地方，这个savepoint是由connection给的，一开始默认值是null,我看了rollback方法两个是分开的方法，所以savepoint一定要先判断是否为null再决定是rollback(savepoint)还是rollback()直接回到一开始；</p>
<p>2.对rollback函数的构想，能否单独抽离出rollback函数，这样自己设置保存点。就能自己写一个callback的方法，能回到自己想回到的地方，但是这个怎么执行之类，还需要对这个函数更加了解才行</p>
<h2 id="星期二（8-6）"><a href="#星期二（8-6）" class="headerlink" title="星期二（8.6）"></a>星期二（8.6）</h2><h3 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h3><p>什么是数据库连接池，为什么需要？<br>在之前的JDBC操作中，每次都需要手动去创建一个连接，并且在使用完成之后，关闭该连接。但是在真实的生产环境中，连接的创建是非常消耗性能的，花费时间较久，在多用户并发访问的时候，极容易出现数据库内存溢出，系统宕机。<br>解决方案，就是新建一个数据库连接池，预先在连接池里面存放一些数据库连接，当用户访问的时候，直接去连接池中去拿一个连接，而不是新创建一个。同时使用完之后，也不是直接关闭销毁，而是放回连接池。</p>
<p>数据库连接池和我们之前学的JDBC的操作流程有没有互相违背的地方？？？<br>JDBC中一致强调要及释放资源，关闭connection对象。连接池又说要用一个池子来保存连接，避免新建一个连接。</p>
<h3 id="初识连接池"><a href="#初识连接池" class="headerlink" title="初识连接池"></a>初识连接池</h3><p>自己手写一个连接池，然后只重写了close方法，close并不是关闭连接，只是把连接丢会连接池</p>
<pre><code>public class MyConnectionPool {
  //要从头删除，所以使用LinkedList
  private static List&lt;Connection&gt; pool = new LinkedList&lt;&gt;();
  //初始化连接池
  static {
    resize(10); //就构建一个长度10的连接池
  }
  private static void resize(int number){
    for (int i = 0; i &lt; number; i++) {
      try {
        //真正类型是JDBC4Connection
        Connection connection = JdbcUtil.getConnection();
        pool.add(connection);
      } catch (IOException e) {
        e.printStackTrace();
      } catch (ClassNotFoundException e) {
        e.printStackTrace();
      } catch (SQLException e) {
        e.printStackTrace();
      }
    }
  }
  public static Connection getConnection(){
    if(pool.size() &lt; 4) {
      resize(6);
    }
    return pool.remove(0);
  }
  //回收Connection
  public static void returnConnection(Connection connection){
    pool.add(connection);
  }
}
</code></pre><p><strong>出现的问题</strong><br>第一个数据库连接池存在的问题：没有符合规范。每家的数据库连接池可能API名称都不同，同时也许有的可以直接通过静态方法调用，有的不能够直接调用，这个时候还是需要去查阅相应的开发文档，使用起来不是很方便，如果有一个规范来约束每个API名称应该是什么，这个时候，在使用各个开源数据库连接池产品时，可以直接调用接口的方法即可。<br>Sun公司定义了一个<strong>DataSource</strong>接口，用以规范数据库连接池相关的API。<br>解决办法就是实现DataSource接口，实现规范！！！让大家用同一种规范来重写方法</p>
<h2 id="重写连接池"><a href="#重写连接池" class="headerlink" title="重写连接池"></a>重写连接池</h2><pre><code>//MyDataSource
public class MyDataSource implements DataScoure {
  private static List&lt;Connection&gt; pool = new LinkedList&lt;&gt;();
  static {
      resize(10);
  }
  private static void resize(int number){
    for (int i = 0; i &lt; number; i++) {
      try {
        //真正类型是JDBC4Connection
        Connection connection = JdbcUtil.getConnection();

        //接下来将JDBC4Connection对象作为参数传入到connectionWrapper中
        ConnectionWrapper connectionWrapper = new ConnectionWrapper(connection,pool);

        //pool.add(connection);
        pool.add(connectionWrapper);
      } catch (IOException e) {
        e.printStackTrace();
      } catch (ClassNotFoundException e) {
        e.printStackTrace();
      } catch (SQLException e) {
        e.printStackTrace();
      }
    }
  }
  @Override 重写方法
  public Connection getConnection() throws SQLException {
      if(pool.size() &lt; 4){
          resize(6);
      }
      return pool.remove(0);
  }

  //这个方法并没有被重写
  //public  void returnConnection(Connection connection){
    public void close(Connection connection) {
      pool.add(connection);
    }
  }
}
</code></pre><p>实现了DataSource接口之后，发现接口中没有定义returnConnection的API，同时还有一点，我们自己实现的DataSoure肯定希望别人能够使用，作为一个第三方jar包。无法阻止其他人主动去调用connection.close方法。再次放入连接池，该连接池就没有任何意义了。我们应该想一个办法重写close()方法：<br><strong>当调用connection.close方法时，不是关闭连接，而是将连接返回到连接池中。</strong><br>所以，这里我们发现resize方法有一些不同，add的是一个ConnectionWrapper，而不是第一次写的Connection。给Connection了一个包装类，这样就能阻止用户直接调用Connection自身的close()方法结束链接，而是调用我们包装类的close()。把数据连接放回到连接池。连接池里面放的就是我们的包装类，而不是Connection的本身实现的子类JDBC4Connection;</p>
<pre><code>public class ConnectionWrapper implements Connection {
  private Connection connectin;
  private List&lt;Connection&gt; pool;

  //通过构造函数传进来一个会写这些方法的connection过来，然后完成这些方法

  public ConnectionWrapper(Connection connection, List&lt;Connection&gt; pool) {
      this.connection = connection;
      this.pool = pool;
  }
  ...
  ...
  ...
  //需要将这个方法重写，不是真正关闭连接，而是返回连接池
  @Override
  public void close() throws SQLException {
      //connection.close();
      pool.add(this);
  }
}
</code></pre><p>虽然我们实现了dataSource接口的规范，但是自己写的工具类还是有一些问题的：</p>
<pre><code>1.很多API没有实现
2.没有扩容机制
3.也没有回收连接机制，存在连接池中也是一种资源浪费
</code></pre><p>更多的还是理解写包装类的作用。就是为了数据连接池能复用连接。</p>
<h3 id="第三方开源的数据库连接池"><a href="#第三方开源的数据库连接池" class="headerlink" title="第三方开源的数据库连接池"></a>第三方开源的数据库连接池</h3><p><strong>友情提示：</strong>这三个数据库的连接池还是需要用：<strong>mysql-connection.jar</strong>的并不是说不用了。这里一定要注意</p>
<h3 id="DBCP"><a href="#DBCP" class="headerlink" title="DBCP"></a>DBCP</h3><p>原理就是上面自己写的connectionpool，就是来使用：</p>
<pre><code>首先要加载三个包：
commons-dbcp2-2.5.0.jar
commons-logging-1.2.jar
commons-pool2-2.6.0.jar
</code></pre><p>//test</p>
<pre><code>public class DbcpTest {
  public static void main(String[] args) {
    Connection connection = null;
    PreparedStatement preparedStatement = null;
    ResultSet resultSet = null;
    try {
      connection = DBCPUtils.getConnection();
      preparedStatement = connection.prepareStatement(&quot;select * from account&quot;);
      resultSet = preparedStatement.executeQuery();
      resultSet.next();
      String name = resultSet.getString(&quot;name&quot;);
      System.out.println(name);
    } catch (SQLException e) {
      e.printStackTrace();
    }finally {
      try {
          //就把connction 放回连接池并不是关闭
          connection.close();
          if(preparedStatement != null){
              preparedStatement.close();
          }
          if(resultSet != null){
              resultSet.close();
          }
      }catch (Exception e){
          e.printStackTrace();
      }
    }
  }
}
</code></pre><p>//代替之前的JdbcUtil工具类<br>DBCPUtils.java</p>
<pre><code>public class DBCPUtil {
  private static DataSource dataSource;
  static {
    BasicDataSourceFactory factory = new BasicDataSourceFactory();
    Properties properties = new Properties)();
    try{
      //以前读取配置文件是这样的：
      properties.load(new FileInputStream(&quot;dbcpconfig.properties&quot;));
      //现在可以这样
      InputStream resourceAsStream = DBCPUtil.class.getClassLoader().getResourceAsStream(&quot;dbcpconfig.properties&quot;);
      properties.load(resourceAsStream);
      //创建连接池
      dataSource = factory.createDataSource(properties);
    } catch (IOException e) {
      e.printStackTrace();
    } catch (Exception e) {
      e.printStackTrace();
    }
  }
  public static Connection getConnection() throws SQLException {
      //调用DBCP重写的dataSource子类的getConnection();
      return dataSource.getConnection();
  }
}
</code></pre><p><strong>注意事项：</strong><br>1.两种配置文件写法的不不同点</p>
<pre><code>第一种写法，相对路径默认是相对于整个项目的相对路径，需要自己去配置edit configuration。
第二种写法，相对路径相对于src文件。不需要自己在配置。可以直接读得到。这个文件最终会被IDEA带到out文件夹里面
</code></pre><h3 id="C3P0"><a href="#C3P0" class="headerlink" title="C3P0"></a>C3P0</h3><p>配置文件必须放到src目录下，且配置文件的名称必须为c3p0-config.xml</p>
<p>需要导入包：</p>
<pre><code>c3p0-0.9.1.2.jar
public class C3p0Test {
  public static void main(String[] args) {
    Connection connection = null;
    PreparedStatement preparedStatement = null;
    ResultSet resultSet = null;
    try {
        connection = C3p0Utils.getConnection();
        preparedStatement = connection.prepareStatement(&quot;select * from account&quot;);
        resultSet = preparedStatement.executeQuery();
        resultSet.next();
        String name = resultSet.getString(&quot;name&quot;);
        System.out.println(name);
    } catch (SQLException e) {
        e.printStackTrace();
    }finally {
        try {
            connection.close();
            if(preparedStatement != null){
                preparedStatement.close();
            }
            if(resultSet != null){
                resultSet.close();
            }
        }catch (Exception e){
            e.printStackTrace();
        }
    }
  }
}
</code></pre><p>//C3p0Utils</p>
<pre><code>public class C3p0Utils {
  private static ComboPooledDataSource dataSource;
  static {
    dataSource = new ComboPooledDataSource(&quot;dev&quot;);
  }
  public static Connection getConnection() throws SQLException {
      return dataSource.getConnection();
  }
}
</code></pre><p>//c3p0-config.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;c3p0-config&gt;
  &lt;default-config&gt;
    &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt;
    &lt;property name=&quot;password&quot;&gt;123456&lt;/property&gt;
    &lt;property name=&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt;
    &lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql://localhost:3306/bank?characterEncoding=utf8&lt;/property&gt;
    &lt;property name=&quot;checkoutTimeout&quot;&gt;30000&lt;/property&gt;
    &lt;property name=&quot;idleConnectionTestPeriod&quot;&gt;30&lt;/property&gt;
    &lt;property name=&quot;initialPoolSize&quot;&gt;10&lt;/property&gt;
    &lt;property name=&quot;maxIdleTime&quot;&gt;30&lt;/property&gt;
    &lt;property name=&quot;maxPoolSize&quot;&gt;100&lt;/property&gt;
    &lt;property name=&quot;minPoolSize&quot;&gt;10&lt;/property&gt;
    &lt;property name=&quot;maxStatements&quot;&gt;200&lt;/property&gt;
  &lt;/default-config&gt;

  &lt;named-config name=&quot;dev&quot;&gt;
    &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt;
    &lt;property name=&quot;password&quot;&gt;123456&lt;/property&gt;
    &lt;property name=&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt;
    &lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql://localhost:3306/bank?serverTimezone=GMT&lt;/property&gt;
    &lt;property name=&quot;checkoutTimeout&quot;&gt;30000&lt;/property&gt;
    &lt;property name=&quot;idleConnectionTestPeriod&quot;&gt;30&lt;/property&gt;
    &lt;property name=&quot;initialPoolSize&quot;&gt;10&lt;/property&gt;
    &lt;property name=&quot;maxIdleTime&quot;&gt;30&lt;/property&gt;
    &lt;property name=&quot;maxPoolSize&quot;&gt;100&lt;/property&gt;
    &lt;property name=&quot;minPoolSize&quot;&gt;10&lt;/property&gt;
    &lt;property name=&quot;maxStatements&quot;&gt;200&lt;/property&gt;
  &lt;/named-config&gt;

&lt;/c3p0-config&gt;
</code></pre><p>我们看到C3P0Util里面只有一两句话，这主要是因为他把需要用的参数都抽离出来成配置文件了。只需要时设置一下使用哪个标签</p>
<pre><code>默认是&lt;c3p0-config&gt;
dataSource = new ComboPooledDataSource(); //默认会调用标签：&lt;c3p0-config&gt;里的配置
dataSource = new ComboPooledDataSource(&quot;dev&quot;);//调用标签dev：&lt;named-config name=&quot;dev&quot;&gt;的配置
</code></pre><h3 id="Druid-德鲁伊"><a href="#Druid-德鲁伊" class="headerlink" title="Druid(德鲁伊)"></a>Druid(德鲁伊)</h3><p>导包：</p>
<pre><code>druid-1.1.10.jar
</code></pre><p>//测试</p>
<pre><code>public class DruidTest {
  public static void main(String[] args) {
    Connection connection = null;
    PreparedStatement preparedStatement = null;
    ResultSet resultSet = null;
    try {
      connection = DruidUtils.getConnection();
      preparedStatement = connection.prepareStatement(&quot;select * from account&quot;);
      resultSet = preparedStatement.executeQuery();
      resultSet.next();
      String name = resultSet.getString(&quot;name&quot;);
      System.out.println(name);
    } catch (SQLException e) {
        e.printStackTrace();
    } finally {
      try {
          connection.close();
          if(preparedStatement != null){
              preparedStatement.close();
          }
          if(resultSet != null){
              resultSet.close();
          }
      }catch (Exception e){
          e.printStackTrace();
      }
    }
  }
}
</code></pre><p>DruidUtil.java</p>
<pre><code>public class DruidUtil {
  private static DataSource dataSource;
  static {
    InputStream resourceAsStream = DruidUtils.clas.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);
    Properties properties = new Properties();
    try {
      properties.load(resourceAsStream);
      dataSorce = new DruidDataSourceFactory().createDataSource(properties);
    } catch (IOException e) {
      e.printStackTrace();
    } catch (Exception e) {
      e.printStackTrace();
    }
  }

  public static Connection getConnection() throws SQLException {
    return dataSource.getConnection();
  }
}
</code></pre><p><strong>小结</strong><br>三种connectionPool 第三种最常用，阿里自己的连接池，光平简单的操作。看不出来他们之间的差异，第一种和第三种感觉写法是很类似的。使用了工厂类来创建dataSource，第二种方法全部给你搞好了。只需要自己创建，连配置文件都给你弄好了。三种写法再总结一下创建连接池dataSource：<br>DBCP：</p>
<pre><code>private static DataSource dataSource;
dataSource = new BasicDataSourceFactory().createDataSource(properties);
</code></pre><p>C3P0</p>
<pre><code>private static ComboPooledDataSource dataSource;
dataSource = new ComboPooledDataSource(&quot;dev&quot;);
</code></pre><p>Druid<br>    private static DataSource dataSource;<br>    dataSorce = new DruidDataSourceFactory().createDataSource(properties);</p>
<h2 id="Dbutils"><a href="#Dbutils" class="headerlink" title="Dbutils"></a>Dbutils</h2><p>Commons DbUtils是Apache组织提供的一个对JDBC进行简单封装的开源工具类库，使用它能够简化JDBC应用程序的开发，同时也不会影响程序的性能。(百度百科)</p>
<p>DbUtils is a very small library of classes so it won’t take long to go through the javadocs for each class. The core classes/interfaces in DbUtils are <strong>QueryRunner</strong> and <strong>ResultSetHandler</strong>. You don’t need to know about any other DbUtils classes to benefit from using the library. The following example demonstrates how these classes are used together.（apache官方的介绍）</p>
<p>导包</p>
<pre><code>mysql-connector-java-5.1.17.jar (还是需要这个包的)
commons-dbutils-1.4.jar
</code></pre><h3 id="QueryRunner"><a href="#QueryRunner" class="headerlink" title="QueryRunner"></a>QueryRunner</h3><p>构造函数有带datasource和无参两种。<br>所有的API也都有带Connection参数和无Connection参数两种。<br>如果使用的是无Connection参数的API，则必须提供一个datasource，这样DBUtil才知道你用的是哪个connection</p>
<p>构造函数：</p>
<pre><code>QueryRunner()
          Constructor for QueryRunner.
QueryRunner(DataSource ds)
    Constructor for QueryRunner which takes a DataSource.
</code></pre><p>看例子</p>
<pre><code>public class QueryRunnerTest {
  public static void main(String[] args) {
    QueryRunner runner = new QueryRunner(DruidUtils.getDataSource());
    //如果构造函数使用的是带datasource的，则query方法用不带connection的
    try {
      Account account = (Account) runner.query(&quot;select * from account&quot;, new ResultSetHandler&lt;Object&gt;() {
        @Override
        public Object handle(ResultSet resultSet) throws SQLException {
          //应该怎么写呢？？？ ---&gt;这里应该是runner.query返回的对象
          //这是自己写的ResultSetHandler，但是这TM肯定是错误的用法
          resultSet.next();
          int id = resultSet.getInt(&quot;id&quot;);
          String name = resultSet.getString(&quot;name&quot;);
          double money = resultSet.getDouble(&quot;money&quot;);
          Account account = new Account();
          account.setUid(id);
          account.setName(name);
          account.setMoney(money);
          //这里面return的东西将作为整个query函数的返回值
          return account;
        }
      });
    } catch (SQLException e) {
      e.printStackTrace();
    }
  }
}
</code></pre><p>我们看到里面QueryRunner 有个方法query</p>
<pre><code>query(Connection conn, String sql, ResultSetHandler&lt;T&gt; rsh)
  Execute an SQL SELECT query without any replacement parameters.
</code></pre><p>ResultSetHandler是什么？</p>
<h3 id="ResultSetHandler"><a href="#ResultSetHandler" class="headerlink" title="ResultSetHandler"></a>ResultSetHandler</h3><p>Interface ResultSetHandler<t><br>Type Parameters:<br>    T - the target type the input ResultSet will be converted to.</t></p>
<p>All Known Implementing Classes:</p>
<pre><code>AbstractKeyedHandler, AbstractListHandler, ArrayHandler, ArrayListHandler, BeanHandler, BeanListHandler, ColumnListHandler, KeyedHandler, MapHandler, MapListHandler, ScalarHandler
</code></pre><p>方法：</p>
<pre><code>handle(ResultSet rs)
Turn the ResultSet into an Object.
</code></pre><p>上面那些已知的子类肯定是已经重写好ResultSet方法了，不需要我们再写了；直接用即可<br>例如</p>
<pre><code>QueryRunner qr = new QueryRunner(DruidUtil.getDataSource());给他一个dataSource就不用我们自己设置了
List&lt;Emp&gt; list = qr.query(sql,new BeanListHandler&lt;Emp&gt;(Emp.class));//获取得到查询的结果包装成bean集合，需要自己先创建一个bean类，然后他会自己去找对应的setXX方法，
</code></pre><p><strong>注意1</strong>这里的setXX()方法的XX 必须和数据库的字段一样，要不然找不到。可以和类里的成员变量不一样。但是必须和数据库的字段名一样<br>例如：(如果mysql保存的字段是id)</p>
<pre><code>emp.java
void setId(int cid){
  this.cid = cid; //成功，因为setXX和数据库中的一致
}
void setCid(int cid){
  this.cid = cid; //失败这就找不到
}
</code></pre><p><strong>注意2</strong><br>我们建议在创建 QueryRunner 时候还是给一个dataSource 给他构造，这样DButil会帮我们关掉connection 要不然要我们自己需要关，当使用事务的时候，我们就需要自己设置connection的setAutoCommit,commit,rollback等等，就需要我们自己去创建一个connection了</p>
<p>我们去QueryRunner源码看看就知道了：假设就看query方法：<br>//我们已经写了dataSorce不带connection写法：</p>
<pre><code>public &lt;T&gt; T query(String sql, ResultSetHandler&lt;T&gt; rsh) throws SQLException {
    Connection conn = this.prepareConnection(); //自动给我从dataSource里面取出连接
    return this.query(conn, true, sql, rsh, (Object[])null);
}
</code></pre><p>//没有写dataSorce自己写了一个getConnection()获得一个connection传进去</p>
<pre><code>public &lt;T&gt; T query(Connection conn, String sql, ResultSetHandler&lt;T&gt; rsh) throws SQLException {
    return this.query(conn, false, sql, rsh, (Object[])null);
}
</code></pre><p>我们发现最终调用了：</p>
<pre><code>private &lt;T&gt; T query(Connection conn, boolean closeConn, String sql, ResultSetHandler&lt;T&gt; rsh, Object... params) throws SQLException {
</code></pre><p>如果我们自己没有传connection,他会自己去找dataSorce里面拿一个connection,看prepareConnection()方法</p>
<pre><code>protected Connection prepareConnection() throws SQLException {
    if (this.getDataSource() == null) {
        throw new SQLException(&quot;QueryRunner requires a DataSource to be invoked in this way, or a Connection should be passed in&quot;);
    } else {
        return this.getDataSource().getConnection(); //他自己去用我们传的dataSorce里面去拿一个
    }
}
</code></pre><p>而query方法里这里有一个布尔值的参数： <strong>closeCon</strong>，这个标签就控制了是否会帮我们关闭connection连接,当我们没有传connection是true,当我们传connection时候是false;</p>
<p>一起来解析一下这个函数：</p>
<pre><code>private &lt;T&gt; T query(Connection conn, boolean closeConn, String sql, ResultSetHandler&lt;T&gt; rsh, Object... params) throws SQLException {
    //如果连接是conn
    if (conn == null) {
        throw new SQLException(&quot;Null connection&quot;);
        //如果sql语句是null
    } else if (sql == null) {
        if (closeConn) {
            this.close(conn);
        }
        throw new SQLException(&quot;Null SQL statement&quot;);
        //如果resultSetHandler是null就关闭
    } else if (rsh == null) {
        if (closeConn) {
            this.close(conn);
        }
        throw new SQLException(&quot;Null ResultSetHandler&quot;);

    //这里才开始判断
    } else {
        PreparedStatement stmt = null;
        ResultSet rs = null;
        Object result = null;
        try {
            stmt = this.prepareStatement(conn, sql);
            this.fillStatement(stmt, params);  //就是我们的setXX(index,value)那个方法
            rs = this.wrap(stmt.executeQuery()); //这一步啥也没干
            result = rsh.handle(rs);
        } catch (SQLException var33) {
            this.rethrow(var33, sql, params);
        } finally {
            try {
                //关闭resultSet
                this.close(rs);
            } finally {
                //关闭statement
                this.close(stmt);
                //如果设置了closeConn为true则把他放会到池子里
                if (closeConn) {
                    this.close(conn);
                }
            }
        }
        return result;
    }
}
</code></pre><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>//junit单元测试<br>//如何做到的?  反射调用某个方法<br>//rsh内部通过反射然后调用相应类的set方法，将数据库的相应字段的值赋给对应的成员变量<br>//javabena中的某个成员变量的名称可以不与表中的列名保持一致，但是相应的set方法一定要一致<br>在方法上面写：    @Test<br>就会运行这个方法，<br>但是要记得先导入java.junit.Test;例如测试一下ResultSetHandler的 子类beanListHandler就可以这样写：</p>
<pre><code>@Test
public void test1(){
    QueryRunner runner = new QueryRunner(DruidUtil.getDataSource());
    try {
        List&lt;Dept&gt; list = runner.query(&quot;select * from Dept where id &gt; ?&quot;, new BeanListHandler&lt;Dept&gt;(Dept.class),2);
        for (Dept Dept : list) {
            System.out.println(Dept);
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
}
</code></pre><p>后面几天都是在讲前端的东西，但是讲的不好，我自己总结了，但是很多东西都忘记。所以等我整理出来在发前端的知识吧</p>
<h2 id="星期三（8-7）"><a href="#星期三（8-7）" class="headerlink" title="星期三（8.7）"></a>星期三（8.7）</h2><h2 id="星期四（8-8）"><a href="#星期四（8-8）" class="headerlink" title="星期四（8.8）"></a>星期四（8.8）</h2><h2 id="星期五（8-9）"><a href="#星期五（8-9）" class="headerlink" title="星期五（8.9）"></a>星期五（8.9）</h2><h2 id="星期六（8-10）"><a href="#星期六（8-10）" class="headerlink" title="星期六（8.10）"></a>星期六（8.10）</h2><h3 id="本周小总结："><a href="#本周小总结：" class="headerlink" title="本周小总结："></a>本周小总结：</h3><p>1.关于批处理问题：报错</p>
<pre><code>java.sql.BatchUpdateException: No value specified for parameter 1
在使用prepareStatement.addBatch()；
在addBatch之前，最好setXX 对之前的sql语句进行修改，而不要空过，这样会报错不懂为啥
如果之前没有占位符，那就手动加一个占位符

例如：
    String s1 = &quot;insert into student () value ()&quot;;
    PreparedStatement preparedstatement = connection.preparedstatement(s1);
    preparestatement.addBatch();//这里可能报错

    String s1 = &quot;insert into student (id,math) value (null,?)&quot;;
    PreparedStatement preparedstatement = connection.preparedstatement(s1);
    preparedstatement.setDouble(1,100);
    preparestatement.addBatch();//这就不会报错了
</code></pre><p>2.debug窗口可以移动。有几个页面注意<br>watch 和 variable不一样 ，variable才是我们debug能看到的变量的参数</p>
<p>3.java.sql.SQLException: com.mysql.jdbc.Driver<br>今天讲的三个连接池，还有DBUtil必须还要添加mysql-connection<br>要不然还是会报错找不到driver</p>
<p>4.主键被删了好像不能再设置成主键？<br>报错<br>ALTER TABLE causes auto_increment resequencing, resulting in duplicate entry ‘1’ for key ‘PRIMARY’<br>设置主键字段为自动递增时报错：<br>解答：需要把数据中已存在主键值为0的记录，改成不为0且不重复的任意数字，而且要包装数字是自增的</p>
<p>5一些内容：</p>
<pre><code>SEO（Search Engine Optimization）
https://baike.baidu.com/item/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BC%98%E5%8C%96/3132?fromtitle=seo&amp;fromid=102990&amp;fr=aladdin

2.html——a标签与base标签
base已经淘汰了。就用a标签好了

3.Go语言
了解了一下

4.安排
把前端先过完一遍，再回顾之前写的东西

5。
一些技术栈：
quasarchs
http://www.quasarchs.com/guide/index.html
vue

6. HTML标准
https://html.spec.whatwg.org/multipage/

7 做作业忘记的标签，也就是还没复习到的标签
    1、input radio设置默认选中值 加checked
    2、label 能够点击能够跳转到对应的输入框
    &lt;form&gt;
      &lt;label for=&quot;male&quot;&gt;Male&lt;/label&gt;
      &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;male&quot; /&gt;
      &lt;br /&gt;
      &lt;label for=&quot;female&quot;&gt;Female&lt;/label&gt;
      &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;female&quot; /&gt;
    &lt;/form&gt;
    3、获取DOM getElementById()
    4、监听事件addEventListener() //注意要window.onload 之后才可以
    5、单选框radio 复选框checkbox
    6、下拉列表
    &lt;selection&gt;
      &lt;option value = &quot;1&quot;&gt;1&lt;/option&gt;
      &lt;option value = &quot;2&quot;&gt;2&lt;/option&gt;
      &lt;option value = &quot;3&quot;&gt;3&lt;/option&gt;
    &lt;/selection&gt;

8.前端技术栈：
vscode
</code></pre><p>6.关于反射：</p>
<pre><code>Constructor&lt;T&gt;getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)
Constructor&lt;?&gt;[] getDeclaredConstructors()
</code></pre><p>如果是getDeclaredConstructors（）获取Constructor数组不需要设置</p>
<pre><code>void setAccessible(boolean flag)
</code></pre><p>将此对象的 accessible 标志设置为指示的布尔值，为true，就可以拿到所有的自己Declared的构造函数。<br>那么可以立即推：我相信所有的getDeclaredFields()和getDeclaredMethods()也不需要设置，能拿到所有自己定义的；</p>
<p>7.其他<br>        2、&nbsp;表示英文空格， 两个英文空格是一个汉字长度</p>
<pre><code>3.误删IDEA的out中的字节码文件，把整个module都删了就能重新生成一个out的module文件夹

4flutter
谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。

5.select 选择触发事件 onchange

6.如何设置默认选项
  &lt;option  selected=&quot;selected&quot;&gt;&lt;/option&gt;
</code></pre><p>8.CSS3相关 动画布局<br>        1.背景颜色的透明度，设置RGBA<br>         background-color:rgba(255,45,81,0); color: #fff;</p>
<pre><code>2.动画属性
animation:animation_name 2s;
在下面再定义
@keyframes{
  0% {}
  100% {}
}

div.show{
  animation:myAnimation 0.5s;
  border-radius: 5px;
  background: #ff2d51;
  color: #fff;
}
@keyframes myAnimation {
  0%   { background-color:rgba(255,45,81,0); color: #fff; }
  100% { background-color:rgba(255,45,81,1); color: #fff;}
}

3.flex属性
container 和 里面的item
</code></pre><p><strong>我觉得这些东西一定要天天搞，熟能生巧</strong></p>
<p>9.margin塌陷问题<br>父元素使用：</p>
<pre><code>overflow ： hidden;
</code></pre><p><a href="https://www.cnblogs.com/syp172654682/p/7671830.html" target="_blank" rel="external">文章</a></p>
<p>10.css 如何让test-align : justify生效<br>不能是只有一行的，或者是最后一行<br>需要给他再加一行</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/08/04/Java总结（六）下/" rel="next" title="Java总结（六）下">
                <i class="fa fa-chevron-left"></i> Java总结（六）下
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/08/18/Java总结（八）/" rel="prev" title="Java总结（八）">
                Java总结（八） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Inhaltsverzeichnis
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Übersicht
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">王邸</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">Artikel</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">Tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#星期一（8-5）"><span class="nav-number">1.</span> <span class="nav-text">星期一（8.5）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JDBC批处理"><span class="nav-number">1.1.</span> <span class="nav-text">JDBC批处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用statement的批处理："><span class="nav-number">1.2.</span> <span class="nav-text">使用statement的批处理：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#prepareStatement批处理："><span class="nav-number">1.3.</span> <span class="nav-text">prepareStatement批处理：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事务"><span class="nav-number">2.</span> <span class="nav-text">事务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#事务的四个特性-ACID"><span class="nav-number">2.1.</span> <span class="nav-text">事务的四个特性(ACID)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事务的隔离性"><span class="nav-number">2.2.</span> <span class="nav-text">事务的隔离性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据库提供了四种不同级别的隔离等级："><span class="nav-number">2.3.</span> <span class="nav-text">数据库提供了四种不同级别的隔离等级：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDBC启用事务模式"><span class="nav-number">2.4.</span> <span class="nav-text">JDBC启用事务模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设置事务回滚点Connection-rollback"><span class="nav-number">2.5.</span> <span class="nav-text">设置事务回滚点Connection.rollback()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#星期二（8-6）"><span class="nav-number">3.</span> <span class="nav-text">星期二（8.6）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据库连接池"><span class="nav-number">3.1.</span> <span class="nav-text">数据库连接池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#初识连接池"><span class="nav-number">3.2.</span> <span class="nav-text">初识连接池</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重写连接池"><span class="nav-number">4.</span> <span class="nav-text">重写连接池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#第三方开源的数据库连接池"><span class="nav-number">4.1.</span> <span class="nav-text">第三方开源的数据库连接池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DBCP"><span class="nav-number">4.2.</span> <span class="nav-text">DBCP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C3P0"><span class="nav-number">4.3.</span> <span class="nav-text">C3P0</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Druid-德鲁伊"><span class="nav-number">4.4.</span> <span class="nav-text">Druid(德鲁伊)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dbutils"><span class="nav-number">5.</span> <span class="nav-text">Dbutils</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#QueryRunner"><span class="nav-number">5.1.</span> <span class="nav-text">QueryRunner</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ResultSetHandler"><span class="nav-number">5.2.</span> <span class="nav-text">ResultSetHandler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单元测试"><span class="nav-number">5.3.</span> <span class="nav-text">单元测试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#星期三（8-7）"><span class="nav-number">6.</span> <span class="nav-text">星期三（8.7）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#星期四（8-8）"><span class="nav-number">7.</span> <span class="nav-text">星期四（8.8）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#星期五（8-9）"><span class="nav-number">8.</span> <span class="nav-text">星期五（8.9）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#星期六（8-10）"><span class="nav-number">9.</span> <span class="nav-text">星期六（8.10）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#本周小总结："><span class="nav-number">9.1.</span> <span class="nav-text">本周小总结：</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王邸</span>

  
</div>


  <div class="powered-by">Erstellt mit  <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'Fn4BuvoixOxjJAhR79TvaD5M-gzGzoHsz',
        appKey: '1uspTrSwPqkmSBSUr948WqxE',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("Fn4BuvoixOxjJAhR79TvaD5M-gzGzoHsz", "1uspTrSwPqkmSBSUr948WqxE");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
