<!DOCTYPE html>
<html class="full-height">
<head>
  <meta charset="utf-8">
  <link rel="stylesheet" href="//cdn.bootcss.com/bulma/0.4.1/css/bulma.min.css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  
  <title>Java总结（六）下 | 路要坚持</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="接下来JAVAEE，一开始先学习mysql数据库的语言（sql）操作的语言四种（DDL,DML,DQL,DCL(没讲之后我补上),TPL），数据库主要进行的是查询Query一定要会，JDBC（JAVA DB CONNECTIVITY）三连(connection preparedstatement,resultset) 星期四(8.01)MYSQL学习总结指令的编写： 登录本机mysql: mysq">
<meta property="og:type" content="article">
<meta property="og:title" content="Java总结（六）下">
<meta property="og:url" content="http://yoursite.com/2019/08/04/Java总结（六）下/index.html">
<meta property="og:site_name" content="路要坚持">
<meta property="og:description" content="接下来JAVAEE，一开始先学习mysql数据库的语言（sql）操作的语言四种（DDL,DML,DQL,DCL(没讲之后我补上),TPL），数据库主要进行的是查询Query一定要会，JDBC（JAVA DB CONNECTIVITY）三连(connection preparedstatement,resultset) 星期四(8.01)MYSQL学习总结指令的编写： 登录本机mysql: mysq">
<meta property="og:updated_time" content="2019-08-17T04:04:13.833Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java总结（六）下">
<meta name="twitter:description" content="接下来JAVAEE，一开始先学习mysql数据库的语言（sql）操作的语言四种（DDL,DML,DQL,DCL(没讲之后我补上),TPL），数据库主要进行的是查询Query一定要会，JDBC（JAVA DB CONNECTIVITY）三连(connection preparedstatement,resultset) 星期四(8.01)MYSQL学习总结指令的编写： 登录本机mysql: mysq">
  
    <link rel="alternate" href="/" title="路要坚持" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/common.css">
<link rel="stylesheet" href="/css/nav.css">
<link rel="stylesheet" href="/css/layout.css">
  

</head>

<body>
  <header id="navbar" class="overflow-hidden">
  <div class="container">
    <nav class="nav">
         <div class="nav-left">
            <a href="/" class="nav-item" style="font-size: 20px;">
              <span class="logo">王邸</span>'s Blog
            </a>
         </div>
        <div class="nav-center is-hidden position-relative" id="search_container">
            <div class="nav-item full-width full-height">
                <i class="fa fa-search has-padding" aria-hidden="true"></i>
                <input type="text" id="search_input" class="search-input full-height full-width" placeholder="Search post" autofocus>
                <i id="close_search" class="fa fa-times" aria-hidden="true"></i>
            </div>
            <div id="search_result"></div>
        </div>
        <div class="nav-right nav-menu">
            <a class="nav-item" id="search">
                <i class="fa fa-search" aria-hidden="true"></i>
            </a>
            
            <a class="nav-item" href="/">
                Home
            </a>
            
            <a class="nav-item" href="/works">
                My Works
            </a>
            
            <a class="nav-item" href="/about">
                About
            </a>
            
        </div>
        <span class="nav-toggle" id="navMenuDropdown">
            <span></span>
            <span></span>
            <span></span>
        </span>
        <div class="navbar-menu position-absolute full-width content-box is-hidden-desktop is-flex flex-column center" style="top: 100%;">
            
            <a class="nav-item flex-1" href="/">
                Home
            </a>
            
            <a class="nav-item flex-1" href="/works">
                My Works
            </a>
            
            <a class="nav-item flex-1" href="/about">
                About
            </a>
            
        </div>
    </nav>
  </div>
</header>

  <div id="main-wrap" class="position-relative" style="margin-top: 55px;">
      <div class="main-inner-content">
          <!--博文页面-->

<style>
    .header-box {
        height: 370px;
        filter: blur(10px);
        background-size: cover;
        background-color: lightsteelblue;
    }

    .post-box {
        padding: 15px;
        padding-top: 60px;
        min-height: 80vh;
        margin-top: -200px;
        border-radius: 4px;
        background-color: rgba(255,255,255,.8);
    }

    .post-avatar {
        height: 30px;
        width: 30px;
        border-radius: 50%;
    }

    .flow-chart {
        text-align: center;
    }

    img[alt="post-cover"] {
        display: none;
    }
</style>
<header>
    <div id="header_box" class="header-box"></div>
</header>
<section>
    <div class="container post-box">
        <div class="content post-title is-flex center flex-column" style="margin-bottom: 70px; overflow: auto;">
            <h1 class="has-text-centered" style="padding-bottom: 10px; border-bottom: 3px solid #fff">
                <strong>Java总结（六）下</strong>
            </h1>
            
            <div class="is-flex align-center">
                <img class="post-avatar" src="https://q2.qlogo.cn/headimg_dl?bs=996057150&dst_uin=996057150&dst_uin=996057150&;dst_uin=996057150&spec=100&url_enc=0&referer=bu_interface&term_type=PC">
                <span style="padding:0 10px;"> <span class="sub-title">By</span> 王邸</span>
                <span class="post-date sub-title">at: 2019-08-04</span>
            </div>
            
                <div>
                    
                </div>
            
        </div>
        <div class="content" style="overflow: auto">
            <p>接下来JAVAEE，一开始先学习mysql数据库的语言（sql）操作的语言四种（DDL,DML,DQL,DCL(没讲之后我补上),TPL），数据库主要进行的是查询Query一定要会，JDBC（JAVA DB CONNECTIVITY）三连(connection preparedstatement,resultset)</p>
<h2 id="星期四-8-01"><a href="#星期四-8-01" class="headerlink" title="星期四(8.01)"></a>星期四(8.01)</h2><h2 id="MYSQL学习"><a href="#MYSQL学习" class="headerlink" title="MYSQL学习"></a>MYSQL学习</h2><p>总结指令的编写：</p>
<p>登录本机mysql:</p>
<pre><code>mysql -u 用户名 -p 输入密码。默认的root;
</code></pre><p>注意：请正确认识 “SQL 不区分大小写“</p>
<p>组成：</p>
<pre><code>DDL：数据定义语言
DML：数据操作语言
DQL： 数据查询语言
DCL： 数据控制语言
TPL： 事务处理语言
</code></pre><h2 id="DDL：Data-Definition-Language"><a href="#DDL：Data-Definition-Language" class="headerlink" title="DDL：Data Definition Language"></a>DDL：Data Definition Language</h2><p>作用：创建 &amp; 管理 数据库和表 的结构。<br>常用关键字：</p>
<pre><code>CREATE  SHOW  ALTER   DROP
</code></pre><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="创建数据库-create"><a href="#创建数据库-create" class="headerlink" title="创建数据库(create)"></a>创建数据库(create)</h3><p>1.默认方式创造数据库</p>
<pre><code>CREATE database db_name;
</code></pre><p>2.创建有参数的数据库</p>
<pre><code>CREATE database db_name CHARACTER SET UTF8 COLLEATE UTF8_GENERAL_CI;
</code></pre><p>create_specification:</p>
<pre><code>[DEFAULT] CHARACTER SET charset_name | [DEFAULT] COLLATE collation_name
</code></pre><p>collection_name;<br>utf8_general_ci（不区分大小写）, utf8_bin（区分大小写）</p>
<h3 id="查看数据库-show-："><a href="#查看数据库-show-：" class="headerlink" title="查看数据库(show)："></a>查看数据库(show)：</h3><p>1.显示数据库的语句</p>
<pre><code>SHOW databases;
</code></pre><p>2.显示数据库创建语句</p>
<pre><code>SHOW CREATE DATABASE db_name;
</code></pre><h3 id="删除数据库-DROP"><a href="#删除数据库-DROP" class="headerlink" title="删除数据库(DROP)"></a>删除数据库(DROP)</h3><pre><code>DROP DATABASE db_name;
</code></pre><h3 id="修改数据库（ALTER）"><a href="#修改数据库（ALTER）" class="headerlink" title="修改数据库（ALTER）"></a>修改数据库（ALTER）</h3><p>1.修改数据库名字<br>很遗憾地告诉你，官方并没有提供直接修改数据库名称的命令。但网上有提供各种修改数据库名称的脚本，感兴趣的同学可以自己去研究~~~</p>
<p>2.修改数据库创建的参数；</p>
<pre><code>ALTER  DATABASE   db_name   
[alter_specification [, alter_specification] ...]
</code></pre><h3 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h3><pre><code>USE db_name;
</code></pre><h2 id="表"><a href="#表" class="headerlink" title="表"></a>表</h2><h3 id="创建表-create"><a href="#创建表-create" class="headerlink" title="创建表(create)"></a>创建表(create)</h3><pre><code>CREATE TABLE table_name
(
  field1  datatype,
  field2  datatype,
  field3  datatype
)[CHARACTER SET 字符集 COLLATE 校对规则]
field：指定列名　datatype：指定列类型
</code></pre><p>问题：表名是否可以和数据库名字相同？<br>可以创建和数据库名字相同的表名；</p>
<h4 id="datatype（创建表参数）"><a href="#datatype（创建表参数）" class="headerlink" title="datatype（创建表参数）:"></a>datatype（创建表参数）:</h4><p><strong>注意：这里以MySQL为例，不同的DBMS的都支持数值类型，字符串类型以及日期类型，但他们的实现可能不一样。</strong></p>
<p>整数类型<br>数据类型|占用字节|说明<br>-:|:-:|:-<br>TINYINT   |1| 很小的整数<br>SMALLINT  |2| 小的整数<br>MEDIUMINT |3| 中等大小的整数<br>INT       |4| 普通大小的整数<br>BIGINT    |8| 大整数</p>
<p>浮点数类型和定点数类型<br>类型名称|占用字节|说明<br>-:|:-:|:-<br>FLOAT(M,D)    |4   |单精度浮点数<br>DOUBLE(M,D)   |8   |双精度浮点数<br>DECIMAL(M,D)  |M+2 |定点数<br>其中</p>
<pre><code>M 称为精度，表示总共的位数;
D 称为标度，表示小数的位数。
DECIMAL 类型不同于 FLOAT &amp; DOUBLE，DECIMAL 实际是以字符串存放的，它的存储空间并不固定，而是由精度 M 决定的。
</code></pre><p>例如：</p>
<pre><code>CREATE TABLE float_data(float1 FLOAT(5,3),double1 DOUBLE(5,3),decimal1 decimal(5,3));
</code></pre><p><strong><em>这三个有什么区别？</em></strong><br>（回答）<br>1.默认不设置MD,FLOAT显示6位，DOUBLE全部 显示。DECIMAL 只显示整数部分。他们小数部分都四舍五入；</p>
<p>日期与时间类型<br>类型名称   日期格式                占用字节<br>-:|:-:|:-<br>YEAR      |YYYY       (2018)       |1<br>TIME      |HH:MM:SS   (10:20:00)   |3<br>DATE      |YYYY-MM-DD (2018-7-23)  |3<br>DATETIME  |YYYY-MM-DD HH:MM:SS     |8<br>TIMESTAMP |YYYY-MM-DD HH:MM:SS     |4</p>
<p>DATETIME 和 TIMESTAMP 虽然显示的格式是一样的，但是它们有很大的区别：</p>
<pre><code>1.DATETIME 的系统默认值是 NULL, 而 TIMESTAMP 的系统默认值是 当前时间 NOW();
2.DATETIME 存储的时间与时区无关，而 TIMESTAMP 与时区有关
</code></pre><p>例子：</p>
<pre><code>CREATE table time1(t4 datetime, t5 timestamp);
INSERT INTO time1 values (now(),now());

INSERT INTO time1 values（）; //datetime默认值是null

set time_zone = &apos;+10:00&apos;;
//里面的timestamp会动态的更改成+10时区的时间，而datetime不变
</code></pre><p>字符串类型</p>
<table>
<thead>
<tr>
<th style="text-align:right">类型名称</th>
<th style="text-align:center">占用字节</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right"></td>
</tr>
</tbody>
</table>
<p>CHAR(M)      |M, 1 &lt;= M &lt;= 255         |固定长度字符串<br>VARCHAR(M)   |L+1, L &lt;=M, 1 &lt;=M &lt;=255  |变长字符串<br>TINYTEXT     |L+1, L &lt; 2^8             |非常小的文本字符串<br>TEXT         |L+2, L &lt; 2^16            |小的文本字符串<br>MEDIUMTEXT   |L+3, L &lt; 2^24            |中等大小的文本字符串<br>LONGTEXT     |L+4, L &lt; 2^32            |大的文本字符串<br>ENUM         |1 或者 2个字节，          |取决于枚举的数目，最大 65535个  枚举类型<br>SET          |1,2,3,4或8个字节          |集合类型</p>
<p>ENUM 类型总有一个默认值，当ENUM 列声明为NULL，则默认值为NULL。如果 ENUM 列被声明为 NOT NULL，<br>则其默认值为列表的第一个元素。</p>
<p>ENUM 和 SET有什么区别</p>
<pre><code>CREATE TABLE enum_set(enum1 ENUM(&apos;1&apos;,&apos;2&apos;,&apos;3&apos;), set1 SET(&apos;1&apos;,&apos;2&apos;,&apos;3&apos;));
mysql&gt; insert into enum_set values(&apos;1&apos;,&apos;1,2,3&apos;);      //这样就能成功
mysql&gt; insert into enum_set values(&apos;1，2&apos;,&apos;1,2,3&apos;);   //这样就会失败
</code></pre><p>ENUM 设置多个备选项，但是只能选择一个<br>SET  设置多个备选项，也可以选择多个，但是不能选择声明外的<br>注意在插入时候两个写的格式是： ‘ ， ，’;而不是单独括号括起来<br>    mysql&gt; insert into enum_set values((‘1’),(‘1,2,3’));      //这是错误示范，没有括号，直接写引号；</p>
<h3 id="查询表-desc"><a href="#查询表-desc" class="headerlink" title="查询表(desc)"></a>查询表(desc)</h3><p>简单描述表结构</p>
<pre><code>DESC 表名
DESCRIBE 表名
</code></pre><p>查看生成数据定义语言的语句</p>
<pre><code>show create table table_name;
</code></pre><p>打印之后看到如下的属性页面，我之后会一个一个解释<br>Field|Type    | Null | Key | Default | Extra<br>id   | int(11)| YES  |     | NULL    |</p>
<pre><code>Field:属性名字
type:数据类型
Null:应该是是否可以为null
key:比如主键、外键。这个是用来建立索引的。
Default:默认约束。输入数据时，如果不指定该列的值，那么就使用默认约束规定的值。
Extra:对字段额外的说明
</code></pre><h3 id="修改表-ALTER"><a href="#修改表-ALTER" class="headerlink" title="修改表(ALTER)"></a>修改表(ALTER)</h3><h3 id="ALTER-TABLE-table-name-ADD-增加一列"><a href="#ALTER-TABLE-table-name-ADD-增加一列" class="headerlink" title="ALTER TABLE table_name ADD //增加一列"></a>ALTER TABLE table_name ADD //增加一列</h3><pre><code>ALTER TABLE table_name
ADD      (column datatype [DEFAULT expr]
       [,ADD column datatype]...);
</code></pre><h3 id="ALTER-TABLE-table-name-CHANGE-改变一列的name和datatype"><a href="#ALTER-TABLE-table-name-CHANGE-改变一列的name和datatype" class="headerlink" title="ALTER TABLE table_name CHANGE  改变一列的name和datatype"></a>ALTER TABLE table_name CHANGE  改变一列的name和datatype</h3><pre><code>ALTER TABLE table_name
change     col_name new_col_name datatype [DEFAULT expr]
[,change col_name new_col_name datatype [DEFAULT ...] ]...;
</code></pre><h3 id="ALTER-TABLE-table-name-MODIFY-改变一列的datatype"><a href="#ALTER-TABLE-table-name-MODIFY-改变一列的datatype" class="headerlink" title="ALTER TABLE table_name MODIFY  改变一列的datatype"></a>ALTER TABLE table_name MODIFY  改变一列的datatype</h3><pre><code>ALTER TABLE table_name
MODIFY column datatype [DEFAULT expr]
       [,MODIFY column datatype]...;
</code></pre><h3 id="ALTER-TABLE-table-name-DROP-删除一列"><a href="#ALTER-TABLE-table-name-DROP-删除一列" class="headerlink" title="ALTER TABLE table_name DROP; 删除一列"></a>ALTER TABLE table_name DROP; 删除一列</h3><pre><code>ALTER TABLE table_name
DROP        (column);
</code></pre><h3 id="RENAME-TABLE-table-name-to-new-name-修改表名"><a href="#RENAME-TABLE-table-name-to-new-name-修改表名" class="headerlink" title="RENAME TABLE table_name to new_name 修改表名"></a>RENAME TABLE table_name to new_name 修改表名</h3><p>修改表的名称：RENAME TABLE 表名 TO 新表名</p>
<p>RENAME TABLE 语句的另一个用法是移动该表到另一个数据库<br>语法为：<br>RENAME TABLE 旧数据库名.旧表名 TO 新数据库名.新表名<br>提示：我们可以把 RENAME TABLE 的这两种用法很好地统一起来，如果我们把 “重命名” 理解为 “在同一数据库里的移动”。甚至我们可以省略数据库名，如果你恰好正在使用该数据库。<br>这个就好像Field的重命名一样，也有剪切的效果</p>
<pre><code>File的方法：
boolean renameTo(File dest)
重新命名此抽象路径名表示的文件。
</code></pre><p><strong>注意事项：</strong>只有添加的方法ADD 需要加（） 因为可以增加多个列，要设置括号。<br>其他都是</p>
<pre><code>ALTER TABLE table_name 操作；
</code></pre><h3 id="修改字符集"><a href="#修改字符集" class="headerlink" title="修改字符集"></a>修改字符集</h3><p>修改表的字符集：alter table student character set utf8;<br><strong>注意</strong>这应该要把数据库的字符集也要改了吧 要不然肯定还是不行的；</p>
<h3 id="删除表-DROP"><a href="#删除表-DROP" class="headerlink" title="删除表(DROP)"></a>删除表(DROP)</h3><pre><code>DROP TABLE table_name;
</code></pre><h2 id="DML数据操纵语言结合DQL"><a href="#DML数据操纵语言结合DQL" class="headerlink" title="DML数据操纵语言结合DQL"></a>DML数据操纵语言结合DQL</h2><p>DML:Data Manipulation Language<br>作用：用于向数据库表中插入、删除、修改数据。<br>常用关键字：<br>INSERT UPDATE DELETE</p>
<h3 id="插入（INSERT）"><a href="#插入（INSERT）" class="headerlink" title="插入（INSERT）"></a>插入（INSERT）</h3><pre><code>INSERT INTO table_name [(column [, column...])]
VALUES    (value [, value...]);
</code></pre><p>插入的数据应与字段的数据类型相同。<br>数据的大小应在列的规定范围内，例如：不能将一个长度为80的字符串加入到长度为40的列中。<br>在values中列出的数据 。<br><strong>字符串和日期型数据应包含在单引号中。</strong><br>插入空值 insert into table value(null)  //注意之前设置table时候有可以设置是否可以为null;默认是yes;</p>
<h3 id="更新（UPDATE）"><a href="#更新（UPDATE）" class="headerlink" title="更新（UPDATE）"></a>更新（UPDATE）</h3><p>使用 update语句修改表中数据。</p>
<pre><code>UPDATE  table_name   
  SET col_name1 = expr1 [, col_name2=expr2 ...]    
  [WHERE where_definition]   
</code></pre><p><strong>注意事项</strong></p>
<ol>
<li>UPDATE语法可以用新值更新原有表行中的各列。</li>
<li>SET子句指示要修改哪些列和要给予哪些值。</li>
<li>WHERE子句指定应更新哪些行。如没有WHERE子句，则更新所有的行。<br><strong>4. NULL+任何数的结果都是NULL 这里并不会报错</strong></li>
</ol>
<h3 id="删除（DELETE）"><a href="#删除（DELETE）" class="headerlink" title="删除（DELETE）"></a>删除（DELETE）</h3><p>使用 delete语句删除表中数据。</p>
<pre><code>DELETE  from  table_name       
  [WHERE where_definition]   
</code></pre><p>如果不使用where子句，将删除表中所有数据。<br>Delete语句不能删除某一列的值，可使用update把一列的值都改了。或者直接 ALTER TABLE table_name drop colname;删除一列<br>delete删除的单位是行<br>使用delete语句仅删除记录，不删除表本身。如要删除表，使用drop  table语句。<br><strong>同insert和update一样，从一个表中删除记录将引起其它表的参照完整性问题，在修改数据库数据时，头脑中应该始终不要忘记这个潜在的问题。</strong></p>
<h2 id="DQL数据查询语言（简单查询）"><a href="#DQL数据查询语言（简单查询）" class="headerlink" title="DQL数据查询语言（简单查询）"></a>DQL数据查询语言（简单查询）</h2><p>DQL：Data Query Language<br>作用：查询表中的数据。<br>关键字：<br>    SELECT</p>
<h3 id="查询-SELECT"><a href="#查询-SELECT" class="headerlink" title="查询(SELECT)"></a>查询(SELECT)</h3><pre><code>SELECT column_name1 From table_name;
SELECT column_name1,column_name2 From table_name;
SELECT * From table_name;
</code></pre><h3 id="使用-WHERE-子句过滤记录"><a href="#使用-WHERE-子句过滤记录" class="headerlink" title="使用 WHERE 子句过滤记录"></a>使用 WHERE 子句过滤记录</h3><pre><code>SELECT * | {column_names}
FROM table_name
WHERE &lt;filter_condition&gt;;
</code></pre><p>filter_condition 是一个逻辑表达式，即表达式的结果是布尔类型</p>
<h3 id="常见运算符介绍"><a href="#常见运算符介绍" class="headerlink" title="常见运算符介绍"></a>常见运算符介绍</h3><p>算术运算符</p>
<pre><code>+    -    *    /     %
</code></pre><table>
<thead>
<tr>
<th style="text-align:right">运算符</th>
<th style="text-align:center">作用</th>
<th style="text-align:center">运算符</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right"></td>
</tr>
</tbody>
</table>
<p>=           |等于           |&lt;=&gt;         | 安全的等于<br>&lt;&gt; (!=)     |不等于         |&lt;=          |  小于等于</p>
<blockquote>
<p>=          |大于等于       | &gt;          |  大于<br>IS NULL     |是否为NULL     |IS NOT NULL |  是否不为NULL<br>BETWEEN AND |是否在闭区间内  |IN          | 是否在列表内<br>NOT IN      |是否不在列表内  |LIKE        | 通配符匹配</p>
</blockquote>
<p>逻辑运算符<br>      NOT(!)       AND(&amp;&amp;)      OR(||)<br>位操作运算符<br>      &amp;     |     ~     ^     &lt;&lt;     &gt;&gt;</p>
<h3 id="lt-gt"><a href="#lt-gt" class="headerlink" title="&lt;=&gt;"></a>&lt;=&gt;</h3><p>可以找到值为null的数据<br>= 找不到值为null的数据</p>
<h3 id="LIKE"><a href="#LIKE" class="headerlink" title="LIKE"></a>LIKE</h3><p>模糊匹配</p>
<pre><code>select * from student where NAME LIKE &apos;陆%&apos;;
</code></pre><p>通配符规则：</p>
<pre><code>‘%’ 匹配任何数目的字符，甚至包括零字符
‘_’ 只能匹配一个字符
</code></pre><h3 id="DISTINCT-过滤相同的记录"><a href="#DISTINCT-过滤相同的记录" class="headerlink" title="DISTINCT 过滤相同的记录"></a>DISTINCT 过滤相同的记录</h3><pre><code>SELECT DISTINCT {column_names}
FROM table_name;
</code></pre><h3 id="LIMIT-限制结果"><a href="#LIMIT-限制结果" class="headerlink" title="LIMIT 限制结果"></a>LIMIT 限制结果</h3><p>SELECT 语句返回所有匹配的记录。但是如果我们只想返回第一行或者一定数量的行，这该怎么办呢？<br>在 MySQL 中，我们可以用 LIMIT 关键字实现这一要求。</p>
<pre><code>SELECT * FROM file_name LIMIT offset, nums;     -- LIMIT 3, 4;
--OR
SELECT * FROM file_name LIMIT nums OFFSET offset;（建议第二种）
</code></pre><p>注意：offset是指偏移量，当我们从第1行查起，偏移量自然为0。此时，可以写成 LIMIT nums;<br>扩展：我们可以使用 LIMIT 关键字实现分页查询。 LIMIT (page_num – 1) * page_size, page_size;</p>
<h3 id="ORDER-BY-排序"><a href="#ORDER-BY-排序" class="headerlink" title="ORDER BY 排序"></a>ORDER BY 排序</h3><p>我们可以使用 ORDER BY 子句对查询结果进行排序。</p>
<pre><code>select * from file_name order by column_name asc); //升序asc 降序desc
</code></pre><p>默认是升序asc</p>
<p><strong>注意事项</strong> ORDER BY 和LIMIT 同时存在的时候，ORDER BY 要写在 LIMIT前面;我发现的；</p>
<pre><code>SELECT * FROM EMPLOYEE ORDER BY math LIMIT 3 OFFSET 1;
</code></pre><p>功能全部加上</p>
<pre><code>SELECT DISTINCT {column_name} from file_name ORDER BY math LIMIT num OFFSET offset;
</code></pre><h2 id="星期五-8-02"><a href="#星期五-8-02" class="headerlink" title="星期五(8.02)"></a>星期五(8.02)</h2><p>MYSQL的控制：<br><a href="http://makaidong.com/linguoguo/148551_1704957.html" target="_blank" rel="external">链接</a></p>
<p>2.ppt设置的超链接的文档打不开<br>把pptx的格式设置成ppt格式就可以了；<br>原理我也不知道- -</p>
<h2 id="今日学习总结"><a href="#今日学习总结" class="headerlink" title="今日学习总结"></a>今日学习总结</h2><p>昨天学习到order by 今天我们继续；</p>
<h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>当然，我们可以给 Chinese + math + english 起一个更简单直接一点的名字。AS 关键字就可以做到这一点。</p>
<pre><code>SELECT name, chinese + math + english AS total FROM t_students;
</code></pre><p>注意：在很多DBMS中，AS关键字是可选的，不过最好使用它，这被视为一条最佳实践。<br>提示：AS 关键字不仅能给列起别名，还可以给表起别名。在多表查询中，我们会这样使用它。</p>
<h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p>位置：在select后面</p>
<p>COUNT()</p>
<p>COUNT(*) 计算表中的总行数;<br>COUNT(column_name) 计算指定列下的总行数，<br>计算时将忽略值为NULL的行。<br>这里计算的是总的行数，下面计算的是一列的总和。</p>
<p>SUM():返回指定<strong>列</strong>的所有值之和<br>    计算时将忽略值为NULL的行;<br>AVG():返回指定<strong>列</strong>的平均值<br>    计算时将忽略值为NULL的行;<br><strong>注意事项</strong>： AVG()求平均值的个数，并不是里面数据的条数，而是有值非null的个数，当我插入一个math为null的数据。求出平均值和之前的相同</p>
<p>MAX():返回指定<strong>列</strong>的最大值<br>    计算时将忽略值为NULL的行;<br>MIN():返回指定<strong>列</strong>的最小值<br>    计算时将忽略值为NULL的行;</p>
<p>查询全班平均成绩</p>
<pre><code>select avg(math) as &apos;数学&apos;, avg(chinese) as &apos;中文 &apos;,avg(english) as &apos;英语&apos; from t_students;
</code></pre><h3 id="分组查询GROUP-BY"><a href="#分组查询GROUP-BY" class="headerlink" title="分组查询GROUP BY"></a>分组查询GROUP BY</h3><p>比如：我们想统计各班学生的人数，该怎么办？这时候我们就得用到分组的概念。在 SQL 中，我们使用 GROUP BY 关键字对数据进行分组。<br>位置：加在from table_name的后面</p>
<pre><code>[GROUP BY {column_names}] [HAVING &lt;filter_condition&gt;]
使用 HAVING 过滤分组
</code></pre><h3 id="having-and-where"><a href="#having-and-where" class="headerlink" title="having and where"></a>having and where</h3><pre><code>Where语句在分组之前，执行完where语句再去对数据进行分组
Having语句在分组之后，执行完分组之后，再对分组数据进行一个过滤筛选。


select class,name from t_students group by class;
</code></pre><p>例子：获取每个班的人数，并且找出人数大于2的班级</p>
<pre><code>select count(id) as &apos;人数&apos; ,class ,group_concat(id) from t_students group by class having 人数 &gt; 2;
+------+-------+------------------+
| 人数 | class | group_concat(id) |
+------+-------+------------------+
|    3 | 一班  | 1,6,7            |
</code></pre><p>GROUP BY 关键字后可以接多个列名，其意思是从左到右，按层次分组。即先按第一个字段分组，然后在第一个字段值相同的记录中，再根据第2个字段的值进行分组…<strong>（多个字段看成一个整体）</strong></p>
<p>分组和排序<br>我们经常发现，用 GROUP BY 分组的数据确实是以分组顺序输出的。此外，即使特定的 DBMS 总是按给出的 GROUP BY 子句排序数据，用户也可能会要求以不同的顺序排序。应该提供明确的 ORDER BY 子句，即使其效果等同于GROUP BY子句。<br>例如：统计每个班多少人，然后按班级人数升序排列(默认升序排列)：</p>
<pre><code>SELECT COUNT(id) AS &apos;人数&apos; , class , group_concat(id) from t_students group by class order by 人数 asc;
</code></pre><h3 id="SELECT语句执行顺序"><a href="#SELECT语句执行顺序" class="headerlink" title="SELECT语句执行顺序"></a>SELECT语句执行顺序</h3><p>顺序表示写法 括号的序号，表示指令执行的顺序；</p>
<p><em>(5)</em> SELECT column_name, 聚合函数…<br><em>(1)</em> FROM table_name, …<br><em>(2)</em> [WHERE …]<br><em>(3)</em> [GROUP BY …]<br><em>(4)</em> [HAVING …]<br><em>(6)</em> [ORDER BY …];<br><em>(7)</em> [LIMIT nums OFFSET offset …];//分页是最后的</p>
<h3 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h3><p>数据完整性是为了保证插入到数据库中的数据是正确的，它防止了用户可能的输入错误。<br>数据完整性主要分为以下三类：</p>
<p>实体完整性 （唯一性）</p>
<pre><code>规定表的一行（即每一条记录）在表中是唯一的实体。实体完整性通过表的主键来实现。
</code></pre><p>域完整性：</p>
<pre><code>指数据库表的列（即字段）必须符合某种特定的数据类型或约束。比如NOT NULL。
</code></pre><p>参照完整性：</p>
<pre><code>保证一个表的外键和另一个表的主键对应。
</code></pre><h3 id="数据主键：表中经常有一个列或列的组合，其值能唯一地标识表中的每一行。这样的一列或多列称为表的主键，通过它可强制表的实体完整性。当创建或更改表时可通过定义PRIMARY-KEY-约束来创建主键。一个表只能有一个-PRIMARY-KEY-约束，而且-PRIMARY-KEY-约束中的列不能接受空值。由于-PRIMARY-KEY-约束确保唯一数据，所以经常用来定义标识列。-作用"><a href="#数据主键：表中经常有一个列或列的组合，其值能唯一地标识表中的每一行。这样的一列或多列称为表的主键，通过它可强制表的实体完整性。当创建或更改表时可通过定义PRIMARY-KEY-约束来创建主键。一个表只能有一个-PRIMARY-KEY-约束，而且-PRIMARY-KEY-约束中的列不能接受空值。由于-PRIMARY-KEY-约束确保唯一数据，所以经常用来定义标识列。-作用" class="headerlink" title="数据主键：表中经常有一个列或列的组合，其值能唯一地标识表中的每一行。这样的一列或多列称为表的主键，通过它可强制表的实体完整性。当创建或更改表时可通过定义PRIMARY KEY 约束来创建主键。一个表只能有一个 PRIMARY KEY 约束，而且 PRIMARY KEY 约束中的列不能接受空值。由于 PRIMARY KEY 约束确保唯一数据，所以经常用来定义标识列。 作用 :"></a>数据主键：表中经常有一个列或列的组合，其值能唯一地标识表中的每一行。这样的一列或多列称为表的主键，通过它可强制表的实体完整性。当创建或更改表时可通过定义<strong>PRIMARY KEY</strong> 约束来创建主键。一个表只能有一个 PRIMARY KEY 约束，而且 PRIMARY KEY 约束中的列不能接受空值。由于 PRIMARY KEY 约束确保唯一数据，所以经常用来定义标识列。 作用 :</h3><pre><code>1）保证实体的完整性;
2）加快数据库的操作速度
3） 在表中添加新记录时，会自动检查新记录的主键值，不允许该值与其他记录的主键值重复。
4) 自动按主键值的顺序显示表中的记录。如果没有定义主键，则按输入记录的顺序显示表中的记录。
</code></pre><h3 id="新建表的时候创建（CREATE）"><a href="#新建表的时候创建（CREATE）" class="headerlink" title="新建表的时候创建（CREATE）"></a>新建表的时候创建（CREATE）</h3><pre><code>create table people(
  id int primary key auto_increment, //auto_increment默认自增
  name varchar(30)
)
</code></pre><h3 id="修改表创建主键-ALTER"><a href="#修改表创建主键-ALTER" class="headerlink" title="修改表创建主键(ALTER)"></a>修改表创建主键(ALTER)</h3><pre><code>ALTER TABLE table_name modify id int primary key auto_increment;
</code></pre><h3 id="主键的删除"><a href="#主键的删除" class="headerlink" title="主键的删除"></a>主键的删除</h3><p><strong>注意事项</strong> 主键要删除，必须先删除自增</p>
<pre><code>ALTER TABLE table_name modify id int; //删除自增
ALTER TABLE table_name drop primary key; //丢弃主键
</code></pre><h3 id="主键的注意事项"><a href="#主键的注意事项" class="headerlink" title="主键的注意事项"></a>主键的注意事项</h3><p>1.主键默认自增，而且你修改id大于当前自增最大值，默认会把id自增的指针为现在最大值。<br>2.如果当前删除一个元素id = 9, 下次添加元素id = 10,id并不等于9。表中会默认记录曾经最大的id的值，<strong>但是id = 9的地方依旧可以插入</strong>，如果不设置id的值，默认还是最高指针的下一个地方。</p>
<h3 id="唯一约束（UNIQUE）"><a href="#唯一约束（UNIQUE）" class="headerlink" title="唯一约束（UNIQUE）"></a>唯一约束（UNIQUE）</h3><p>可以添加多个null值</p>
<h3 id="unique的新建表的时候创建"><a href="#unique的新建表的时候创建" class="headerlink" title="unique的新建表的时候创建"></a>unique的新建表的时候创建</h3><pre><code>CREATE TABLE table_name(
  email varchar(50) unique;
)
</code></pre><h3 id="unique修改表创建-ALTER"><a href="#unique修改表创建-ALTER" class="headerlink" title="unique修改表创建(ALTER)"></a>unique修改表创建(ALTER)</h3><pre><code>ALTER TABLE table_name modify email varchar(50) unique;
</code></pre><h3 id="unique的删除"><a href="#unique的删除" class="headerlink" title="unique的删除"></a>unique的删除</h3><pre><code>ALTER TABLT table_name drop index email;
</code></pre><p><strong>注意</strong> 这就表明了 unique是通过index来确认是否是唯一的。</p>
<h3 id="非空约束（not-null）"><a href="#非空约束（not-null）" class="headerlink" title="非空约束（not null）"></a>非空约束（not null）</h3><h3 id="非空的新建表的时候创建"><a href="#非空的新建表的时候创建" class="headerlink" title="非空的新建表的时候创建"></a>非空的新建表的时候创建</h3><pre><code>CREATE TABLE table_name(
  email varchar(50) not null;
)
</code></pre><h3 id="非空的修改表创建-ALTER"><a href="#非空的修改表创建-ALTER" class="headerlink" title="非空的修改表创建(ALTER)"></a>非空的修改表创建(ALTER)</h3><pre><code>ALTER TABLE table_name modify email varchar(50) not null;
</code></pre><h3 id="非空的删除"><a href="#非空的删除" class="headerlink" title="非空的删除"></a>非空的删除</h3><pre><code>ALTER TABLE table_name modify email varchar(50);
</code></pre><h3 id="外键约束（constrain）-重点"><a href="#外键约束（constrain）-重点" class="headerlink" title="外键约束（constrain）!!重点"></a>外键约束（constrain）!!重点</h3><p>比如有两张表，一张学生选课表，另外一张课程表，学生选择的课程必须是课程表中出现的课程，这个时候可以用外键来约束。如果不是课程表内的课程，则无法插入。</p>
<h3 id="外键的新建表的时候创建"><a href="#外键的新建表的时候创建" class="headerlink" title="外键的新建表的时候创建"></a>外键的新建表的时候创建</h3><pre><code>create table course(
  id int primary key auto_increment,
  cname varchar(30),
)

create table students(
  id int primary key auto_increment;
  cid int,
  constraint student_course_FK foreign key (cid) references course (id)
)
</code></pre><h3 id="外键的修改表创建-ALTER"><a href="#外键的修改表创建-ALTER" class="headerlink" title="外键的修改表创建(ALTER)"></a>外键的修改表创建(ALTER)</h3><pre><code>ALTER TABLE table_name add(constraint student_course_FK foreign key (cid) references course id);
</code></pre><h3 id="外键的删除"><a href="#外键的删除" class="headerlink" title="外键的删除"></a>外键的删除</h3><p><strong>删除外键的时候，需要用到新建外键时取的名称。</strong></p>
<pre><code>ALTER TABLE table_name drop foreign key student_course_FK;
</code></pre><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><pre><code>SELECT * FROM t_students;  -- This is a annotation
SELECT * FROM t_students;  # This is a annotation
/* Hello World!
     Hello Kitty~  */
SELECT * FROM t_students
</code></pre><h2 id="DQL数据查询语言（多表）"><a href="#DQL数据查询语言（多表）" class="headerlink" title="DQL数据查询语言（多表）"></a>DQL数据查询语言（多表）</h2><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><pre><code>Select *
from TABLE1 join_type TABLE2  [on (join_condition)]
               [where (query_condition)]
</code></pre><h3 id="交叉连接查询"><a href="#交叉连接查询" class="headerlink" title="交叉连接查询"></a>交叉连接查询</h3><p>不带on子句，返回连接表中所有数据行的笛卡儿积。<br>可以写成不带cross的写法，不过用的不多</p>
<pre><code>Select * from table1 cross join table2;
Select * from table1 join table2;
Select * from table1 , table2; //这个速度偏慢
</code></pre><h3 id="内部连接查询"><a href="#内部连接查询" class="headerlink" title="内部连接查询"></a>内部连接查询</h3><p>返回连接表中符合连接条件及查询条件的数据行。</p>
<pre><code>SELECT * FROM customer    c INNER JOIN orders    o ON c.id=o.customer_id;
SELECT * FROM customer as  c INNER JOIN orders as o  ON c.id=o.customer_id;
</code></pre><p><strong>注意事项</strong> 表名的别名不需要加as</p>
<h3 id="外连接查询"><a href="#外连接查询" class="headerlink" title="外连接查询"></a>外连接查询</h3><p>分为左外连接（left out join）、右外连接（right outer join）。与内连接不同的是，外连接不仅返回连接表中符合连接条件及查询条件的数据行，也返回左表（左外连接时）或右表（右外连接时）中仅符合查询条件但不符合连接条件的数据行。</p>
<h3 id="左外连接查询"><a href="#左外连接查询" class="headerlink" title="左外连接查询"></a>左外连接查询</h3><pre><code>SELECT * FROM customer c LEFT OUTER JOIN orders o ON c.id=o.customer_id;
不仅包含符合c.id=o.customer_id连接条件的数据行，还包含左表中的其他数据行
</code></pre><p>带查询条件的左外连接查询，在where子句中设定查询条件</p>
<pre><code>SELECT * FROM customer c LEFT OUTER JOIN orders o ON c.id=o.customer_id WHERE o.price&gt;250;
</code></pre><h3 id="右外连接查询"><a href="#右外连接查询" class="headerlink" title="右外连接查询"></a>右外连接查询</h3><pre><code>SELECT * FROM customer c RIGHT OUTER JOIN orders o ON c.id=o.customer_id;
不仅包含符合c.id=o.customer_id连接条件的数据行，还包含orders右表中的其他数据行
</code></pre><p>带查询条件的右外连接查询，在where子句中设定查询条件</p>
<pre><code>SELECT * FROM customer c RIGHT OUTER JOIN orders o ON c.id=o.customer_id WHERE o.price&gt;250;
</code></pre><p><strong>注意事项</strong>:这里注意一定要用where 不要用成and<br>select * from emp right join dept on emp.deptno = dept.deptno and job = ‘clerk’;<br>+——-+——-+——-+——+——+——–+——–+——–+<br>| empno | ename | job   | mgr  | sal  | deptno | deptno | dname  |<br>+——-+——-+——-+——+——+——–+——–+——–+<br>| 01    | jacky | clerk | tom  | 1000 | 1      | 1      | 事业部 |<br>| 02    | tom   | clerk |      | 2000 | 1      | 1      | 事业部 |<br>| 07    | biddy | clerk |      | 2000 | 1      | 1      | 事业部 |<br>| NULL  | NULL  | NULL  | NULL | NULL | NULL   | 2      | 销售部 |<br>| NULL  | NULL  | NULL  | NULL | NULL | NULL   | 3      | 技术部 |<br>+——-+——-+——-+——+——+——–+——–+——–+</p>
<p>因为在join …on 。。。 之前会先执行and 】<br>就把<br>| 01    | jacky | clerk | tom  | 1000 | 1      | 1      | 事业部 |<br>| 02    | tom   | clerk |      | 2000 | 1      | 1      | 事业部 |<br>| 07    | biddy | clerk |      | 2000 | 1      | 1      | 事业部 |<br>然后再和<br>+——–+——–+<br>| deptno | dname  |<br>+——–+——–+<br>| 1      | 事业部 |<br>| 2      | 销售部 |<br>| 3      | 技术部 |<br>+——–+——–+</p>
<p>拼接，就出现了两个幽灵行，因为左边没有deptno = 2,3的<br>最后又发现 and 可以先找到 左边表 和 右边表，新建一个新的表 符合and的判断，然后再和另一个表拼接；</p>
<p>当没有join…on 时候。 and 就会变成where</p>
<h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>子查询也叫嵌套查询，是指在where子句或from子句中又嵌入select查询语句（一般写在where字句）<br>练习：<br>查询“郭靖”的所有订单信息</p>
<pre><code>SELECT * FROM orders WHERE customer_id=(SELECT id FROM customer WHERE name LIKE ‘%郭靖%&apos;);
select * from customer c inner join orders o on c.id = o.customer_id and c.name like &apos;%郭靖%&apos;;
</code></pre><h3 id="联合查询（取并集）"><a href="#联合查询（取并集）" class="headerlink" title="联合查询（取并集）"></a>联合查询（取并集）</h3><p>联合查询能够合并两条查询语句的查询结果，去掉其中的重复数据行，然后返并没有重复数据行的查询结果。联合查询使用union关键字<br>SELECT <em> FROM orders WHERE price&gt;100 UNION SELECT </em> FROM orders WHERE customer_id=1;<br>注意：联合查询的各子查询使用的表结构应该相同，同时两个子查询返回的列也应相同。</p>
<h3 id="报表查询"><a href="#报表查询" class="headerlink" title="报表查询"></a>报表查询</h3><p>对数据行进行分组统计，其语法格式为：</p>
<pre><code>select …  from … [where…] [ group by … [having… ]] [ order by … ]
其中group by 子句指定按照哪些字段分组，having子句设定分组查询条件。
</code></pre><h3 id="数据库的备份和还原"><a href="#数据库的备份和还原" class="headerlink" title="数据库的备份和还原"></a>数据库的备份和还原</h3><p>在说备份和还原之前，先要知道数据库备份的路径在哪里：</p>
<pre><code>show global variables like &apos;%datadir%&apos;;
datadir： C:\ProgramData\MySQL\MySQL Server 5.7\Data\
</code></pre><p><strong>数据库备份： cmd命令下</strong></p>
<pre><code>mysqldump -u root -p test(数据库名称) &gt;test.sql   在执行这条语句的路径下面创建一个.sql的文件，
</code></pre><p>备份整个数据库</p>
<pre><code>mysqldump -u root -p --all-databases &gt; alldump.sql;
</code></pre><p>2）备份部分数据库（不带–databases的备份语句在生成的.sql文件中没有create database和use 语句，需要手动建立数据库，可能导致数据库名与之前不一致）</p>
<pre><code>mysqldump -u root -p --databases yekai&gt;yekai.sql
</code></pre><p>3）备份数据库中的几张表</p>
<pre><code>mysqldump -u root -p yekai emp &gt; emp.sql
</code></pre><p><strong>注意事项</strong>： mysqldump不需要加分号，因为是在cmd命令中</p>
<p>数据库恢复：<br><strong>创建数据库并选择该数据库</strong>注意，如果备份文件没有自动创建数据库，需要自己创一个数据库</p>
<pre><code>在cmd命令下：mysql -u root -p test &lt; test.sql
</code></pre><p>或者：<br>在mysql &gt;命令行下 执行  SOURCE 数据库文件</p>
<pre><code>先创建一个空的数据库
Mysql&gt;create databse mydb7;
Mysql&gt;use mydb7;
mysql &gt; source c:\user\zhao\test.sql
</code></pre><p><strong>注意事项</strong>：如果文件放在c盘，可能由于权限原因无法访问。更换到其他盘符再试。</p>
<h3 id="数据库三大范式"><a href="#数据库三大范式" class="headerlink" title="数据库三大范式"></a>数据库三大范式</h3><h3 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h3><p>每列应当保证原子性。即不可以再进行分割。</p>
<p>比如收货地址这列，就不是原子性的，如果需要经常统计到省份或者城市信息，则该列的设计就不符合第一范式的要求，仍然可以进一步拆分为省份，城市。。。。</p>
<h3 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h3><p>表：学号、课程号、姓名、学分;<br>学分依赖课程，姓名依赖学号</p>
<p>这个时候，如果删除一条学分数据，会导致相应的课程数据也会被删除。同时这张表还存在数据冗余的情况。<br>如果数据存在部分依赖的情形，需要将字段进行拆分，拆成多个表。这样删除一个数据时，就不会把其他的需要的数据项删除，<br><strong>注意</strong> 这里说的删数据是删一条数据，而不是删除一列，列是一个字段，字段一般不能删除。最好把依赖的字段分成两个表<br>需要重新拆分表：<br>学生表：学号、姓名<br>课程表：课程号<br>选课表：课程号、学号、学分</p>
<h3 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h3><p>不要存在冗余数据，虽然说可能有潜在的关系，但是最好使用外链关系起来，而不是放在一起你<br>表: 学号, 姓名, 年龄, 学院名称, 学院电话<br>学生表：学号、姓名、年龄、学院号<br>学院表：学院名称、学院电话、学院号<br>每一张表在设计的时候，都应该遵循着，只关注最小的一块功能，如统计学生信息，就仅停留在学生信息中，不要过多去延伸。分工而治的思想</p>
<h2 id="星期六-8-03"><a href="#星期六-8-03" class="headerlink" title="星期六(8.03)"></a>星期六(8.03)</h2><p>（太忙了没时间写了，我明天补上8.4记录）</p>
<h3 id="数据库的访问过程"><a href="#数据库的访问过程" class="headerlink" title="数据库的访问过程"></a>数据库的访问过程</h3><p>根据之前我们所学过的知识，其实不难知道，数据库的访问过程如下：</p>
<pre><code>客服端与Mysql服务器之间建立连接
客户端向Mysql服务器发送数据库请求
Mysql服务器处理客户端请求，并返回结果给客户端
客户端接受Mysql服务器的响应，并按照自己的业务逻辑做响应处理。
释放相关资源。
</code></pre><h3 id="数据库驱动"><a href="#数据库驱动" class="headerlink" title="数据库驱动"></a>数据库驱动</h3><p>java定义的访问数据库的接口（jdbc）<br>SUN公司为了简化、统一对数据库的操作，定义了一套Java操作数据库的规范，称之为JDBC。这套接口由数据库厂商去实现，这样，开发人员只需要学习jdbc接口，并通过jdbc加载具体的驱动，就可以操作数据库。</p>
<p>JDBC全称为：Java Data Base Connectivity（java数据库连接），它主要由接口组成。组成JDBC的２个包：java.sql  javax.sql</p>
<pre><code>java.sql.*;  是核心包里的
java.sql.*是jdbc2.0之前的东西
javax.sql.*; 是扩展包中的
javax.sql.*包括了jdbc3.0的特性
</code></pre><p>开发JDBC应用需要以上2个包的支持外，还需要导入相应JDBC的数据库实现(即数据库驱动)</p>
<h3 id="JDBC第一个程序"><a href="#JDBC第一个程序" class="headerlink" title="JDBC第一个程序"></a>JDBC第一个程序</h3><p>1、搭建实验环境</p>
<pre><code>1、在mysql中创建一个库，并创建user表和插入表的数据。
2、新建一个Java工程，并导入数据驱动。(mysql-connector-xx.jar)
</code></pre><p>2、编写程序，在程序中加载数据库驱动（二选一）</p>
<pre><code>DriverManage.registerDiver(new Driver);
Class.forName(com.mysql.jdbc.Driver);
</code></pre><p>3、建立连接</p>
<pre><code>Connection conn = DriverManage.getConnection(url,username,password);
</code></pre><p>4、创建用于向数据库发送sql的Statement对象并发送sql</p>
<pre><code>Statement statement = conn.createStatement();
</code></pre><p>5、从代表结果集的ResultSet中取出数据，打印</p>
<pre><code>ResultSet resultSet = statement.executeQuery(sql)
</code></pre><p>6、断开与数据库的链接</p>
<pre><code>conn.close();//必须要关闭，而且必须先关闭
statement.close();
resultSet.close();
</code></pre><h3 id="程序详解"><a href="#程序详解" class="headerlink" title="程序详解"></a>程序详解</h3><p>URL编写：<br>URL用于标识数据库的位置，程序员通过URL地址告诉JDBC程序连接哪个数据库，URL的写法为：</p>
<pre><code>jdbc:mysql:［］//localhost:3306/test ?参数名=参数值
</code></pre><p>常用数据库URL地址的写法：<br>Oracle写法：jdbc:oracle:thin:@localhost:1521:dbname<br>SqlServer：jdbc:microsoft:sqlserver://localhost:1433; DatabaseName=dbname<br>MySql：jdbc:mysql://localhost:3306/dbname<br>Mysql的url地址的简写形式： jdbc:mysql:///sid如果你的主机地址默认是localhost  端口是3306</p>
<h3 id="程序详解—Connection"><a href="#程序详解—Connection" class="headerlink" title="程序详解—Connection"></a>程序详解—Connection</h3><p>Jdbc程序中的Connection，它用于代表数据库的连接（桥梁）， Connection是数据库编程中最重要的一个对象，客户端与数据库所有交互都是通过connection对象完成的，这个对象的常用方法：</p>
<pre><code>createStatement()：创建向数据库发送sql的statement对象。
prepareStatement(sql) ：创建向数据库发送预编译sql的PrepareSatement对象。
setAutoCommit(boolean autoCommit)：设置事务是否自动提交。
commit() ：在链接上提交事务。
rollback() ：在此链接上回滚事务。
</code></pre><h3 id="程序详解—Statement"><a href="#程序详解—Statement" class="headerlink" title="程序详解—Statement"></a>程序详解—Statement</h3><p>Jdbc程序中的Statement对象用于向数据库发送SQL语句， Statement对象常用方法：</p>
<pre><code>boolean execute(String sql)：用于向数据库发送任意sql语句
ResultSet executeQuery(String sql) ：用于向数据发送查询语句。
int executeUpdate(String sql)：用于向数据库发送insert、update或delete语句
</code></pre><p><strong>execute注意！</strong><br>一般execute用来判断是向数据库发送查询信息，或者是发送insert、update或delete语句，<br>查询信息返回的true，修改返回的是false;<strong>现在的问题是</strong>查询失败是否会返回false,经过试验证明查找不存在的数据execute返回的还是true，所以并不能用execute判断是否插入</p>
<p>executeQuery:返回的是计数的值 大于0表示操作成功</p>
<pre><code>1) 对于 SQL 数据操作语言 (DML) 语句，返回行计数
(2) 对于什么都不返回的 SQL 语句，返回 0
</code></pre><h3 id="程序详解—ResultSet"><a href="#程序详解—ResultSet" class="headerlink" title="程序详解—ResultSet"></a>程序详解—ResultSet</h3><p>Jdbc程序中的ResultSet用于代表Sql语句的执行结果。Resultset封装执行结果时，采用的类似于表格的方式。ResultSet 对象维护了一个指向表格数据行的游标，初始的时候，游标在第一行之前，调用ResultSet.next() 方法，可以使游标指向具体的数据行，进行调用方法获取该行的数据。<br>ResultSet既然用于封装执行结果的，所以该对象提供的都是用于获取数据的get方法：</p>
<pre><code>获取任意类型的数据
getObject(int index)
getObject(string columnName)
获取指定类型的数据，(封装数据时方便)例如：
getString(int index)
getString(String columnName)
</code></pre><p>提问：数据库中列的类型是varchar，获取该列的数据调用什么方法？Int类型呢？bigInt类型呢？Boolean类型？<br>我TM用getString()全都可以拿到，没毛病</p>
<p>Tip：常用数据类型转换表</p>
<table>
<thead>
<tr>
<th style="text-align:right">SQL类型 数据库</th>
<th style="text-align:center">Jdbc对应方法</th>
<th style="text-align:left">返回类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">TINYINT</td>
<td style="text-align:center">getByte()</td>
<td style="text-align:left">byte</td>
</tr>
<tr>
<td style="text-align:right">SMALLINT</td>
<td style="text-align:center">getShort()</td>
<td style="text-align:left">short</td>
</tr>
<tr>
<td style="text-align:right">INT</td>
<td style="text-align:center">getInt()</td>
<td style="text-align:left">int</td>
</tr>
<tr>
<td style="text-align:right">BIGINT</td>
<td style="text-align:center">getLong()</td>
<td style="text-align:left">long</td>
</tr>
<tr>
<td style="text-align:right">CHAR,VARCHAR,LONG VARCHAR</td>
<td style="text-align:center">getString()</td>
<td style="text-align:left">String</td>
</tr>
<tr>
<td style="text-align:right">text(clob) Blob</td>
<td style="text-align:center">getClob,getBlob()</td>
<td style="text-align:left">clob blob</td>
</tr>
<tr>
<td style="text-align:right">DATE</td>
<td style="text-align:center">getDate()</td>
<td style="text-align:left">java.sql.Date</td>
</tr>
<tr>
<td style="text-align:right">TIME</td>
<td style="text-align:center">getTime()</td>
<td style="text-align:left">java.sql.Time</td>
</tr>
<tr>
<td style="text-align:right">TIMESTAMP</td>
<td style="text-align:center">getTimestamp()</td>
<td style="text-align:left">java.sql.Timestamp</td>
</tr>
</tbody>
</table>
<p>注意事项：这里date返回类似并不是java.util.date而是java.mysql.date他们之间方法可能有差异，所以要注意</p>
<p>ResultSet还提供了对结果集的游标进行滚动的方法：</p>
<pre><code>next()：移动到下一行
Previous()：移动到前一行
absolute(int row)：移动到指定行
beforeFirst()：移动resultSet的最前面。
afterLast() ：移动到resultSet的最后一行之后。
</code></pre><p>程序详解—释放资源</p>
<p>Jdbc程序运行完后，切记要释放程序在运行过程中，创建的那些与数据库进行交互的对象，这些对象通常是ResultSet, Statement和Connection对象。<br>特别是Connection对象，它是非常稀有的资源，用完后必须马上释放，如果Connection不能及时、正确的关闭，极易导致系统宕机。Connection的使用原则是尽量晚创建，尽量早的释放。<br>为确保资源释放代码能运行，资源释放代码也一定要放在finally语句中。</p>
<p>数据库存放数据，那么数据库安全吗？</p>
<h3 id="数据库注入问题"><a href="#数据库注入问题" class="headerlink" title="数据库注入问题"></a>数据库注入问题</h3><p>对于数据库注入，我们来看一个登陆的例子：</p>
<pre><code>假设有一个登陆界面，让我们输入用户名和密码进行登陆，我们这样输入用户名和密码：
用户名：name = &quot;xxxx&apos; (用户名随便输入)OR 0==0 --&quot;;
密码：密码=“xxxx”（随便输入一串）
此时我们可以试一下，我们是否可以登陆成功。
让我们看一下，在我们的代码中，最终拼接而成的，发送给数据库执行的sql语句
String sql = &quot;select * from t_user where name =&apos;&quot;+ name +&quot;&apos; AND PASSWORD = &apos;&quot;+ password +&quot;&apos;&quot;;
</code></pre><p>不管写什么都能直接登陆。问题来了，如何规避这种情况呢？<br>仔细分析一下，数据库注入成功的根本原因是，<br>我们把sql语句中的参数(用户的输入)和sql命令拼接成了一个sql语句，因为一个sql语句中既可以有sql的命令又可以有参数，因此，用户的输入也可以被当做sql的语句来解析执行。<br>那么，既然知道了sql注入成功的原因，我们就反其道而行之，不让用户输入的参数被当做sql命令解析，而是只把它当做普通字符串来解析。<br>由此，java中引入了prepareStatement，利用preparestatement来防止sql注入的核心思想就是，不把用户的输入当做sql命令来解析和执行。</p>
<h3 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h3><p>PreparedStatement继承自Statement，可以通过Connection的prepareStatement方法得到。<br>prepareStatement很明显的将sql命令语句与参数分开处理，其执行过程是，首先在sql语句真正执行之前，先把sql命令送到数据库中进行预编译，生成相应 的数据库命令，然后在获取sql中的参数，然后真正执行该sql语句。<br>这样一来，用户输入的参数，只被当做参数而非命令来解析，就可以避免数据库注入这样的问题发生。<br><strong>不过，这样一来，单次执行PreparedStatement需要与数据库通信两次，效率，比之于单词执行Statement要低。</strong><br>PreparedStatement用法：</p>
<pre><code>DriverManager.register(New Driver());
Connection connection = DriverManager.getConnection(url,username,password);
String sql = &quot;select * from emp where id = ?&quot;
PreparedStatement preparedstatement = connection.prepareStatement(sql);
preparedstatement.setInt(1,i);
preparedstatement.executeQuery();
connection.close();
preparedstatement.close();
</code></pre><h3 id="一些小总结"><a href="#一些小总结" class="headerlink" title="一些小总结"></a>一些小总结</h3><p>原来是学习JMS的，后来发现不懂MQ真的学不了</p>
<p><a href="https://blog.csdn.net/guanghuichenshao/article/details/79546140" target="_blank" rel="external">传送门</a></p>
<h3 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h3><p>消息队列（MQ）是一种应用程序对应用程序的通信方法。应用程序通过写和检索出入列队的针对应用程序的数据（消息）来通信，而无需专用连接来链接它们。</p>
<h3 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h3><pre><code>JMS即Java消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。
</code></pre><h3 id="JNDI"><a href="#JNDI" class="headerlink" title="JNDI"></a>JNDI</h3><pre><code>JNDI(Java Naming and Directory Interface,Java命名和目录接口)是SUN公司提供的一种标准的Java命名系统接口，JNDI提供统一的客户端API，通过不同的访问提供者接口JNDI服务供应接口(SPI)的实现，由管理者将JNDI API映射为特定的命名服务和目录系统，使得Java应用程序可以和这些命名服务和目录服务之间进行交互。目录服务是命名服务的一种自然扩展。两者之间的关键差别是目录服务中对象不但可以有名称还可以有属性（例如，用户有email地址），而命名服务中对象没有属性 [1]  。
</code></pre><h3 id="mysql5-7设置允许外部访问"><a href="#mysql5-7设置允许外部访问" class="headerlink" title="mysql5.7设置允许外部访问"></a>mysql5.7设置允许外部访问</h3><p>JDBC设置外部访问<br><a href="https://blog.csdn.net/qq_17810899/article/details/90642207" target="_blank" rel="external">https://blog.csdn.net/qq_17810899/article/details/90642207</a></p>
<p>登陆进去mysql</p>
<pre><code>update user set host = &apos;%&apos; where user = &apos;root&apos;;
FLUSH PRIVILEGES;
</code></pre><h3 id="数据库显示链接不上问题"><a href="#数据库显示链接不上问题" class="headerlink" title=".数据库显示链接不上问题"></a>.数据库显示链接不上问题</h3><p>还原系统设置；</p>
<h3 id="命令行执行java用到jar包"><a href="#命令行执行java用到jar包" class="headerlink" title="命令行执行java用到jar包"></a>命令行执行java用到jar包</h3><p><a href="https://blog.csdn.net/vaq37942/article/details/86654217" target="_blank" rel="external">传送门</a><br>需要使用命令行<br>编译</p>
<pre><code>javac -Djava.ext.dirs=D:\lib test.java
</code></pre><p>执行</p>
<pre><code>java  -Djava.ext.dirs=D:\lib test
</code></pre><p>这个方法需要在jdk1.6以上支持</p>
<h3 id="如何共享包"><a href="#如何共享包" class="headerlink" title="如何共享包"></a>如何共享包</h3><p>把jar包添加到module中共用可以右键点击module 然后setting把jar添加到module中<br>或者按F4也有相同的效果</p>

        </div>
        <div class="post-reply">
            
                <!-- 来必力City版安装代码 -->
                <div id="lv-container" data-id="city" data-uid="MTAyMC8yOTE4Ni81NzUz">
                    <script type="text/javascript">
                        (function(d, s) {
                            var j, e = d.getElementsByTagName(s)[0];

                            if (typeof LivereTower === 'function') { return; }

                            j = d.createElement(s);
                            j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
                            j.async = true;

                            e.parentNode.insertBefore(j, e);
                        })(document, 'script');
                    </script>
                    <noscript> 为正常使用来必力评论功能请激活JavaScript</noscript>
                </div>
                <!-- City版安装代码已完成 -->
            
            
        </div>
    </div>
</section>
<script>
    // 获取第一张图, 用以当封面背景图
    var img = document.querySelectorAll('img')[1]

    if (img) {
        var header_box = document.querySelector('#header_box')
        header_box.style.backgroundImage = 'url('+ img.src +')'
    }
</script>
      </div>
  </div>
  <style>
  #footer {
    min-height: 10vh;
    background: black;
    color: #fff;
  }

  #footer a {
    color: #e1e1e1;
  }
</style>
<footer id="footer" class="has-text-centered is-flex center">
  <div class="container has-padding">
    <div>
      <div>
        <!--请您保留作者署名, 主题制作来之不易-->
        主题来自 <a href="http://haojen.github.io/">Haojen Ma</a>
        <br>
        Copyright © 王邸 2019
        <!--
          Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        -->
      </div>
    </div>
  </div>
</footer>

<script src="/js/search_core.js"></script>
<script src="/js/script.js"></script>

</body>
</html>